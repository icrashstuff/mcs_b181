// clang-format off
/* [mcs_b181]: Stripped of all encoders, most decoders, most backends, and other cruft with the following command
unifdef                                    \
-DMA_NO_FLAC -Uma_dr_flac_h -UMA_HAS_FLAC  \
-DMA_NO_MP3  -Uma_dr_mp3_h  -UMA_HAS_MP3   \
-DMA_NO_WAV  -Uma_dr_wav_h  -UMA_HAS_WAV   \
-DMA_NO_ENCODING                           \
-DMA_NO_DEVICE_IO                          \
-DMA_NO_GENERATION                         \
-UMA_HAS_WASAPI                            \
-UMA_HAS_DSOUND                            \
-UMA_HAS_WINMM                             \
-UMA_HAS_ALSA                              \
-UMA_HAS_PULSEAUDIO                        \
-UMA_HAS_JACK                              \
-UMA_HAS_COREAUDIO                         \
-UMA_HAS_SNDIO                             \
-UMA_HAS_AUDIO4                            \
-UMA_HAS_OSS                               \
-UMA_HAS_AAUDIO                            \
-UMA_HAS_OPENSL                            \
-UMA_HAS_WEBAUDIO                          \
-UMA_HAS_NULL                              \
miniaudio.h > miniaudio_unifdef.h
 */
#include "stb_vorbis.h"
/*
Audio playback and capture library. Choice of public domain or MIT-0. See license statements at the end of this file.
miniaudio - v0.11.22 - 2025-02-24

David Reid - mackron@gmail.com

Website:       https://miniaud.io
Documentation: https://miniaud.io/docs
GitHub:        https://github.com/mackron/miniaudio
*/

/*
1. Introduction
===============
To use miniaudio, include "miniaudio.h":

    ```c
    #include "miniaudio.h"
    ```

The implementation is contained in "miniaudio.c". Just compile this like any other source file. You
can include miniaudio.c if you want to compile your project as a single translation unit:

    ```c
    #include "miniaudio.c"
    ```

miniaudio includes both low level and high level APIs. The low level API is good for those who want
to do all of their mixing themselves and only require a light weight interface to the underlying
audio device. The high level API is good for those who have complex mixing and effect requirements.

In miniaudio, objects are transparent structures. Unlike many other libraries, there are no handles
to opaque objects which means you need to allocate memory for objects yourself. In the examples
presented in this documentation you will often see objects declared on the stack. You need to be
careful when translating these examples to your own code so that you don't accidentally declare
your objects on the stack and then cause them to become invalid once the function returns. In
addition, you must ensure the memory address of your objects remain the same throughout their
lifetime. You therefore cannot be making copies of your objects.

A config/init pattern is used throughout the entire library. The idea is that you set up a config
object and pass that into the initialization routine. The advantage to this system is that the
config object can be initialized with logical defaults and new properties added to it without
breaking the API. The config object can be allocated on the stack and does not need to be
maintained after initialization of the corresponding object.


1.1. Low Level API
------------------
The low level API gives you access to the raw audio data of an audio device. It supports playback,
capture, full-duplex and loopback (WASAPI only). You can enumerate over devices to determine which
physical device(s) you want to connect to.

The low level API uses the concept of a "device" as the abstraction for physical devices. The idea
is that you choose a physical device to emit or capture audio from, and then move data to/from the
device when miniaudio tells you to. Data is delivered to and from devices asynchronously via a
callback which you specify when initializing the device.

When initializing the device you first need to configure it. The device configuration allows you to
specify things like the format of the data delivered via the callback, the size of the internal
buffer and the ID of the device you want to emit or capture audio from.

Once you have the device configuration set up you can initialize the device. When initializing a
device you need to allocate memory for the device object beforehand. This gives the application
complete control over how the memory is allocated. In the example below we initialize a playback
device on the stack, but you could allocate it on the heap if that suits your situation better.

    ```c
    void data_callback(ma_device* pDevice, void* pOutput, const void* pInput, ma_uint32 frameCount)
    {
        // In playback mode copy data to pOutput. In capture mode read data from pInput. In full-duplex mode, both
        // pOutput and pInput will be valid and you can move data from pInput into pOutput. Never process more than
        // frameCount frames.
    }

    int main()
    {
        ma_device_config config = ma_device_config_init(ma_device_type_playback);
        config.playback.format   = ma_format_f32;   // Set to ma_format_unknown to use the device's native format.
        config.playback.channels = 2;               // Set to 0 to use the device's native channel count.
        config.sampleRate        = 48000;           // Set to 0 to use the device's native sample rate.
        config.dataCallback      = data_callback;   // This function will be called when miniaudio needs more data.
        config.pUserData         = pMyCustomData;   // Can be accessed from the device object (device.pUserData).

        ma_device device;
        if (ma_device_init(NULL, &config, &device) != MA_SUCCESS) {
            return -1;  // Failed to initialize the device.
        }

        ma_device_start(&device);     // The device is sleeping by default so you'll need to start it manually.

        // Do something here. Probably your program's main loop.

        ma_device_uninit(&device);
        return 0;
    }
    ```

In the example above, `data_callback()` is where audio data is written and read from the device.
The idea is in playback mode you cause sound to be emitted from the speakers by writing audio data
to the output buffer (`pOutput` in the example). In capture mode you read data from the input
buffer (`pInput`) to extract sound captured by the microphone. The `frameCount` parameter tells you
how many frames can be written to the output buffer and read from the input buffer. A "frame" is
one sample for each channel. For example, in a stereo stream (2 channels), one frame is 2
samples: one for the left, one for the right. The channel count is defined by the device config.
The size in bytes of an individual sample is defined by the sample format which is also specified
in the device config. Multi-channel audio data is always interleaved, which means the samples for
each frame are stored next to each other in memory. For example, in a stereo stream the first pair
of samples will be the left and right samples for the first frame, the second pair of samples will
be the left and right samples for the second frame, etc.

The configuration of the device is defined by the `ma_device_config` structure. The config object
is always initialized with `ma_device_config_init()`. It's important to always initialize the
config with this function as it initializes it with logical defaults and ensures your program
doesn't break when new members are added to the `ma_device_config` structure. The example above
uses a fairly simple and standard device configuration. The call to `ma_device_config_init()` takes
a single parameter, which is whether or not the device is a playback, capture, duplex or loopback
device (loopback devices are not supported on all backends). The `config.playback.format` member
sets the sample format which can be one of the following (all formats are native-endian):

    +---------------+----------------------------------------+---------------------------+
    | Symbol        | Description                            | Range                     |
    +---------------+----------------------------------------+---------------------------+
    | ma_format_f32 | 32-bit floating point                  | [-1, 1]                   |
    | ma_format_s16 | 16-bit signed integer                  | [-32768, 32767]           |
    | ma_format_s24 | 24-bit signed integer (tightly packed) | [-8388608, 8388607]       |
    | ma_format_s32 | 32-bit signed integer                  | [-2147483648, 2147483647] |
    | ma_format_u8  | 8-bit unsigned integer                 | [0, 255]                  |
    +---------------+----------------------------------------+---------------------------+

The `config.playback.channels` member sets the number of channels to use with the device. The
channel count cannot exceed MA_MAX_CHANNELS. The `config.sampleRate` member sets the sample rate
(which must be the same for both playback and capture in full-duplex configurations). This is
usually set to 44100 or 48000, but can be set to anything. It's recommended to keep this between
8000 and 384000, however.

Note that leaving the format, channel count and/or sample rate at their default values will result
in the internal device's native configuration being used which is useful if you want to avoid the
overhead of miniaudio's automatic data conversion.

In addition to the sample format, channel count and sample rate, the data callback and user data
pointer are also set via the config. The user data pointer is not passed into the callback as a
parameter, but is instead set to the `pUserData` member of `ma_device` which you can access
directly since all miniaudio structures are transparent.

Initializing the device is done with `ma_device_init()`. This will return a result code telling you
what went wrong, if anything. On success it will return `MA_SUCCESS`. After initialization is
complete the device will be in a stopped state. To start it, use `ma_device_start()`.
Uninitializing the device will stop it, which is what the example above does, but you can also stop
the device with `ma_device_stop()`. To resume the device simply call `ma_device_start()` again.
Note that it's important to never stop or start the device from inside the callback. This will
result in a deadlock. Instead you set a variable or signal an event indicating that the device
needs to stop and handle it in a different thread. The following APIs must never be called inside
the callback:

    ```c
    ma_device_init()
    ma_device_init_ex()
    ma_device_uninit()
    ma_device_start()
    ma_device_stop()
    ```

You must never try uninitializing and reinitializing a device inside the callback. You must also
never try to stop and start it from inside the callback. There are a few other things you shouldn't
do in the callback depending on your requirements, however this isn't so much a thread-safety
thing, but rather a real-time processing thing which is beyond the scope of this introduction.

The example above demonstrates the initialization of a playback device, but it works exactly the
same for capture. All you need to do is change the device type from `ma_device_type_playback` to
`ma_device_type_capture` when setting up the config, like so:

    ```c
    ma_device_config config = ma_device_config_init(ma_device_type_capture);
    config.capture.format   = MY_FORMAT;
    config.capture.channels = MY_CHANNEL_COUNT;
    ```

In the data callback you just read from the input buffer (`pInput` in the example above) and leave
the output buffer alone (it will be set to NULL when the device type is set to
`ma_device_type_capture`).

These are the available device types and how you should handle the buffers in the callback:

    +-------------------------+--------------------------------------------------------+
    | Device Type             | Callback Behavior                                      |
    +-------------------------+--------------------------------------------------------+
    | ma_device_type_playback | Write to output buffer, leave input buffer untouched.  |
    | ma_device_type_capture  | Read from input buffer, leave output buffer untouched. |
    | ma_device_type_duplex   | Read from input buffer, write to output buffer.        |
    | ma_device_type_loopback | Read from input buffer, leave output buffer untouched. |
    +-------------------------+--------------------------------------------------------+

You will notice in the example above that the sample format and channel count is specified
separately for playback and capture. This is to support different data formats between the playback
and capture devices in a full-duplex system. An example may be that you want to capture audio data
as a monaural stream (one channel), but output sound to a stereo speaker system. Note that if you
use different formats between playback and capture in a full-duplex configuration you will need to
convert the data yourself. There are functions available to help you do this which will be
explained later.

The example above did not specify a physical device to connect to which means it will use the
operating system's default device. If you have multiple physical devices connected and you want to
use a specific one you will need to specify the device ID in the configuration, like so:

    ```c
    config.playback.pDeviceID = pMyPlaybackDeviceID;    // Only if requesting a playback or duplex device.
    config.capture.pDeviceID = pMyCaptureDeviceID;      // Only if requesting a capture, duplex or loopback device.
    ```

To retrieve the device ID you will need to perform device enumeration, however this requires the
use of a new concept called the "context". Conceptually speaking the context sits above the device.
There is one context to many devices. The purpose of the context is to represent the backend at a
more global level and to perform operations outside the scope of an individual device. Mainly it is
used for performing run-time linking against backend libraries, initializing backends and
enumerating devices. The example below shows how to enumerate devices.

    ```c
    ma_context context;
    if (ma_context_init(NULL, 0, NULL, &context) != MA_SUCCESS) {
        // Error.
    }

    ma_device_info* pPlaybackInfos;
    ma_uint32 playbackCount;
    ma_device_info* pCaptureInfos;
    ma_uint32 captureCount;
    if (ma_context_get_devices(&context, &pPlaybackInfos, &playbackCount, &pCaptureInfos, &captureCount) != MA_SUCCESS) {
        // Error.
    }

    // Loop over each device info and do something with it. Here we just print the name with their index. You may want
    // to give the user the opportunity to choose which device they'd prefer.
    for (ma_uint32 iDevice = 0; iDevice < playbackCount; iDevice += 1) {
        printf("%d - %s\n", iDevice, pPlaybackInfos[iDevice].name);
    }

    ma_device_config config = ma_device_config_init(ma_device_type_playback);
    config.playback.pDeviceID = &pPlaybackInfos[chosenPlaybackDeviceIndex].id;
    config.playback.format    = MY_FORMAT;
    config.playback.channels  = MY_CHANNEL_COUNT;
    config.sampleRate         = MY_SAMPLE_RATE;
    config.dataCallback       = data_callback;
    config.pUserData          = pMyCustomData;

    ma_device device;
    if (ma_device_init(&context, &config, &device) != MA_SUCCESS) {
        // Error
    }

    ...

    ma_device_uninit(&device);
    ma_context_uninit(&context);
    ```

The first thing we do in this example is initialize a `ma_context` object with `ma_context_init()`.
The first parameter is a pointer to a list of `ma_backend` values which are used to override the
default backend priorities. When this is NULL, as in this example, miniaudio's default priorities
are used. The second parameter is the number of backends listed in the array pointed to by the
first parameter. The third parameter is a pointer to a `ma_context_config` object which can be
NULL, in which case defaults are used. The context configuration is used for setting the logging
callback, custom memory allocation callbacks, user-defined data and some backend-specific
configurations.

Once the context has been initialized you can enumerate devices. In the example above we use the
simpler `ma_context_get_devices()`, however you can also use a callback for handling devices by
using `ma_context_enumerate_devices()`. When using `ma_context_get_devices()` you provide a pointer
to a pointer that will, upon output, be set to a pointer to a buffer containing a list of
`ma_device_info` structures. You also provide a pointer to an unsigned integer that will receive
the number of items in the returned buffer. Do not free the returned buffers as their memory is
managed internally by miniaudio.

The `ma_device_info` structure contains an `id` member which is the ID you pass to the device
config. It also contains the name of the device which is useful for presenting a list of devices
to the user via the UI.

When creating your own context you will want to pass it to `ma_device_init()` when initializing the
device. Passing in NULL, like we do in the first example, will result in miniaudio creating the
context for you, which you don't want to do since you've already created a context. Note that
internally the context is only tracked by it's pointer which means you must not change the location
of the `ma_context` object. If this is an issue, consider using `malloc()` to allocate memory for
the context.


1.2. High Level API
-------------------
The high level API consists of three main parts:

  * Resource management for loading and streaming sounds.
  * A node graph for advanced mixing and effect processing.
  * A high level "engine" that wraps around the resource manager and node graph.

The resource manager (`ma_resource_manager`) is used for loading sounds. It supports loading sounds
fully into memory and also streaming. It will also deal with reference counting for you which
avoids the same sound being loaded multiple times.

The node graph is used for mixing and effect processing. The idea is that you connect a number of
nodes into the graph by connecting each node's outputs to another node's inputs. Each node can
implement its own effect. By chaining nodes together, advanced mixing and effect processing can
be achieved.

The engine encapsulates both the resource manager and the node graph to create a simple, easy to
use high level API. The resource manager and node graph APIs are covered in more later sections of
this manual.

The code below shows how you can initialize an engine using it's default configuration.

    ```c
    ma_result result;
    ma_engine engine;

    result = ma_engine_init(NULL, &engine);
    if (result != MA_SUCCESS) {
        return result;  // Failed to initialize the engine.
    }
    ```

This creates an engine instance which will initialize a device internally which you can access with
`ma_engine_get_device()`. It will also initialize a resource manager for you which can be accessed
with `ma_engine_get_resource_manager()`. The engine itself is a node graph (`ma_node_graph`) which
means you can pass a pointer to the engine object into any of the `ma_node_graph` APIs (with a
cast). Alternatively, you can use `ma_engine_get_node_graph()` instead of a cast.

Note that all objects in miniaudio, including the `ma_engine` object in the example above, are
transparent structures. There are no handles to opaque structures in miniaudio which means you need
to be mindful of how you declare them. In the example above we are declaring it on the stack, but
this will result in the struct being invalidated once the function encapsulating it returns. If
allocating the engine on the heap is more appropriate, you can easily do so with a standard call
to `malloc()` or whatever heap allocation routine you like:

    ```c
    ma_engine* pEngine = malloc(sizeof(*pEngine));
    ```

The `ma_engine` API uses the same config/init pattern used all throughout miniaudio. To configure
an engine, you can fill out a `ma_engine_config` object and pass it into the first parameter of
`ma_engine_init()`:

    ```c
    ma_result result;
    ma_engine engine;
    ma_engine_config engineConfig;

    engineConfig = ma_engine_config_init();
    engineConfig.pResourceManager = &myCustomResourceManager;   // <-- Initialized as some earlier stage.

    result = ma_engine_init(&engineConfig, &engine);
    if (result != MA_SUCCESS) {
        return result;
    }
    ```

This creates an engine instance using a custom config. In this particular example it's showing how
you can specify a custom resource manager rather than having the engine initialize one internally.
This is particularly useful if you want to have multiple engine's share the same resource manager.

The engine must be uninitialized with `ma_engine_uninit()` when it's no longer needed.

By default the engine will be started, but nothing will be playing because no sounds have been
initialized. The easiest but least flexible way of playing a sound is like so:

    ```c
    ma_engine_play_sound(&engine, "my_sound.wav", NULL);
    ```

This plays what miniaudio calls an "inline" sound. It plays the sound once, and then puts the
internal sound up for recycling. The last parameter is used to specify which sound group the sound
should be associated with which will be explained later. This particular way of playing a sound is
simple, but lacks flexibility and features. A more flexible way of playing a sound is to first
initialize a sound:

    ```c
    ma_result result;
    ma_sound sound;

    result = ma_sound_init_from_file(&engine, "my_sound.wav", 0, NULL, NULL, &sound);
    if (result != MA_SUCCESS) {
        return result;
    }

    ma_sound_start(&sound);
    ```

This returns a `ma_sound` object which represents a single instance of the specified sound file. If
you want to play the same file multiple times simultaneously, you need to create one sound for each
instance.

Sounds should be uninitialized with `ma_sound_uninit()`.

Sounds are not started by default. Start a sound with `ma_sound_start()` and stop it with
`ma_sound_stop()`. When a sound is stopped, it is not rewound to the start. Use
`ma_sound_seek_to_pcm_frame(&sound, 0)` to seek back to the start of a sound. By default, starting
and stopping sounds happens immediately, but sometimes it might be convenient to schedule the sound
the be started and/or stopped at a specific time. This can be done with the following functions:

    ```c
    ma_sound_set_start_time_in_pcm_frames()
    ma_sound_set_start_time_in_milliseconds()
    ma_sound_set_stop_time_in_pcm_frames()
    ma_sound_set_stop_time_in_milliseconds()
    ```

The start/stop time needs to be specified based on the absolute timer which is controlled by the
engine. The current global time in PCM frames can be retrieved with
`ma_engine_get_time_in_pcm_frames()`. The engine's global time can be changed with
`ma_engine_set_time_in_pcm_frames()` for synchronization purposes if required. Note that scheduling
a start time still requires an explicit call to `ma_sound_start()` before anything will play:

    ```c
    ma_sound_set_start_time_in_pcm_frames(&sound, ma_engine_get_time_in_pcm_frames(&engine) + (ma_engine_get_sample_rate(&engine) * 2);
    ma_sound_start(&sound);
    ```

The third parameter of `ma_sound_init_from_file()` is a set of flags that control how the sound be
loaded and a few options on which features should be enabled for that sound. By default, the sound
is synchronously loaded fully into memory straight from the file system without any kind of
decoding. If you want to decode the sound before storing it in memory, you need to specify the
`MA_SOUND_FLAG_DECODE` flag. This is useful if you want to incur the cost of decoding at an earlier
stage, such as a loading stage. Without this option, decoding will happen dynamically at mixing
time which might be too expensive on the audio thread.

If you want to load the sound asynchronously, you can specify the `MA_SOUND_FLAG_ASYNC` flag. This
will result in `ma_sound_init_from_file()` returning quickly, but the sound will not start playing
until the sound has had some audio decoded.

The fourth parameter is a pointer to sound group. A sound group is used as a mechanism to organise
sounds into groups which have their own effect processing and volume control. An example is a game
which might have separate groups for sfx, voice and music. Each of these groups have their own
independent volume control. Use `ma_sound_group_init()` or `ma_sound_group_init_ex()` to initialize
a sound group.

Sounds and sound groups are nodes in the engine's node graph and can be plugged into any `ma_node`
API. This makes it possible to connect sounds and sound groups to effect nodes to produce complex
effect chains.

A sound can have its volume changed with `ma_sound_set_volume()`. If you prefer decibel volume
control you can use `ma_volume_db_to_linear()` to convert from decibel representation to linear.

Panning and pitching is supported with `ma_sound_set_pan()` and `ma_sound_set_pitch()`. If you know
a sound will never have its pitch changed with `ma_sound_set_pitch()` or via the doppler effect,
you can specify the `MA_SOUND_FLAG_NO_PITCH` flag when initializing the sound for an optimization.

By default, sounds and sound groups have spatialization enabled. If you don't ever want to
spatialize your sounds, initialize the sound with the `MA_SOUND_FLAG_NO_SPATIALIZATION` flag. The
spatialization model is fairly simple and is roughly on feature parity with OpenAL. HRTF and
environmental occlusion are not currently supported, but planned for the future. The supported
features include:

  * Sound and listener positioning and orientation with cones
  * Attenuation models: none, inverse, linear and exponential
  * Doppler effect

Sounds can be faded in and out with `ma_sound_set_fade_in_pcm_frames()`.

To check if a sound is currently playing, you can use `ma_sound_is_playing()`. To check if a sound
is at the end, use `ma_sound_at_end()`. Looping of a sound can be controlled with
`ma_sound_set_looping()`. Use `ma_sound_is_looping()` to check whether or not the sound is looping.



2. Building
===========
miniaudio should work cleanly out of the box without the need to download or install any
dependencies. See below for platform-specific details.

Note that GCC and Clang require `-msse2`, `-mavx2`, etc. for SIMD optimizations.

If you get errors about undefined references to `__sync_val_compare_and_swap_8`, `__atomic_load_8`,
etc. you need to link with `-latomic`.


2.1. Windows
------------
The Windows build should compile cleanly on all popular compilers without the need to configure any
include paths nor link to any libraries.

The UWP build may require linking to mmdevapi.lib if you get errors about an unresolved external
symbol for `ActivateAudioInterfaceAsync()`.


2.2. macOS and iOS
------------------
The macOS build should compile cleanly without the need to download any dependencies nor link to
any libraries or frameworks. The iOS build needs to be compiled as Objective-C and will need to
link the relevant frameworks but should compile cleanly out of the box with Xcode. Compiling
through the command line requires linking to `-lpthread` and `-lm`.

Due to the way miniaudio links to frameworks at runtime, your application may not pass Apple's
notarization process. To fix this there are two options. The first is to compile with
`-DMA_NO_RUNTIME_LINKING` which in turn will require linking with
`-framework CoreFoundation -framework CoreAudio -framework AudioToolbox`. If you get errors about
AudioToolbox, try with `-framework AudioUnit` instead. You may get this when using older versions
of iOS. Alternatively, if you would rather keep using runtime linking you can add the following to
your entitlements.xcent file:

    ```
    <key>com.apple.security.cs.allow-dyld-environment-variables</key>
    <true/>
    <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
    <true/>
    ```

See this discussion for more info: https://github.com/mackron/miniaudio/issues/203.


2.3. Linux
----------
The Linux build only requires linking to `-ldl`, `-lpthread` and `-lm`. You do not need any
development packages. You may need to link with `-latomic` if you're compiling for 32-bit ARM.


2.4. BSD
--------
The BSD build only requires linking to `-lpthread` and `-lm`. NetBSD uses audio(4), OpenBSD uses
sndio and FreeBSD uses OSS. You may need to link with `-latomic` if you're compiling for 32-bit
ARM.


2.5. Android
------------
AAudio is the highest priority backend on Android. This should work out of the box without needing
any kind of compiler configuration. Support for AAudio starts with Android 8 which means older
versions will fall back to OpenSL|ES which requires API level 16+.

There have been reports that the OpenSL|ES backend fails to initialize on some Android based
devices due to `dlopen()` failing to open "libOpenSLES.so". If this happens on your platform
you'll need to disable run-time linking with `MA_NO_RUNTIME_LINKING` and link with -lOpenSLES.


2.6. Emscripten
---------------
The Emscripten build emits Web Audio JavaScript directly and should compile cleanly out of the box.
You cannot use `-std=c*` compiler flags, nor `-ansi`.

You can enable the use of AudioWorkets by defining `MA_ENABLE_AUDIO_WORKLETS` and then compiling
with the following options:

    -sAUDIO_WORKLET=1 -sWASM_WORKERS=1 -sASYNCIFY

An example for compiling with AudioWorklet support might look like this:

    emcc program.c -o bin/program.html -DMA_ENABLE_AUDIO_WORKLETS -sAUDIO_WORKLET=1 -sWASM_WORKERS=1 -sASYNCIFY

To run locally, you'll need to use emrun:

    emrun bin/program.html



2.7. Build Options
------------------
`#define` these options before including miniaudio.c, or pass them as compiler flags:

    +----------------------------------+--------------------------------------------------------------------+
    | Option                           | Description                                                        |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_WASAPI                     | Disables the WASAPI backend.                                       |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_DSOUND                     | Disables the DirectSound backend.                                  |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_WINMM                      | Disables the WinMM backend.                                        |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_ALSA                       | Disables the ALSA backend.                                         |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_PULSEAUDIO                 | Disables the PulseAudio backend.                                   |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_JACK                       | Disables the JACK backend.                                         |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_COREAUDIO                  | Disables the Core Audio backend.                                   |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_SNDIO                      | Disables the sndio backend.                                        |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_AUDIO4                     | Disables the audio(4) backend.                                     |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_OSS                        | Disables the OSS backend.                                          |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_AAUDIO                     | Disables the AAudio backend.                                       |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_OPENSL                     | Disables the OpenSL|ES backend.                                    |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_WEBAUDIO                   | Disables the Web Audio backend.                                    |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_CUSTOM                     | Disables support for custom backends.                              |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_NULL                       | Disables the null backend.                                         |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_ONLY_SPECIFIC_BACKENDS | Disables all backends by default and requires `MA_ENABLE_*` to     |
    |                                  | enable specific backends.                                          |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_WASAPI                 | Used in conjunction with MA_ENABLE_ONLY_SPECIFIC_BACKENDS to       |
    |                                  | enable the WASAPI backend.                                         |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_DSOUND                 | Used in conjunction with MA_ENABLE_ONLY_SPECIFIC_BACKENDS to       |
    |                                  | enable the DirectSound backend.                                    |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_WINMM                  | Used in conjunction with MA_ENABLE_ONLY_SPECIFIC_BACKENDS to       |
    |                                  | enable the WinMM backend.                                          |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_ALSA                   | Used in conjunction with MA_ENABLE_ONLY_SPECIFIC_BACKENDS to       |
    |                                  | enable the ALSA backend.                                           |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_PULSEAUDIO             | Used in conjunction with MA_ENABLE_ONLY_SPECIFIC_BACKENDS to       |
    |                                  | enable the PulseAudio backend.                                     |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_JACK                   | Used in conjunction with MA_ENABLE_ONLY_SPECIFIC_BACKENDS to       |
    |                                  | enable the JACK backend.                                           |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_COREAUDIO              | Used in conjunction with MA_ENABLE_ONLY_SPECIFIC_BACKENDS to       |
    |                                  | enable the Core Audio backend.                                     |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_SNDIO                  | Used in conjunction with MA_ENABLE_ONLY_SPECIFIC_BACKENDS to       |
    |                                  | enable the sndio backend.                                          |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_AUDIO4                 | Used in conjunction with MA_ENABLE_ONLY_SPECIFIC_BACKENDS to       |
    |                                  | enable the audio(4) backend.                                       |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_OSS                    | Used in conjunction with MA_ENABLE_ONLY_SPECIFIC_BACKENDS to       |
    |                                  | enable the OSS backend.                                            |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_AAUDIO                 | Used in conjunction with MA_ENABLE_ONLY_SPECIFIC_BACKENDS to       |
    |                                  | enable the AAudio backend.                                         |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_OPENSL                 | Used in conjunction with MA_ENABLE_ONLY_SPECIFIC_BACKENDS to       |
    |                                  | enable the OpenSL|ES backend.                                      |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_WEBAUDIO               | Used in conjunction with MA_ENABLE_ONLY_SPECIFIC_BACKENDS to       |
    |                                  | enable the Web Audio backend.                                      |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_CUSTOM                 | Used in conjunction with MA_ENABLE_ONLY_SPECIFIC_BACKENDS to       |
    |                                  | enable custom backends.                                            |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ENABLE_NULL                   | Used in conjunction with MA_ENABLE_ONLY_SPECIFIC_BACKENDS to       |
    |                                  | enable the null backend.                                           |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_DECODING                   | Disables decoding APIs.                                            |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_ENCODING                   | Disables encoding APIs.                                            |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_WAV                        | Disables the built-in WAV decoder and encoder.                     |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_FLAC                       | Disables the built-in FLAC decoder.                                |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_MP3                        | Disables the built-in MP3 decoder.                                 |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_DEVICE_IO                  | Disables playback and recording. This will disable `ma_context`    |
    |                                  | and `ma_device` APIs. This is useful if you only want to use       |
    |                                  | miniaudio's data conversion and/or decoding APIs.                  |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_RESOURCE_MANAGER           | Disables the resource manager. When using the engine this will     |
    |                                  | also disable the following functions:                              |
    |                                  |                                                                    |
    |                                  | ```                                                                |
    |                                  | ma_sound_init_from_file()                                          |
    |                                  | ma_sound_init_from_file_w()                                        |
    |                                  | ma_sound_init_copy()                                               |
    |                                  | ma_engine_play_sound_ex()                                          |
    |                                  | ma_engine_play_sound()                                             |
    |                                  | ```                                                                |
    |                                  |                                                                    |
    |                                  | The only way to initialize a `ma_sound` object is to initialize it |
    |                                  | from a data source.                                                |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_NODE_GRAPH                 | Disables the node graph API. This will also disable the engine API |
    |                                  | because it depends on the node graph.                              |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_ENGINE                     | Disables the engine API.                                           |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_THREADING                  | Disables the `ma_thread`, `ma_mutex`, `ma_semaphore` and           |
    |                                  | `ma_event` APIs. This option is useful if you only need to use     |
    |                                  | miniaudio for data conversion, decoding and/or encoding. Some      |
    |                                  | families of APIs require threading which means the following       |
    |                                  | options must also be set:                                          |
    |                                  |                                                                    |
    |                                  |     ```                                                            |
    |                                  |     MA_NO_DEVICE_IO                                                |
    |                                  |     ```                                                            |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_GENERATION                 | Disables generation APIs such a `ma_waveform` and `ma_noise`.      |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_SSE2                       | Disables SSE2 optimizations.                                       |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_AVX2                       | Disables AVX2 optimizations.                                       |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_NEON                       | Disables NEON optimizations.                                       |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_NO_RUNTIME_LINKING            | Disables runtime linking. This is useful for passing Apple's       |
    |                                  | notarization process. When enabling this, you may need to avoid    |
    |                                  | using `-std=c89` or `-std=c99` on Linux builds or else you may end |
    |                                  | up with compilation errors due to conflicts with `timespec` and    |
    |                                  | `timeval` data types.                                              |
    |                                  |                                                                    |
    |                                  | You may need to enable this if your target platform does not allow |
    |                                  | runtime linking via `dlopen()`.                                    |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_USE_STDINT                    | (Pass this in as a compiler flag. Do not `#define` this before     |
    |                                  | miniaudio.c) Forces the use of stdint.h for sized types.           |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_DEBUG_OUTPUT                  | Enable `printf()` output of debug logs (`MA_LOG_LEVEL_DEBUG`).     |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_COINIT_VALUE                  | Windows only. The value to pass to internal calls to               |
    |                                  | `CoInitializeEx()`. Defaults to `COINIT_MULTITHREADED`.            |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_FORCE_UWP                     | Windows only. Affects only the WASAPI backend. Will force the      |
    |                                  | WASAPI backend to use the UWP code path instead of the regular     |
    |                                  | desktop path. This is normally auto-detected and should rarely be  |
    |                                  | needed to be used explicitly, but can be useful for debugging.     |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ON_THREAD_ENTRY               | Defines some code that will be executed as soon as an internal     |
    |                                  | miniaudio-managed thread is created. This will be the first thing  |
    |                                  | to be executed by the thread entry point.                          |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_ON_THREAD_EXIT                | Defines some code that will be executed from the entry point of an |
    |                                  | internal miniaudio-managed thread upon exit. This will be the last |
    |                                  | thing to be executed before the thread's entry point exits.        |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_THREAD_DEFAULT_STACK_SIZE     | If set, specifies the default stack size used by miniaudio-managed |
    |                                  | threads.                                                           |
    +----------------------------------+--------------------------------------------------------------------+
    | MA_API                           | Controls how public APIs should be decorated. Default is `extern`. |
    +----------------------------------+--------------------------------------------------------------------+


3. Definitions
==============
This section defines common terms used throughout miniaudio. Unfortunately there is often ambiguity
in the use of terms throughout the audio space, so this section is intended to clarify how miniaudio
uses each term.

3.1. Sample
-----------
A sample is a single unit of audio data. If the sample format is f32, then one sample is one 32-bit
floating point number.

3.2. Frame / PCM Frame
----------------------
A frame is a group of samples equal to the number of channels. For a stereo stream a frame is 2
samples, a mono frame is 1 sample, a 5.1 surround sound frame is 6 samples, etc. The terms "frame"
and "PCM frame" are the same thing in miniaudio. Note that this is different to a compressed frame.
If ever miniaudio needs to refer to a compressed frame, such as a FLAC frame, it will always
clarify what it's referring to with something like "FLAC frame".

3.3. Channel
------------
A stream of monaural audio that is emitted from an individual speaker in a speaker system, or
received from an individual microphone in a microphone system. A stereo stream has two channels (a
left channel, and a right channel), a 5.1 surround sound system has 6 channels, etc. Some audio
systems refer to a channel as a complex audio stream that's mixed with other channels to produce
the final mix - this is completely different to miniaudio's use of the term "channel" and should
not be confused.

3.4. Sample Rate
----------------
The sample rate in miniaudio is always expressed in Hz, such as 44100, 48000, etc. It's the number
of PCM frames that are processed per second.

3.5. Formats
------------
Throughout miniaudio you will see references to different sample formats:

    +---------------+----------------------------------------+---------------------------+
    | Symbol        | Description                            | Range                     |
    +---------------+----------------------------------------+---------------------------+
    | ma_format_f32 | 32-bit floating point                  | [-1, 1]                   |
    | ma_format_s16 | 16-bit signed integer                  | [-32768, 32767]           |
    | ma_format_s24 | 24-bit signed integer (tightly packed) | [-8388608, 8388607]       |
    | ma_format_s32 | 32-bit signed integer                  | [-2147483648, 2147483647] |
    | ma_format_u8  | 8-bit unsigned integer                 | [0, 255]                  |
    +---------------+----------------------------------------+---------------------------+

All formats are native-endian.



4. Data Sources
===============
The data source abstraction in miniaudio is used for retrieving audio data from some source. A few
examples include `ma_decoder`, `ma_noise` and `ma_waveform`. You will need to be familiar with data
sources in order to make sense of some of the higher level concepts in miniaudio.

The `ma_data_source` API is a generic interface for reading from a data source. Any object that
implements the data source interface can be plugged into any `ma_data_source` function.

To read data from a data source:

    ```c
    ma_result result;
    ma_uint64 framesRead;

    result = ma_data_source_read_pcm_frames(pDataSource, pFramesOut, frameCount, &framesRead);
    if (result != MA_SUCCESS) {
        return result;  // Failed to read data from the data source.
    }
    ```

If you don't need the number of frames that were successfully read you can pass in `NULL` to the
`pFramesRead` parameter. If this returns a value less than the number of frames requested it means
the end of the file has been reached. `MA_AT_END` will be returned only when the number of frames
read is 0.

When calling any data source function, with the exception of `ma_data_source_init()` and
`ma_data_source_uninit()`, you can pass in any object that implements a data source. For example,
you could plug in a decoder like so:

    ```c
    ma_result result;
    ma_uint64 framesRead;
    ma_decoder decoder;   // <-- This would be initialized with `ma_decoder_init_*()`.

    result = ma_data_source_read_pcm_frames(&decoder, pFramesOut, frameCount, &framesRead);
    if (result != MA_SUCCESS) {
        return result;  // Failed to read data from the decoder.
    }
    ```

If you want to seek forward you can pass in `NULL` to the `pFramesOut` parameter. Alternatively you
can use `ma_data_source_seek_pcm_frames()`.

To seek to a specific PCM frame:

    ```c
    result = ma_data_source_seek_to_pcm_frame(pDataSource, frameIndex);
    if (result != MA_SUCCESS) {
        return result;  // Failed to seek to PCM frame.
    }
    ```

You can retrieve the total length of a data source in PCM frames, but note that some data sources
may not have the notion of a length, such as noise and waveforms, and others may just not have a
way of determining the length such as some decoders. To retrieve the length:

    ```c
    ma_uint64 length;

    result = ma_data_source_get_length_in_pcm_frames(pDataSource, &length);
    if (result != MA_SUCCESS) {
        return result;  // Failed to retrieve the length.
    }
    ```

Care should be taken when retrieving the length of a data source where the underlying decoder is
pulling data from a data stream with an undefined length, such as internet radio or some kind of
broadcast. If you do this, `ma_data_source_get_length_in_pcm_frames()` may never return.

The current position of the cursor in PCM frames can also be retrieved:

    ```c
    ma_uint64 cursor;

    result = ma_data_source_get_cursor_in_pcm_frames(pDataSource, &cursor);
    if (result != MA_SUCCESS) {
        return result;  // Failed to retrieve the cursor.
    }
    ```

You will often need to know the data format that will be returned after reading. This can be
retrieved like so:

    ```c
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
    ma_channel channelMap[MA_MAX_CHANNELS];

    result = ma_data_source_get_data_format(pDataSource, &format, &channels, &sampleRate, channelMap, MA_MAX_CHANNELS);
    if (result != MA_SUCCESS) {
        return result;  // Failed to retrieve data format.
    }
    ```

If you do not need a specific data format property, just pass in NULL to the respective parameter.

There may be cases where you want to implement something like a sound bank where you only want to
read data within a certain range of the underlying data. To do this you can use a range:

    ```c
    result = ma_data_source_set_range_in_pcm_frames(pDataSource, rangeBegInFrames, rangeEndInFrames);
    if (result != MA_SUCCESS) {
        return result;  // Failed to set the range.
    }
    ```

This is useful if you have a sound bank where many sounds are stored in the same file and you want
the data source to only play one of those sub-sounds. Note that once the range is set, everything
that takes a position, such as cursors and loop points, should always be relatvie to the start of
the range. When the range is set, any previously defined loop point will be reset.

Custom loop points can also be used with data sources. By default, data sources will loop after
they reach the end of the data source, but if you need to loop at a specific location, you can do
the following:

    ```c
    result = ma_data_set_loop_point_in_pcm_frames(pDataSource, loopBegInFrames, loopEndInFrames);
    if (result != MA_SUCCESS) {
        return result;  // Failed to set the loop point.
    }
    ```

The loop point is relative to the current range.

It's sometimes useful to chain data sources together so that a seamless transition can be achieved.
To do this, you can use chaining:

    ```c
    ma_decoder decoder1;
    ma_decoder decoder2;

    // ... initialize decoders with ma_decoder_init_*() ...

    result = ma_data_source_set_next(&decoder1, &decoder2);
    if (result != MA_SUCCESS) {
        return result;  // Failed to set the next data source.
    }

    result = ma_data_source_read_pcm_frames(&decoder1, pFramesOut, frameCount, pFramesRead);
    if (result != MA_SUCCESS) {
        return result;  // Failed to read from the decoder.
    }
    ```

In the example above we're using decoders. When reading from a chain, you always want to read from
the top level data source in the chain. In the example above, `decoder1` is the top level data
source in the chain. When `decoder1` reaches the end, `decoder2` will start seamlessly without any
gaps.

Note that when looping is enabled, only the current data source will be looped. You can loop the
entire chain by linking in a loop like so:

    ```c
    ma_data_source_set_next(&decoder1, &decoder2);  // decoder1 -> decoder2
    ma_data_source_set_next(&decoder2, &decoder1);  // decoder2 -> decoder1 (loop back to the start).
    ```

Note that setting up chaining is not thread safe, so care needs to be taken if you're dynamically
changing links while the audio thread is in the middle of reading.

Do not use `ma_decoder_seek_to_pcm_frame()` as a means to reuse a data source to play multiple
instances of the same sound simultaneously. This can be extremely inefficient depending on the type
of data source and can result in glitching due to subtle changes to the state of internal filters.
Instead, initialize multiple data sources for each instance.


4.1. Custom Data Sources
------------------------
You can implement a custom data source by implementing the functions in `ma_data_source_vtable`.
Your custom object must have `ma_data_source_base` as it's first member:

    ```c
    struct my_data_source
    {
        ma_data_source_base base;
        ...
    };
    ```

In your initialization routine, you need to call `ma_data_source_init()` in order to set up the
base object (`ma_data_source_base`):

    ```c
    static ma_result my_data_source_read(ma_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
    {
        // Read data here. Output in the same format returned by my_data_source_get_data_format().
    }

    static ma_result my_data_source_seek(ma_data_source* pDataSource, ma_uint64 frameIndex)
    {
        // Seek to a specific PCM frame here. Return MA_NOT_IMPLEMENTED if seeking is not supported.
    }

    static ma_result my_data_source_get_data_format(ma_data_source* pDataSource, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)
    {
        // Return the format of the data here.
    }

    static ma_result my_data_source_get_cursor(ma_data_source* pDataSource, ma_uint64* pCursor)
    {
        // Retrieve the current position of the cursor here. Return MA_NOT_IMPLEMENTED and set *pCursor to 0 if there is no notion of a cursor.
    }

    static ma_result my_data_source_get_length(ma_data_source* pDataSource, ma_uint64* pLength)
    {
        // Retrieve the length in PCM frames here. Return MA_NOT_IMPLEMENTED and set *pLength to 0 if there is no notion of a length or if the length is unknown.
    }

    static ma_data_source_vtable g_my_data_source_vtable =
    {
        my_data_source_read,
        my_data_source_seek,
        my_data_source_get_data_format,
        my_data_source_get_cursor,
        my_data_source_get_length
    };

    ma_result my_data_source_init(my_data_source* pMyDataSource)
    {
        ma_result result;
        ma_data_source_config baseConfig;

        baseConfig = ma_data_source_config_init();
        baseConfig.vtable = &g_my_data_source_vtable;

        result = ma_data_source_init(&baseConfig, &pMyDataSource->base);
        if (result != MA_SUCCESS) {
            return result;
        }

        // ... do the initialization of your custom data source here ...

        return MA_SUCCESS;
    }

    void my_data_source_uninit(my_data_source* pMyDataSource)
    {
        // ... do the uninitialization of your custom data source here ...

        // You must uninitialize the base data source.
        ma_data_source_uninit(&pMyDataSource->base);
    }
    ```

Note that `ma_data_source_init()` and `ma_data_source_uninit()` are never called directly outside
of the custom data source. It's up to the custom data source itself to call these within their own
init/uninit functions.



5. Engine
=========
The `ma_engine` API is a high level API for managing and mixing sounds and effect processing. The
`ma_engine` object encapsulates a resource manager and a node graph, both of which will be
explained in more detail later.

Sounds are called `ma_sound` and are created from an engine. Sounds can be associated with a mixing
group called `ma_sound_group` which are also created from the engine. Both `ma_sound` and
`ma_sound_group` objects are nodes within the engine's node graph.

When the engine is initialized, it will normally create a device internally. If you would rather
manage the device yourself, you can do so and just pass a pointer to it via the engine config when
you initialize the engine. You can also just use the engine without a device, which again can be
configured via the engine config.

The most basic way to initialize the engine is with a default config, like so:

    ```c
    ma_result result;
    ma_engine engine;

    result = ma_engine_init(NULL, &engine);
    if (result != MA_SUCCESS) {
        return result;  // Failed to initialize the engine.
    }
    ```

This will result in the engine initializing a playback device using the operating system's default
device. This will be sufficient for many use cases, but if you need more flexibility you'll want to
configure the engine with an engine config:

    ```c
    ma_result result;
    ma_engine engine;
    ma_engine_config engineConfig;

    engineConfig = ma_engine_config_init();
    engineConfig.pDevice = &myDevice;

    result = ma_engine_init(&engineConfig, &engine);
    if (result != MA_SUCCESS) {
        return result;  // Failed to initialize the engine.
    }
    ```

In the example above we're passing in a pre-initialized device. Since the caller is the one in
control of the device's data callback, it's their responsibility to manually call
`ma_engine_read_pcm_frames()` from inside their data callback:

    ```c
    void playback_data_callback(ma_device* pDevice, void* pOutput, const void* pInput, ma_uint32 frameCount)
    {
        ma_engine_read_pcm_frames(&g_Engine, pOutput, frameCount, NULL);
    }
    ```

You can also use the engine independent of a device entirely:

    ```c
    ma_result result;
    ma_engine engine;
    ma_engine_config engineConfig;

    engineConfig = ma_engine_config_init();
    engineConfig.noDevice   = MA_TRUE;
    engineConfig.channels   = 2;        // Must be set when not using a device.
    engineConfig.sampleRate = 48000;    // Must be set when not using a device.

    result = ma_engine_init(&engineConfig, &engine);
    if (result != MA_SUCCESS) {
        return result;  // Failed to initialize the engine.
    }
    ```

Note that when you're not using a device, you must set the channel count and sample rate in the
config or else miniaudio won't know what to use (miniaudio will use the device to determine this
normally). When not using a device, you need to use `ma_engine_read_pcm_frames()` to process audio
data from the engine. This kind of setup is useful if you want to do something like offline
processing or want to use a different audio system for playback such as SDL.

When a sound is loaded it goes through a resource manager. By default the engine will initialize a
resource manager internally, but you can also specify a pre-initialized resource manager:

    ```c
    ma_result result;
    ma_engine engine1;
    ma_engine engine2;
    ma_engine_config engineConfig;

    engineConfig = ma_engine_config_init();
    engineConfig.pResourceManager = &myResourceManager;

    ma_engine_init(&engineConfig, &engine1);
    ma_engine_init(&engineConfig, &engine2);
    ```

In this example we are initializing two engines, both of which are sharing the same resource
manager. This is especially useful for saving memory when loading the same file across multiple
engines. If you were not to use a shared resource manager, each engine instance would use their own
which would result in any sounds that are used between both engine's being loaded twice. By using
a shared resource manager, it would only be loaded once. Using multiple engine's is useful when you
need to output to multiple playback devices, such as in a local multiplayer game where each player
is using their own set of headphones.

By default an engine will be in a started state. To make it so the engine is not automatically
started you can configure it as such:

    ```c
    engineConfig.noAutoStart = MA_TRUE;

    // The engine will need to be started manually.
    ma_engine_start(&engine);

    // Later on the engine can be stopped with ma_engine_stop().
    ma_engine_stop(&engine);
    ```

The concept of starting or stopping an engine is only relevant when using the engine with a
device. Attempting to start or stop an engine that is not associated with a device will result in
`MA_INVALID_OPERATION`.

The master volume of the engine can be controlled with `ma_engine_set_volume()` which takes a
linear scale, with 0 resulting in silence and anything above 1 resulting in amplification. If you
prefer decibel based volume control, use `ma_volume_db_to_linear()` to convert from dB to linear.

When a sound is spatialized, it is done so relative to a listener. An engine can be configured to
have multiple listeners which can be configured via the config:

    ```c
    engineConfig.listenerCount = 2;
    ```

The maximum number of listeners is restricted to `MA_ENGINE_MAX_LISTENERS`. By default, when a
sound is spatialized, it will be done so relative to the closest listener. You can also pin a sound
to a specific listener which will be explained later. Listener's have a position, direction, cone,
and velocity (for doppler effect). A listener is referenced by an index, the meaning of which is up
to the caller (the index is 0 based and cannot go beyond the listener count, minus 1). The
position, direction and velocity are all specified in absolute terms:

    ```c
    ma_engine_listener_set_position(&engine, listenerIndex, worldPosX, worldPosY, worldPosZ);
    ```

The direction of the listener represents it's forward vector. The listener's up vector can also be
specified and defaults to +1 on the Y axis.

    ```c
    ma_engine_listener_set_direction(&engine, listenerIndex, forwardX, forwardY, forwardZ);
    ma_engine_listener_set_world_up(&engine, listenerIndex, 0, 1, 0);
    ```

The engine supports directional attenuation. The listener can have a cone the controls how sound is
attenuated based on the listener's direction. When a sound is between the inner and outer cones, it
will be attenuated between 1 and the cone's outer gain:

    ```c
    ma_engine_listener_set_cone(&engine, listenerIndex, innerAngleInRadians, outerAngleInRadians, outerGain);
    ```

When a sound is inside the inner code, no directional attenuation is applied. When the sound is
outside of the outer cone, the attenuation will be set to `outerGain` in the example above. When
the sound is in between the inner and outer cones, the attenuation will be interpolated between 1
and the outer gain.

The engine's coordinate system follows the OpenGL coordinate system where positive X points right,
positive Y points up and negative Z points forward.

The simplest and least flexible way to play a sound is like so:

    ```c
    ma_engine_play_sound(&engine, "my_sound.wav", pGroup);
    ```

This is a "fire and forget" style of function. The engine will manage the `ma_sound` object
internally. When the sound finishes playing, it'll be put up for recycling. For more flexibility
you'll want to initialize a sound object:

    ```c
    ma_sound sound;

    result = ma_sound_init_from_file(&engine, "my_sound.wav", flags, pGroup, NULL, &sound);
    if (result != MA_SUCCESS) {
        return result;  // Failed to load sound.
    }
    ```

Sounds need to be uninitialized with `ma_sound_uninit()`.

The example above loads a sound from a file. If the resource manager has been disabled you will not
be able to use this function and instead you'll need to initialize a sound directly from a data
source:

    ```c
    ma_sound sound;

    result = ma_sound_init_from_data_source(&engine, &dataSource, flags, pGroup, &sound);
    if (result != MA_SUCCESS) {
        return result;
    }
    ```

Each `ma_sound` object represents a single instance of the sound. If you want to play the same
sound multiple times at the same time, you need to initialize a separate `ma_sound` object.

For the most flexibility when initializing sounds, use `ma_sound_init_ex()`. This uses miniaudio's
standard config/init pattern:

    ```c
    ma_sound sound;
    ma_sound_config soundConfig;

    soundConfig = ma_sound_config_init();
    soundConfig.pFilePath   = NULL; // Set this to load from a file path.
    soundConfig.pDataSource = NULL; // Set this to initialize from an existing data source.
    soundConfig.pInitialAttachment = &someNodeInTheNodeGraph;
    soundConfig.initialAttachmentInputBusIndex = 0;
    soundConfig.channelsIn  = 1;
    soundConfig.channelsOut = 0;    // Set to 0 to use the engine's native channel count.

    result = ma_sound_init_ex(&soundConfig, &sound);
    if (result != MA_SUCCESS) {
        return result;
    }
    ```

In the example above, the sound is being initialized without a file nor a data source. This is
valid, in which case the sound acts as a node in the middle of the node graph. This means you can
connect other sounds to this sound and allow it to act like a sound group. Indeed, this is exactly
what a `ma_sound_group` is.

When loading a sound, you specify a set of flags that control how the sound is loaded and what
features are enabled for that sound. When no flags are set, the sound will be fully loaded into
memory in exactly the same format as how it's stored on the file system. The resource manager will
allocate a block of memory and then load the file directly into it. When reading audio data, it
will be decoded dynamically on the fly. In order to save processing time on the audio thread, it
might be beneficial to pre-decode the sound. You can do this with the `MA_SOUND_FLAG_DECODE` flag:

    ```c
    ma_sound_init_from_file(&engine, "my_sound.wav", MA_SOUND_FLAG_DECODE, pGroup, NULL, &sound);
    ```

By default, sounds will be loaded synchronously, meaning `ma_sound_init_*()` will not return until
the sound has been fully loaded. If this is prohibitive you can instead load sounds asynchronously
by specifying the `MA_SOUND_FLAG_ASYNC` flag:

    ```c
    ma_sound_init_from_file(&engine, "my_sound.wav", MA_SOUND_FLAG_DECODE | MA_SOUND_FLAG_ASYNC, pGroup, NULL, &sound);
    ```

This will result in `ma_sound_init_*()` returning quickly, but the sound won't yet have been fully
loaded. When you start the sound, it won't output anything until some sound is available. The sound
will start outputting audio before the sound has been fully decoded when the `MA_SOUND_FLAG_DECODE`
is specified.

If you need to wait for an asynchronously loaded sound to be fully loaded, you can use a fence. A
fence in miniaudio is a simple synchronization mechanism which simply blocks until it's internal
counter hit's zero. You can specify a fence like so:

    ```c
    ma_result result;
    ma_fence fence;
    ma_sound sounds[4];

    result = ma_fence_init(&fence);
    if (result != MA_SUCCESS) {
        return result;
    }

    // Load some sounds asynchronously.
    for (int iSound = 0; iSound < 4; iSound += 1) {
        ma_sound_init_from_file(&engine, mySoundFilesPaths[iSound], MA_SOUND_FLAG_DECODE | MA_SOUND_FLAG_ASYNC, pGroup, &fence, &sounds[iSound]);
    }

    // ... do some other stuff here in the mean time ...

    // Wait for all sounds to finish loading.
    ma_fence_wait(&fence);
    ```

If loading the entire sound into memory is prohibitive, you can also configure the engine to stream
the audio data:

    ```c
    ma_sound_init_from_file(&engine, "my_sound.wav", MA_SOUND_FLAG_STREAM, pGroup, NULL, &sound);
    ```

When streaming sounds, 2 seconds worth of audio data is stored in memory. Although it should work
fine, it's inefficient to use streaming for short sounds. Streaming is useful for things like music
tracks in games.

When loading a sound from a file path, the engine will reference count the file to prevent it from
being loaded if it's already in memory. When you uninitialize a sound, the reference count will be
decremented, and if it hits zero, the sound will be unloaded from memory. This reference counting
system is not used for streams. The engine will use a 64-bit hash of the file name when comparing
file paths which means there's a small chance you might encounter a name collision. If this is an
issue, you'll need to use a different name for one of the colliding file paths, or just not load
from files and instead load from a data source.

You can use `ma_sound_init_copy()` to initialize a copy of another sound. Note, however, that this
only works for sounds that were initialized with `ma_sound_init_from_file()` and without the
`MA_SOUND_FLAG_STREAM` flag.

When you initialize a sound, if you specify a sound group the sound will be attached to that group
automatically. If you set it to NULL, it will be automatically attached to the engine's endpoint.
If you would instead rather leave the sound unattached by default, you can specify the
`MA_SOUND_FLAG_NO_DEFAULT_ATTACHMENT` flag. This is useful if you want to set up a complex node
graph.

Sounds are not started by default. To start a sound, use `ma_sound_start()`. Stop a sound with
`ma_sound_stop()`.

Sounds can have their volume controlled with `ma_sound_set_volume()` in the same way as the
engine's master volume.

Sounds support stereo panning and pitching. Set the pan with `ma_sound_set_pan()`. Setting the pan
to 0 will result in an unpanned sound. Setting it to -1 will shift everything to the left, whereas
+1 will shift it to the right. The pitch can be controlled with `ma_sound_set_pitch()`. A larger
value will result in a higher pitch. The pitch must be greater than 0.

The engine supports 3D spatialization of sounds. By default sounds will have spatialization
enabled, but if a sound does not need to be spatialized it's best to disable it. There are two ways
to disable spatialization of a sound:

    ```c
    // Disable spatialization at initialization time via a flag:
    ma_sound_init_from_file(&engine, "my_sound.wav", MA_SOUND_FLAG_NO_SPATIALIZATION, NULL, NULL, &sound);

    // Dynamically disable or enable spatialization post-initialization:
    ma_sound_set_spatialization_enabled(&sound, isSpatializationEnabled);
    ```

By default sounds will be spatialized based on the closest listener. If a sound should always be
spatialized relative to a specific listener it can be pinned to one:

    ```c
    ma_sound_set_pinned_listener_index(&sound, listenerIndex);
    ```

Like listeners, sounds have a position. By default, the position of a sound is in absolute space,
but it can be changed to be relative to a listener:

    ```c
    ma_sound_set_positioning(&sound, ma_positioning_relative);
    ```

Note that relative positioning of a sound only makes sense if there is either only one listener, or
the sound is pinned to a specific listener. To set the position of a sound:

    ```c
    ma_sound_set_position(&sound, posX, posY, posZ);
    ```

The direction works the same way as a listener and represents the sound's forward direction:

    ```c
    ma_sound_set_direction(&sound, forwardX, forwardY, forwardZ);
    ```

Sound's also have a cone for controlling directional attenuation. This works exactly the same as
listeners:

    ```c
    ma_sound_set_cone(&sound, innerAngleInRadians, outerAngleInRadians, outerGain);
    ```

The velocity of a sound is used for doppler effect and can be set as such:

    ```c
    ma_sound_set_velocity(&sound, velocityX, velocityY, velocityZ);
    ```

The engine supports different attenuation models which can be configured on a per-sound basis. By
default the attenuation model is set to `ma_attenuation_model_inverse` which is the equivalent to
OpenAL's `AL_INVERSE_DISTANCE_CLAMPED`. Configure the attenuation model like so:

    ```c
    ma_sound_set_attenuation_model(&sound, ma_attenuation_model_inverse);
    ```

The supported attenuation models include the following:

    +----------------------------------+----------------------------------------------+
    | ma_attenuation_model_none        | No distance attenuation.                     |
    +----------------------------------+----------------------------------------------+
    | ma_attenuation_model_inverse     | Equivalent to `AL_INVERSE_DISTANCE_CLAMPED`. |
    +----------------------------------+----------------------------------------------+
    | ma_attenuation_model_linear      | Linear attenuation.                          |
    +----------------------------------+----------------------------------------------+
    | ma_attenuation_model_exponential | Exponential attenuation.                     |
    +----------------------------------+----------------------------------------------+

To control how quickly a sound rolls off as it moves away from the listener, you need to configure
the rolloff:

    ```c
    ma_sound_set_rolloff(&sound, rolloff);
    ```

You can control the minimum and maximum gain to apply from spatialization:

    ```c
    ma_sound_set_min_gain(&sound, minGain);
    ma_sound_set_max_gain(&sound, maxGain);
    ```

Likewise, in the calculation of attenuation, you can control the minimum and maximum distances for
the attenuation calculation. This is useful if you want to ensure sounds don't drop below a certain
volume after the listener moves further away and to have sounds play a maximum volume when the
listener is within a certain distance:

    ```c
    ma_sound_set_min_distance(&sound, minDistance);
    ma_sound_set_max_distance(&sound, maxDistance);
    ```

The engine's spatialization system supports doppler effect. The doppler factor can be configure on
a per-sound basis like so:

    ```c
    ma_sound_set_doppler_factor(&sound, dopplerFactor);
    ```

You can fade sounds in and out with `ma_sound_set_fade_in_pcm_frames()` and
`ma_sound_set_fade_in_milliseconds()`. Set the volume to -1 to use the current volume as the
starting volume:

    ```c
    // Fade in over 1 second.
    ma_sound_set_fade_in_milliseconds(&sound, 0, 1, 1000);

    // ... sometime later ...

    // Fade out over 1 second, starting from the current volume.
    ma_sound_set_fade_in_milliseconds(&sound, -1, 0, 1000);
    ```

By default sounds will start immediately, but sometimes for timing and synchronization purposes it
can be useful to schedule a sound to start or stop:

    ```c
    // Start the sound in 1 second from now.
    ma_sound_set_start_time_in_pcm_frames(&sound, ma_engine_get_time_in_pcm_frames(&engine) + (ma_engine_get_sample_rate(&engine) * 1));

    // Stop the sound in 2 seconds from now.
    ma_sound_set_stop_time_in_pcm_frames(&sound, ma_engine_get_time_in_pcm_frames(&engine) + (ma_engine_get_sample_rate(&engine) * 2));
    ```

Note that scheduling a start time still requires an explicit call to `ma_sound_start()` before
anything will play.

The time is specified in global time which is controlled by the engine. You can get the engine's
current time with `ma_engine_get_time_in_pcm_frames()`. The engine's global time is incremented
automatically as audio data is read, but it can be reset with `ma_engine_set_time_in_pcm_frames()`
in case it needs to be resynchronized for some reason.

To determine whether or not a sound is currently playing, use `ma_sound_is_playing()`. This will
take the scheduled start and stop times into account.

Whether or not a sound should loop can be controlled with `ma_sound_set_looping()`. Sounds will not
be looping by default. Use `ma_sound_is_looping()` to determine whether or not a sound is looping.

Use `ma_sound_at_end()` to determine whether or not a sound is currently at the end. For a looping
sound this should never return true. Alternatively, you can configure a callback that will be fired
when the sound reaches the end. Note that the callback is fired from the audio thread which means
you cannot be uninitializing sound from the callback. To set the callback you can use
`ma_sound_set_end_callback()`. Alternatively, if you're using `ma_sound_init_ex()`, you can pass it
into the config like so:

    ```c
    soundConfig.endCallback = my_end_callback;
    soundConfig.pEndCallbackUserData = pMyEndCallbackUserData;
    ```

The end callback is declared like so:

    ```c
    void my_end_callback(void* pUserData, ma_sound* pSound)
    {
        ...
    }
    ```

Internally a sound wraps around a data source. Some APIs exist to control the underlying data
source, mainly for convenience:

    ```c
    ma_sound_seek_to_pcm_frame(&sound, frameIndex);
    ma_sound_get_data_format(&sound, &format, &channels, &sampleRate, pChannelMap, channelMapCapacity);
    ma_sound_get_cursor_in_pcm_frames(&sound, &cursor);
    ma_sound_get_length_in_pcm_frames(&sound, &length);
    ```

Sound groups have the same API as sounds, only they are called `ma_sound_group`, and since they do
not have any notion of a data source, anything relating to a data source is unavailable.

Internally, sound data is loaded via the `ma_decoder` API which means by default it only supports
file formats that have built-in support in miniaudio. You can extend this to support any kind of
file format through the use of custom decoders. To do this you'll need to use a self-managed
resource manager and configure it appropriately. See the "Resource Management" section below for
details on how to set this up.


6. Resource Management
======================
Many programs will want to manage sound resources for things such as reference counting and
streaming. This is supported by miniaudio via the `ma_resource_manager` API.

The resource manager is mainly responsible for the following:

  * Loading of sound files into memory with reference counting.
  * Streaming of sound data.

When loading a sound file, the resource manager will give you back a `ma_data_source` compatible
object called `ma_resource_manager_data_source`. This object can be passed into any
`ma_data_source` API which is how you can read and seek audio data. When loading a sound file, you
specify whether or not you want the sound to be fully loaded into memory (and optionally
pre-decoded) or streamed. When loading into memory, you can also specify whether or not you want
the data to be loaded asynchronously.

The example below is how you can initialize a resource manager using it's default configuration:

    ```c
    ma_resource_manager_config config;
    ma_resource_manager resourceManager;

    config = ma_resource_manager_config_init();
    result = ma_resource_manager_init(&config, &resourceManager);
    if (result != MA_SUCCESS) {
        ma_device_uninit(&device);
        printf("Failed to initialize the resource manager.");
        return -1;
    }
    ```

You can configure the format, channels and sample rate of the decoded audio data. By default it
will use the file's native data format, but you can configure it to use a consistent format. This
is useful for offloading the cost of data conversion to load time rather than dynamically
converting at mixing time. To do this, you configure the decoded format, channels and sample rate
like the code below:

    ```c
    config = ma_resource_manager_config_init();
    config.decodedFormat     = device.playback.format;
    config.decodedChannels   = device.playback.channels;
    config.decodedSampleRate = device.sampleRate;
    ```

In the code above, the resource manager will be configured so that any decoded audio data will be
pre-converted at load time to the device's native data format. If instead you used defaults and
the data format of the file did not match the device's data format, you would need to convert the
data at mixing time which may be prohibitive in high-performance and large scale scenarios like
games.

Internally the resource manager uses the `ma_decoder` API to load sounds. This means by default it
only supports decoders that are built into miniaudio. It's possible to support additional encoding
formats through the use of custom decoders. To do so, pass in your `ma_decoding_backend_vtable`
vtables into the resource manager config:

    ```c
    ma_decoding_backend_vtable* pCustomBackendVTables[] =
    {
        &g_ma_decoding_backend_vtable_libvorbis,
        &g_ma_decoding_backend_vtable_libopus
    };

    ...

    resourceManagerConfig.ppCustomDecodingBackendVTables = pCustomBackendVTables;
    resourceManagerConfig.customDecodingBackendCount     = sizeof(pCustomBackendVTables) / sizeof(pCustomBackendVTables[0]);
    resourceManagerConfig.pCustomDecodingBackendUserData = NULL;
    ```

This system can allow you to support any kind of file format. See the "Decoding" section for
details on how to implement custom decoders. The miniaudio repository includes examples for Opus
via libopus and libopusfile and Vorbis via libvorbis and libvorbisfile.

Asynchronicity is achieved via a job system. When an operation needs to be performed, such as the
decoding of a page, a job will be posted to a queue which will then be processed by a job thread.
By default there will be only one job thread running, but this can be configured, like so:

    ```c
    config = ma_resource_manager_config_init();
    config.jobThreadCount = MY_JOB_THREAD_COUNT;
    ```

By default job threads are managed internally by the resource manager, however you can also self
manage your job threads if, for example, you want to integrate the job processing into your
existing job infrastructure, or if you simply don't like the way the resource manager does it. To
do this, just set the job thread count to 0 and process jobs manually. To process jobs, you first
need to retrieve a job using `ma_resource_manager_next_job()` and then process it using
`ma_job_process()`:

    ```c
    config = ma_resource_manager_config_init();
    config.jobThreadCount = 0;                            // Don't manage any job threads internally.
    config.flags = MA_RESOURCE_MANAGER_FLAG_NON_BLOCKING; // Optional. Makes `ma_resource_manager_next_job()` non-blocking.

    // ... Initialize your custom job threads ...

    void my_custom_job_thread(...)
    {
        for (;;) {
            ma_job job;
            ma_result result = ma_resource_manager_next_job(pMyResourceManager, &job);
            if (result != MA_SUCCESS) {
                if (result == MA_NO_DATA_AVAILABLE) {
                    // No jobs are available. Keep going. Will only get this if the resource manager was initialized
                    // with MA_RESOURCE_MANAGER_FLAG_NON_BLOCKING.
                    continue;
                } else if (result == MA_CANCELLED) {
                    // MA_JOB_TYPE_QUIT was posted. Exit.
                    break;
                } else {
                    // Some other error occurred.
                    break;
                }
            }

            ma_job_process(&job);
        }
    }
    ```

In the example above, the `MA_JOB_TYPE_QUIT` event is the used as the termination
indicator, but you can use whatever you would like to terminate the thread. The call to
`ma_resource_manager_next_job()` is blocking by default, but can be configured to be non-blocking
by initializing the resource manager with the `MA_RESOURCE_MANAGER_FLAG_NON_BLOCKING` configuration
flag. Note that the `MA_JOB_TYPE_QUIT` will never be removed from the job queue. This
is to give every thread the opportunity to catch the event and terminate naturally.

When loading a file, it's sometimes convenient to be able to customize how files are opened and
read instead of using standard `fopen()`, `fclose()`, etc. which is what miniaudio will use by
default. This can be done by setting `pVFS` member of the resource manager's config:

    ```c
    // Initialize your custom VFS object. See documentation for VFS for information on how to do this.
    my_custom_vfs vfs = my_custom_vfs_init();

    config = ma_resource_manager_config_init();
    config.pVFS = &vfs;
    ```

This is particularly useful in programs like games where you want to read straight from an archive
rather than the normal file system. If you do not specify a custom VFS, the resource manager will
use the operating system's normal file operations.

To load a sound file and create a data source, call `ma_resource_manager_data_source_init()`. When
loading a sound you need to specify the file path and options for how the sounds should be loaded.
By default a sound will be loaded synchronously. The returned data source is owned by the caller
which means the caller is responsible for the allocation and freeing of the data source. Below is
an example for initializing a data source:

    ```c
    ma_resource_manager_data_source dataSource;
    ma_result result = ma_resource_manager_data_source_init(pResourceManager, pFilePath, flags, &dataSource);
    if (result != MA_SUCCESS) {
        // Error.
    }

    // ...

    // A ma_resource_manager_data_source object is compatible with the `ma_data_source` API. To read data, just call
    // the `ma_data_source_read_pcm_frames()` like you would with any normal data source.
    result = ma_data_source_read_pcm_frames(&dataSource, pDecodedData, frameCount, &framesRead);
    if (result != MA_SUCCESS) {
        // Failed to read PCM frames.
    }

    // ...

    ma_resource_manager_data_source_uninit(&dataSource);
    ```

The `flags` parameter specifies how you want to perform loading of the sound file. It can be a
combination of the following flags:

    ```
    MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM
    MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_DECODE
    MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC
    MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT
    MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_LOOPING
    ```

When no flags are specified (set to 0), the sound will be fully loaded into memory, but not
decoded, meaning the raw file data will be stored in memory, and then dynamically decoded when
`ma_data_source_read_pcm_frames()` is called. To instead decode the audio data before storing it in
memory, use the `MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_DECODE` flag. By default, the sound file will
be loaded synchronously, meaning `ma_resource_manager_data_source_init()` will only return after
the entire file has been loaded. This is good for simplicity, but can be prohibitively slow. You
can instead load the sound asynchronously using the `MA_RESOURCE_MANAGER_DATA_SOURCE_ASYNC` flag.
This will result in `ma_resource_manager_data_source_init()` returning quickly, but no data will be
returned by `ma_data_source_read_pcm_frames()` until some data is available. When no data is
available because the asynchronous decoding hasn't caught up, `MA_BUSY` will be returned by
`ma_data_source_read_pcm_frames()`.

For large sounds, it's often prohibitive to store the entire file in memory. To mitigate this, you
can instead stream audio data which you can do by specifying the
`MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM` flag. When streaming, data will be decoded in 1
second pages. When a new page needs to be decoded, a job will be posted to the job queue and then
subsequently processed in a job thread.

The `MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_LOOPING` flag can be used so that the sound will loop
when it reaches the end by default. It's recommended you use this flag when you want to have a
looping streaming sound. If you try loading a very short sound as a stream, you will get a glitch.
This is because the resource manager needs to pre-fill the initial buffer at initialization time,
and if you don't specify the `MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_LOOPING` flag, the resource
manager will assume the sound is not looping and will stop filling the buffer when it reaches the
end, therefore resulting in a discontinuous buffer.

For in-memory sounds, reference counting is used to ensure the data is loaded only once. This means
multiple calls to `ma_resource_manager_data_source_init()` with the same file path will result in
the file data only being loaded once. Each call to `ma_resource_manager_data_source_init()` must be
matched up with a call to `ma_resource_manager_data_source_uninit()`. Sometimes it can be useful
for a program to register self-managed raw audio data and associate it with a file path. Use the
`ma_resource_manager_register_*()` and `ma_resource_manager_unregister_*()` APIs to do this.
`ma_resource_manager_register_decoded_data()` is used to associate a pointer to raw, self-managed
decoded audio data in the specified data format with the specified name. Likewise,
`ma_resource_manager_register_encoded_data()` is used to associate a pointer to raw self-managed
encoded audio data (the raw file data) with the specified name. Note that these names need not be
actual file paths. When `ma_resource_manager_data_source_init()` is called (without the
`MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM` flag), the resource manager will look for these
explicitly registered data buffers and, if found, will use it as the backing data for the data
source. Note that the resource manager does *not* make a copy of this data so it is up to the
caller to ensure the pointer stays valid for its lifetime. Use
`ma_resource_manager_unregister_data()` to unregister the self-managed data. You can also use
`ma_resource_manager_register_file()` and `ma_resource_manager_unregister_file()` to register and
unregister a file. It does not make sense to use the `MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM`
flag with a self-managed data pointer.


6.1. Asynchronous Loading and Synchronization
---------------------------------------------
When loading asynchronously, it can be useful to poll whether or not loading has finished. Use
`ma_resource_manager_data_source_result()` to determine this. For in-memory sounds, this will
return `MA_SUCCESS` when the file has been *entirely* decoded. If the sound is still being decoded,
`MA_BUSY` will be returned. Otherwise, some other error code will be returned if the sound failed
to load. For streaming data sources, `MA_SUCCESS` will be returned when the first page has been
decoded and the sound is ready to be played. If the first page is still being decoded, `MA_BUSY`
will be returned. Otherwise, some other error code will be returned if the sound failed to load.

In addition to polling, you can also use a simple synchronization object called a "fence" to wait
for asynchronously loaded sounds to finish. This is called `ma_fence`. The advantage to using a
fence is that it can be used to wait for a group of sounds to finish loading rather than waiting
for sounds on an individual basis. There are two stages to loading a sound:

  * Initialization of the internal decoder; and
  * Completion of decoding of the file (the file is fully decoded)

You can specify separate fences for each of the different stages. Waiting for the initialization
of the internal decoder is important for when you need to know the sample format, channels and
sample rate of the file.

The example below shows how you could use a fence when loading a number of sounds:

    ```c
    // This fence will be released when all sounds are finished loading entirely.
    ma_fence fence;
    ma_fence_init(&fence);

    // This will be passed into the initialization routine for each sound.
    ma_resource_manager_pipeline_notifications notifications = ma_resource_manager_pipeline_notifications_init();
    notifications.done.pFence = &fence;

    // Now load a bunch of sounds:
    for (iSound = 0; iSound < soundCount; iSound += 1) {
        ma_resource_manager_data_source_init(pResourceManager, pSoundFilePaths[iSound], flags, &notifications, &pSoundSources[iSound]);
    }

    // ... DO SOMETHING ELSE WHILE SOUNDS ARE LOADING ...

    // Wait for loading of sounds to finish.
    ma_fence_wait(&fence);
    ```

In the example above we used a fence for waiting until the entire file has been fully decoded. If
you only need to wait for the initialization of the internal decoder to complete, you can use the
`init` member of the `ma_resource_manager_pipeline_notifications` object:

    ```c
    notifications.init.pFence = &fence;
    ```

If a fence is not appropriate for your situation, you can instead use a callback that is fired on
an individual sound basis. This is done in a very similar way to fences:

    ```c
    typedef struct
    {
        ma_async_notification_callbacks cb;
        void* pMyData;
    } my_notification;

    void my_notification_callback(ma_async_notification* pNotification)
    {
        my_notification* pMyNotification = (my_notification*)pNotification;

        // Do something in response to the sound finishing loading.
    }

    ...

    my_notification myCallback;
    myCallback.cb.onSignal = my_notification_callback;
    myCallback.pMyData     = pMyData;

    ma_resource_manager_pipeline_notifications notifications = ma_resource_manager_pipeline_notifications_init();
    notifications.done.pNotification = &myCallback;

    ma_resource_manager_data_source_init(pResourceManager, "my_sound.wav", flags, &notifications, &mySound);
    ```

In the example above we just extend the `ma_async_notification_callbacks` object and pass an
instantiation into the `ma_resource_manager_pipeline_notifications` in the same way as we did with
the fence, only we set `pNotification` instead of `pFence`. You can set both of these at the same
time and they should both work as expected. If using the `pNotification` system, you need to ensure
your `ma_async_notification_callbacks` object stays valid.



6.2. Resource Manager Implementation Details
--------------------------------------------
Resources are managed in two main ways:

  * By storing the entire sound inside an in-memory buffer (referred to as a data buffer)
  * By streaming audio data on the fly (referred to as a data stream)

A resource managed data source (`ma_resource_manager_data_source`) encapsulates a data buffer or
data stream, depending on whether or not the data source was initialized with the
`MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM` flag. If so, it will make use of a
`ma_resource_manager_data_stream` object. Otherwise it will use a `ma_resource_manager_data_buffer`
object. Both of these objects are data sources which means they can be used with any
`ma_data_source_*()` API.

Another major feature of the resource manager is the ability to asynchronously decode audio files.
This relieves the audio thread of time-consuming decoding which can negatively affect scalability
due to the audio thread needing to complete it's work extremely quickly to avoid glitching.
Asynchronous decoding is achieved through a job system. There is a central multi-producer,
multi-consumer, fixed-capacity job queue. When some asynchronous work needs to be done, a job is
posted to the queue which is then read by a job thread. The number of job threads can be
configured for improved scalability, and job threads can all run in parallel without needing to
worry about the order of execution (how this is achieved is explained below).

When a sound is being loaded asynchronously, playback can begin before the sound has been fully
decoded. This enables the application to start playback of the sound quickly, while at the same
time allowing to resource manager to keep loading in the background. Since there may be less
threads than the number of sounds being loaded at a given time, a simple scheduling system is used
to keep decoding time balanced and fair. The resource manager solves this by splitting decoding
into chunks called pages. By default, each page is 1 second long. When a page has been decoded, a
new job will be posted to start decoding the next page. By dividing up decoding into pages, an
individual sound shouldn't ever delay every other sound from having their first page decoded. Of
course, when loading many sounds at the same time, there will always be an amount of time required
to process jobs in the queue so in heavy load situations there will still be some delay. To
determine if a data source is ready to have some frames read, use
`ma_resource_manager_data_source_get_available_frames()`. This will return the number of frames
available starting from the current position.


6.2.1. Job Queue
----------------
The resource manager uses a job queue which is multi-producer, multi-consumer, and fixed-capacity.
This job queue is not currently lock-free, and instead uses a spinlock to achieve thread-safety.
Only a fixed number of jobs can be allocated and inserted into the queue which is done through a
lock-free data structure for allocating an index into a fixed sized array, with reference counting
for mitigation of the ABA problem. The reference count is 32-bit.

For many types of jobs it's important that they execute in a specific order. In these cases, jobs
are executed serially. For the resource manager, serial execution of jobs is only required on a
per-object basis (per data buffer or per data stream). Each of these objects stores an execution
counter. When a job is posted it is associated with an execution counter. When the job is
processed, it checks if the execution counter of the job equals the execution counter of the
owning object and if so, processes the job. If the counters are not equal, the job will be posted
back onto the job queue for later processing. When the job finishes processing the execution order
of the main object is incremented. This system means the no matter how many job threads are
executing, decoding of an individual sound will always get processed serially. The advantage to
having multiple threads comes into play when loading multiple sounds at the same time.

The resource manager's job queue is not 100% lock-free and will use a spinlock to achieve
thread-safety for a very small section of code. This is only relevant when the resource manager
uses more than one job thread. If only using a single job thread, which is the default, the
lock should never actually wait in practice. The amount of time spent locking should be quite
short, but it's something to be aware of for those who have pedantic lock-free requirements and
need to use more than one job thread. There are plans to remove this lock in a future version.

In addition, posting a job will release a semaphore, which on Win32 is implemented with
`ReleaseSemaphore` and on POSIX platforms via a condition variable:

    ```c
    pthread_mutex_lock(&pSemaphore->lock);
    {
        pSemaphore->value += 1;
        pthread_cond_signal(&pSemaphore->cond);
    }
    pthread_mutex_unlock(&pSemaphore->lock);
    ```

Again, this is relevant for those with strict lock-free requirements in the audio thread. To avoid
this, you can use non-blocking mode (via the `MA_JOB_QUEUE_FLAG_NON_BLOCKING`
flag) and implement your own job processing routine (see the "Resource Manager" section above for
details on how to do this).



6.2.2. Data Buffers
-------------------
When the `MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM` flag is excluded at initialization time, the
resource manager will try to load the data into an in-memory data buffer. Before doing so, however,
it will first check if the specified file is already loaded. If so, it will increment a reference
counter and just use the already loaded data. This saves both time and memory. When the data buffer
is uninitialized, the reference counter will be decremented. If the counter hits zero, the file
will be unloaded. This is a detail to keep in mind because it could result in excessive loading and
unloading of a sound. For example, the following sequence will result in a file be loaded twice,
once after the other:

    ```c
    ma_resource_manager_data_source_init(pResourceManager, "my_file", ..., &myDataBuffer0); // Refcount = 1. Initial load.
    ma_resource_manager_data_source_uninit(&myDataBuffer0);                                 // Refcount = 0. Unloaded.

    ma_resource_manager_data_source_init(pResourceManager, "my_file", ..., &myDataBuffer1); // Refcount = 1. Reloaded because previous uninit() unloaded it.
    ma_resource_manager_data_source_uninit(&myDataBuffer1);                                 // Refcount = 0. Unloaded.
    ```

A binary search tree (BST) is used for storing data buffers as it has good balance between
efficiency and simplicity. The key of the BST is a 64-bit hash of the file path that was passed
into `ma_resource_manager_data_source_init()`. The advantage of using a hash is that it saves
memory over storing the entire path, has faster comparisons, and results in a mostly balanced BST
due to the random nature of the hash. The disadvantages are that file names are case-sensitive and
there's a small chance of name collisions. If case-sensitivity is an issue, you should normalize
your file names to upper- or lower-case before initializing your data sources. If name collisions
become an issue, you'll need to change the name of one of the colliding names or just not use the
resource manager.

When a sound file has not already been loaded and the `MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC`
flag is excluded, the file will be decoded synchronously by the calling thread. There are two
options for controlling how the audio is stored in the data buffer - encoded or decoded. When the
`MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_DECODE` option is excluded, the raw file data will be stored
in memory. Otherwise the sound will be decoded before storing it in memory. Synchronous loading is
a very simple and standard process of simply adding an item to the BST, allocating a block of
memory and then decoding (if `MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_DECODE` is specified).

When the `MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC` flag is specified, loading of the data buffer
is done asynchronously. In this case, a job is posted to the queue to start loading and then the
function immediately returns, setting an internal result code to `MA_BUSY`. This result code is
returned when the program calls `ma_resource_manager_data_source_result()`. When decoding has fully
completed `MA_SUCCESS` will be returned. This can be used to know if loading has fully completed.

When loading asynchronously, a single job is posted to the queue of the type
`MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_BUFFER_NODE`. This involves making a copy of the file path and
associating it with job. When the job is processed by the job thread, it will first load the file
using the VFS associated with the resource manager. When using a custom VFS, it's important that it
be completely thread-safe because it will be used from one or more job threads at the same time.
Individual files should only ever be accessed by one thread at a time, however. After opening the
file via the VFS, the job will determine whether or not the file is being decoded. If not, it
simply allocates a block of memory and loads the raw file contents into it and returns. On the
other hand, when the file is being decoded, it will first allocate a decoder on the heap and
initialize it. Then it will check if the length of the file is known. If so it will allocate a
block of memory to store the decoded output and initialize it to silence. If the size is unknown,
it will allocate room for one page. After memory has been allocated, the first page will be
decoded. If the sound is shorter than a page, the result code will be set to `MA_SUCCESS` and the
completion event will be signalled and loading is now complete. If, however, there is more to
decode, a job with the code `MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_BUFFER_NODE` is posted. This job
will decode the next page and perform the same process if it reaches the end. If there is more to
decode, the job will post another `MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_BUFFER_NODE` job which will
keep on happening until the sound has been fully decoded. For sounds of an unknown length, each
page will be linked together as a linked list. Internally this is implemented via the
`ma_paged_audio_buffer` object.


6.2.3. Data Streams
-------------------
Data streams only ever store two pages worth of data for each instance. They are most useful for
large sounds like music tracks in games that would consume too much memory if fully decoded in
memory. After every frame from a page has been read, a job will be posted to load the next page
which is done from the VFS.

For data streams, the `MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC` flag will determine whether or
not initialization of the data source waits until the two pages have been decoded. When unset,
`ma_resource_manager_data_source_init()` will wait until the two pages have been loaded, otherwise
it will return immediately.

When frames are read from a data stream using `ma_resource_manager_data_source_read_pcm_frames()`,
`MA_BUSY` will be returned if there are no frames available. If there are some frames available,
but less than the number requested, `MA_SUCCESS` will be returned, but the actual number of frames
read will be less than the number requested. Due to the asynchronous nature of data streams,
seeking is also asynchronous. If the data stream is in the middle of a seek, `MA_BUSY` will be
returned when trying to read frames.

When `ma_resource_manager_data_source_read_pcm_frames()` results in a page getting fully consumed
a job is posted to load the next page. This will be posted from the same thread that called
`ma_resource_manager_data_source_read_pcm_frames()`.

Data streams are uninitialized by posting a job to the queue, but the function won't return until
that job has been processed. The reason for this is that the caller owns the data stream object and
therefore miniaudio needs to ensure everything completes before handing back control to the caller.
Also, if the data stream is uninitialized while pages are in the middle of decoding, they must
complete before destroying any underlying object and the job system handles this cleanly.

Note that when a new page needs to be loaded, a job will be posted to the resource manager's job
thread from the audio thread. You must keep in mind the details mentioned in the "Job Queue"
section above regarding locking when posting an event if you require a strictly lock-free audio
thread.



7. Node Graph
=============
miniaudio's routing infrastructure follows a node graph paradigm. The idea is that you create a
node whose outputs are attached to inputs of another node, thereby creating a graph. There are
different types of nodes, with each node in the graph processing input data to produce output,
which is then fed through the chain. Each node in the graph can apply their own custom effects. At
the start of the graph will usually be one or more data source nodes which have no inputs and
instead pull their data from a data source. At the end of the graph is an endpoint which represents
the end of the chain and is where the final output is ultimately extracted from.

Each node has a number of input buses and a number of output buses. An output bus from a node is
attached to an input bus of another. Multiple nodes can connect their output buses to another
node's input bus, in which case their outputs will be mixed before processing by the node. Below is
a diagram that illustrates a hypothetical node graph setup:

    ```
    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Data flows left to right >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    +---------------+                              +-----------------+
    | Data Source 1 =----+    +----------+    +----= Low Pass Filter =----+
    +---------------+    |    |          =----+    +-----------------+    |    +----------+
                         +----= Splitter |                                +----= ENDPOINT |
    +---------------+    |    |          =----+    +-----------------+    |    +----------+
    | Data Source 2 =----+    +----------+    +----=  Echo / Delay   =----+
    +---------------+                              +-----------------+
    ```

In the above graph, it starts with two data sources whose outputs are attached to the input of a
splitter node. It's at this point that the two data sources are mixed. After mixing, the splitter
performs it's processing routine and produces two outputs which is simply a duplication of the
input stream. One output is attached to a low pass filter, whereas the other output is attached to
a echo/delay. The outputs of the low pass filter and the echo are attached to the endpoint, and
since they're both connected to the same input bus, they'll be mixed.

Each input bus must be configured to accept the same number of channels, but the number of channels
used by input buses can be different to the number of channels for output buses in which case
miniaudio will automatically convert the input data to the output channel count before processing.
The number of channels of an output bus of one node must match the channel count of the input bus
it's attached to. The channel counts cannot be changed after the node has been initialized. If you
attempt to attach an output bus to an input bus with a different channel count, attachment will
fail.

To use a node graph, you first need to initialize a `ma_node_graph` object. This is essentially a
container around the entire graph. The `ma_node_graph` object is required for some thread-safety
issues which will be explained later. A `ma_node_graph` object is initialized using miniaudio's
standard config/init system:

    ```c
    ma_node_graph_config nodeGraphConfig = ma_node_graph_config_init(myChannelCount);

    result = ma_node_graph_init(&nodeGraphConfig, NULL, &nodeGraph);    // Second parameter is a pointer to allocation callbacks.
    if (result != MA_SUCCESS) {
        // Failed to initialize node graph.
    }
    ```

When you initialize the node graph, you're specifying the channel count of the endpoint. The
endpoint is a special node which has one input bus and one output bus, both of which have the
same channel count, which is specified in the config. Any nodes that connect directly to the
endpoint must be configured such that their output buses have the same channel count. When you read
audio data from the node graph, it'll have the channel count you specified in the config. To read
data from the graph:

    ```c
    ma_uint32 framesRead;
    result = ma_node_graph_read_pcm_frames(&nodeGraph, pFramesOut, frameCount, &framesRead);
    if (result != MA_SUCCESS) {
        // Failed to read data from the node graph.
    }
    ```

When you read audio data, miniaudio starts at the node graph's endpoint node which then pulls in
data from its input attachments, which in turn recursively pull in data from their inputs, and so
on. At the start of the graph there will be some kind of data source node which will have zero
inputs and will instead read directly from a data source. The base nodes don't literally need to
read from a `ma_data_source` object, but they will always have some kind of underlying object that
sources some kind of audio. The `ma_data_source_node` node can be used to read from a
`ma_data_source`. Data is always in floating-point format and in the number of channels you
specified when the graph was initialized. The sample rate is defined by the underlying data sources.
It's up to you to ensure they use a consistent and appropriate sample rate.

The `ma_node` API is designed to allow custom nodes to be implemented with relative ease, but
miniaudio includes a few stock nodes for common functionality. This is how you would initialize a
node which reads directly from a data source (`ma_data_source_node`) which is an example of one
of the stock nodes that comes with miniaudio:

    ```c
    ma_data_source_node_config config = ma_data_source_node_config_init(pMyDataSource);

    ma_data_source_node dataSourceNode;
    result = ma_data_source_node_init(&nodeGraph, &config, NULL, &dataSourceNode);
    if (result != MA_SUCCESS) {
        // Failed to create data source node.
    }
    ```

The data source node will use the output channel count to determine the channel count of the output
bus. There will be 1 output bus and 0 input buses (data will be drawn directly from the data
source). The data source must output to floating-point (`ma_format_f32`) or else an error will be
returned from `ma_data_source_node_init()`.

By default the node will not be attached to the graph. To do so, use `ma_node_attach_output_bus()`:

    ```c
    result = ma_node_attach_output_bus(&dataSourceNode, 0, ma_node_graph_get_endpoint(&nodeGraph), 0);
    if (result != MA_SUCCESS) {
        // Failed to attach node.
    }
    ```

The code above connects the data source node directly to the endpoint. Since the data source node
has only a single output bus, the index will always be 0. Likewise, the endpoint only has a single
input bus which means the input bus index will also always be 0.

To detach a specific output bus, use `ma_node_detach_output_bus()`. To detach all output buses, use
`ma_node_detach_all_output_buses()`. If you want to just move the output bus from one attachment to
another, you do not need to detach first. You can just call `ma_node_attach_output_bus()` and it'll
deal with it for you.

Less frequently you may want to create a specialized node. This will be a node where you implement
your own processing callback to apply a custom effect of some kind. This is similar to initializing
one of the stock node types, only this time you need to specify a pointer to a vtable containing a
pointer to the processing function and the number of input and output buses. Example:

    ```c
    static void my_custom_node_process_pcm_frames(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
    {
        // Do some processing of ppFramesIn (one stream of audio data per input bus)
        const float* pFramesIn_0 = ppFramesIn[0]; // Input bus @ index 0.
        const float* pFramesIn_1 = ppFramesIn[1]; // Input bus @ index 1.
        float* pFramesOut_0 = ppFramesOut[0];     // Output bus @ index 0.

        // Do some processing. On input, `pFrameCountIn` will be the number of input frames in each
        // buffer in `ppFramesIn` and `pFrameCountOut` will be the capacity of each of the buffers
        // in `ppFramesOut`. On output, `pFrameCountIn` should be set to the number of input frames
        // your node consumed and `pFrameCountOut` should be set the number of output frames that
        // were produced.
        //
        // You should process as many frames as you can. If your effect consumes input frames at the
        // same rate as output frames (always the case, unless you're doing resampling), you need
        // only look at `ppFramesOut` and process that exact number of frames. If you're doing
        // resampling, you'll need to be sure to set both `pFrameCountIn` and `pFrameCountOut`
        // properly.
    }

    static ma_node_vtable my_custom_node_vtable =
    {
        my_custom_node_process_pcm_frames, // The function that will be called to process your custom node. This is where you'd implement your effect processing.
        NULL,   // Optional. A callback for calculating the number of input frames that are required to process a specified number of output frames.
        2,      // 2 input buses.
        1,      // 1 output bus.
        0       // Default flags.
    };

    ...

    // Each bus needs to have a channel count specified. To do this you need to specify the channel
    // counts in an array and then pass that into the node config.
    ma_uint32 inputChannels[2];     // Equal in size to the number of input channels specified in the vtable.
    ma_uint32 outputChannels[1];    // Equal in size to the number of output channels specified in the vtable.

    inputChannels[0]  = channelsIn;
    inputChannels[1]  = channelsIn;
    outputChannels[0] = channelsOut;

    ma_node_config nodeConfig = ma_node_config_init();
    nodeConfig.vtable          = &my_custom_node_vtable;
    nodeConfig.pInputChannels  = inputChannels;
    nodeConfig.pOutputChannels = outputChannels;

    ma_node_base node;
    result = ma_node_init(&nodeGraph, &nodeConfig, NULL, &node);
    if (result != MA_SUCCESS) {
        // Failed to initialize node.
    }
    ```

When initializing a custom node, as in the code above, you'll normally just place your vtable in
static space. The number of input and output buses are specified as part of the vtable. If you need
a variable number of buses on a per-node bases, the vtable should have the relevant bus count set
to `MA_NODE_BUS_COUNT_UNKNOWN`. In this case, the bus count should be set in the node config:

    ```c
    static ma_node_vtable my_custom_node_vtable =
    {
        my_custom_node_process_pcm_frames, // The function that will be called process your custom node. This is where you'd implement your effect processing.
        NULL,   // Optional. A callback for calculating the number of input frames that are required to process a specified number of output frames.
        MA_NODE_BUS_COUNT_UNKNOWN,  // The number of input buses is determined on a per-node basis.
        1,      // 1 output bus.
        0       // Default flags.
    };

    ...

    ma_node_config nodeConfig = ma_node_config_init();
    nodeConfig.vtable          = &my_custom_node_vtable;
    nodeConfig.inputBusCount   = myBusCount;        // <-- Since the vtable specifies MA_NODE_BUS_COUNT_UNKNOWN, the input bus count should be set here.
    nodeConfig.pInputChannels  = inputChannels;     // <-- Make sure there are nodeConfig.inputBusCount elements in this array.
    nodeConfig.pOutputChannels = outputChannels;    // <-- The vtable specifies 1 output bus, so there must be 1 element in this array.
    ```

In the above example it's important to never set the `inputBusCount` and `outputBusCount` members
to anything other than their defaults if the vtable specifies an explicit count. They can only be
set if the vtable specifies MA_NODE_BUS_COUNT_UNKNOWN in the relevant bus count.

Most often you'll want to create a structure to encapsulate your node with some extra data. You
need to make sure the `ma_node_base` object is your first member of the structure:

    ```c
    typedef struct
    {
        ma_node_base base; // <-- Make sure this is always the first member.
        float someCustomData;
    } my_custom_node;
    ```

By doing this, your object will be compatible with all `ma_node` APIs and you can attach it to the
graph just like any other node.

In the custom processing callback (`my_custom_node_process_pcm_frames()` in the example above), the
number of channels for each bus is what was specified by the config when the node was initialized
with `ma_node_init()`. In addition, all attachments to each of the input buses will have been
pre-mixed by miniaudio. The config allows you to specify different channel counts for each
individual input and output bus. It's up to the effect to handle it appropriate, and if it can't,
return an error in it's initialization routine.

Custom nodes can be assigned some flags to describe their behaviour. These are set via the vtable
and include the following:

    +-----------------------------------------+---------------------------------------------------+
    | Flag Name                               | Description                                       |
    +-----------------------------------------+---------------------------------------------------+
    | MA_NODE_FLAG_PASSTHROUGH                | Useful for nodes that do not do any kind of audio |
    |                                         | processing, but are instead used for tracking     |
    |                                         | time, handling events, etc. Also used by the      |
    |                                         | internal endpoint node. It reads directly from    |
    |                                         | the input bus to the output bus. Nodes with this  |
    |                                         | flag must have exactly 1 input bus and 1 output   |
    |                                         | bus, and both buses must have the same channel    |
    |                                         | counts.                                           |
    +-----------------------------------------+---------------------------------------------------+
    | MA_NODE_FLAG_CONTINUOUS_PROCESSING      | Causes the processing callback to be called even  |
    |                                         | when no data is available to be read from input   |
    |                                         | attachments. When a node has at least one input   |
    |                                         | bus, but there are no inputs attached or the      |
    |                                         | inputs do not deliver any data, the node's        |
    |                                         | processing callback will not get fired. This flag |
    |                                         | will make it so the callback is always fired      |
    |                                         | regardless of whether or not any input data is    |
    |                                         | received. This is useful for effects like         |
    |                                         | echos where there will be a tail of audio data    |
    |                                         | that still needs to be processed even when the    |
    |                                         | original data sources have reached their ends. It |
    |                                         | may also be useful for nodes that must always     |
    |                                         | have their processing callback fired when there   |
    |                                         | are no inputs attached.                           |
    +-----------------------------------------+---------------------------------------------------+
    | MA_NODE_FLAG_ALLOW_NULL_INPUT           | Used in conjunction with                          |
    |                                         | `MA_NODE_FLAG_CONTINUOUS_PROCESSING`. When this   |
    |                                         | is set, the `ppFramesIn` parameter of the         |
    |                                         | processing callback will be set to NULL when      |
    |                                         | there are no input frames are available. When     |
    |                                         | this is unset, silence will be posted to the      |
    |                                         | processing callback.                              |
    +-----------------------------------------+---------------------------------------------------+
    | MA_NODE_FLAG_DIFFERENT_PROCESSING_RATES | Used to tell miniaudio that input and output      |
    |                                         | frames are processed at different rates. You      |
    |                                         | should set this for any nodes that perform        |
    |                                         | resampling.                                       |
    +-----------------------------------------+---------------------------------------------------+
    | MA_NODE_FLAG_SILENT_OUTPUT              | Used to tell miniaudio that a node produces only  |
    |                                         | silent output. This is useful for nodes where you |
    |                                         | don't want the output to contribute to the final  |
    |                                         | mix. An example might be if you want split your   |
    |                                         | stream and have one branch be output to a file.   |
    |                                         | When using this flag, you should avoid writing to |
    |                                         | the output buffer of the node's processing        |
    |                                         | callback because miniaudio will ignore it anyway. |
    +-----------------------------------------+---------------------------------------------------+


If you need to make a copy of an audio stream for effect processing you can use a splitter node
called `ma_splitter_node`. This takes has 1 input bus and splits the stream into 2 output buses.
You can use it like this:

    ```c
    ma_splitter_node_config splitterNodeConfig = ma_splitter_node_config_init(channels);

    ma_splitter_node splitterNode;
    result = ma_splitter_node_init(&nodeGraph, &splitterNodeConfig, NULL, &splitterNode);
    if (result != MA_SUCCESS) {
        // Failed to create node.
    }

    // Attach your output buses to two different input buses (can be on two different nodes).
    ma_node_attach_output_bus(&splitterNode, 0, ma_node_graph_get_endpoint(&nodeGraph), 0); // Attach directly to the endpoint.
    ma_node_attach_output_bus(&splitterNode, 1, &myEffectNode,                          0); // Attach to input bus 0 of some effect node.
    ```

The volume of an output bus can be configured on a per-bus basis:

    ```c
    ma_node_set_output_bus_volume(&splitterNode, 0, 0.5f);
    ma_node_set_output_bus_volume(&splitterNode, 1, 0.5f);
    ```

In the code above we're using the splitter node from before and changing the volume of each of the
copied streams.

You can start and stop a node with the following:

    ```c
    ma_node_set_state(&splitterNode, ma_node_state_started);    // The default state.
    ma_node_set_state(&splitterNode, ma_node_state_stopped);
    ```

By default the node is in a started state, but since it won't be connected to anything won't
actually be invoked by the node graph until it's connected. When you stop a node, data will not be
read from any of its input connections. You can use this property to stop a group of sounds
atomically.

You can configure the initial state of a node in it's config:

    ```c
    nodeConfig.initialState = ma_node_state_stopped;
    ```

Note that for the stock specialized nodes, all of their configs will have a `nodeConfig` member
which is the config to use with the base node. This is where the initial state can be configured
for specialized nodes:

    ```c
    dataSourceNodeConfig.nodeConfig.initialState = ma_node_state_stopped;
    ```

When using a specialized node like `ma_data_source_node` or `ma_splitter_node`, be sure to not
modify the `vtable` member of the `nodeConfig` object.


7.1. Timing
-----------
The node graph supports starting and stopping nodes at scheduled times. This is especially useful
for data source nodes where you want to get the node set up, but only start playback at a specific
time. There are two clocks: local and global.

A local clock is per-node, whereas the global clock is per graph. Scheduling starts and stops can
only be done based on the global clock because the local clock will not be running while the node
is stopped. The global clocks advances whenever `ma_node_graph_read_pcm_frames()` is called. On the
other hand, the local clock only advances when the node's processing callback is fired, and is
advanced based on the output frame count.

To retrieve the global time, use `ma_node_graph_get_time()`. The global time can be set with
`ma_node_graph_set_time()` which might be useful if you want to do seeking on a global timeline.
Getting and setting the local time is similar. Use `ma_node_get_time()` to retrieve the local time,
and `ma_node_set_time()` to set the local time. The global and local times will be advanced by the
audio thread, so care should be taken to avoid data races. Ideally you should avoid calling these
outside of the node processing callbacks which are always run on the audio thread.

There is basic support for scheduling the starting and stopping of nodes. You can only schedule one
start and one stop at a time. This is mainly intended for putting nodes into a started or stopped
state in a frame-exact manner. Without this mechanism, starting and stopping of a node is limited
to the resolution of a call to `ma_node_graph_read_pcm_frames()` which would typically be in blocks
of several milliseconds. The following APIs can be used for scheduling node states:

    ```c
    ma_node_set_state_time()
    ma_node_get_state_time()
    ```

The time is absolute and must be based on the global clock. An example is below:

    ```c
    ma_node_set_state_time(&myNode, ma_node_state_started, sampleRate*1);   // Delay starting to 1 second.
    ma_node_set_state_time(&myNode, ma_node_state_stopped, sampleRate*5);   // Delay stopping to 5 seconds.
    ```

An example for changing the state using a relative time.

    ```c
    ma_node_set_state_time(&myNode, ma_node_state_started, sampleRate*1 + ma_node_graph_get_time(&myNodeGraph));
    ma_node_set_state_time(&myNode, ma_node_state_stopped, sampleRate*5 + ma_node_graph_get_time(&myNodeGraph));
    ```

Note that due to the nature of multi-threading the times may not be 100% exact. If this is an
issue, consider scheduling state changes from within a processing callback. An idea might be to
have some kind of passthrough trigger node that is used specifically for tracking time and handling
events.



7.2. Thread Safety and Locking
------------------------------
When processing audio, it's ideal not to have any kind of locking in the audio thread. Since it's
expected that `ma_node_graph_read_pcm_frames()` would be run on the audio thread, it does so
without the use of any locks. This section discusses the implementation used by miniaudio and goes
over some of the compromises employed by miniaudio to achieve this goal. Note that the current
implementation may not be ideal - feedback and critiques are most welcome.

The node graph API is not *entirely* lock-free. Only `ma_node_graph_read_pcm_frames()` is expected
to be lock-free. Attachment, detachment and uninitialization of nodes use locks to simplify the
implementation, but are crafted in a way such that such locking is not required when reading audio
data from the graph. Locking in these areas are achieved by means of spinlocks.

The main complication with keeping `ma_node_graph_read_pcm_frames()` lock-free stems from the fact
that a node can be uninitialized, and it's memory potentially freed, while in the middle of being
processed on the audio thread. There are times when the audio thread will be referencing a node,
which means the uninitialization process of a node needs to make sure it delays returning until the
audio thread is finished so that control is not handed back to the caller thereby giving them a
chance to free the node's memory.

When the audio thread is processing a node, it does so by reading from each of the output buses of
the node. In order for a node to process data for one of its output buses, it needs to read from
each of its input buses, and so on an so forth. It follows that once all output buses of a node
are detached, the node as a whole will be disconnected and no further processing will occur unless
it's output buses are reattached, which won't be happening when the node is being uninitialized.
By having `ma_node_detach_output_bus()` wait until the audio thread is finished with it, we can
simplify a few things, at the expense of making `ma_node_detach_output_bus()` a bit slower. By
doing this, the implementation of `ma_node_uninit()` becomes trivial - just detach all output
nodes, followed by each of the attachments to each of its input nodes, and then do any final clean
up.

With the above design, the worst-case scenario is `ma_node_detach_output_bus()` taking as long as
it takes to process the output bus being detached. This will happen if it's called at just the
wrong moment where the audio thread has just iterated it and has just started processing. The
caller of `ma_node_detach_output_bus()` will stall until the audio thread is finished, which
includes the cost of recursively processing its inputs. This is the biggest compromise made with
the approach taken by miniaudio for its lock-free processing system. The cost of detaching nodes
earlier in the pipeline (data sources, for example) will be cheaper than the cost of detaching
higher level nodes, such as some kind of final post-processing endpoint. If you need to do mass
detachments, detach starting from the lowest level nodes and work your way towards the final
endpoint node (but don't try detaching the node graph's endpoint). If the audio thread is not
running, detachment will be fast and detachment in any order will be the same. The reason nodes
need to wait for their input attachments to complete is due to the potential for desyncs between
data sources. If the node was to terminate processing mid way through processing its inputs,
there's a chance that some of the underlying data sources will have been read, but then others not.
That will then result in a potential desynchronization when detaching and reattaching higher-level
nodes. A possible solution to this is to have an option when detaching to terminate processing
before processing all input attachments which should be fairly simple.

Another compromise, albeit less significant, is locking when attaching and detaching nodes. This
locking is achieved by means of a spinlock in order to reduce memory overhead. A lock is present
for each input bus and output bus. When an output bus is connected to an input bus, both the output
bus and input bus is locked. This locking is specifically for attaching and detaching across
different threads and does not affect `ma_node_graph_read_pcm_frames()` in any way. The locking and
unlocking is mostly self-explanatory, but a slightly less intuitive aspect comes into it when
considering that iterating over attachments must not break as a result of attaching or detaching a
node while iteration is occurring.

Attaching and detaching are both quite simple. When an output bus of a node is attached to an input
bus of another node, it's added to a linked list. Basically, an input bus is a linked list, where
each item in the list is and output bus. We have some intentional (and convenient) restrictions on
what can done with the linked list in order to simplify the implementation. First of all, whenever
something needs to iterate over the list, it must do so in a forward direction. Backwards iteration
is not supported. Also, items can only be added to the start of the list.

The linked list is a doubly-linked list where each item in the list (an output bus) holds a pointer
to the next item in the list, and another to the previous item. A pointer to the previous item is
only required for fast detachment of the node - it is never used in iteration. This is an
important property because it means from the perspective of iteration, attaching and detaching of
an item can be done with a single atomic assignment. This is exploited by both the attachment and
detachment process. When attaching the node, the first thing that is done is the setting of the
local "next" and "previous" pointers of the node. After that, the item is "attached" to the list
by simply performing an atomic exchange with the head pointer. After that, the node is "attached"
to the list from the perspective of iteration. Even though the "previous" pointer of the next item
hasn't yet been set, from the perspective of iteration it's been attached because iteration will
only be happening in a forward direction which means the "previous" pointer won't actually ever get
used. The same general process applies to detachment. See `ma_node_attach_output_bus()` and
`ma_node_detach_output_bus()` for the implementation of this mechanism.



8. Decoding
===========
The `ma_decoder` API is used for reading audio files. Decoders are completely decoupled from
devices and can be used independently. Built-in support is included for the following formats:

    +---------+
    | Format  |
    +---------+
    | WAV     |
    | MP3     |
    | FLAC    |
    +---------+

You can disable the built-in decoders by specifying one or more of the following options before the
miniaudio implementation:

    ```c
    #define MA_NO_WAV
    #define MA_NO_MP3
    #define MA_NO_FLAC
    ```

miniaudio supports the ability to plug in custom decoders. See the section below for details on how
to use custom decoders.

A decoder can be initialized from a file with `ma_decoder_init_file()`, a block of memory with
`ma_decoder_init_memory()`, or from data delivered via callbacks with `ma_decoder_init()`. Here is
an example for loading a decoder from a file:

    ```c
    ma_decoder decoder;
    ma_result result = ma_decoder_init_file("MySong.mp3", NULL, &decoder);
    if (result != MA_SUCCESS) {
        return false;   // An error occurred.
    }

    ...

    ma_decoder_uninit(&decoder);
    ```

When initializing a decoder, you can optionally pass in a pointer to a `ma_decoder_config` object
(the `NULL` argument in the example above) which allows you to configure the output format, channel
count, sample rate and channel map:

    ```c
    ma_decoder_config config = ma_decoder_config_init(ma_format_f32, 2, 48000);
    ```

When passing in `NULL` for decoder config in `ma_decoder_init*()`, the output format will be the
same as that defined by the decoding backend.

Data is read from the decoder as PCM frames. This will output the number of PCM frames actually
read. If this is less than the requested number of PCM frames it means you've reached the end. The
return value will be `MA_AT_END` if no samples have been read and the end has been reached.

    ```c
    ma_result result = ma_decoder_read_pcm_frames(pDecoder, pFrames, framesToRead, &framesRead);
    if (framesRead < framesToRead) {
        // Reached the end.
    }
    ```

You can also seek to a specific frame like so:

    ```c
    ma_result result = ma_decoder_seek_to_pcm_frame(pDecoder, targetFrame);
    if (result != MA_SUCCESS) {
        return false;   // An error occurred.
    }
    ```

If you want to loop back to the start, you can simply seek back to the first PCM frame:

    ```c
    ma_decoder_seek_to_pcm_frame(pDecoder, 0);
    ```

When loading a decoder, miniaudio uses a trial and error technique to find the appropriate decoding
backend. This can be unnecessarily inefficient if the type is already known. In this case you can
use `encodingFormat` variable in the device config to specify a specific encoding format you want
to decode:

    ```c
    decoderConfig.encodingFormat = ma_encoding_format_wav;
    ```

See the `ma_encoding_format` enum for possible encoding formats.

The `ma_decoder_init_file()` API will try using the file extension to determine which decoding
backend to prefer.


8.1. Custom Decoders
--------------------
It's possible to implement a custom decoder and plug it into miniaudio. This is extremely useful
when you want to use the `ma_decoder` API, but need to support an encoding format that's not one of
the stock formats supported by miniaudio. This can be put to particularly good use when using the
`ma_engine` and/or `ma_resource_manager` APIs because they use `ma_decoder` internally. If, for
example, you wanted to support Opus, you can do so with a custom decoder (there if a reference
Opus decoder in the "extras" folder of the miniaudio repository which uses libopus + libopusfile).

A custom decoder must implement a data source. A vtable called `ma_decoding_backend_vtable` needs
to be implemented which is then passed into the decoder config:

    ```c
    ma_decoding_backend_vtable* pCustomBackendVTables[] =
    {
        &g_ma_decoding_backend_vtable_libvorbis,
        &g_ma_decoding_backend_vtable_libopus
    };

    ...

    decoderConfig = ma_decoder_config_init_default();
    decoderConfig.pCustomBackendUserData = NULL;
    decoderConfig.ppCustomBackendVTables = pCustomBackendVTables;
    decoderConfig.customBackendCount     = sizeof(pCustomBackendVTables) / sizeof(pCustomBackendVTables[0]);
    ```

The `ma_decoding_backend_vtable` vtable has the following functions:

    ```
    onInit
    onInitFile
    onInitFileW
    onInitMemory
    onUninit
    ```

There are only two functions that must be implemented - `onInit` and `onUninit`. The other
functions can be implemented for a small optimization for loading from a file path or memory. If
these are not specified, miniaudio will deal with it for you via a generic implementation.

When you initialize a custom data source (by implementing the `onInit` function in the vtable) you
will need to output a pointer to a `ma_data_source` which implements your custom decoder. See the
section about data sources for details on how to implement this. Alternatively, see the
"custom_decoders" example in the miniaudio repository.

The `onInit` function takes a pointer to some callbacks for the purpose of reading raw audio data
from some arbitrary source. You'll use these functions to read from the raw data and perform the
decoding. When you call them, you will pass in the `pReadSeekTellUserData` pointer to the relevant
parameter.

The `pConfig` parameter in `onInit` can be used to configure the backend if appropriate. It's only
used as a hint and can be ignored. However, if any of the properties are relevant to your decoder,
an optimal implementation will handle the relevant properties appropriately.

If memory allocation is required, it should be done so via the specified allocation callbacks if
possible (the `pAllocationCallbacks` parameter).

If an error occurs when initializing the decoder, you should leave `ppBackend` unset, or set to
NULL, and make sure everything is cleaned up appropriately and an appropriate result code returned.
When multiple custom backends are specified, miniaudio will cycle through the vtables in the order
they're listed in the array that's passed into the decoder config so it's important that your
initialization routine is clean.

When a decoder is uninitialized, the `onUninit` callback will be fired which will give you an
opportunity to clean up and internal data.



9. Encoding
===========
The `ma_encoding` API is used for writing audio files. The only supported output format is WAV.
This can be disabled by specifying the following option before the implementation of miniaudio:

    ```c
    #define MA_NO_WAV
    ```

An encoder can be initialized to write to a file with `ma_encoder_init_file()` or from data
delivered via callbacks with `ma_encoder_init()`. Below is an example for initializing an encoder
to output to a file.

    ```c
    ma_encoder_config config = ma_encoder_config_init(ma_encoding_format_wav, FORMAT, CHANNELS, SAMPLE_RATE);
    ma_encoder encoder;
    ma_result result = ma_encoder_init_file("my_file.wav", &config, &encoder);
    if (result != MA_SUCCESS) {
        // Error
    }

    ...

    ma_encoder_uninit(&encoder);
    ```

When initializing an encoder you must specify a config which is initialized with
`ma_encoder_config_init()`. Here you must specify the file type, the output sample format, output
channel count and output sample rate. The following file types are supported:

    +------------------------+-------------+
    | Enum                   | Description |
    +------------------------+-------------+
    | ma_encoding_format_wav | WAV         |
    +------------------------+-------------+

If the format, channel count or sample rate is not supported by the output file type an error will
be returned. The encoder will not perform data conversion so you will need to convert it before
outputting any audio data. To output audio data, use `ma_encoder_write_pcm_frames()`, like in the
example below:

    ```c
    ma_uint64 framesWritten;
    result = ma_encoder_write_pcm_frames(&encoder, pPCMFramesToWrite, framesToWrite, &framesWritten);
    if (result != MA_SUCCESS) {
        ... handle error ...
    }
    ```

The `framesWritten` variable will contain the number of PCM frames that were actually written. This
is optionally and you can pass in `NULL` if you need this.

Encoders must be uninitialized with `ma_encoder_uninit()`.



10. Data Conversion
===================
A data conversion API is included with miniaudio which supports the majority of data conversion
requirements. This supports conversion between sample formats, channel counts (with channel
mapping) and sample rates.


10.1. Sample Format Conversion
------------------------------
Conversion between sample formats is achieved with the `ma_pcm_*_to_*()`, `ma_pcm_convert()` and
`ma_convert_pcm_frames_format()` APIs. Use `ma_pcm_*_to_*()` to convert between two specific
formats. Use `ma_pcm_convert()` to convert based on a `ma_format` variable. Use
`ma_convert_pcm_frames_format()` to convert PCM frames where you want to specify the frame count
and channel count as a variable instead of the total sample count.


10.1.1. Dithering
-----------------
Dithering can be set using the ditherMode parameter.

The different dithering modes include the following, in order of efficiency:

    +-----------+--------------------------+
    | Type      | Enum Token               |
    +-----------+--------------------------+
    | None      | ma_dither_mode_none      |
    | Rectangle | ma_dither_mode_rectangle |
    | Triangle  | ma_dither_mode_triangle  |
    +-----------+--------------------------+

Note that even if the dither mode is set to something other than `ma_dither_mode_none`, it will be
ignored for conversions where dithering is not needed. Dithering is available for the following
conversions:

    ```
    s16 -> u8
    s24 -> u8
    s32 -> u8
    f32 -> u8
    s24 -> s16
    s32 -> s16
    f32 -> s16
    ```

Note that it is not an error to pass something other than ma_dither_mode_none for conversions where
dither is not used. It will just be ignored.



10.2. Channel Conversion
------------------------
Channel conversion is used for channel rearrangement and conversion from one channel count to
another. The `ma_channel_converter` API is used for channel conversion. Below is an example of
initializing a simple channel converter which converts from mono to stereo.

    ```c
    ma_channel_converter_config config = ma_channel_converter_config_init(
        ma_format,                      // Sample format
        1,                              // Input channels
        NULL,                           // Input channel map
        2,                              // Output channels
        NULL,                           // Output channel map
        ma_channel_mix_mode_default);   // The mixing algorithm to use when combining channels.

    result = ma_channel_converter_init(&config, NULL, &converter);
    if (result != MA_SUCCESS) {
        // Error.
    }
    ```

To perform the conversion simply call `ma_channel_converter_process_pcm_frames()` like so:

    ```c
    ma_result result = ma_channel_converter_process_pcm_frames(&converter, pFramesOut, pFramesIn, frameCount);
    if (result != MA_SUCCESS) {
        // Error.
    }
    ```

It is up to the caller to ensure the output buffer is large enough to accommodate the new PCM
frames.

Input and output PCM frames are always interleaved. Deinterleaved layouts are not supported.


10.2.1. Channel Mapping
-----------------------
In addition to converting from one channel count to another, like the example above, the channel
converter can also be used to rearrange channels. When initializing the channel converter, you can
optionally pass in channel maps for both the input and output frames. If the channel counts are the
same, and each channel map contains the same channel positions with the exception that they're in
a different order, a simple shuffling of the channels will be performed. If, however, there is not
a 1:1 mapping of channel positions, or the channel counts differ, the input channels will be mixed
based on a mixing mode which is specified when initializing the `ma_channel_converter_config`
object.

When converting from mono to multi-channel, the mono channel is simply copied to each output
channel. When going the other way around, the audio of each output channel is simply averaged and
copied to the mono channel.

In more complicated cases blending is used. The `ma_channel_mix_mode_simple` mode will drop excess
channels and silence extra channels. For example, converting from 4 to 2 channels, the 3rd and 4th
channels will be dropped, whereas converting from 2 to 4 channels will put silence into the 3rd and
4th channels.

The `ma_channel_mix_mode_rectangle` mode uses spacial locality based on a rectangle to compute a
simple distribution between input and output. Imagine sitting in the middle of a room, with
speakers on the walls representing channel positions. The `MA_CHANNEL_FRONT_LEFT` position can be
thought of as being in the corner of the front and left walls.

Finally, the `ma_channel_mix_mode_custom_weights` mode can be used to use custom user-defined
weights. Custom weights can be passed in as the last parameter of
`ma_channel_converter_config_init()`.

Predefined channel maps can be retrieved with `ma_channel_map_init_standard()`. This takes a
`ma_standard_channel_map` enum as its first parameter, which can be one of the following:

    +-----------------------------------+-----------------------------------------------------------+
    | Name                              | Description                                               |
    +-----------------------------------+-----------------------------------------------------------+
    | ma_standard_channel_map_default   | Default channel map used by miniaudio. See below.         |
    | ma_standard_channel_map_microsoft | Channel map used by Microsoft's bitfield channel maps.    |
    | ma_standard_channel_map_alsa      | Default ALSA channel map.                                 |
    | ma_standard_channel_map_rfc3551   | RFC 3551. Based on AIFF.                                  |
    | ma_standard_channel_map_flac      | FLAC channel map.                                         |
    | ma_standard_channel_map_vorbis    | Vorbis channel map.                                       |
    | ma_standard_channel_map_sound4    | FreeBSD's sound(4).                                       |
    | ma_standard_channel_map_sndio     | sndio channel map. http://www.sndio.org/tips.html.        |
    | ma_standard_channel_map_webaudio  | https://webaudio.github.io/web-audio-api/#ChannelOrdering |
    +-----------------------------------+-----------------------------------------------------------+

Below are the channel maps used by default in miniaudio (`ma_standard_channel_map_default`):

    +---------------+---------------------------------+
    | Channel Count | Mapping                         |
    +---------------+---------------------------------+
    | 1 (Mono)      | 0: MA_CHANNEL_MONO              |
    +---------------+---------------------------------+
    | 2 (Stereo)    | 0: MA_CHANNEL_FRONT_LEFT   <br> |
    |               | 1: MA_CHANNEL_FRONT_RIGHT       |
    +---------------+---------------------------------+
    | 3             | 0: MA_CHANNEL_FRONT_LEFT   <br> |
    |               | 1: MA_CHANNEL_FRONT_RIGHT  <br> |
    |               | 2: MA_CHANNEL_FRONT_CENTER      |
    +---------------+---------------------------------+
    | 4 (Surround)  | 0: MA_CHANNEL_FRONT_LEFT   <br> |
    |               | 1: MA_CHANNEL_FRONT_RIGHT  <br> |
    |               | 2: MA_CHANNEL_FRONT_CENTER <br> |
    |               | 3: MA_CHANNEL_BACK_CENTER       |
    +---------------+---------------------------------+
    | 5             | 0: MA_CHANNEL_FRONT_LEFT   <br> |
    |               | 1: MA_CHANNEL_FRONT_RIGHT  <br> |
    |               | 2: MA_CHANNEL_FRONT_CENTER <br> |
    |               | 3: MA_CHANNEL_BACK_LEFT    <br> |
    |               | 4: MA_CHANNEL_BACK_RIGHT        |
    +---------------+---------------------------------+
    | 6 (5.1)       | 0: MA_CHANNEL_FRONT_LEFT   <br> |
    |               | 1: MA_CHANNEL_FRONT_RIGHT  <br> |
    |               | 2: MA_CHANNEL_FRONT_CENTER <br> |
    |               | 3: MA_CHANNEL_LFE          <br> |
    |               | 4: MA_CHANNEL_SIDE_LEFT    <br> |
    |               | 5: MA_CHANNEL_SIDE_RIGHT        |
    +---------------+---------------------------------+
    | 7             | 0: MA_CHANNEL_FRONT_LEFT   <br> |
    |               | 1: MA_CHANNEL_FRONT_RIGHT  <br> |
    |               | 2: MA_CHANNEL_FRONT_CENTER <br> |
    |               | 3: MA_CHANNEL_LFE          <br> |
    |               | 4: MA_CHANNEL_BACK_CENTER  <br> |
    |               | 4: MA_CHANNEL_SIDE_LEFT    <br> |
    |               | 5: MA_CHANNEL_SIDE_RIGHT        |
    +---------------+---------------------------------+
    | 8 (7.1)       | 0: MA_CHANNEL_FRONT_LEFT   <br> |
    |               | 1: MA_CHANNEL_FRONT_RIGHT  <br> |
    |               | 2: MA_CHANNEL_FRONT_CENTER <br> |
    |               | 3: MA_CHANNEL_LFE          <br> |
    |               | 4: MA_CHANNEL_BACK_LEFT    <br> |
    |               | 5: MA_CHANNEL_BACK_RIGHT   <br> |
    |               | 6: MA_CHANNEL_SIDE_LEFT    <br> |
    |               | 7: MA_CHANNEL_SIDE_RIGHT        |
    +---------------+---------------------------------+
    | Other         | All channels set to 0. This     |
    |               | is equivalent to the same       |
    |               | mapping as the device.          |
    +---------------+---------------------------------+



10.3. Resampling
----------------
Resampling is achieved with the `ma_resampler` object. To create a resampler object, do something
like the following:

    ```c
    ma_resampler_config config = ma_resampler_config_init(
        ma_format_s16,
        channels,
        sampleRateIn,
        sampleRateOut,
        ma_resample_algorithm_linear);

    ma_resampler resampler;
    ma_result result = ma_resampler_init(&config, NULL, &resampler);
    if (result != MA_SUCCESS) {
        // An error occurred...
    }
    ```

Do the following to uninitialize the resampler:

    ```c
    ma_resampler_uninit(&resampler);
    ```

The following example shows how data can be processed

    ```c
    ma_uint64 frameCountIn  = 1000;
    ma_uint64 frameCountOut = 2000;
    ma_result result = ma_resampler_process_pcm_frames(&resampler, pFramesIn, &frameCountIn, pFramesOut, &frameCountOut);
    if (result != MA_SUCCESS) {
        // An error occurred...
    }

    // At this point, frameCountIn contains the number of input frames that were consumed and frameCountOut contains the
    // number of output frames written.
    ```

To initialize the resampler you first need to set up a config (`ma_resampler_config`) with
`ma_resampler_config_init()`. You need to specify the sample format you want to use, the number of
channels, the input and output sample rate, and the algorithm.

The sample format can be either `ma_format_s16` or `ma_format_f32`. If you need a different format
you will need to perform pre- and post-conversions yourself where necessary. Note that the format
is the same for both input and output. The format cannot be changed after initialization.

The resampler supports multiple channels and is always interleaved (both input and output). The
channel count cannot be changed after initialization.

The sample rates can be anything other than zero, and are always specified in hertz. They should be
set to something like 44100, etc. The sample rate is the only configuration property that can be
changed after initialization.

The miniaudio resampler has built-in support for the following algorithms:

    +-----------+------------------------------+
    | Algorithm | Enum Token                   |
    +-----------+------------------------------+
    | Linear    | ma_resample_algorithm_linear |
    | Custom    | ma_resample_algorithm_custom |
    +-----------+------------------------------+

The algorithm cannot be changed after initialization.

Processing always happens on a per PCM frame basis and always assumes interleaved input and output.
De-interleaved processing is not supported. To process frames, use
`ma_resampler_process_pcm_frames()`. On input, this function takes the number of output frames you
can fit in the output buffer and the number of input frames contained in the input buffer. On
output these variables contain the number of output frames that were written to the output buffer
and the number of input frames that were consumed in the process. You can pass in NULL for the
input buffer in which case it will be treated as an infinitely large buffer of zeros. The output
buffer can also be NULL, in which case the processing will be treated as seek.

The sample rate can be changed dynamically on the fly. You can change this with explicit sample
rates with `ma_resampler_set_rate()` and also with a decimal ratio with
`ma_resampler_set_rate_ratio()`. The ratio is in/out.

Sometimes it's useful to know exactly how many input frames will be required to output a specific
number of frames. You can calculate this with `ma_resampler_get_required_input_frame_count()`.
Likewise, it's sometimes useful to know exactly how many frames would be output given a certain
number of input frames. You can do this with `ma_resampler_get_expected_output_frame_count()`.

Due to the nature of how resampling works, the resampler introduces some latency. This can be
retrieved in terms of both the input rate and the output rate with
`ma_resampler_get_input_latency()` and `ma_resampler_get_output_latency()`.


10.3.1. Resampling Algorithms
-----------------------------
The choice of resampling algorithm depends on your situation and requirements.


10.3.1.1. Linear Resampling
---------------------------
The linear resampler is the fastest, but comes at the expense of poorer quality. There is, however,
some control over the quality of the linear resampler which may make it a suitable option depending
on your requirements.

The linear resampler performs low-pass filtering before or after downsampling or upsampling,
depending on the sample rates you're converting between. When decreasing the sample rate, the
low-pass filter will be applied before downsampling. When increasing the rate it will be performed
after upsampling. By default a fourth order low-pass filter will be applied. This can be configured
via the `lpfOrder` configuration variable. Setting this to 0 will disable filtering.

The low-pass filter has a cutoff frequency which defaults to half the sample rate of the lowest of
the input and output sample rates (Nyquist Frequency).

The API for the linear resampler is the same as the main resampler API, only it's called
`ma_linear_resampler`.


10.3.2. Custom Resamplers
-------------------------
You can implement a custom resampler by using the `ma_resample_algorithm_custom` resampling
algorithm and setting a vtable in the resampler config:

    ```c
    ma_resampler_config config = ma_resampler_config_init(..., ma_resample_algorithm_custom);
    config.pBackendVTable = &g_customResamplerVTable;
    ```

Custom resamplers are useful if the stock algorithms are not appropriate for your use case. You
need to implement the required functions in `ma_resampling_backend_vtable`. Note that not all
functions in the vtable need to be implemented, but if it's possible to implement, they should be.

You can use the `ma_linear_resampler` object for an example on how to implement the vtable. The
`onGetHeapSize` callback is used to calculate the size of any internal heap allocation the custom
resampler will need to make given the supplied config. When you initialize the resampler via the
`onInit` callback, you'll be given a pointer to a heap allocation which is where you should store
the heap allocated data. You should not free this data in `onUninit` because miniaudio will manage
it for you.

The `onProcess` callback is where the actual resampling takes place. On input, `pFrameCountIn`
points to a variable containing the number of frames in the `pFramesIn` buffer and
`pFrameCountOut` points to a variable containing the capacity in frames of the `pFramesOut` buffer.
On output, `pFrameCountIn` should be set to the number of input frames that were fully consumed,
whereas `pFrameCountOut` should be set to the number of frames that were written to `pFramesOut`.

The `onSetRate` callback is optional and is used for dynamically changing the sample rate. If
dynamic rate changes are not supported, you can set this callback to NULL.

The `onGetInputLatency` and `onGetOutputLatency` functions are used for retrieving the latency in
input and output rates respectively. These can be NULL in which case latency calculations will be
assumed to be NULL.

The `onGetRequiredInputFrameCount` callback is used to give miniaudio a hint as to how many input
frames are required to be available to produce the given number of output frames. Likewise, the
`onGetExpectedOutputFrameCount` callback is used to determine how many output frames will be
produced given the specified number of input frames. miniaudio will use these as a hint, but they
are optional and can be set to NULL if you're unable to implement them.



10.4. General Data Conversion
-----------------------------
The `ma_data_converter` API can be used to wrap sample format conversion, channel conversion and
resampling into one operation. This is what miniaudio uses internally to convert between the format
requested when the device was initialized and the format of the backend's native device. The API
for general data conversion is very similar to the resampling API. Create a `ma_data_converter`
object like this:

    ```c
    ma_data_converter_config config = ma_data_converter_config_init(
        inputFormat,
        outputFormat,
        inputChannels,
        outputChannels,
        inputSampleRate,
        outputSampleRate
    );

    ma_data_converter converter;
    ma_result result = ma_data_converter_init(&config, NULL, &converter);
    if (result != MA_SUCCESS) {
        // An error occurred...
    }
    ```

In the example above we use `ma_data_converter_config_init()` to initialize the config, however
there's many more properties that can be configured, such as channel maps and resampling quality.
Something like the following may be more suitable depending on your requirements:

    ```c
    ma_data_converter_config config = ma_data_converter_config_init_default();
    config.formatIn = inputFormat;
    config.formatOut = outputFormat;
    config.channelsIn = inputChannels;
    config.channelsOut = outputChannels;
    config.sampleRateIn = inputSampleRate;
    config.sampleRateOut = outputSampleRate;
    ma_channel_map_init_standard(ma_standard_channel_map_flac, config.channelMapIn, sizeof(config.channelMapIn)/sizeof(config.channelMapIn[0]), config.channelCountIn);
    config.resampling.linear.lpfOrder = MA_MAX_FILTER_ORDER;
    ```

Do the following to uninitialize the data converter:

    ```c
    ma_data_converter_uninit(&converter, NULL);
    ```

The following example shows how data can be processed

    ```c
    ma_uint64 frameCountIn  = 1000;
    ma_uint64 frameCountOut = 2000;
    ma_result result = ma_data_converter_process_pcm_frames(&converter, pFramesIn, &frameCountIn, pFramesOut, &frameCountOut);
    if (result != MA_SUCCESS) {
        // An error occurred...
    }

    // At this point, frameCountIn contains the number of input frames that were consumed and frameCountOut contains the number
    // of output frames written.
    ```

The data converter supports multiple channels and is always interleaved (both input and output).
The channel count cannot be changed after initialization.

Sample rates can be anything other than zero, and are always specified in hertz. They should be set
to something like 44100, etc. The sample rate is the only configuration property that can be
changed after initialization, but only if the `resampling.allowDynamicSampleRate` member of
`ma_data_converter_config` is set to `MA_TRUE`. To change the sample rate, use
`ma_data_converter_set_rate()` or `ma_data_converter_set_rate_ratio()`. The ratio must be in/out.
The resampling algorithm cannot be changed after initialization.

Processing always happens on a per PCM frame basis and always assumes interleaved input and output.
De-interleaved processing is not supported. To process frames, use
`ma_data_converter_process_pcm_frames()`. On input, this function takes the number of output frames
you can fit in the output buffer and the number of input frames contained in the input buffer. On
output these variables contain the number of output frames that were written to the output buffer
and the number of input frames that were consumed in the process. You can pass in NULL for the
input buffer in which case it will be treated as an infinitely large
buffer of zeros. The output buffer can also be NULL, in which case the processing will be treated
as seek.

Sometimes it's useful to know exactly how many input frames will be required to output a specific
number of frames. You can calculate this with `ma_data_converter_get_required_input_frame_count()`.
Likewise, it's sometimes useful to know exactly how many frames would be output given a certain
number of input frames. You can do this with `ma_data_converter_get_expected_output_frame_count()`.

Due to the nature of how resampling works, the data converter introduces some latency if resampling
is required. This can be retrieved in terms of both the input rate and the output rate with
`ma_data_converter_get_input_latency()` and `ma_data_converter_get_output_latency()`.



11. Filtering
=============

11.1. Biquad Filtering
----------------------
Biquad filtering is achieved with the `ma_biquad` API. Example:

    ```c
    ma_biquad_config config = ma_biquad_config_init(ma_format_f32, channels, b0, b1, b2, a0, a1, a2);
    ma_result result = ma_biquad_init(&config, NULL, &biquad);
    if (result != MA_SUCCESS) {
        // Error.
    }

    ...

    ma_biquad_process_pcm_frames(&biquad, pFramesOut, pFramesIn, frameCount);
    ```

Biquad filtering is implemented using transposed direct form 2. The numerator coefficients are b0,
b1 and b2, and the denominator coefficients are a0, a1 and a2. The a0 coefficient is required and
coefficients must not be pre-normalized.

Supported formats are `ma_format_s16` and `ma_format_f32`. If you need to use a different format
you need to convert it yourself beforehand. When using `ma_format_s16` the biquad filter will use
fixed point arithmetic. When using `ma_format_f32`, floating point arithmetic will be used.

Input and output frames are always interleaved.

Filtering can be applied in-place by passing in the same pointer for both the input and output
buffers, like so:

    ```c
    ma_biquad_process_pcm_frames(&biquad, pMyData, pMyData, frameCount);
    ```

If you need to change the values of the coefficients, but maintain the values in the registers you
can do so with `ma_biquad_reinit()`. This is useful if you need to change the properties of the
filter while keeping the values of registers valid to avoid glitching. Do not use
`ma_biquad_init()` for this as it will do a full initialization which involves clearing the
registers to 0. Note that changing the format or channel count after initialization is invalid and
will result in an error.


11.2. Low-Pass Filtering
------------------------
Low-pass filtering is achieved with the following APIs:

    +---------+------------------------------------------+
    | API     | Description                              |
    +---------+------------------------------------------+
    | ma_lpf1 | First order low-pass filter              |
    | ma_lpf2 | Second order low-pass filter             |
    | ma_lpf  | High order low-pass filter (Butterworth) |
    +---------+------------------------------------------+

Low-pass filter example:

    ```c
    ma_lpf_config config = ma_lpf_config_init(ma_format_f32, channels, sampleRate, cutoffFrequency, order);
    ma_result result = ma_lpf_init(&config, &lpf);
    if (result != MA_SUCCESS) {
        // Error.
    }

    ...

    ma_lpf_process_pcm_frames(&lpf, pFramesOut, pFramesIn, frameCount);
    ```

Supported formats are `ma_format_s16` and` ma_format_f32`. If you need to use a different format
you need to convert it yourself beforehand. Input and output frames are always interleaved.

Filtering can be applied in-place by passing in the same pointer for both the input and output
buffers, like so:

    ```c
    ma_lpf_process_pcm_frames(&lpf, pMyData, pMyData, frameCount);
    ```

The maximum filter order is limited to `MA_MAX_FILTER_ORDER` which is set to 8. If you need more,
you can chain first and second order filters together.

    ```c
    for (iFilter = 0; iFilter < filterCount; iFilter += 1) {
        ma_lpf2_process_pcm_frames(&lpf2[iFilter], pMyData, pMyData, frameCount);
    }
    ```

If you need to change the configuration of the filter, but need to maintain the state of internal
registers you can do so with `ma_lpf_reinit()`. This may be useful if you need to change the sample
rate and/or cutoff frequency dynamically while maintaining smooth transitions. Note that changing the
format or channel count after initialization is invalid and will result in an error.

The `ma_lpf` object supports a configurable order, but if you only need a first order filter you
may want to consider using `ma_lpf1`. Likewise, if you only need a second order filter you can use
`ma_lpf2`. The advantage of this is that they're lighter weight and a bit more efficient.

If an even filter order is specified, a series of second order filters will be processed in a
chain. If an odd filter order is specified, a first order filter will be applied, followed by a
series of second order filters in a chain.


11.3. High-Pass Filtering
-------------------------
High-pass filtering is achieved with the following APIs:

    +---------+-------------------------------------------+
    | API     | Description                               |
    +---------+-------------------------------------------+
    | ma_hpf1 | First order high-pass filter              |
    | ma_hpf2 | Second order high-pass filter             |
    | ma_hpf  | High order high-pass filter (Butterworth) |
    +---------+-------------------------------------------+

High-pass filters work exactly the same as low-pass filters, only the APIs are called `ma_hpf1`,
`ma_hpf2` and `ma_hpf`. See example code for low-pass filters for example usage.


11.4. Band-Pass Filtering
-------------------------
Band-pass filtering is achieved with the following APIs:

    +---------+-------------------------------+
    | API     | Description                   |
    +---------+-------------------------------+
    | ma_bpf2 | Second order band-pass filter |
    | ma_bpf  | High order band-pass filter   |
    +---------+-------------------------------+

Band-pass filters work exactly the same as low-pass filters, only the APIs are called `ma_bpf2` and
`ma_hpf`. See example code for low-pass filters for example usage. Note that the order for
band-pass filters must be an even number which means there is no first order band-pass filter,
unlike low-pass and high-pass filters.


11.5. Notch Filtering
---------------------
Notch filtering is achieved with the following APIs:

    +-----------+------------------------------------------+
    | API       | Description                              |
    +-----------+------------------------------------------+
    | ma_notch2 | Second order notching filter             |
    +-----------+------------------------------------------+


11.6. Peaking EQ Filtering
-------------------------
Peaking filtering is achieved with the following APIs:

    +----------+------------------------------------------+
    | API      | Description                              |
    +----------+------------------------------------------+
    | ma_peak2 | Second order peaking filter              |
    +----------+------------------------------------------+


11.7. Low Shelf Filtering
-------------------------
Low shelf filtering is achieved with the following APIs:

    +-------------+------------------------------------------+
    | API         | Description                              |
    +-------------+------------------------------------------+
    | ma_loshelf2 | Second order low shelf filter            |
    +-------------+------------------------------------------+

Where a high-pass filter is used to eliminate lower frequencies, a low shelf filter can be used to
just turn them down rather than eliminate them entirely.


11.8. High Shelf Filtering
--------------------------
High shelf filtering is achieved with the following APIs:

    +-------------+------------------------------------------+
    | API         | Description                              |
    +-------------+------------------------------------------+
    | ma_hishelf2 | Second order high shelf filter           |
    +-------------+------------------------------------------+

The high shelf filter has the same API as the low shelf filter, only you would use `ma_hishelf`
instead of `ma_loshelf`. Where a low shelf filter is used to adjust the volume of low frequencies,
the high shelf filter does the same thing for high frequencies.




12. Waveform and Noise Generation
=================================

12.1. Waveforms
---------------
miniaudio supports generation of sine, square, triangle and sawtooth waveforms. This is achieved
with the `ma_waveform` API. Example:

    ```c
    ma_waveform_config config = ma_waveform_config_init(
        FORMAT,
        CHANNELS,
        SAMPLE_RATE,
        ma_waveform_type_sine,
        amplitude,
        frequency);

    ma_waveform waveform;
    ma_result result = ma_waveform_init(&config, &waveform);
    if (result != MA_SUCCESS) {
        // Error.
    }

    ...

    ma_waveform_read_pcm_frames(&waveform, pOutput, frameCount);
    ```

The amplitude, frequency, type, and sample rate can be changed dynamically with
`ma_waveform_set_amplitude()`, `ma_waveform_set_frequency()`, `ma_waveform_set_type()`, and
`ma_waveform_set_sample_rate()` respectively.

You can invert the waveform by setting the amplitude to a negative value. You can use this to
control whether or not a sawtooth has a positive or negative ramp, for example.

Below are the supported waveform types:

    +---------------------------+
    | Enum Name                 |
    +---------------------------+
    | ma_waveform_type_sine     |
    | ma_waveform_type_square   |
    | ma_waveform_type_triangle |
    | ma_waveform_type_sawtooth |
    +---------------------------+



12.2. Noise
-----------
miniaudio supports generation of white, pink and Brownian noise via the `ma_noise` API. Example:

    ```c
    ma_noise_config config = ma_noise_config_init(
        FORMAT,
        CHANNELS,
        ma_noise_type_white,
        SEED,
        amplitude);

    ma_noise noise;
    ma_result result = ma_noise_init(&config, &noise);
    if (result != MA_SUCCESS) {
        // Error.
    }

    ...

    ma_noise_read_pcm_frames(&noise, pOutput, frameCount);
    ```

The noise API uses simple LCG random number generation. It supports a custom seed which is useful
for things like automated testing requiring reproducibility. Setting the seed to zero will default
to `MA_DEFAULT_LCG_SEED`.

The amplitude and seed can be changed dynamically with `ma_noise_set_amplitude()` and
`ma_noise_set_seed()` respectively.

By default, the noise API will use different values for different channels. So, for example, the
left side in a stereo stream will be different to the right side. To instead have each channel use
the same random value, set the `duplicateChannels` member of the noise config to true, like so:

    ```c
    config.duplicateChannels = MA_TRUE;
    ```

Below are the supported noise types.

    +------------------------+
    | Enum Name              |
    +------------------------+
    | ma_noise_type_white    |
    | ma_noise_type_pink     |
    | ma_noise_type_brownian |
    +------------------------+



13. Audio Buffers
=================
miniaudio supports reading from a buffer of raw audio data via the `ma_audio_buffer` API. This can
read from memory that's managed by the application, but can also handle the memory management for
you internally. Memory management is flexible and should support most use cases.

Audio buffers are initialized using the standard configuration system used everywhere in miniaudio:

    ```c
    ma_audio_buffer_config config = ma_audio_buffer_config_init(
        format,
        channels,
        sizeInFrames,
        pExistingData,
        &allocationCallbacks);

    ma_audio_buffer buffer;
    result = ma_audio_buffer_init(&config, &buffer);
    if (result != MA_SUCCESS) {
        // Error.
    }

    ...

    ma_audio_buffer_uninit(&buffer);
    ```

In the example above, the memory pointed to by `pExistingData` will *not* be copied and is how an
application can do self-managed memory allocation. If you would rather make a copy of the data, use
`ma_audio_buffer_init_copy()`. To uninitialize the buffer, use `ma_audio_buffer_uninit()`.

Sometimes it can be convenient to allocate the memory for the `ma_audio_buffer` structure and the
raw audio data in a contiguous block of memory. That is, the raw audio data will be located
immediately after the `ma_audio_buffer` structure. To do this, use
`ma_audio_buffer_alloc_and_init()`:

    ```c
    ma_audio_buffer_config config = ma_audio_buffer_config_init(
        format,
        channels,
        sizeInFrames,
        pExistingData,
        &allocationCallbacks);

    ma_audio_buffer* pBuffer
    result = ma_audio_buffer_alloc_and_init(&config, &pBuffer);
    if (result != MA_SUCCESS) {
        // Error
    }

    ...

    ma_audio_buffer_uninit_and_free(&buffer);
    ```

If you initialize the buffer with `ma_audio_buffer_alloc_and_init()` you should uninitialize it
with `ma_audio_buffer_uninit_and_free()`. In the example above, the memory pointed to by
`pExistingData` will be copied into the buffer, which is contrary to the behavior of
`ma_audio_buffer_init()`.

An audio buffer has a playback cursor just like a decoder. As you read frames from the buffer, the
cursor moves forward. The last parameter (`loop`) can be used to determine if the buffer should
loop. The return value is the number of frames actually read. If this is less than the number of
frames requested it means the end has been reached. This should never happen if the `loop`
parameter is set to true. If you want to manually loop back to the start, you can do so with with
`ma_audio_buffer_seek_to_pcm_frame(pAudioBuffer, 0)`. Below is an example for reading data from an
audio buffer.

    ```c
    ma_uint64 framesRead = ma_audio_buffer_read_pcm_frames(pAudioBuffer, pFramesOut, desiredFrameCount, isLooping);
    if (framesRead < desiredFrameCount) {
        // If not looping, this means the end has been reached. This should never happen in looping mode with valid input.
    }
    ```

Sometimes you may want to avoid the cost of data movement between the internal buffer and the
output buffer. Instead you can use memory mapping to retrieve a pointer to a segment of data:

    ```c
    void* pMappedFrames;
    ma_uint64 frameCount = frameCountToTryMapping;
    ma_result result = ma_audio_buffer_map(pAudioBuffer, &pMappedFrames, &frameCount);
    if (result == MA_SUCCESS) {
        // Map was successful. The value in frameCount will be how many frames were _actually_ mapped, which may be
        // less due to the end of the buffer being reached.
        ma_copy_pcm_frames(pFramesOut, pMappedFrames, frameCount, pAudioBuffer->format, pAudioBuffer->channels);

        // You must unmap the buffer.
        ma_audio_buffer_unmap(pAudioBuffer, frameCount);
    }
    ```

When you use memory mapping, the read cursor is increment by the frame count passed in to
`ma_audio_buffer_unmap()`. If you decide not to process every frame you can pass in a value smaller
than the value returned by `ma_audio_buffer_map()`. The disadvantage to using memory mapping is
that it does not handle looping for you. You can determine if the buffer is at the end for the
purpose of looping with `ma_audio_buffer_at_end()` or by inspecting the return value of
`ma_audio_buffer_unmap()` and checking if it equals `MA_AT_END`. You should not treat `MA_AT_END`
as an error when returned by `ma_audio_buffer_unmap()`.



14. Ring Buffers
================
miniaudio supports lock free (single producer, single consumer) ring buffers which are exposed via
the `ma_rb` and `ma_pcm_rb` APIs. The `ma_rb` API operates on bytes, whereas the `ma_pcm_rb`
operates on PCM frames. They are otherwise identical as `ma_pcm_rb` is just a wrapper around
`ma_rb`.

Unlike most other APIs in miniaudio, ring buffers support both interleaved and deinterleaved
streams. The caller can also allocate their own backing memory for the ring buffer to use
internally for added flexibility. Otherwise the ring buffer will manage it's internal memory for
you.

The examples below use the PCM frame variant of the ring buffer since that's most likely the one
you will want to use. To initialize a ring buffer, do something like the following:

    ```c
    ma_pcm_rb rb;
    ma_result result = ma_pcm_rb_init(FORMAT, CHANNELS, BUFFER_SIZE_IN_FRAMES, NULL, NULL, &rb);
    if (result != MA_SUCCESS) {
        // Error
    }
    ```

The `ma_pcm_rb_init()` function takes the sample format and channel count as parameters because
it's the PCM variant of the ring buffer API. For the regular ring buffer that operates on bytes you
would call `ma_rb_init()` which leaves these out and just takes the size of the buffer in bytes
instead of frames. The fourth parameter is an optional pre-allocated buffer and the fifth parameter
is a pointer to a `ma_allocation_callbacks` structure for custom memory allocation routines.
Passing in `NULL` for this results in `MA_MALLOC()` and `MA_FREE()` being used.

Use `ma_pcm_rb_init_ex()` if you need a deinterleaved buffer. The data for each sub-buffer is
offset from each other based on the stride. To manage your sub-buffers you can use
`ma_pcm_rb_get_subbuffer_stride()`, `ma_pcm_rb_get_subbuffer_offset()` and
`ma_pcm_rb_get_subbuffer_ptr()`.

Use `ma_pcm_rb_acquire_read()` and `ma_pcm_rb_acquire_write()` to retrieve a pointer to a section
of the ring buffer. You specify the number of frames you need, and on output it will set to what
was actually acquired. If the read or write pointer is positioned such that the number of frames
requested will require a loop, it will be clamped to the end of the buffer. Therefore, the number
of frames you're given may be less than the number you requested.

After calling `ma_pcm_rb_acquire_read()` or `ma_pcm_rb_acquire_write()`, you do your work on the
buffer and then "commit" it with `ma_pcm_rb_commit_read()` or `ma_pcm_rb_commit_write()`. This is
where the read/write pointers are updated. When you commit you need to pass in the buffer that was
returned by the earlier call to `ma_pcm_rb_acquire_read()` or `ma_pcm_rb_acquire_write()` and is
only used for validation. The number of frames passed to `ma_pcm_rb_commit_read()` and
`ma_pcm_rb_commit_write()` is what's used to increment the pointers, and can be less that what was
originally requested.

If you want to correct for drift between the write pointer and the read pointer you can use a
combination of `ma_pcm_rb_pointer_distance()`, `ma_pcm_rb_seek_read()` and
`ma_pcm_rb_seek_write()`. Note that you can only move the pointers forward, and you should only
move the read pointer forward via the consumer thread, and the write pointer forward by the
producer thread. If there is too much space between the pointers, move the read pointer forward. If
there is too little space between the pointers, move the write pointer forward.

You can use a ring buffer at the byte level instead of the PCM frame level by using the `ma_rb`
API. This is exactly the same, only you will use the `ma_rb` functions instead of `ma_pcm_rb` and
instead of frame counts you will pass around byte counts.

The maximum size of the buffer in bytes is `0x7FFFFFFF-(MA_SIMD_ALIGNMENT-1)` due to the most
significant bit being used to encode a loop flag and the internally managed buffers always being
aligned to `MA_SIMD_ALIGNMENT`.

Note that the ring buffer is only thread safe when used by a single consumer thread and single
producer thread.



15. Backends
============
The following backends are supported by miniaudio. These are listed in order of default priority.
When no backend is specified when initializing a context or device, miniaudio will attempt to use
each of these backends in the order listed in the table below.

Note that backends that are not usable by the build target will not be included in the build. For
example, ALSA, which is specific to Linux, will not be included in the Windows build.

    +-------------+-----------------------+--------------------------------------------------------+
    | Name        | Enum Name             | Supported Operating Systems                            |
    +-------------+-----------------------+--------------------------------------------------------+
    | WASAPI      | ma_backend_wasapi     | Windows Vista+                                         |
    | DirectSound | ma_backend_dsound     | Windows XP+                                            |
    | WinMM       | ma_backend_winmm      | Windows 95+                                            |
    | Core Audio  | ma_backend_coreaudio  | macOS, iOS                                             |
    | sndio       | ma_backend_sndio      | OpenBSD                                                |
    | audio(4)    | ma_backend_audio4     | NetBSD, OpenBSD                                        |
    | OSS         | ma_backend_oss        | FreeBSD                                                |
    | PulseAudio  | ma_backend_pulseaudio | Cross Platform (disabled on Windows, BSD and Android)  |
    | ALSA        | ma_backend_alsa       | Linux                                                  |
    | JACK        | ma_backend_jack       | Cross Platform (disabled on BSD and Android)           |
    | AAudio      | ma_backend_aaudio     | Android 8+                                             |
    | OpenSL ES   | ma_backend_opensl     | Android (API level 16+)                                |
    | Web Audio   | ma_backend_webaudio   | Web (via Emscripten)                                   |
    | Custom      | ma_backend_custom     | Cross Platform                                         |
    | Null        | ma_backend_null       | Cross Platform (not used on Web)                       |
    +-------------+-----------------------+--------------------------------------------------------+

Some backends have some nuance details you may want to be aware of.

15.1. WASAPI
------------
- Low-latency shared mode will be disabled when using an application-defined sample rate which is
  different to the device's native sample rate. To work around this, set `wasapi.noAutoConvertSRC`
  to true in the device config. This is due to IAudioClient3_InitializeSharedAudioStream() failing
  when the `AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM` flag is specified. Setting wasapi.noAutoConvertSRC
  will result in miniaudio's internal resampler being used instead which will in turn enable the
  use of low-latency shared mode.

15.2. PulseAudio
----------------
- If you experience bad glitching/noise on Arch Linux, consider this fix from the Arch wiki:
  https://wiki.archlinux.org/index.php/PulseAudio/Troubleshooting#Glitches,_skips_or_crackling.
  Alternatively, consider using a different backend such as ALSA.

15.3. Android
-------------
- To capture audio on Android, remember to add the RECORD_AUDIO permission to your manifest:
  `<uses-permission android:name="android.permission.RECORD_AUDIO" />`
- With OpenSL|ES, only a single ma_context can be active at any given time. This is due to a
  limitation with OpenSL|ES.
- With AAudio, only default devices are enumerated. This is due to AAudio not having an enumeration
  API (devices are enumerated through Java). You can however perform your own device enumeration
  through Java and then set the ID in the ma_device_id structure (ma_device_id.aaudio) and pass it
  to ma_device_init().
- The backend API will perform resampling where possible. The reason for this as opposed to using
  miniaudio's built-in resampler is to take advantage of any potential device-specific
  optimizations the driver may implement.

BSD
---
- The sndio backend is currently only enabled on OpenBSD builds.
- The audio(4) backend is supported on OpenBSD, but you may need to disable sndiod before you can
  use it.

15.4. UWP
---------
- UWP only supports default playback and capture devices.
- UWP requires the Microphone capability to be enabled in the application's manifest (Package.appxmanifest):

    ```
    <Package ...>
        ...
        <Capabilities>
            <DeviceCapability Name="microphone" />
        </Capabilities>
    </Package>
    ```

15.5. Web Audio / Emscripten
----------------------------
- You cannot use `-std=c*` compiler flags, nor `-ansi`. This only applies to the Emscripten build.
- The first time a context is initialized it will create a global object called "miniaudio" whose
  primary purpose is to act as a factory for device objects.
- Currently the Web Audio backend uses ScriptProcessorNode's, but this may need to change later as
  they've been deprecated.
- Google has implemented a policy in their browsers that prevent automatic media output without
  first receiving some kind of user input. The following web page has additional details:
  https://developers.google.com/web/updates/2017/09/autoplay-policy-changes. Starting the device
  may fail if you try to start playback without first handling some kind of user input.



16. Optimization Tips
=====================
See below for some tips on improving performance.

16.1. Low Level API
-------------------
- In the data callback, if your data is already clipped prior to copying it into the output buffer,
  set the `noClip` config option in the device config to true. This will disable miniaudio's built
  in clipping function.
- By default, miniaudio will pre-silence the data callback's output buffer. If you know that you
  will always write valid data to the output buffer you can disable pre-silencing by setting the
  `noPreSilence` config option in the device config to true.

16.2. High Level API
--------------------
- If a sound does not require doppler or pitch shifting, consider disabling pitching by
  initializing the sound with the `MA_SOUND_FLAG_NO_PITCH` flag.
- If a sound does not require spatialization, disable it by initializing the sound with the
  `MA_SOUND_FLAG_NO_SPATIALIZATION` flag. It can be re-enabled again post-initialization with
  `ma_sound_set_spatialization_enabled()`.
- If you know all of your sounds will always be the same sample rate, set the engine's sample
  rate to match that of the sounds. Likewise, if you're using a self-managed resource manager,
  consider setting the decoded sample rate to match your sounds. By configuring everything to
  use a consistent sample rate, sample rate conversion can be avoided.



17. Miscellaneous Notes
=======================
- Automatic stream routing is enabled on a per-backend basis. Support is explicitly enabled for
  WASAPI and Core Audio, however other backends such as PulseAudio may naturally support it, though
  not all have been tested.
- When compiling with VC6 and earlier, decoding is restricted to files less than 2GB in size. This
  is due to 64-bit file APIs not being available.
*/

#ifndef miniaudio_h
#define miniaudio_h

#ifdef __cplusplus
extern "C" {
#endif

#define MA_STRINGIFY(x)     #x
#define MA_XSTRINGIFY(x)    MA_STRINGIFY(x)

#define MA_VERSION_MAJOR    0
#define MA_VERSION_MINOR    11
#define MA_VERSION_REVISION 22
#define MA_VERSION_STRING   MA_XSTRINGIFY(MA_VERSION_MAJOR) "." MA_XSTRINGIFY(MA_VERSION_MINOR) "." MA_XSTRINGIFY(MA_VERSION_REVISION)

#if defined(_MSC_VER) && !defined(__clang__)
    #pragma warning(push)
    #pragma warning(disable:4201)   /* nonstandard extension used: nameless struct/union */
    #pragma warning(disable:4214)   /* nonstandard extension used: bit field types other than int */
    #pragma warning(disable:4324)   /* structure was padded due to alignment specifier */
#elif defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)))
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpedantic" /* For ISO C99 doesn't support unnamed structs/unions [-Wpedantic] */
    #if defined(__clang__)
        #pragma GCC diagnostic ignored "-Wc11-extensions"   /* anonymous unions are a C11 extension */
    #endif
#endif


#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__)) || defined(_M_X64) || defined(__ia64) || defined(_M_IA64) || defined(__aarch64__) || defined(_M_ARM64) || defined(__powerpc64__) || defined(__ppc64__)
    #define MA_SIZEOF_PTR   8
#else
    #define MA_SIZEOF_PTR   4
#endif

#include <stddef.h> /* For size_t. */

/* Sized types. */
#if defined(MA_USE_STDINT)
    #include <stdint.h>
    typedef int8_t   ma_int8;
    typedef uint8_t  ma_uint8;
    typedef int16_t  ma_int16;
    typedef uint16_t ma_uint16;
    typedef int32_t  ma_int32;
    typedef uint32_t ma_uint32;
    typedef int64_t  ma_int64;
    typedef uint64_t ma_uint64;
#else
    typedef   signed char           ma_int8;
    typedef unsigned char           ma_uint8;
    typedef   signed short          ma_int16;
    typedef unsigned short          ma_uint16;
    typedef   signed int            ma_int32;
    typedef unsigned int            ma_uint32;
    #if defined(_MSC_VER) && !defined(__clang__)
        typedef   signed __int64    ma_int64;
        typedef unsigned __int64    ma_uint64;
    #else
        #if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)))
            #pragma GCC diagnostic push
            #pragma GCC diagnostic ignored "-Wlong-long"
            #if defined(__clang__)
                #pragma GCC diagnostic ignored "-Wc++11-long-long"
            #endif
        #endif
        typedef   signed long long  ma_int64;
        typedef unsigned long long  ma_uint64;
        #if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)))
            #pragma GCC diagnostic pop
        #endif
    #endif
#endif  /* MA_USE_STDINT */

#if MA_SIZEOF_PTR == 8
    typedef ma_uint64           ma_uintptr;
#else
    typedef ma_uint32           ma_uintptr;
#endif

typedef ma_uint8    ma_bool8;
typedef ma_uint32   ma_bool32;
#define MA_TRUE     1
#define MA_FALSE    0

/* These float types are not used universally by miniaudio. It's to simplify some macro expansion for atomic types. */
typedef float       ma_float;
typedef double      ma_double;

typedef void* ma_handle;
typedef void* ma_ptr;

/*
ma_proc is annoying because when compiling with GCC we get pedantic warnings about converting
between `void*` and `void (*)()`. We can't use `void (*)()` with MSVC however, because we'll get
warning C4191 about "type cast between incompatible function types". To work around this I'm going
to use a different data type depending on the compiler.
*/
#if defined(__GNUC__)
typedef void (*ma_proc)(void);
#else
typedef void* ma_proc;
#endif

#if defined(_MSC_VER) && !defined(_WCHAR_T_DEFINED)
typedef ma_uint16 wchar_t;
#endif

/* Define NULL for some compilers. */
#ifndef NULL
#define NULL 0
#endif

#if defined(SIZE_MAX)
    #define MA_SIZE_MAX    SIZE_MAX
#else
    #define MA_SIZE_MAX    0xFFFFFFFF  /* When SIZE_MAX is not defined by the standard library just default to the maximum 32-bit unsigned integer. */
#endif


/* Platform/backend detection. */
#if defined(_WIN32) || defined(__COSMOPOLITAN__)
    #define MA_WIN32
    #if defined(MA_FORCE_UWP) || (defined(WINAPI_FAMILY) && ((defined(WINAPI_FAMILY_PC_APP) && WINAPI_FAMILY == WINAPI_FAMILY_PC_APP) || (defined(WINAPI_FAMILY_PHONE_APP) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP)))
        #define MA_WIN32_UWP
    #elif defined(WINAPI_FAMILY) && (defined(WINAPI_FAMILY_GAMES) && WINAPI_FAMILY == WINAPI_FAMILY_GAMES)
        #define MA_WIN32_GDK
    #else
        #define MA_WIN32_DESKTOP
    #endif
#endif
#if !defined(_WIN32)    /* If it's not Win32, assume POSIX. */
    #define MA_POSIX

    /*
    Use the MA_NO_PTHREAD_IN_HEADER option at your own risk. This is intentionally undocumented.
    You can use this to avoid including pthread.h in the header section. The downside is that it
    results in some fixed sized structures being declared for the various types that are used in
    miniaudio. The risk here is that these types might be too small for a given platform. This
    risk is yours to take and no support will be offered if you enable this option.
    */
    #ifndef MA_NO_PTHREAD_IN_HEADER
        #include <pthread.h>    /* Unfortunate #include, but needed for pthread_t, pthread_mutex_t and pthread_cond_t types. */
        typedef pthread_t       ma_pthread_t;
        typedef pthread_mutex_t ma_pthread_mutex_t;
        typedef pthread_cond_t  ma_pthread_cond_t;
    #else
        typedef ma_uintptr      ma_pthread_t;
        typedef union           ma_pthread_mutex_t { char __data[40]; ma_uint64 __alignment; } ma_pthread_mutex_t;
        typedef union           ma_pthread_cond_t  { char __data[48]; ma_uint64 __alignment; } ma_pthread_cond_t;
    #endif

    #if defined(__unix__)
        #define MA_UNIX
    #endif
    #if defined(__linux__)
        #define MA_LINUX
    #endif
    #if defined(__APPLE__)
        #define MA_APPLE
    #endif
    #if defined(__DragonFly__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
        #define MA_BSD
    #endif
    #if defined(__ANDROID__)
        #define MA_ANDROID
    #endif
    #if defined(__EMSCRIPTEN__)
        #define MA_EMSCRIPTEN
    #endif
    #if defined(__ORBIS__)
        #define MA_ORBIS
    #endif
    #if defined(__PROSPERO__)
        #define MA_PROSPERO
    #endif
    #if defined(__NX__)
        #define MA_NX
    #endif
    #if defined(__BEOS__) || defined(__HAIKU__)
        #define MA_BEOS
    #endif
    #if defined(__HAIKU__)
        #define MA_HAIKU
    #endif
#endif

#if defined(__has_c_attribute)
    #if __has_c_attribute(fallthrough)
        #define MA_FALLTHROUGH [[fallthrough]]
    #endif
#endif
#if !defined(MA_FALLTHROUGH) && defined(__has_attribute) && (defined(__clang__) || defined(__GNUC__))
    #if __has_attribute(fallthrough)
        #define MA_FALLTHROUGH __attribute__((fallthrough))
    #endif
#endif
#if !defined(MA_FALLTHROUGH)
    #define MA_FALLTHROUGH ((void)0)
#endif

#ifdef _MSC_VER
    #define MA_INLINE __forceinline

    /* noinline was introduced in Visual Studio 2005. */
    #if _MSC_VER >= 1400
        #define MA_NO_INLINE __declspec(noinline)
    #else
        #define MA_NO_INLINE
    #endif
#elif defined(__GNUC__)
    /*
    I've had a bug report where GCC is emitting warnings about functions possibly not being inlineable. This warning happens when
    the __attribute__((always_inline)) attribute is defined without an "inline" statement. I think therefore there must be some
    case where "__inline__" is not always defined, thus the compiler emitting these warnings. When using -std=c89 or -ansi on the
    command line, we cannot use the "inline" keyword and instead need to use "__inline__". In an attempt to work around this issue
    I am using "__inline__" only when we're compiling in strict ANSI mode.
    */
    #if defined(__STRICT_ANSI__)
        #define MA_GNUC_INLINE_HINT __inline__
    #else
        #define MA_GNUC_INLINE_HINT inline
    #endif

    #if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 2)) || defined(__clang__)
        #define MA_INLINE MA_GNUC_INLINE_HINT __attribute__((always_inline))
        #define MA_NO_INLINE __attribute__((noinline))
    #else
        #define MA_INLINE MA_GNUC_INLINE_HINT
        #define MA_NO_INLINE __attribute__((noinline))
    #endif
#elif defined(__WATCOMC__)
    #define MA_INLINE __inline
    #define MA_NO_INLINE
#else
    #define MA_INLINE
    #define MA_NO_INLINE
#endif

/* MA_DLL is not officially supported. You're on your own if you want to use this. */
#if defined(MA_DLL)
    #if defined(_WIN32)
        #define MA_DLL_IMPORT  __declspec(dllimport)
        #define MA_DLL_EXPORT  __declspec(dllexport)
        #define MA_DLL_PRIVATE static
    #else
        #if defined(__GNUC__) && __GNUC__ >= 4
            #define MA_DLL_IMPORT  __attribute__((visibility("default")))
            #define MA_DLL_EXPORT  __attribute__((visibility("default")))
            #define MA_DLL_PRIVATE __attribute__((visibility("hidden")))
        #else
            #define MA_DLL_IMPORT
            #define MA_DLL_EXPORT
            #define MA_DLL_PRIVATE static
        #endif
    #endif
#endif

#if !defined(MA_API)
    #if defined(MA_DLL)
        #if defined(MINIAUDIO_IMPLEMENTATION) || defined(MA_IMPLEMENTATION)
            #define MA_API  MA_DLL_EXPORT
        #else
            #define MA_API  MA_DLL_IMPORT
        #endif
    #else
        #define MA_API extern
    #endif
#endif

#if !defined(MA_STATIC)
    #if defined(MA_DLL)
        #define MA_PRIVATE MA_DLL_PRIVATE
    #else
        #define MA_PRIVATE static
    #endif
#endif


/* SIMD alignment in bytes. Currently set to 32 bytes in preparation for future AVX optimizations. */
#define MA_SIMD_ALIGNMENT  32

/*
Special wchar_t type to ensure any structures in the public sections that reference it have a
consistent size across all platforms.

On Windows, wchar_t is 2 bytes, whereas everywhere else it's 4 bytes. Since Windows likes to use
wchar_t for its IDs, we need a special explicitly sized wchar type that is always 2 bytes on all
platforms.
*/
#if !defined(MA_POSIX) && defined(MA_WIN32)
typedef wchar_t     ma_wchar_win32;
#else
typedef ma_uint16   ma_wchar_win32;
#endif



/*
Logging Levels
==============
Log levels are only used to give logging callbacks some context as to the severity of a log message
so they can do filtering. All log levels will be posted to registered logging callbacks. If you
don't want to output a certain log level you can discriminate against the log level in the callback.

MA_LOG_LEVEL_DEBUG
    Used for debugging. Useful for debug and test builds, but should be disabled in release builds.

MA_LOG_LEVEL_INFO
    Informational logging. Useful for debugging. This will never be called from within the data
    callback.

MA_LOG_LEVEL_WARNING
    Warnings. You should enable this in you development builds and action them when encountered. These
    logs usually indicate a potential problem or misconfiguration, but still allow you to keep
    running. This will never be called from within the data callback.

MA_LOG_LEVEL_ERROR
    Error logging. This will be fired when an operation fails and is subsequently aborted. This can
    be fired from within the data callback, in which case the device will be stopped. You should
    always have this log level enabled.
*/
typedef enum
{
    MA_LOG_LEVEL_DEBUG   = 4,
    MA_LOG_LEVEL_INFO    = 3,
    MA_LOG_LEVEL_WARNING = 2,
    MA_LOG_LEVEL_ERROR   = 1
} ma_log_level;

/*
Variables needing to be accessed atomically should be declared with this macro for two reasons:

    1) It allows people who read the code to identify a variable as such; and
    2) It forces alignment on platforms where it's required or optimal.

Note that for x86/64, alignment is not strictly necessary, but does have some performance
implications. Where supported by the compiler, alignment will be used, but otherwise if the CPU
architecture does not require it, it will simply leave it unaligned. This is the case with old
versions of Visual Studio, which I've confirmed with at least VC6.
*/
#if !defined(_MSC_VER) && defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)
    #include <stdalign.h>
    #define MA_ATOMIC(alignment, type)            _Alignas(alignment) type
#else
    #if defined(__GNUC__)
        /* GCC-style compilers. */
        #define MA_ATOMIC(alignment, type)        type __attribute__((aligned(alignment)))
    #elif defined(_MSC_VER) && _MSC_VER > 1200  /* 1200 = VC6. Alignment not supported, but not necessary because x86 is the only supported target. */
        /* MSVC. */
        #define MA_ATOMIC(alignment, type)        __declspec(align(alignment)) type
    #else
        /* Other compilers. */
        #define MA_ATOMIC(alignment, type)        type
    #endif
#endif

typedef struct ma_context ma_context;
typedef struct ma_device ma_device;

typedef ma_uint8 ma_channel;
typedef enum
{
    MA_CHANNEL_NONE               = 0,
    MA_CHANNEL_MONO               = 1,
    MA_CHANNEL_FRONT_LEFT         = 2,
    MA_CHANNEL_FRONT_RIGHT        = 3,
    MA_CHANNEL_FRONT_CENTER       = 4,
    MA_CHANNEL_LFE                = 5,
    MA_CHANNEL_BACK_LEFT          = 6,
    MA_CHANNEL_BACK_RIGHT         = 7,
    MA_CHANNEL_FRONT_LEFT_CENTER  = 8,
    MA_CHANNEL_FRONT_RIGHT_CENTER = 9,
    MA_CHANNEL_BACK_CENTER        = 10,
    MA_CHANNEL_SIDE_LEFT          = 11,
    MA_CHANNEL_SIDE_RIGHT         = 12,
    MA_CHANNEL_TOP_CENTER         = 13,
    MA_CHANNEL_TOP_FRONT_LEFT     = 14,
    MA_CHANNEL_TOP_FRONT_CENTER   = 15,
    MA_CHANNEL_TOP_FRONT_RIGHT    = 16,
    MA_CHANNEL_TOP_BACK_LEFT      = 17,
    MA_CHANNEL_TOP_BACK_CENTER    = 18,
    MA_CHANNEL_TOP_BACK_RIGHT     = 19,
    MA_CHANNEL_AUX_0              = 20,
    MA_CHANNEL_AUX_1              = 21,
    MA_CHANNEL_AUX_2              = 22,
    MA_CHANNEL_AUX_3              = 23,
    MA_CHANNEL_AUX_4              = 24,
    MA_CHANNEL_AUX_5              = 25,
    MA_CHANNEL_AUX_6              = 26,
    MA_CHANNEL_AUX_7              = 27,
    MA_CHANNEL_AUX_8              = 28,
    MA_CHANNEL_AUX_9              = 29,
    MA_CHANNEL_AUX_10             = 30,
    MA_CHANNEL_AUX_11             = 31,
    MA_CHANNEL_AUX_12             = 32,
    MA_CHANNEL_AUX_13             = 33,
    MA_CHANNEL_AUX_14             = 34,
    MA_CHANNEL_AUX_15             = 35,
    MA_CHANNEL_AUX_16             = 36,
    MA_CHANNEL_AUX_17             = 37,
    MA_CHANNEL_AUX_18             = 38,
    MA_CHANNEL_AUX_19             = 39,
    MA_CHANNEL_AUX_20             = 40,
    MA_CHANNEL_AUX_21             = 41,
    MA_CHANNEL_AUX_22             = 42,
    MA_CHANNEL_AUX_23             = 43,
    MA_CHANNEL_AUX_24             = 44,
    MA_CHANNEL_AUX_25             = 45,
    MA_CHANNEL_AUX_26             = 46,
    MA_CHANNEL_AUX_27             = 47,
    MA_CHANNEL_AUX_28             = 48,
    MA_CHANNEL_AUX_29             = 49,
    MA_CHANNEL_AUX_30             = 50,
    MA_CHANNEL_AUX_31             = 51,
    MA_CHANNEL_LEFT               = MA_CHANNEL_FRONT_LEFT,
    MA_CHANNEL_RIGHT              = MA_CHANNEL_FRONT_RIGHT,
    MA_CHANNEL_POSITION_COUNT     = (MA_CHANNEL_AUX_31 + 1)
} _ma_channel_position; /* Do not use `_ma_channel_position` directly. Use `ma_channel` instead. */

typedef enum
{
    MA_SUCCESS                        =  0,
    MA_ERROR                          = -1,  /* A generic error. */
    MA_INVALID_ARGS                   = -2,
    MA_INVALID_OPERATION              = -3,
    MA_OUT_OF_MEMORY                  = -4,
    MA_OUT_OF_RANGE                   = -5,
    MA_ACCESS_DENIED                  = -6,
    MA_DOES_NOT_EXIST                 = -7,
    MA_ALREADY_EXISTS                 = -8,
    MA_TOO_MANY_OPEN_FILES            = -9,
    MA_INVALID_FILE                   = -10,
    MA_TOO_BIG                        = -11,
    MA_PATH_TOO_LONG                  = -12,
    MA_NAME_TOO_LONG                  = -13,
    MA_NOT_DIRECTORY                  = -14,
    MA_IS_DIRECTORY                   = -15,
    MA_DIRECTORY_NOT_EMPTY            = -16,
    MA_AT_END                         = -17,
    MA_NO_SPACE                       = -18,
    MA_BUSY                           = -19,
    MA_IO_ERROR                       = -20,
    MA_INTERRUPT                      = -21,
    MA_UNAVAILABLE                    = -22,
    MA_ALREADY_IN_USE                 = -23,
    MA_BAD_ADDRESS                    = -24,
    MA_BAD_SEEK                       = -25,
    MA_BAD_PIPE                       = -26,
    MA_DEADLOCK                       = -27,
    MA_TOO_MANY_LINKS                 = -28,
    MA_NOT_IMPLEMENTED                = -29,
    MA_NO_MESSAGE                     = -30,
    MA_BAD_MESSAGE                    = -31,
    MA_NO_DATA_AVAILABLE              = -32,
    MA_INVALID_DATA                   = -33,
    MA_TIMEOUT                        = -34,
    MA_NO_NETWORK                     = -35,
    MA_NOT_UNIQUE                     = -36,
    MA_NOT_SOCKET                     = -37,
    MA_NO_ADDRESS                     = -38,
    MA_BAD_PROTOCOL                   = -39,
    MA_PROTOCOL_UNAVAILABLE           = -40,
    MA_PROTOCOL_NOT_SUPPORTED         = -41,
    MA_PROTOCOL_FAMILY_NOT_SUPPORTED  = -42,
    MA_ADDRESS_FAMILY_NOT_SUPPORTED   = -43,
    MA_SOCKET_NOT_SUPPORTED           = -44,
    MA_CONNECTION_RESET               = -45,
    MA_ALREADY_CONNECTED              = -46,
    MA_NOT_CONNECTED                  = -47,
    MA_CONNECTION_REFUSED             = -48,
    MA_NO_HOST                        = -49,
    MA_IN_PROGRESS                    = -50,
    MA_CANCELLED                      = -51,
    MA_MEMORY_ALREADY_MAPPED          = -52,

    /* General non-standard errors. */
    MA_CRC_MISMATCH                   = -100,

    /* General miniaudio-specific errors. */
    MA_FORMAT_NOT_SUPPORTED           = -200,
    MA_DEVICE_TYPE_NOT_SUPPORTED      = -201,
    MA_SHARE_MODE_NOT_SUPPORTED       = -202,
    MA_NO_BACKEND                     = -203,
    MA_NO_DEVICE                      = -204,
    MA_API_NOT_FOUND                  = -205,
    MA_INVALID_DEVICE_CONFIG          = -206,
    MA_LOOP                           = -207,
    MA_BACKEND_NOT_ENABLED            = -208,

    /* State errors. */
    MA_DEVICE_NOT_INITIALIZED         = -300,
    MA_DEVICE_ALREADY_INITIALIZED     = -301,
    MA_DEVICE_NOT_STARTED             = -302,
    MA_DEVICE_NOT_STOPPED             = -303,

    /* Operation errors. */
    MA_FAILED_TO_INIT_BACKEND         = -400,
    MA_FAILED_TO_OPEN_BACKEND_DEVICE  = -401,
    MA_FAILED_TO_START_BACKEND_DEVICE = -402,
    MA_FAILED_TO_STOP_BACKEND_DEVICE  = -403
} ma_result;


#define MA_MIN_CHANNELS                 1
#ifndef MA_MAX_CHANNELS
#define MA_MAX_CHANNELS                 254
#endif

#ifndef MA_MAX_FILTER_ORDER
#define MA_MAX_FILTER_ORDER             8
#endif

typedef enum
{
    ma_stream_format_pcm = 0
} ma_stream_format;

typedef enum
{
    ma_stream_layout_interleaved = 0,
    ma_stream_layout_deinterleaved
} ma_stream_layout;

typedef enum
{
    ma_dither_mode_none = 0,
    ma_dither_mode_rectangle,
    ma_dither_mode_triangle
} ma_dither_mode;

typedef enum
{
    /*
    I like to keep these explicitly defined because they're used as a key into a lookup table. When items are
    added to this, make sure there are no gaps and that they're added to the lookup table in ma_get_bytes_per_sample().
    */
    ma_format_unknown = 0,     /* Mainly used for indicating an error, but also used as the default for the output format for decoders. */
    ma_format_u8      = 1,
    ma_format_s16     = 2,     /* Seems to be the most widely supported format. */
    ma_format_s24     = 3,     /* Tightly packed. 3 bytes per sample. */
    ma_format_s32     = 4,
    ma_format_f32     = 5,
    ma_format_count
} ma_format;

typedef enum
{
    /* Standard rates need to be in priority order. */
    ma_standard_sample_rate_48000  = 48000,     /* Most common */
    ma_standard_sample_rate_44100  = 44100,

    ma_standard_sample_rate_32000  = 32000,     /* Lows */
    ma_standard_sample_rate_24000  = 24000,
    ma_standard_sample_rate_22050  = 22050,

    ma_standard_sample_rate_88200  = 88200,     /* Highs */
    ma_standard_sample_rate_96000  = 96000,
    ma_standard_sample_rate_176400 = 176400,
    ma_standard_sample_rate_192000 = 192000,

    ma_standard_sample_rate_16000  = 16000,     /* Extreme lows */
    ma_standard_sample_rate_11025  = 11025,
    ma_standard_sample_rate_8000   = 8000,

    ma_standard_sample_rate_352800 = 352800,    /* Extreme highs */
    ma_standard_sample_rate_384000 = 384000,

    ma_standard_sample_rate_min    = ma_standard_sample_rate_8000,
    ma_standard_sample_rate_max    = ma_standard_sample_rate_384000,
    ma_standard_sample_rate_count  = 14         /* Need to maintain the count manually. Make sure this is updated if items are added to enum. */
} ma_standard_sample_rate;


typedef enum
{
    ma_channel_mix_mode_rectangular = 0,   /* Simple averaging based on the plane(s) the channel is sitting on. */
    ma_channel_mix_mode_simple,            /* Drop excess channels; zeroed out extra channels. */
    ma_channel_mix_mode_custom_weights,    /* Use custom weights specified in ma_channel_converter_config. */
    ma_channel_mix_mode_default = ma_channel_mix_mode_rectangular
} ma_channel_mix_mode;

typedef enum
{
    ma_standard_channel_map_microsoft,
    ma_standard_channel_map_alsa,
    ma_standard_channel_map_rfc3551,   /* Based off AIFF. */
    ma_standard_channel_map_flac,
    ma_standard_channel_map_vorbis,
    ma_standard_channel_map_sound4,    /* FreeBSD's sound(4). */
    ma_standard_channel_map_sndio,     /* www.sndio.org/tips.html */
    ma_standard_channel_map_webaudio = ma_standard_channel_map_flac, /* https://webaudio.github.io/web-audio-api/#ChannelOrdering. Only 1, 2, 4 and 6 channels are defined, but can fill in the gaps with logical assumptions. */
    ma_standard_channel_map_default = ma_standard_channel_map_microsoft
} ma_standard_channel_map;

typedef enum
{
    ma_performance_profile_low_latency = 0,
    ma_performance_profile_conservative
} ma_performance_profile;


typedef struct
{
    void* pUserData;
    void* (* onMalloc)(size_t sz, void* pUserData);
    void* (* onRealloc)(void* p, size_t sz, void* pUserData);
    void  (* onFree)(void* p, void* pUserData);
} ma_allocation_callbacks;

typedef struct
{
    ma_int32 state;
} ma_lcg;


/*
Atomics.

These are typesafe structures to prevent errors as a result of forgetting to reference variables atomically. It's too
easy to introduce subtle bugs where you accidentally do a regular assignment instead of an atomic load/store, etc. By
using a struct we can enforce the use of atomics at compile time.

These types are declared in the header section because we need to reference them in structs below, but functions for
using them are only exposed in the implementation section. I do not want these to be part of the public API.

There's a few downsides to this system. The first is that you need to declare a new struct for each type. Below are
some macros to help with the declarations. They will be named like so:

    ma_atomic_uint32 - atomic ma_uint32
    ma_atomic_int32  - atomic ma_int32
    ma_atomic_uint64 - atomic ma_uint64
    ma_atomic_float  - atomic float
    ma_atomic_bool32 - atomic ma_bool32

The other downside is that atomic pointers are extremely messy. You need to declare a new struct for each specific
type of pointer you need to make atomic. For example, an atomic ma_node* will look like this:

    MA_ATOMIC_SAFE_TYPE_IMPL_PTR(node)

Which will declare a type struct that's named like so:

    ma_atomic_ptr_node

Functions to use the atomic types are declared in the implementation section. All atomic functions are prefixed with
the name of the struct. For example:

    ma_atomic_uint32_set() - Atomic store of ma_uint32
    ma_atomic_uint32_get() - Atomic load of ma_uint32
    etc.

For pointer types it's the same, which makes them a bit messy to use due to the length of each function name, but in
return you get type safety and enforcement of atomic operations.
*/
#define MA_ATOMIC_SAFE_TYPE_DECL(c89TypeExtension, typeSize, type) \
    typedef struct \
    { \
        MA_ATOMIC(typeSize, ma_##type) value; \
    } ma_atomic_##type; \

#define MA_ATOMIC_SAFE_TYPE_DECL_PTR(type) \
    typedef struct \
    { \
        MA_ATOMIC(MA_SIZEOF_PTR, ma_##type*) value; \
    } ma_atomic_ptr_##type; \

MA_ATOMIC_SAFE_TYPE_DECL(32,  4, uint32)
MA_ATOMIC_SAFE_TYPE_DECL(i32, 4, int32)
MA_ATOMIC_SAFE_TYPE_DECL(64,  8, uint64)
MA_ATOMIC_SAFE_TYPE_DECL(f32, 4, float)
MA_ATOMIC_SAFE_TYPE_DECL(32,  4, bool32)


/* Spinlocks are 32-bit for compatibility reasons. */
typedef ma_uint32 ma_spinlock;

#ifndef MA_NO_THREADING
    /* Thread priorities should be ordered such that the default priority of the worker thread is 0. */
    typedef enum
    {
        ma_thread_priority_idle     = -5,
        ma_thread_priority_lowest   = -4,
        ma_thread_priority_low      = -3,
        ma_thread_priority_normal   = -2,
        ma_thread_priority_high     = -1,
        ma_thread_priority_highest  =  0,
        ma_thread_priority_realtime =  1,
        ma_thread_priority_default  =  0
    } ma_thread_priority;

    #if defined(MA_POSIX)
        typedef ma_pthread_t ma_thread;
    #elif defined(MA_WIN32)
        typedef ma_handle ma_thread;
    #endif

    #if defined(MA_POSIX)
        typedef ma_pthread_mutex_t ma_mutex;
    #elif defined(MA_WIN32)
        typedef ma_handle ma_mutex;
    #endif

    #if defined(MA_POSIX)
        typedef struct
        {
            ma_uint32 value;
            ma_pthread_mutex_t lock;
            ma_pthread_cond_t cond;
        } ma_event;
    #elif defined(MA_WIN32)
        typedef ma_handle ma_event;
    #endif

    #if defined(MA_POSIX)
        typedef struct
        {
            int value;
            ma_pthread_mutex_t lock;
            ma_pthread_cond_t cond;
        } ma_semaphore;
    #elif defined(MA_WIN32)
        typedef ma_handle ma_semaphore;
    #endif
#else
    /* MA_NO_THREADING is set which means threading is disabled. Threading is required by some API families. If any of these are enabled we need to throw an error. */
#endif  /* MA_NO_THREADING */


/*
Retrieves the version of miniaudio as separated integers. Each component can be NULL if it's not required.
*/
MA_API void ma_version(ma_uint32* pMajor, ma_uint32* pMinor, ma_uint32* pRevision);

/*
Retrieves the version of miniaudio as a string which can be useful for logging purposes.
*/
MA_API const char* ma_version_string(void);


/**************************************************************************************************************************************************************

Logging

**************************************************************************************************************************************************************/
#include <stdarg.h> /* For va_list. */

#if defined(__has_attribute)
    #if __has_attribute(format)
        #define MA_ATTRIBUTE_FORMAT(fmt, va) __attribute__((format(printf, fmt, va)))
    #endif
#endif
#ifndef MA_ATTRIBUTE_FORMAT
#define MA_ATTRIBUTE_FORMAT(fmt, va)
#endif

#ifndef MA_MAX_LOG_CALLBACKS
#define MA_MAX_LOG_CALLBACKS    4
#endif


/*
The callback for handling log messages.


Parameters
----------
pUserData (in)
    The user data pointer that was passed into ma_log_register_callback().

logLevel (in)
    The log level. This can be one of the following:

    +----------------------+
    | Log Level            |
    +----------------------+
    | MA_LOG_LEVEL_DEBUG   |
    | MA_LOG_LEVEL_INFO    |
    | MA_LOG_LEVEL_WARNING |
    | MA_LOG_LEVEL_ERROR   |
    +----------------------+

pMessage (in)
    The log message.
*/
typedef void (* ma_log_callback_proc)(void* pUserData, ma_uint32 level, const char* pMessage);

typedef struct
{
    ma_log_callback_proc onLog;
    void* pUserData;
} ma_log_callback;

MA_API ma_log_callback ma_log_callback_init(ma_log_callback_proc onLog, void* pUserData);


typedef struct
{
    ma_log_callback callbacks[MA_MAX_LOG_CALLBACKS];
    ma_uint32 callbackCount;
    ma_allocation_callbacks allocationCallbacks;    /* Need to store these persistently because ma_log_postv() might need to allocate a buffer on the heap. */
#ifndef MA_NO_THREADING
    ma_mutex lock;  /* For thread safety just to make it easier and safer for the logging implementation. */
#endif
} ma_log;

MA_API ma_result ma_log_init(const ma_allocation_callbacks* pAllocationCallbacks, ma_log* pLog);
MA_API void ma_log_uninit(ma_log* pLog);
MA_API ma_result ma_log_register_callback(ma_log* pLog, ma_log_callback callback);
MA_API ma_result ma_log_unregister_callback(ma_log* pLog, ma_log_callback callback);
MA_API ma_result ma_log_post(ma_log* pLog, ma_uint32 level, const char* pMessage);
MA_API ma_result ma_log_postv(ma_log* pLog, ma_uint32 level, const char* pFormat, va_list args);
MA_API ma_result ma_log_postf(ma_log* pLog, ma_uint32 level, const char* pFormat, ...) MA_ATTRIBUTE_FORMAT(3, 4);


/**************************************************************************************************************************************************************

Biquad Filtering

**************************************************************************************************************************************************************/
typedef union
{
    float    f32;
    ma_int32 s32;
} ma_biquad_coefficient;

typedef struct
{
    ma_format format;
    ma_uint32 channels;
    double b0;
    double b1;
    double b2;
    double a0;
    double a1;
    double a2;
} ma_biquad_config;

MA_API ma_biquad_config ma_biquad_config_init(ma_format format, ma_uint32 channels, double b0, double b1, double b2, double a0, double a1, double a2);

typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_biquad_coefficient b0;
    ma_biquad_coefficient b1;
    ma_biquad_coefficient b2;
    ma_biquad_coefficient a1;
    ma_biquad_coefficient a2;
    ma_biquad_coefficient* pR1;
    ma_biquad_coefficient* pR2;

    /* Memory management. */
    void* _pHeap;
    ma_bool32 _ownsHeap;
} ma_biquad;

MA_API ma_result ma_biquad_get_heap_size(const ma_biquad_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_biquad_init_preallocated(const ma_biquad_config* pConfig, void* pHeap, ma_biquad* pBQ);
MA_API ma_result ma_biquad_init(const ma_biquad_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_biquad* pBQ);
MA_API void ma_biquad_uninit(ma_biquad* pBQ, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_biquad_reinit(const ma_biquad_config* pConfig, ma_biquad* pBQ);
MA_API ma_result ma_biquad_clear_cache(ma_biquad* pBQ);
MA_API ma_result ma_biquad_process_pcm_frames(ma_biquad* pBQ, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_uint32 ma_biquad_get_latency(const ma_biquad* pBQ);


/**************************************************************************************************************************************************************

Low-Pass Filtering

**************************************************************************************************************************************************************/
typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
    double cutoffFrequency;
    double q;
} ma_lpf1_config, ma_lpf2_config;

MA_API ma_lpf1_config ma_lpf1_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency);
MA_API ma_lpf2_config ma_lpf2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, double q);

typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_biquad_coefficient a;
    ma_biquad_coefficient* pR1;

    /* Memory management. */
    void* _pHeap;
    ma_bool32 _ownsHeap;
} ma_lpf1;

MA_API ma_result ma_lpf1_get_heap_size(const ma_lpf1_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_lpf1_init_preallocated(const ma_lpf1_config* pConfig, void* pHeap, ma_lpf1* pLPF);
MA_API ma_result ma_lpf1_init(const ma_lpf1_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_lpf1* pLPF);
MA_API void ma_lpf1_uninit(ma_lpf1* pLPF, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_lpf1_reinit(const ma_lpf1_config* pConfig, ma_lpf1* pLPF);
MA_API ma_result ma_lpf1_clear_cache(ma_lpf1* pLPF);
MA_API ma_result ma_lpf1_process_pcm_frames(ma_lpf1* pLPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_uint32 ma_lpf1_get_latency(const ma_lpf1* pLPF);

typedef struct
{
    ma_biquad bq;   /* The second order low-pass filter is implemented as a biquad filter. */
} ma_lpf2;

MA_API ma_result ma_lpf2_get_heap_size(const ma_lpf2_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_lpf2_init_preallocated(const ma_lpf2_config* pConfig, void* pHeap, ma_lpf2* pHPF);
MA_API ma_result ma_lpf2_init(const ma_lpf2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_lpf2* pLPF);
MA_API void ma_lpf2_uninit(ma_lpf2* pLPF, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_lpf2_reinit(const ma_lpf2_config* pConfig, ma_lpf2* pLPF);
MA_API ma_result ma_lpf2_clear_cache(ma_lpf2* pLPF);
MA_API ma_result ma_lpf2_process_pcm_frames(ma_lpf2* pLPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_uint32 ma_lpf2_get_latency(const ma_lpf2* pLPF);


typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
    double cutoffFrequency;
    ma_uint32 order;    /* If set to 0, will be treated as a passthrough (no filtering will be applied). */
} ma_lpf_config;

MA_API ma_lpf_config ma_lpf_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order);

typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
    ma_uint32 lpf1Count;
    ma_uint32 lpf2Count;
    ma_lpf1* pLPF1;
    ma_lpf2* pLPF2;

    /* Memory management. */
    void* _pHeap;
    ma_bool32 _ownsHeap;
} ma_lpf;

MA_API ma_result ma_lpf_get_heap_size(const ma_lpf_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_lpf_init_preallocated(const ma_lpf_config* pConfig, void* pHeap, ma_lpf* pLPF);
MA_API ma_result ma_lpf_init(const ma_lpf_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_lpf* pLPF);
MA_API void ma_lpf_uninit(ma_lpf* pLPF, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_lpf_reinit(const ma_lpf_config* pConfig, ma_lpf* pLPF);
MA_API ma_result ma_lpf_clear_cache(ma_lpf* pLPF);
MA_API ma_result ma_lpf_process_pcm_frames(ma_lpf* pLPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_uint32 ma_lpf_get_latency(const ma_lpf* pLPF);


/**************************************************************************************************************************************************************

High-Pass Filtering

**************************************************************************************************************************************************************/
typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
    double cutoffFrequency;
    double q;
} ma_hpf1_config, ma_hpf2_config;

MA_API ma_hpf1_config ma_hpf1_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency);
MA_API ma_hpf2_config ma_hpf2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, double q);

typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_biquad_coefficient a;
    ma_biquad_coefficient* pR1;

    /* Memory management. */
    void* _pHeap;
    ma_bool32 _ownsHeap;
} ma_hpf1;

MA_API ma_result ma_hpf1_get_heap_size(const ma_hpf1_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_hpf1_init_preallocated(const ma_hpf1_config* pConfig, void* pHeap, ma_hpf1* pLPF);
MA_API ma_result ma_hpf1_init(const ma_hpf1_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hpf1* pHPF);
MA_API void ma_hpf1_uninit(ma_hpf1* pHPF, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_hpf1_reinit(const ma_hpf1_config* pConfig, ma_hpf1* pHPF);
MA_API ma_result ma_hpf1_process_pcm_frames(ma_hpf1* pHPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_uint32 ma_hpf1_get_latency(const ma_hpf1* pHPF);

typedef struct
{
    ma_biquad bq;   /* The second order high-pass filter is implemented as a biquad filter. */
} ma_hpf2;

MA_API ma_result ma_hpf2_get_heap_size(const ma_hpf2_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_hpf2_init_preallocated(const ma_hpf2_config* pConfig, void* pHeap, ma_hpf2* pHPF);
MA_API ma_result ma_hpf2_init(const ma_hpf2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hpf2* pHPF);
MA_API void ma_hpf2_uninit(ma_hpf2* pHPF, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_hpf2_reinit(const ma_hpf2_config* pConfig, ma_hpf2* pHPF);
MA_API ma_result ma_hpf2_process_pcm_frames(ma_hpf2* pHPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_uint32 ma_hpf2_get_latency(const ma_hpf2* pHPF);


typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
    double cutoffFrequency;
    ma_uint32 order;    /* If set to 0, will be treated as a passthrough (no filtering will be applied). */
} ma_hpf_config;

MA_API ma_hpf_config ma_hpf_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order);

typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
    ma_uint32 hpf1Count;
    ma_uint32 hpf2Count;
    ma_hpf1* pHPF1;
    ma_hpf2* pHPF2;

    /* Memory management. */
    void* _pHeap;
    ma_bool32 _ownsHeap;
} ma_hpf;

MA_API ma_result ma_hpf_get_heap_size(const ma_hpf_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_hpf_init_preallocated(const ma_hpf_config* pConfig, void* pHeap, ma_hpf* pLPF);
MA_API ma_result ma_hpf_init(const ma_hpf_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hpf* pHPF);
MA_API void ma_hpf_uninit(ma_hpf* pHPF, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_hpf_reinit(const ma_hpf_config* pConfig, ma_hpf* pHPF);
MA_API ma_result ma_hpf_process_pcm_frames(ma_hpf* pHPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_uint32 ma_hpf_get_latency(const ma_hpf* pHPF);


/**************************************************************************************************************************************************************

Band-Pass Filtering

**************************************************************************************************************************************************************/
typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
    double cutoffFrequency;
    double q;
} ma_bpf2_config;

MA_API ma_bpf2_config ma_bpf2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, double q);

typedef struct
{
    ma_biquad bq;   /* The second order band-pass filter is implemented as a biquad filter. */
} ma_bpf2;

MA_API ma_result ma_bpf2_get_heap_size(const ma_bpf2_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_bpf2_init_preallocated(const ma_bpf2_config* pConfig, void* pHeap, ma_bpf2* pBPF);
MA_API ma_result ma_bpf2_init(const ma_bpf2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_bpf2* pBPF);
MA_API void ma_bpf2_uninit(ma_bpf2* pBPF, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_bpf2_reinit(const ma_bpf2_config* pConfig, ma_bpf2* pBPF);
MA_API ma_result ma_bpf2_process_pcm_frames(ma_bpf2* pBPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_uint32 ma_bpf2_get_latency(const ma_bpf2* pBPF);


typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
    double cutoffFrequency;
    ma_uint32 order;    /* If set to 0, will be treated as a passthrough (no filtering will be applied). */
} ma_bpf_config;

MA_API ma_bpf_config ma_bpf_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order);

typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 bpf2Count;
    ma_bpf2* pBPF2;

    /* Memory management. */
    void* _pHeap;
    ma_bool32 _ownsHeap;
} ma_bpf;

MA_API ma_result ma_bpf_get_heap_size(const ma_bpf_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_bpf_init_preallocated(const ma_bpf_config* pConfig, void* pHeap, ma_bpf* pBPF);
MA_API ma_result ma_bpf_init(const ma_bpf_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_bpf* pBPF);
MA_API void ma_bpf_uninit(ma_bpf* pBPF, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_bpf_reinit(const ma_bpf_config* pConfig, ma_bpf* pBPF);
MA_API ma_result ma_bpf_process_pcm_frames(ma_bpf* pBPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_uint32 ma_bpf_get_latency(const ma_bpf* pBPF);


/**************************************************************************************************************************************************************

Notching Filter

**************************************************************************************************************************************************************/
typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
    double q;
    double frequency;
} ma_notch2_config, ma_notch_config;

MA_API ma_notch2_config ma_notch2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double q, double frequency);

typedef struct
{
    ma_biquad bq;
} ma_notch2;

MA_API ma_result ma_notch2_get_heap_size(const ma_notch2_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_notch2_init_preallocated(const ma_notch2_config* pConfig, void* pHeap, ma_notch2* pFilter);
MA_API ma_result ma_notch2_init(const ma_notch2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_notch2* pFilter);
MA_API void ma_notch2_uninit(ma_notch2* pFilter, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_notch2_reinit(const ma_notch2_config* pConfig, ma_notch2* pFilter);
MA_API ma_result ma_notch2_process_pcm_frames(ma_notch2* pFilter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_uint32 ma_notch2_get_latency(const ma_notch2* pFilter);


/**************************************************************************************************************************************************************

Peaking EQ Filter

**************************************************************************************************************************************************************/
typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
    double gainDB;
    double q;
    double frequency;
} ma_peak2_config, ma_peak_config;

MA_API ma_peak2_config ma_peak2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double q, double frequency);

typedef struct
{
    ma_biquad bq;
} ma_peak2;

MA_API ma_result ma_peak2_get_heap_size(const ma_peak2_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_peak2_init_preallocated(const ma_peak2_config* pConfig, void* pHeap, ma_peak2* pFilter);
MA_API ma_result ma_peak2_init(const ma_peak2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_peak2* pFilter);
MA_API void ma_peak2_uninit(ma_peak2* pFilter, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_peak2_reinit(const ma_peak2_config* pConfig, ma_peak2* pFilter);
MA_API ma_result ma_peak2_process_pcm_frames(ma_peak2* pFilter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_uint32 ma_peak2_get_latency(const ma_peak2* pFilter);


/**************************************************************************************************************************************************************

Low Shelf Filter

**************************************************************************************************************************************************************/
typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
    double gainDB;
    double shelfSlope;
    double frequency;
} ma_loshelf2_config, ma_loshelf_config;

MA_API ma_loshelf2_config ma_loshelf2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double shelfSlope, double frequency);

typedef struct
{
    ma_biquad bq;
} ma_loshelf2;

MA_API ma_result ma_loshelf2_get_heap_size(const ma_loshelf2_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_loshelf2_init_preallocated(const ma_loshelf2_config* pConfig, void* pHeap, ma_loshelf2* pFilter);
MA_API ma_result ma_loshelf2_init(const ma_loshelf2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_loshelf2* pFilter);
MA_API void ma_loshelf2_uninit(ma_loshelf2* pFilter, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_loshelf2_reinit(const ma_loshelf2_config* pConfig, ma_loshelf2* pFilter);
MA_API ma_result ma_loshelf2_process_pcm_frames(ma_loshelf2* pFilter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_uint32 ma_loshelf2_get_latency(const ma_loshelf2* pFilter);


/**************************************************************************************************************************************************************

High Shelf Filter

**************************************************************************************************************************************************************/
typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
    double gainDB;
    double shelfSlope;
    double frequency;
} ma_hishelf2_config, ma_hishelf_config;

MA_API ma_hishelf2_config ma_hishelf2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double shelfSlope, double frequency);

typedef struct
{
    ma_biquad bq;
} ma_hishelf2;

MA_API ma_result ma_hishelf2_get_heap_size(const ma_hishelf2_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_hishelf2_init_preallocated(const ma_hishelf2_config* pConfig, void* pHeap, ma_hishelf2* pFilter);
MA_API ma_result ma_hishelf2_init(const ma_hishelf2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hishelf2* pFilter);
MA_API void ma_hishelf2_uninit(ma_hishelf2* pFilter, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_hishelf2_reinit(const ma_hishelf2_config* pConfig, ma_hishelf2* pFilter);
MA_API ma_result ma_hishelf2_process_pcm_frames(ma_hishelf2* pFilter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_uint32 ma_hishelf2_get_latency(const ma_hishelf2* pFilter);



/*
Delay
*/
typedef struct
{
    ma_uint32 channels;
    ma_uint32 sampleRate;
    ma_uint32 delayInFrames;
    ma_bool32 delayStart;       /* Set to true to delay the start of the output; false otherwise. */
    float wet;                  /* 0..1. Default = 1. */
    float dry;                  /* 0..1. Default = 1. */
    float decay;                /* 0..1. Default = 0 (no feedback). Feedback decay. Use this for echo. */
} ma_delay_config;

MA_API ma_delay_config ma_delay_config_init(ma_uint32 channels, ma_uint32 sampleRate, ma_uint32 delayInFrames, float decay);


typedef struct
{
    ma_delay_config config;
    ma_uint32 cursor;               /* Feedback is written to this cursor. Always equal or in front of the read cursor. */
    ma_uint32 bufferSizeInFrames;
    float* pBuffer;
} ma_delay;

MA_API ma_result ma_delay_init(const ma_delay_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_delay* pDelay);
MA_API void ma_delay_uninit(ma_delay* pDelay, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_delay_process_pcm_frames(ma_delay* pDelay, void* pFramesOut, const void* pFramesIn, ma_uint32 frameCount);
MA_API void ma_delay_set_wet(ma_delay* pDelay, float value);
MA_API float ma_delay_get_wet(const ma_delay* pDelay);
MA_API void ma_delay_set_dry(ma_delay* pDelay, float value);
MA_API float ma_delay_get_dry(const ma_delay* pDelay);
MA_API void ma_delay_set_decay(ma_delay* pDelay, float value);
MA_API float ma_delay_get_decay(const ma_delay* pDelay);


/* Gainer for smooth volume changes. */
typedef struct
{
    ma_uint32 channels;
    ma_uint32 smoothTimeInFrames;
} ma_gainer_config;

MA_API ma_gainer_config ma_gainer_config_init(ma_uint32 channels, ma_uint32 smoothTimeInFrames);


typedef struct
{
    ma_gainer_config config;
    ma_uint32 t;
    float masterVolume;
    float* pOldGains;
    float* pNewGains;

    /* Memory management. */
    void* _pHeap;
    ma_bool32 _ownsHeap;
} ma_gainer;

MA_API ma_result ma_gainer_get_heap_size(const ma_gainer_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_gainer_init_preallocated(const ma_gainer_config* pConfig, void* pHeap, ma_gainer* pGainer);
MA_API ma_result ma_gainer_init(const ma_gainer_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_gainer* pGainer);
MA_API void ma_gainer_uninit(ma_gainer* pGainer, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_gainer_process_pcm_frames(ma_gainer* pGainer, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_result ma_gainer_set_gain(ma_gainer* pGainer, float newGain);
MA_API ma_result ma_gainer_set_gains(ma_gainer* pGainer, float* pNewGains);
MA_API ma_result ma_gainer_set_master_volume(ma_gainer* pGainer, float volume);
MA_API ma_result ma_gainer_get_master_volume(const ma_gainer* pGainer, float* pVolume);



/* Stereo panner. */
typedef enum
{
    ma_pan_mode_balance = 0,    /* Does not blend one side with the other. Technically just a balance. Compatible with other popular audio engines and therefore the default. */
    ma_pan_mode_pan             /* A true pan. The sound from one side will "move" to the other side and blend with it. */
} ma_pan_mode;

typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_pan_mode mode;
    float pan;
} ma_panner_config;

MA_API ma_panner_config ma_panner_config_init(ma_format format, ma_uint32 channels);


typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_pan_mode mode;
    float pan;  /* -1..1 where 0 is no pan, -1 is left side, +1 is right side. Defaults to 0. */
} ma_panner;

MA_API ma_result ma_panner_init(const ma_panner_config* pConfig, ma_panner* pPanner);
MA_API ma_result ma_panner_process_pcm_frames(ma_panner* pPanner, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API void ma_panner_set_mode(ma_panner* pPanner, ma_pan_mode mode);
MA_API ma_pan_mode ma_panner_get_mode(const ma_panner* pPanner);
MA_API void ma_panner_set_pan(ma_panner* pPanner, float pan);
MA_API float ma_panner_get_pan(const ma_panner* pPanner);



/* Fader. */
typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
} ma_fader_config;

MA_API ma_fader_config ma_fader_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate);

typedef struct
{
    ma_fader_config config;
    float volumeBeg;            /* If volumeBeg and volumeEnd is equal to 1, no fading happens (ma_fader_process_pcm_frames() will run as a passthrough). */
    float volumeEnd;
    ma_uint64 lengthInFrames;   /* The total length of the fade. */
    ma_int64  cursorInFrames;   /* The current time in frames. Incremented by ma_fader_process_pcm_frames(). Signed because it'll be offset by startOffsetInFrames in set_fade_ex(). */
} ma_fader;

MA_API ma_result ma_fader_init(const ma_fader_config* pConfig, ma_fader* pFader);
MA_API ma_result ma_fader_process_pcm_frames(ma_fader* pFader, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API void ma_fader_get_data_format(const ma_fader* pFader, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate);
MA_API void ma_fader_set_fade(ma_fader* pFader, float volumeBeg, float volumeEnd, ma_uint64 lengthInFrames);
MA_API void ma_fader_set_fade_ex(ma_fader* pFader, float volumeBeg, float volumeEnd, ma_uint64 lengthInFrames, ma_int64 startOffsetInFrames);
MA_API float ma_fader_get_current_volume(const ma_fader* pFader);



/* Spatializer. */
typedef struct
{
    float x;
    float y;
    float z;
} ma_vec3f;

typedef struct
{
    ma_vec3f v;
    ma_spinlock lock;
} ma_atomic_vec3f;

typedef enum
{
    ma_attenuation_model_none,          /* No distance attenuation and no spatialization. */
    ma_attenuation_model_inverse,       /* Equivalent to OpenAL's AL_INVERSE_DISTANCE_CLAMPED. */
    ma_attenuation_model_linear,        /* Linear attenuation. Equivalent to OpenAL's AL_LINEAR_DISTANCE_CLAMPED. */
    ma_attenuation_model_exponential    /* Exponential attenuation. Equivalent to OpenAL's AL_EXPONENT_DISTANCE_CLAMPED. */
} ma_attenuation_model;

typedef enum
{
    ma_positioning_absolute,
    ma_positioning_relative
} ma_positioning;

typedef enum
{
    ma_handedness_right,
    ma_handedness_left
} ma_handedness;


typedef struct
{
    ma_uint32 channelsOut;
    ma_channel* pChannelMapOut;
    ma_handedness handedness;   /* Defaults to right. Forward is -1 on the Z axis. In a left handed system, forward is +1 on the Z axis. */
    float coneInnerAngleInRadians;
    float coneOuterAngleInRadians;
    float coneOuterGain;
    float speedOfSound;
    ma_vec3f worldUp;
} ma_spatializer_listener_config;

MA_API ma_spatializer_listener_config ma_spatializer_listener_config_init(ma_uint32 channelsOut);


typedef struct
{
    ma_spatializer_listener_config config;
    ma_atomic_vec3f position;  /* The absolute position of the listener. */
    ma_atomic_vec3f direction; /* The direction the listener is facing. The world up vector is config.worldUp. */
    ma_atomic_vec3f velocity;
    ma_bool32 isEnabled;

    /* Memory management. */
    ma_bool32 _ownsHeap;
    void* _pHeap;
} ma_spatializer_listener;

MA_API ma_result ma_spatializer_listener_get_heap_size(const ma_spatializer_listener_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_spatializer_listener_init_preallocated(const ma_spatializer_listener_config* pConfig, void* pHeap, ma_spatializer_listener* pListener);
MA_API ma_result ma_spatializer_listener_init(const ma_spatializer_listener_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_spatializer_listener* pListener);
MA_API void ma_spatializer_listener_uninit(ma_spatializer_listener* pListener, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_channel* ma_spatializer_listener_get_channel_map(ma_spatializer_listener* pListener);
MA_API void ma_spatializer_listener_set_cone(ma_spatializer_listener* pListener, float innerAngleInRadians, float outerAngleInRadians, float outerGain);
MA_API void ma_spatializer_listener_get_cone(const ma_spatializer_listener* pListener, float* pInnerAngleInRadians, float* pOuterAngleInRadians, float* pOuterGain);
MA_API void ma_spatializer_listener_set_position(ma_spatializer_listener* pListener, float x, float y, float z);
MA_API ma_vec3f ma_spatializer_listener_get_position(const ma_spatializer_listener* pListener);
MA_API void ma_spatializer_listener_set_direction(ma_spatializer_listener* pListener, float x, float y, float z);
MA_API ma_vec3f ma_spatializer_listener_get_direction(const ma_spatializer_listener* pListener);
MA_API void ma_spatializer_listener_set_velocity(ma_spatializer_listener* pListener, float x, float y, float z);
MA_API ma_vec3f ma_spatializer_listener_get_velocity(const ma_spatializer_listener* pListener);
MA_API void ma_spatializer_listener_set_speed_of_sound(ma_spatializer_listener* pListener, float speedOfSound);
MA_API float ma_spatializer_listener_get_speed_of_sound(const ma_spatializer_listener* pListener);
MA_API void ma_spatializer_listener_set_world_up(ma_spatializer_listener* pListener, float x, float y, float z);
MA_API ma_vec3f ma_spatializer_listener_get_world_up(const ma_spatializer_listener* pListener);
MA_API void ma_spatializer_listener_set_enabled(ma_spatializer_listener* pListener, ma_bool32 isEnabled);
MA_API ma_bool32 ma_spatializer_listener_is_enabled(const ma_spatializer_listener* pListener);


typedef struct
{
    ma_uint32 channelsIn;
    ma_uint32 channelsOut;
    ma_channel* pChannelMapIn;
    ma_attenuation_model attenuationModel;
    ma_positioning positioning;
    ma_handedness handedness;           /* Defaults to right. Forward is -1 on the Z axis. In a left handed system, forward is +1 on the Z axis. */
    float minGain;
    float maxGain;
    float minDistance;
    float maxDistance;
    float rolloff;
    float coneInnerAngleInRadians;
    float coneOuterAngleInRadians;
    float coneOuterGain;
    float dopplerFactor;                /* Set to 0 to disable doppler effect. */
    float directionalAttenuationFactor; /* Set to 0 to disable directional attenuation. */
    float minSpatializationChannelGain; /* The minimal scaling factor to apply to channel gains when accounting for the direction of the sound relative to the listener. Must be in the range of 0..1. Smaller values means more aggressive directional panning, larger values means more subtle directional panning. */
    ma_uint32 gainSmoothTimeInFrames;   /* When the gain of a channel changes during spatialization, the transition will be linearly interpolated over this number of frames. */
} ma_spatializer_config;

MA_API ma_spatializer_config ma_spatializer_config_init(ma_uint32 channelsIn, ma_uint32 channelsOut);


typedef struct
{
    ma_uint32 channelsIn;
    ma_uint32 channelsOut;
    ma_channel* pChannelMapIn;
    ma_attenuation_model attenuationModel;
    ma_positioning positioning;
    ma_handedness handedness;           /* Defaults to right. Forward is -1 on the Z axis. In a left handed system, forward is +1 on the Z axis. */
    float minGain;
    float maxGain;
    float minDistance;
    float maxDistance;
    float rolloff;
    float coneInnerAngleInRadians;
    float coneOuterAngleInRadians;
    float coneOuterGain;
    float dopplerFactor;                /* Set to 0 to disable doppler effect. */
    float directionalAttenuationFactor; /* Set to 0 to disable directional attenuation. */
    ma_uint32 gainSmoothTimeInFrames;   /* When the gain of a channel changes during spatialization, the transition will be linearly interpolated over this number of frames. */
    ma_atomic_vec3f position;
    ma_atomic_vec3f direction;
    ma_atomic_vec3f velocity;  /* For doppler effect. */
    float dopplerPitch; /* Will be updated by ma_spatializer_process_pcm_frames() and can be used by higher level functions to apply a pitch shift for doppler effect. */
    float minSpatializationChannelGain;
    ma_gainer gainer;   /* For smooth gain transitions. */
    float* pNewChannelGainsOut; /* An offset of _pHeap. Used by ma_spatializer_process_pcm_frames() to store new channel gains. The number of elements in this array is equal to config.channelsOut. */

    /* Memory management. */
    void* _pHeap;
    ma_bool32 _ownsHeap;
} ma_spatializer;

MA_API ma_result ma_spatializer_get_heap_size(const ma_spatializer_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_spatializer_init_preallocated(const ma_spatializer_config* pConfig, void* pHeap, ma_spatializer* pSpatializer);
MA_API ma_result ma_spatializer_init(const ma_spatializer_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_spatializer* pSpatializer);
MA_API void ma_spatializer_uninit(ma_spatializer* pSpatializer, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_spatializer_process_pcm_frames(ma_spatializer* pSpatializer, ma_spatializer_listener* pListener, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_result ma_spatializer_set_master_volume(ma_spatializer* pSpatializer, float volume);
MA_API ma_result ma_spatializer_get_master_volume(const ma_spatializer* pSpatializer, float* pVolume);
MA_API ma_uint32 ma_spatializer_get_input_channels(const ma_spatializer* pSpatializer);
MA_API ma_uint32 ma_spatializer_get_output_channels(const ma_spatializer* pSpatializer);
MA_API void ma_spatializer_set_attenuation_model(ma_spatializer* pSpatializer, ma_attenuation_model attenuationModel);
MA_API ma_attenuation_model ma_spatializer_get_attenuation_model(const ma_spatializer* pSpatializer);
MA_API void ma_spatializer_set_positioning(ma_spatializer* pSpatializer, ma_positioning positioning);
MA_API ma_positioning ma_spatializer_get_positioning(const ma_spatializer* pSpatializer);
MA_API void ma_spatializer_set_rolloff(ma_spatializer* pSpatializer, float rolloff);
MA_API float ma_spatializer_get_rolloff(const ma_spatializer* pSpatializer);
MA_API void ma_spatializer_set_min_gain(ma_spatializer* pSpatializer, float minGain);
MA_API float ma_spatializer_get_min_gain(const ma_spatializer* pSpatializer);
MA_API void ma_spatializer_set_max_gain(ma_spatializer* pSpatializer, float maxGain);
MA_API float ma_spatializer_get_max_gain(const ma_spatializer* pSpatializer);
MA_API void ma_spatializer_set_min_distance(ma_spatializer* pSpatializer, float minDistance);
MA_API float ma_spatializer_get_min_distance(const ma_spatializer* pSpatializer);
MA_API void ma_spatializer_set_max_distance(ma_spatializer* pSpatializer, float maxDistance);
MA_API float ma_spatializer_get_max_distance(const ma_spatializer* pSpatializer);
MA_API void ma_spatializer_set_cone(ma_spatializer* pSpatializer, float innerAngleInRadians, float outerAngleInRadians, float outerGain);
MA_API void ma_spatializer_get_cone(const ma_spatializer* pSpatializer, float* pInnerAngleInRadians, float* pOuterAngleInRadians, float* pOuterGain);
MA_API void ma_spatializer_set_doppler_factor(ma_spatializer* pSpatializer, float dopplerFactor);
MA_API float ma_spatializer_get_doppler_factor(const ma_spatializer* pSpatializer);
MA_API void ma_spatializer_set_directional_attenuation_factor(ma_spatializer* pSpatializer, float directionalAttenuationFactor);
MA_API float ma_spatializer_get_directional_attenuation_factor(const ma_spatializer* pSpatializer);
MA_API void ma_spatializer_set_position(ma_spatializer* pSpatializer, float x, float y, float z);
MA_API ma_vec3f ma_spatializer_get_position(const ma_spatializer* pSpatializer);
MA_API void ma_spatializer_set_direction(ma_spatializer* pSpatializer, float x, float y, float z);
MA_API ma_vec3f ma_spatializer_get_direction(const ma_spatializer* pSpatializer);
MA_API void ma_spatializer_set_velocity(ma_spatializer* pSpatializer, float x, float y, float z);
MA_API ma_vec3f ma_spatializer_get_velocity(const ma_spatializer* pSpatializer);
MA_API void ma_spatializer_get_relative_position_and_direction(const ma_spatializer* pSpatializer, const ma_spatializer_listener* pListener, ma_vec3f* pRelativePos, ma_vec3f* pRelativeDir);



/************************************************************************************************************************************************************
*************************************************************************************************************************************************************

DATA CONVERSION
===============

This section contains the APIs for data conversion. You will find everything here for channel mapping, sample format conversion, resampling, etc.

*************************************************************************************************************************************************************
************************************************************************************************************************************************************/

/**************************************************************************************************************************************************************

Resampling

**************************************************************************************************************************************************************/
typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRateIn;
    ma_uint32 sampleRateOut;
    ma_uint32 lpfOrder;         /* The low-pass filter order. Setting this to 0 will disable low-pass filtering. */
    double    lpfNyquistFactor; /* 0..1. Defaults to 1. 1 = Half the sampling frequency (Nyquist Frequency), 0.5 = Quarter the sampling frequency (half Nyquest Frequency), etc. */
} ma_linear_resampler_config;

MA_API ma_linear_resampler_config ma_linear_resampler_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut);

typedef struct
{
    ma_linear_resampler_config config;
    ma_uint32 inAdvanceInt;
    ma_uint32 inAdvanceFrac;
    ma_uint32 inTimeInt;
    ma_uint32 inTimeFrac;
    union
    {
        float* f32;
        ma_int16* s16;
    } x0; /* The previous input frame. */
    union
    {
        float* f32;
        ma_int16* s16;
    } x1; /* The next input frame. */
    ma_lpf lpf;

    /* Memory management. */
    void* _pHeap;
    ma_bool32 _ownsHeap;
} ma_linear_resampler;

MA_API ma_result ma_linear_resampler_get_heap_size(const ma_linear_resampler_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_linear_resampler_init_preallocated(const ma_linear_resampler_config* pConfig, void* pHeap, ma_linear_resampler* pResampler);
MA_API ma_result ma_linear_resampler_init(const ma_linear_resampler_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_linear_resampler* pResampler);
MA_API void ma_linear_resampler_uninit(ma_linear_resampler* pResampler, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_linear_resampler_process_pcm_frames(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut);
MA_API ma_result ma_linear_resampler_set_rate(ma_linear_resampler* pResampler, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut);
MA_API ma_result ma_linear_resampler_set_rate_ratio(ma_linear_resampler* pResampler, float ratioInOut);
MA_API ma_uint64 ma_linear_resampler_get_input_latency(const ma_linear_resampler* pResampler);
MA_API ma_uint64 ma_linear_resampler_get_output_latency(const ma_linear_resampler* pResampler);
MA_API ma_result ma_linear_resampler_get_required_input_frame_count(const ma_linear_resampler* pResampler, ma_uint64 outputFrameCount, ma_uint64* pInputFrameCount);
MA_API ma_result ma_linear_resampler_get_expected_output_frame_count(const ma_linear_resampler* pResampler, ma_uint64 inputFrameCount, ma_uint64* pOutputFrameCount);
MA_API ma_result ma_linear_resampler_reset(ma_linear_resampler* pResampler);


typedef struct ma_resampler_config ma_resampler_config;

typedef void ma_resampling_backend;
typedef struct
{
    ma_result (* onGetHeapSize                )(void* pUserData, const ma_resampler_config* pConfig, size_t* pHeapSizeInBytes);
    ma_result (* onInit                       )(void* pUserData, const ma_resampler_config* pConfig, void* pHeap, ma_resampling_backend** ppBackend);
    void      (* onUninit                     )(void* pUserData, ma_resampling_backend* pBackend, const ma_allocation_callbacks* pAllocationCallbacks);
    ma_result (* onProcess                    )(void* pUserData, ma_resampling_backend* pBackend, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut);
    ma_result (* onSetRate                    )(void* pUserData, ma_resampling_backend* pBackend, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut);                 /* Optional. Rate changes will be disabled. */
    ma_uint64 (* onGetInputLatency            )(void* pUserData, const ma_resampling_backend* pBackend);                                                            /* Optional. Latency will be reported as 0. */
    ma_uint64 (* onGetOutputLatency           )(void* pUserData, const ma_resampling_backend* pBackend);                                                            /* Optional. Latency will be reported as 0. */
    ma_result (* onGetRequiredInputFrameCount )(void* pUserData, const ma_resampling_backend* pBackend, ma_uint64 outputFrameCount, ma_uint64* pInputFrameCount);   /* Optional. Latency mitigation will be disabled. */
    ma_result (* onGetExpectedOutputFrameCount)(void* pUserData, const ma_resampling_backend* pBackend, ma_uint64 inputFrameCount, ma_uint64* pOutputFrameCount);   /* Optional. Latency mitigation will be disabled. */
    ma_result (* onReset                      )(void* pUserData, ma_resampling_backend* pBackend);
} ma_resampling_backend_vtable;

typedef enum
{
    ma_resample_algorithm_linear = 0,    /* Fastest, lowest quality. Optional low-pass filtering. Default. */
    ma_resample_algorithm_custom,
} ma_resample_algorithm;

struct ma_resampler_config
{
    ma_format format;   /* Must be either ma_format_f32 or ma_format_s16. */
    ma_uint32 channels;
    ma_uint32 sampleRateIn;
    ma_uint32 sampleRateOut;
    ma_resample_algorithm algorithm;    /* When set to ma_resample_algorithm_custom, pBackendVTable will be used. */
    ma_resampling_backend_vtable* pBackendVTable;
    void* pBackendUserData;
    struct
    {
        ma_uint32 lpfOrder;
    } linear;
};

MA_API ma_resampler_config ma_resampler_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut, ma_resample_algorithm algorithm);

typedef struct
{
    ma_resampling_backend* pBackend;
    ma_resampling_backend_vtable* pBackendVTable;
    void* pBackendUserData;
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRateIn;
    ma_uint32 sampleRateOut;
    union
    {
        ma_linear_resampler linear;
    } state;    /* State for stock resamplers so we can avoid a malloc. For stock resamplers, pBackend will point here. */

    /* Memory management. */
    void* _pHeap;
    ma_bool32 _ownsHeap;
} ma_resampler;

MA_API ma_result ma_resampler_get_heap_size(const ma_resampler_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_resampler_init_preallocated(const ma_resampler_config* pConfig, void* pHeap, ma_resampler* pResampler);

/*
Initializes a new resampler object from a config.
*/
MA_API ma_result ma_resampler_init(const ma_resampler_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_resampler* pResampler);

/*
Uninitializes a resampler.
*/
MA_API void ma_resampler_uninit(ma_resampler* pResampler, const ma_allocation_callbacks* pAllocationCallbacks);

/*
Converts the given input data.

Both the input and output frames must be in the format specified in the config when the resampler was initialized.

On input, [pFrameCountOut] contains the number of output frames to process. On output it contains the number of output frames that
were actually processed, which may be less than the requested amount which will happen if there's not enough input data. You can use
ma_resampler_get_expected_output_frame_count() to know how many output frames will be processed for a given number of input frames.

On input, [pFrameCountIn] contains the number of input frames contained in [pFramesIn]. On output it contains the number of whole
input frames that were actually processed. You can use ma_resampler_get_required_input_frame_count() to know how many input frames
you should provide for a given number of output frames. [pFramesIn] can be NULL, in which case zeroes will be used instead.

If [pFramesOut] is NULL, a seek is performed. In this case, if [pFrameCountOut] is not NULL it will seek by the specified number of
output frames. Otherwise, if [pFramesCountOut] is NULL and [pFrameCountIn] is not NULL, it will seek by the specified number of input
frames. When seeking, [pFramesIn] is allowed to NULL, in which case the internal timing state will be updated, but no input will be
processed. In this case, any internal filter state will be updated as if zeroes were passed in.

It is an error for [pFramesOut] to be non-NULL and [pFrameCountOut] to be NULL.

It is an error for both [pFrameCountOut] and [pFrameCountIn] to be NULL.
*/
MA_API ma_result ma_resampler_process_pcm_frames(ma_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut);


/*
Sets the input and output sample rate.
*/
MA_API ma_result ma_resampler_set_rate(ma_resampler* pResampler, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut);

/*
Sets the input and output sample rate as a ratio.

The ration is in/out.
*/
MA_API ma_result ma_resampler_set_rate_ratio(ma_resampler* pResampler, float ratio);

/*
Retrieves the latency introduced by the resampler in input frames.
*/
MA_API ma_uint64 ma_resampler_get_input_latency(const ma_resampler* pResampler);

/*
Retrieves the latency introduced by the resampler in output frames.
*/
MA_API ma_uint64 ma_resampler_get_output_latency(const ma_resampler* pResampler);

/*
Calculates the number of whole input frames that would need to be read from the client in order to output the specified
number of output frames.

The returned value does not include cached input frames. It only returns the number of extra frames that would need to be
read from the input buffer in order to output the specified number of output frames.
*/
MA_API ma_result ma_resampler_get_required_input_frame_count(const ma_resampler* pResampler, ma_uint64 outputFrameCount, ma_uint64* pInputFrameCount);

/*
Calculates the number of whole output frames that would be output after fully reading and consuming the specified number of
input frames.
*/
MA_API ma_result ma_resampler_get_expected_output_frame_count(const ma_resampler* pResampler, ma_uint64 inputFrameCount, ma_uint64* pOutputFrameCount);

/*
Resets the resampler's timer and clears its internal cache.
*/
MA_API ma_result ma_resampler_reset(ma_resampler* pResampler);


/**************************************************************************************************************************************************************

Channel Conversion

**************************************************************************************************************************************************************/
typedef enum
{
    ma_channel_conversion_path_unknown,
    ma_channel_conversion_path_passthrough,
    ma_channel_conversion_path_mono_out,    /* Converting to mono. */
    ma_channel_conversion_path_mono_in,     /* Converting from mono. */
    ma_channel_conversion_path_shuffle,     /* Simple shuffle. Will use this when all channels are present in both input and output channel maps, but just in a different order. */
    ma_channel_conversion_path_weights      /* Blended based on weights. */
} ma_channel_conversion_path;

typedef enum
{
    ma_mono_expansion_mode_duplicate = 0,   /* The default. */
    ma_mono_expansion_mode_average,         /* Average the mono channel across all channels. */
    ma_mono_expansion_mode_stereo_only,     /* Duplicate to the left and right channels only and ignore the others. */
    ma_mono_expansion_mode_default = ma_mono_expansion_mode_duplicate
} ma_mono_expansion_mode;

typedef struct
{
    ma_format format;
    ma_uint32 channelsIn;
    ma_uint32 channelsOut;
    const ma_channel* pChannelMapIn;
    const ma_channel* pChannelMapOut;
    ma_channel_mix_mode mixingMode;
    ma_bool32 calculateLFEFromSpatialChannels;  /* When an output LFE channel is present, but no input LFE, set to true to set the output LFE to the average of all spatial channels (LR, FR, etc.). Ignored when an input LFE is present. */
    float** ppWeights;  /* [in][out]. Only used when mixingMode is set to ma_channel_mix_mode_custom_weights. */
} ma_channel_converter_config;

MA_API ma_channel_converter_config ma_channel_converter_config_init(ma_format format, ma_uint32 channelsIn, const ma_channel* pChannelMapIn, ma_uint32 channelsOut, const ma_channel* pChannelMapOut, ma_channel_mix_mode mixingMode);

typedef struct
{
    ma_format format;
    ma_uint32 channelsIn;
    ma_uint32 channelsOut;
    ma_channel_mix_mode mixingMode;
    ma_channel_conversion_path conversionPath;
    ma_channel* pChannelMapIn;
    ma_channel* pChannelMapOut;
    ma_uint8* pShuffleTable;    /* Indexed by output channel index. */
    union
    {
        float**    f32;
        ma_int32** s16;
    } weights;  /* [in][out] */

    /* Memory management. */
    void* _pHeap;
    ma_bool32 _ownsHeap;
} ma_channel_converter;

MA_API ma_result ma_channel_converter_get_heap_size(const ma_channel_converter_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_channel_converter_init_preallocated(const ma_channel_converter_config* pConfig, void* pHeap, ma_channel_converter* pConverter);
MA_API ma_result ma_channel_converter_init(const ma_channel_converter_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_channel_converter* pConverter);
MA_API void ma_channel_converter_uninit(ma_channel_converter* pConverter, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_channel_converter_process_pcm_frames(ma_channel_converter* pConverter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
MA_API ma_result ma_channel_converter_get_input_channel_map(const ma_channel_converter* pConverter, ma_channel* pChannelMap, size_t channelMapCap);
MA_API ma_result ma_channel_converter_get_output_channel_map(const ma_channel_converter* pConverter, ma_channel* pChannelMap, size_t channelMapCap);


/**************************************************************************************************************************************************************

Data Conversion

**************************************************************************************************************************************************************/
typedef struct
{
    ma_format formatIn;
    ma_format formatOut;
    ma_uint32 channelsIn;
    ma_uint32 channelsOut;
    ma_uint32 sampleRateIn;
    ma_uint32 sampleRateOut;
    ma_channel* pChannelMapIn;
    ma_channel* pChannelMapOut;
    ma_dither_mode ditherMode;
    ma_channel_mix_mode channelMixMode;
    ma_bool32 calculateLFEFromSpatialChannels;  /* When an output LFE channel is present, but no input LFE, set to true to set the output LFE to the average of all spatial channels (LR, FR, etc.). Ignored when an input LFE is present. */
    float** ppChannelWeights;  /* [in][out]. Only used when mixingMode is set to ma_channel_mix_mode_custom_weights. */
    ma_bool32 allowDynamicSampleRate;
    ma_resampler_config resampling;
} ma_data_converter_config;

MA_API ma_data_converter_config ma_data_converter_config_init_default(void);
MA_API ma_data_converter_config ma_data_converter_config_init(ma_format formatIn, ma_format formatOut, ma_uint32 channelsIn, ma_uint32 channelsOut, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut);


typedef enum
{
    ma_data_converter_execution_path_passthrough,       /* No conversion. */
    ma_data_converter_execution_path_format_only,       /* Only format conversion. */
    ma_data_converter_execution_path_channels_only,     /* Only channel conversion. */
    ma_data_converter_execution_path_resample_only,     /* Only resampling. */
    ma_data_converter_execution_path_resample_first,    /* All conversions, but resample as the first step. */
    ma_data_converter_execution_path_channels_first     /* All conversions, but channels as the first step. */
} ma_data_converter_execution_path;

typedef struct
{
    ma_format formatIn;
    ma_format formatOut;
    ma_uint32 channelsIn;
    ma_uint32 channelsOut;
    ma_uint32 sampleRateIn;
    ma_uint32 sampleRateOut;
    ma_dither_mode ditherMode;
    ma_data_converter_execution_path executionPath; /* The execution path the data converter will follow when processing. */
    ma_channel_converter channelConverter;
    ma_resampler resampler;
    ma_bool8 hasPreFormatConversion;
    ma_bool8 hasPostFormatConversion;
    ma_bool8 hasChannelConverter;
    ma_bool8 hasResampler;
    ma_bool8 isPassthrough;

    /* Memory management. */
    ma_bool8 _ownsHeap;
    void* _pHeap;
} ma_data_converter;

MA_API ma_result ma_data_converter_get_heap_size(const ma_data_converter_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_data_converter_init_preallocated(const ma_data_converter_config* pConfig, void* pHeap, ma_data_converter* pConverter);
MA_API ma_result ma_data_converter_init(const ma_data_converter_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_data_converter* pConverter);
MA_API void ma_data_converter_uninit(ma_data_converter* pConverter, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_data_converter_process_pcm_frames(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut);
MA_API ma_result ma_data_converter_set_rate(ma_data_converter* pConverter, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut);
MA_API ma_result ma_data_converter_set_rate_ratio(ma_data_converter* pConverter, float ratioInOut);
MA_API ma_uint64 ma_data_converter_get_input_latency(const ma_data_converter* pConverter);
MA_API ma_uint64 ma_data_converter_get_output_latency(const ma_data_converter* pConverter);
MA_API ma_result ma_data_converter_get_required_input_frame_count(const ma_data_converter* pConverter, ma_uint64 outputFrameCount, ma_uint64* pInputFrameCount);
MA_API ma_result ma_data_converter_get_expected_output_frame_count(const ma_data_converter* pConverter, ma_uint64 inputFrameCount, ma_uint64* pOutputFrameCount);
MA_API ma_result ma_data_converter_get_input_channel_map(const ma_data_converter* pConverter, ma_channel* pChannelMap, size_t channelMapCap);
MA_API ma_result ma_data_converter_get_output_channel_map(const ma_data_converter* pConverter, ma_channel* pChannelMap, size_t channelMapCap);
MA_API ma_result ma_data_converter_reset(ma_data_converter* pConverter);


/************************************************************************************************************************************************************

Format Conversion

************************************************************************************************************************************************************/
MA_API void ma_pcm_u8_to_s16(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_u8_to_s24(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_u8_to_s32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_u8_to_f32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_s16_to_u8(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_s16_to_s24(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_s16_to_s32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_s16_to_f32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_s24_to_u8(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_s24_to_s16(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_s24_to_s32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_s24_to_f32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_s32_to_u8(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_s32_to_s16(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_s32_to_s24(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_s32_to_f32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_f32_to_u8(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_f32_to_s16(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_f32_to_s24(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_f32_to_s32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
MA_API void ma_pcm_convert(void* pOut, ma_format formatOut, const void* pIn, ma_format formatIn, ma_uint64 sampleCount, ma_dither_mode ditherMode);
MA_API void ma_convert_pcm_frames_format(void* pOut, ma_format formatOut, const void* pIn, ma_format formatIn, ma_uint64 frameCount, ma_uint32 channels, ma_dither_mode ditherMode);

/*
Deinterleaves an interleaved buffer.
*/
MA_API void ma_deinterleave_pcm_frames(ma_format format, ma_uint32 channels, ma_uint64 frameCount, const void* pInterleavedPCMFrames, void** ppDeinterleavedPCMFrames);

/*
Interleaves a group of deinterleaved buffers.
*/
MA_API void ma_interleave_pcm_frames(ma_format format, ma_uint32 channels, ma_uint64 frameCount, const void** ppDeinterleavedPCMFrames, void* pInterleavedPCMFrames);


/************************************************************************************************************************************************************

Channel Maps

************************************************************************************************************************************************************/
/*
This is used in the shuffle table to indicate that the channel index is undefined and should be ignored.
*/
#define MA_CHANNEL_INDEX_NULL   255

/*
Retrieves the channel position of the specified channel in the given channel map.

The pChannelMap parameter can be null, in which case miniaudio's default channel map will be assumed.
*/
MA_API ma_channel ma_channel_map_get_channel(const ma_channel* pChannelMap, ma_uint32 channelCount, ma_uint32 channelIndex);

/*
Initializes a blank channel map.

When a blank channel map is specified anywhere it indicates that the native channel map should be used.
*/
MA_API void ma_channel_map_init_blank(ma_channel* pChannelMap, ma_uint32 channels);

/*
Helper for retrieving a standard channel map.

The output channel map buffer must have a capacity of at least `channelMapCap`.
*/
MA_API void ma_channel_map_init_standard(ma_standard_channel_map standardChannelMap, ma_channel* pChannelMap, size_t channelMapCap, ma_uint32 channels);

/*
Copies a channel map.

Both input and output channel map buffers must have a capacity of at least `channels`.
*/
MA_API void ma_channel_map_copy(ma_channel* pOut, const ma_channel* pIn, ma_uint32 channels);

/*
Copies a channel map if one is specified, otherwise copies the default channel map.

The output buffer must have a capacity of at least `channels`. If not NULL, the input channel map must also have a capacity of at least `channels`.
*/
MA_API void ma_channel_map_copy_or_default(ma_channel* pOut, size_t channelMapCapOut, const ma_channel* pIn, ma_uint32 channels);


/*
Determines whether or not a channel map is valid.

A blank channel map is valid (all channels set to MA_CHANNEL_NONE). The way a blank channel map is handled is context specific, but
is usually treated as a passthrough.

Invalid channel maps:
  - A channel map with no channels
  - A channel map with more than one channel and a mono channel

The channel map buffer must have a capacity of at least `channels`.
*/
MA_API ma_bool32 ma_channel_map_is_valid(const ma_channel* pChannelMap, ma_uint32 channels);

/*
Helper for comparing two channel maps for equality.

This assumes the channel count is the same between the two.

Both channels map buffers must have a capacity of at least `channels`.
*/
MA_API ma_bool32 ma_channel_map_is_equal(const ma_channel* pChannelMapA, const ma_channel* pChannelMapB, ma_uint32 channels);

/*
Helper for determining if a channel map is blank (all channels set to MA_CHANNEL_NONE).

The channel map buffer must have a capacity of at least `channels`.
*/
MA_API ma_bool32 ma_channel_map_is_blank(const ma_channel* pChannelMap, ma_uint32 channels);

/*
Helper for determining whether or not a channel is present in the given channel map.

The channel map buffer must have a capacity of at least `channels`.
*/
MA_API ma_bool32 ma_channel_map_contains_channel_position(ma_uint32 channels, const ma_channel* pChannelMap, ma_channel channelPosition);

/*
Find a channel position in the given channel map. Returns MA_TRUE if the channel is found; MA_FALSE otherwise. The
index of the channel is output to `pChannelIndex`.

The channel map buffer must have a capacity of at least `channels`.
*/
MA_API ma_bool32 ma_channel_map_find_channel_position(ma_uint32 channels, const ma_channel* pChannelMap, ma_channel channelPosition, ma_uint32* pChannelIndex);

/*
Generates a string representing the given channel map.

This is for printing and debugging purposes, not serialization/deserialization.

Returns the length of the string, not including the null terminator.
*/
MA_API size_t ma_channel_map_to_string(const ma_channel* pChannelMap, ma_uint32 channels, char* pBufferOut, size_t bufferCap);

/*
Retrieves a human readable version of a channel position.
*/
MA_API const char* ma_channel_position_to_string(ma_channel channel);


/************************************************************************************************************************************************************

Conversion Helpers

************************************************************************************************************************************************************/

/*
High-level helper for doing a full format conversion in one go. Returns the number of output frames. Call this with pOut set to NULL to
determine the required size of the output buffer. frameCountOut should be set to the capacity of pOut. If pOut is NULL, frameCountOut is
ignored.

A return value of 0 indicates an error.

This function is useful for one-off bulk conversions, but if you're streaming data you should use the ma_data_converter APIs instead.
*/
MA_API ma_uint64 ma_convert_frames(void* pOut, ma_uint64 frameCountOut, ma_format formatOut, ma_uint32 channelsOut, ma_uint32 sampleRateOut, const void* pIn, ma_uint64 frameCountIn, ma_format formatIn, ma_uint32 channelsIn, ma_uint32 sampleRateIn);
MA_API ma_uint64 ma_convert_frames_ex(void* pOut, ma_uint64 frameCountOut, const void* pIn, ma_uint64 frameCountIn, const ma_data_converter_config* pConfig);


/************************************************************************************************************************************************************

Data Source

************************************************************************************************************************************************************/
typedef void ma_data_source;

#define MA_DATA_SOURCE_SELF_MANAGED_RANGE_AND_LOOP_POINT    0x00000001

typedef struct
{
    ma_result (* onRead)(ma_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead);
    ma_result (* onSeek)(ma_data_source* pDataSource, ma_uint64 frameIndex);
    ma_result (* onGetDataFormat)(ma_data_source* pDataSource, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap);
    ma_result (* onGetCursor)(ma_data_source* pDataSource, ma_uint64* pCursor);
    ma_result (* onGetLength)(ma_data_source* pDataSource, ma_uint64* pLength);
    ma_result (* onSetLooping)(ma_data_source* pDataSource, ma_bool32 isLooping);
    ma_uint32 flags;
} ma_data_source_vtable;

typedef ma_data_source* (* ma_data_source_get_next_proc)(ma_data_source* pDataSource);

typedef struct
{
    const ma_data_source_vtable* vtable;
} ma_data_source_config;

MA_API ma_data_source_config ma_data_source_config_init(void);


typedef struct
{
    const ma_data_source_vtable* vtable;
    ma_uint64 rangeBegInFrames;
    ma_uint64 rangeEndInFrames;             /* Set to -1 for unranged (default). */
    ma_uint64 loopBegInFrames;              /* Relative to rangeBegInFrames. */
    ma_uint64 loopEndInFrames;              /* Relative to rangeBegInFrames. Set to -1 for the end of the range. */
    ma_data_source* pCurrent;               /* When non-NULL, the data source being initialized will act as a proxy and will route all operations to pCurrent. Used in conjunction with pNext/onGetNext for seamless chaining. */
    ma_data_source* pNext;                  /* When set to NULL, onGetNext will be used. */
    ma_data_source_get_next_proc onGetNext; /* Will be used when pNext is NULL. If both are NULL, no next will be used. */
    MA_ATOMIC(4, ma_bool32) isLooping;
} ma_data_source_base;

MA_API ma_result ma_data_source_init(const ma_data_source_config* pConfig, ma_data_source* pDataSource);
MA_API void ma_data_source_uninit(ma_data_source* pDataSource);
MA_API ma_result ma_data_source_read_pcm_frames(ma_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead);   /* Must support pFramesOut = NULL in which case a forward seek should be performed. */
MA_API ma_result ma_data_source_seek_pcm_frames(ma_data_source* pDataSource, ma_uint64 frameCount, ma_uint64* pFramesSeeked); /* Can only seek forward. Equivalent to ma_data_source_read_pcm_frames(pDataSource, NULL, frameCount, &framesRead); */
MA_API ma_result ma_data_source_seek_to_pcm_frame(ma_data_source* pDataSource, ma_uint64 frameIndex);
MA_API ma_result ma_data_source_seek_seconds(ma_data_source* pDataSource, float secondCount, float* pSecondsSeeked); /* Can only seek forward. Abstraction to ma_data_source_seek_pcm_frames() */
MA_API ma_result ma_data_source_seek_to_second(ma_data_source* pDataSource, float seekPointInSeconds); /* Abstraction to ma_data_source_seek_to_pcm_frame() */
MA_API ma_result ma_data_source_get_data_format(ma_data_source* pDataSource, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap);
MA_API ma_result ma_data_source_get_cursor_in_pcm_frames(ma_data_source* pDataSource, ma_uint64* pCursor);
MA_API ma_result ma_data_source_get_length_in_pcm_frames(ma_data_source* pDataSource, ma_uint64* pLength);    /* Returns MA_NOT_IMPLEMENTED if the length is unknown or cannot be determined. Decoders can return this. */
MA_API ma_result ma_data_source_get_cursor_in_seconds(ma_data_source* pDataSource, float* pCursor);
MA_API ma_result ma_data_source_get_length_in_seconds(ma_data_source* pDataSource, float* pLength);
MA_API ma_result ma_data_source_set_looping(ma_data_source* pDataSource, ma_bool32 isLooping);
MA_API ma_bool32 ma_data_source_is_looping(const ma_data_source* pDataSource);
MA_API ma_result ma_data_source_set_range_in_pcm_frames(ma_data_source* pDataSource, ma_uint64 rangeBegInFrames, ma_uint64 rangeEndInFrames);
MA_API void ma_data_source_get_range_in_pcm_frames(const ma_data_source* pDataSource, ma_uint64* pRangeBegInFrames, ma_uint64* pRangeEndInFrames);
MA_API ma_result ma_data_source_set_loop_point_in_pcm_frames(ma_data_source* pDataSource, ma_uint64 loopBegInFrames, ma_uint64 loopEndInFrames);
MA_API void ma_data_source_get_loop_point_in_pcm_frames(const ma_data_source* pDataSource, ma_uint64* pLoopBegInFrames, ma_uint64* pLoopEndInFrames);
MA_API ma_result ma_data_source_set_current(ma_data_source* pDataSource, ma_data_source* pCurrentDataSource);
MA_API ma_data_source* ma_data_source_get_current(const ma_data_source* pDataSource);
MA_API ma_result ma_data_source_set_next(ma_data_source* pDataSource, ma_data_source* pNextDataSource);
MA_API ma_data_source* ma_data_source_get_next(const ma_data_source* pDataSource);
MA_API ma_result ma_data_source_set_next_callback(ma_data_source* pDataSource, ma_data_source_get_next_proc onGetNext);
MA_API ma_data_source_get_next_proc ma_data_source_get_next_callback(const ma_data_source* pDataSource);


typedef struct
{
    ma_data_source_base ds;
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
    ma_uint64 cursor;
    ma_uint64 sizeInFrames;
    const void* pData;
} ma_audio_buffer_ref;

MA_API ma_result ma_audio_buffer_ref_init(ma_format format, ma_uint32 channels, const void* pData, ma_uint64 sizeInFrames, ma_audio_buffer_ref* pAudioBufferRef);
MA_API void ma_audio_buffer_ref_uninit(ma_audio_buffer_ref* pAudioBufferRef);
MA_API ma_result ma_audio_buffer_ref_set_data(ma_audio_buffer_ref* pAudioBufferRef, const void* pData, ma_uint64 sizeInFrames);
MA_API ma_uint64 ma_audio_buffer_ref_read_pcm_frames(ma_audio_buffer_ref* pAudioBufferRef, void* pFramesOut, ma_uint64 frameCount, ma_bool32 loop);
MA_API ma_result ma_audio_buffer_ref_seek_to_pcm_frame(ma_audio_buffer_ref* pAudioBufferRef, ma_uint64 frameIndex);
MA_API ma_result ma_audio_buffer_ref_map(ma_audio_buffer_ref* pAudioBufferRef, void** ppFramesOut, ma_uint64* pFrameCount);
MA_API ma_result ma_audio_buffer_ref_unmap(ma_audio_buffer_ref* pAudioBufferRef, ma_uint64 frameCount);    /* Returns MA_AT_END if the end has been reached. This should be considered successful. */
MA_API ma_bool32 ma_audio_buffer_ref_at_end(const ma_audio_buffer_ref* pAudioBufferRef);
MA_API ma_result ma_audio_buffer_ref_get_cursor_in_pcm_frames(const ma_audio_buffer_ref* pAudioBufferRef, ma_uint64* pCursor);
MA_API ma_result ma_audio_buffer_ref_get_length_in_pcm_frames(const ma_audio_buffer_ref* pAudioBufferRef, ma_uint64* pLength);
MA_API ma_result ma_audio_buffer_ref_get_available_frames(const ma_audio_buffer_ref* pAudioBufferRef, ma_uint64* pAvailableFrames);



typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;
    ma_uint64 sizeInFrames;
    const void* pData;  /* If set to NULL, will allocate a block of memory for you. */
    ma_allocation_callbacks allocationCallbacks;
} ma_audio_buffer_config;

MA_API ma_audio_buffer_config ma_audio_buffer_config_init(ma_format format, ma_uint32 channels, ma_uint64 sizeInFrames, const void* pData, const ma_allocation_callbacks* pAllocationCallbacks);

typedef struct
{
    ma_audio_buffer_ref ref;
    ma_allocation_callbacks allocationCallbacks;
    ma_bool32 ownsData;             /* Used to control whether or not miniaudio owns the data buffer. If set to true, pData will be freed in ma_audio_buffer_uninit(). */
    ma_uint8 _pExtraData[1];        /* For allocating a buffer with the memory located directly after the other memory of the structure. */
} ma_audio_buffer;

MA_API ma_result ma_audio_buffer_init(const ma_audio_buffer_config* pConfig, ma_audio_buffer* pAudioBuffer);
MA_API ma_result ma_audio_buffer_init_copy(const ma_audio_buffer_config* pConfig, ma_audio_buffer* pAudioBuffer);
MA_API ma_result ma_audio_buffer_alloc_and_init(const ma_audio_buffer_config* pConfig, ma_audio_buffer** ppAudioBuffer);  /* Always copies the data. Doesn't make sense to use this otherwise. Use ma_audio_buffer_uninit_and_free() to uninit. */
MA_API void ma_audio_buffer_uninit(ma_audio_buffer* pAudioBuffer);
MA_API void ma_audio_buffer_uninit_and_free(ma_audio_buffer* pAudioBuffer);
MA_API ma_uint64 ma_audio_buffer_read_pcm_frames(ma_audio_buffer* pAudioBuffer, void* pFramesOut, ma_uint64 frameCount, ma_bool32 loop);
MA_API ma_result ma_audio_buffer_seek_to_pcm_frame(ma_audio_buffer* pAudioBuffer, ma_uint64 frameIndex);
MA_API ma_result ma_audio_buffer_map(ma_audio_buffer* pAudioBuffer, void** ppFramesOut, ma_uint64* pFrameCount);
MA_API ma_result ma_audio_buffer_unmap(ma_audio_buffer* pAudioBuffer, ma_uint64 frameCount);    /* Returns MA_AT_END if the end has been reached. This should be considered successful. */
MA_API ma_bool32 ma_audio_buffer_at_end(const ma_audio_buffer* pAudioBuffer);
MA_API ma_result ma_audio_buffer_get_cursor_in_pcm_frames(const ma_audio_buffer* pAudioBuffer, ma_uint64* pCursor);
MA_API ma_result ma_audio_buffer_get_length_in_pcm_frames(const ma_audio_buffer* pAudioBuffer, ma_uint64* pLength);
MA_API ma_result ma_audio_buffer_get_available_frames(const ma_audio_buffer* pAudioBuffer, ma_uint64* pAvailableFrames);


/*
Paged Audio Buffer
==================
A paged audio buffer is made up of a linked list of pages. It's expandable, but not shrinkable. It
can be used for cases where audio data is streamed in asynchronously while allowing data to be read
at the same time.

This is lock-free, but not 100% thread safe. You can append a page and read from the buffer across
simultaneously across different threads, however only one thread at a time can append, and only one
thread at a time can read and seek.
*/
typedef struct ma_paged_audio_buffer_page ma_paged_audio_buffer_page;
struct ma_paged_audio_buffer_page
{
    MA_ATOMIC(MA_SIZEOF_PTR, ma_paged_audio_buffer_page*) pNext;
    ma_uint64 sizeInFrames;
    ma_uint8 pAudioData[1];
};

typedef struct
{
    ma_format format;
    ma_uint32 channels;
    ma_paged_audio_buffer_page head;                                /* Dummy head for the lock-free algorithm. Always has a size of 0. */
    MA_ATOMIC(MA_SIZEOF_PTR, ma_paged_audio_buffer_page*) pTail;    /* Never null. Initially set to &head. */
} ma_paged_audio_buffer_data;

MA_API ma_result ma_paged_audio_buffer_data_init(ma_format format, ma_uint32 channels, ma_paged_audio_buffer_data* pData);
MA_API void ma_paged_audio_buffer_data_uninit(ma_paged_audio_buffer_data* pData, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_paged_audio_buffer_page* ma_paged_audio_buffer_data_get_head(ma_paged_audio_buffer_data* pData);
MA_API ma_paged_audio_buffer_page* ma_paged_audio_buffer_data_get_tail(ma_paged_audio_buffer_data* pData);
MA_API ma_result ma_paged_audio_buffer_data_get_length_in_pcm_frames(ma_paged_audio_buffer_data* pData, ma_uint64* pLength);
MA_API ma_result ma_paged_audio_buffer_data_allocate_page(ma_paged_audio_buffer_data* pData, ma_uint64 pageSizeInFrames, const void* pInitialData, const ma_allocation_callbacks* pAllocationCallbacks, ma_paged_audio_buffer_page** ppPage);
MA_API ma_result ma_paged_audio_buffer_data_free_page(ma_paged_audio_buffer_data* pData, ma_paged_audio_buffer_page* pPage, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_paged_audio_buffer_data_append_page(ma_paged_audio_buffer_data* pData, ma_paged_audio_buffer_page* pPage);
MA_API ma_result ma_paged_audio_buffer_data_allocate_and_append_page(ma_paged_audio_buffer_data* pData, ma_uint32 pageSizeInFrames, const void* pInitialData, const ma_allocation_callbacks* pAllocationCallbacks);


typedef struct
{
    ma_paged_audio_buffer_data* pData;  /* Must not be null. */
} ma_paged_audio_buffer_config;

MA_API ma_paged_audio_buffer_config ma_paged_audio_buffer_config_init(ma_paged_audio_buffer_data* pData);


typedef struct
{
    ma_data_source_base ds;
    ma_paged_audio_buffer_data* pData;              /* Audio data is read from here. Cannot be null. */
    ma_paged_audio_buffer_page* pCurrent;
    ma_uint64 relativeCursor;                       /* Relative to the current page. */
    ma_uint64 absoluteCursor;
} ma_paged_audio_buffer;

MA_API ma_result ma_paged_audio_buffer_init(const ma_paged_audio_buffer_config* pConfig, ma_paged_audio_buffer* pPagedAudioBuffer);
MA_API void ma_paged_audio_buffer_uninit(ma_paged_audio_buffer* pPagedAudioBuffer);
MA_API ma_result ma_paged_audio_buffer_read_pcm_frames(ma_paged_audio_buffer* pPagedAudioBuffer, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead);   /* Returns MA_AT_END if no more pages available. */
MA_API ma_result ma_paged_audio_buffer_seek_to_pcm_frame(ma_paged_audio_buffer* pPagedAudioBuffer, ma_uint64 frameIndex);
MA_API ma_result ma_paged_audio_buffer_get_cursor_in_pcm_frames(ma_paged_audio_buffer* pPagedAudioBuffer, ma_uint64* pCursor);
MA_API ma_result ma_paged_audio_buffer_get_length_in_pcm_frames(ma_paged_audio_buffer* pPagedAudioBuffer, ma_uint64* pLength);



/************************************************************************************************************************************************************

Ring Buffer

************************************************************************************************************************************************************/
typedef struct
{
    void* pBuffer;
    ma_uint32 subbufferSizeInBytes;
    ma_uint32 subbufferCount;
    ma_uint32 subbufferStrideInBytes;
    MA_ATOMIC(4, ma_uint32) encodedReadOffset;  /* Most significant bit is the loop flag. Lower 31 bits contains the actual offset in bytes. Must be used atomically. */
    MA_ATOMIC(4, ma_uint32) encodedWriteOffset; /* Most significant bit is the loop flag. Lower 31 bits contains the actual offset in bytes. Must be used atomically. */
    ma_bool8 ownsBuffer;                        /* Used to know whether or not miniaudio is responsible for free()-ing the buffer. */
    ma_bool8 clearOnWriteAcquire;               /* When set, clears the acquired write buffer before returning from ma_rb_acquire_write(). */
    ma_allocation_callbacks allocationCallbacks;
} ma_rb;

MA_API ma_result ma_rb_init_ex(size_t subbufferSizeInBytes, size_t subbufferCount, size_t subbufferStrideInBytes, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_rb* pRB);
MA_API ma_result ma_rb_init(size_t bufferSizeInBytes, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_rb* pRB);
MA_API void ma_rb_uninit(ma_rb* pRB);
MA_API void ma_rb_reset(ma_rb* pRB);
MA_API ma_result ma_rb_acquire_read(ma_rb* pRB, size_t* pSizeInBytes, void** ppBufferOut);
MA_API ma_result ma_rb_commit_read(ma_rb* pRB, size_t sizeInBytes);
MA_API ma_result ma_rb_acquire_write(ma_rb* pRB, size_t* pSizeInBytes, void** ppBufferOut);
MA_API ma_result ma_rb_commit_write(ma_rb* pRB, size_t sizeInBytes);
MA_API ma_result ma_rb_seek_read(ma_rb* pRB, size_t offsetInBytes);
MA_API ma_result ma_rb_seek_write(ma_rb* pRB, size_t offsetInBytes);
MA_API ma_int32 ma_rb_pointer_distance(ma_rb* pRB);    /* Returns the distance between the write pointer and the read pointer. Should never be negative for a correct program. Will return the number of bytes that can be read before the read pointer hits the write pointer. */
MA_API ma_uint32 ma_rb_available_read(ma_rb* pRB);
MA_API ma_uint32 ma_rb_available_write(ma_rb* pRB);
MA_API size_t ma_rb_get_subbuffer_size(ma_rb* pRB);
MA_API size_t ma_rb_get_subbuffer_stride(ma_rb* pRB);
MA_API size_t ma_rb_get_subbuffer_offset(ma_rb* pRB, size_t subbufferIndex);
MA_API void* ma_rb_get_subbuffer_ptr(ma_rb* pRB, size_t subbufferIndex, void* pBuffer);


typedef struct
{
    ma_data_source_base ds;
    ma_rb rb;
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate; /* Not required for the ring buffer itself, but useful for associating the data with some sample rate, particularly for data sources. */
} ma_pcm_rb;

MA_API ma_result ma_pcm_rb_init_ex(ma_format format, ma_uint32 channels, ma_uint32 subbufferSizeInFrames, ma_uint32 subbufferCount, ma_uint32 subbufferStrideInFrames, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_pcm_rb* pRB);
MA_API ma_result ma_pcm_rb_init(ma_format format, ma_uint32 channels, ma_uint32 bufferSizeInFrames, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_pcm_rb* pRB);
MA_API void ma_pcm_rb_uninit(ma_pcm_rb* pRB);
MA_API void ma_pcm_rb_reset(ma_pcm_rb* pRB);
MA_API ma_result ma_pcm_rb_acquire_read(ma_pcm_rb* pRB, ma_uint32* pSizeInFrames, void** ppBufferOut);
MA_API ma_result ma_pcm_rb_commit_read(ma_pcm_rb* pRB, ma_uint32 sizeInFrames);
MA_API ma_result ma_pcm_rb_acquire_write(ma_pcm_rb* pRB, ma_uint32* pSizeInFrames, void** ppBufferOut);
MA_API ma_result ma_pcm_rb_commit_write(ma_pcm_rb* pRB, ma_uint32 sizeInFrames);
MA_API ma_result ma_pcm_rb_seek_read(ma_pcm_rb* pRB, ma_uint32 offsetInFrames);
MA_API ma_result ma_pcm_rb_seek_write(ma_pcm_rb* pRB, ma_uint32 offsetInFrames);
MA_API ma_int32 ma_pcm_rb_pointer_distance(ma_pcm_rb* pRB); /* Return value is in frames. */
MA_API ma_uint32 ma_pcm_rb_available_read(ma_pcm_rb* pRB);
MA_API ma_uint32 ma_pcm_rb_available_write(ma_pcm_rb* pRB);
MA_API ma_uint32 ma_pcm_rb_get_subbuffer_size(ma_pcm_rb* pRB);
MA_API ma_uint32 ma_pcm_rb_get_subbuffer_stride(ma_pcm_rb* pRB);
MA_API ma_uint32 ma_pcm_rb_get_subbuffer_offset(ma_pcm_rb* pRB, ma_uint32 subbufferIndex);
MA_API void* ma_pcm_rb_get_subbuffer_ptr(ma_pcm_rb* pRB, ma_uint32 subbufferIndex, void* pBuffer);
MA_API ma_format ma_pcm_rb_get_format(const ma_pcm_rb* pRB);
MA_API ma_uint32 ma_pcm_rb_get_channels(const ma_pcm_rb* pRB);
MA_API ma_uint32 ma_pcm_rb_get_sample_rate(const ma_pcm_rb* pRB);
MA_API void ma_pcm_rb_set_sample_rate(ma_pcm_rb* pRB, ma_uint32 sampleRate);


/*
The idea of the duplex ring buffer is to act as the intermediary buffer when running two asynchronous devices in a duplex set up. The
capture device writes to it, and then a playback device reads from it.

At the moment this is just a simple naive implementation, but in the future I want to implement some dynamic resampling to seamlessly
handle desyncs. Note that the API is work in progress and may change at any time in any version.

The size of the buffer is based on the capture side since that's what'll be written to the buffer. It is based on the capture period size
in frames. The internal sample rate of the capture device is also needed in order to calculate the size.
*/
typedef struct
{
    ma_pcm_rb rb;
} ma_duplex_rb;

MA_API ma_result ma_duplex_rb_init(ma_format captureFormat, ma_uint32 captureChannels, ma_uint32 sampleRate, ma_uint32 captureInternalSampleRate, ma_uint32 captureInternalPeriodSizeInFrames, const ma_allocation_callbacks* pAllocationCallbacks, ma_duplex_rb* pRB);
MA_API ma_result ma_duplex_rb_uninit(ma_duplex_rb* pRB);


/************************************************************************************************************************************************************

Miscellaneous Helpers

************************************************************************************************************************************************************/
/*
Retrieves a human readable description of the given result code.
*/
MA_API const char* ma_result_description(ma_result result);

/*
malloc()
*/
MA_API void* ma_malloc(size_t sz, const ma_allocation_callbacks* pAllocationCallbacks);

/*
calloc()
*/
MA_API void* ma_calloc(size_t sz, const ma_allocation_callbacks* pAllocationCallbacks);

/*
realloc()
*/
MA_API void* ma_realloc(void* p, size_t sz, const ma_allocation_callbacks* pAllocationCallbacks);

/*
free()
*/
MA_API void ma_free(void* p, const ma_allocation_callbacks* pAllocationCallbacks);

/*
Performs an aligned malloc, with the assumption that the alignment is a power of 2.
*/
MA_API void* ma_aligned_malloc(size_t sz, size_t alignment, const ma_allocation_callbacks* pAllocationCallbacks);

/*
Free's an aligned malloc'd buffer.
*/
MA_API void ma_aligned_free(void* p, const ma_allocation_callbacks* pAllocationCallbacks);

/*
Retrieves a friendly name for a format.
*/
MA_API const char* ma_get_format_name(ma_format format);

/*
Blends two frames in floating point format.
*/
MA_API void ma_blend_f32(float* pOut, float* pInA, float* pInB, float factor, ma_uint32 channels);

/*
Retrieves the size of a sample in bytes for the given format.

This API is efficient and is implemented using a lookup table.

Thread Safety: SAFE
  This API is pure.
*/
MA_API ma_uint32 ma_get_bytes_per_sample(ma_format format);
static MA_INLINE ma_uint32 ma_get_bytes_per_frame(ma_format format, ma_uint32 channels) { return ma_get_bytes_per_sample(format) * channels; }

/*
Converts a log level to a string.
*/
MA_API const char* ma_log_level_to_string(ma_uint32 logLevel);




/************************************************************************************************************************************************************

Synchronization

************************************************************************************************************************************************************/
/*
Locks a spinlock.
*/
MA_API ma_result ma_spinlock_lock(volatile ma_spinlock* pSpinlock);

/*
Locks a spinlock, but does not yield() when looping.
*/
MA_API ma_result ma_spinlock_lock_noyield(volatile ma_spinlock* pSpinlock);

/*
Unlocks a spinlock.
*/
MA_API ma_result ma_spinlock_unlock(volatile ma_spinlock* pSpinlock);


#ifndef MA_NO_THREADING

/*
Creates a mutex.

A mutex must be created from a valid context. A mutex is initially unlocked.
*/
MA_API ma_result ma_mutex_init(ma_mutex* pMutex);

/*
Deletes a mutex.
*/
MA_API void ma_mutex_uninit(ma_mutex* pMutex);

/*
Locks a mutex with an infinite timeout.
*/
MA_API void ma_mutex_lock(ma_mutex* pMutex);

/*
Unlocks a mutex.
*/
MA_API void ma_mutex_unlock(ma_mutex* pMutex);


/*
Initializes an auto-reset event.
*/
MA_API ma_result ma_event_init(ma_event* pEvent);

/*
Uninitializes an auto-reset event.
*/
MA_API void ma_event_uninit(ma_event* pEvent);

/*
Waits for the specified auto-reset event to become signalled.
*/
MA_API ma_result ma_event_wait(ma_event* pEvent);

/*
Signals the specified auto-reset event.
*/
MA_API ma_result ma_event_signal(ma_event* pEvent);


MA_API ma_result ma_semaphore_init(int initialValue, ma_semaphore* pSemaphore);
MA_API void ma_semaphore_uninit(ma_semaphore* pSemaphore);
MA_API ma_result ma_semaphore_wait(ma_semaphore* pSemaphore);
MA_API ma_result ma_semaphore_release(ma_semaphore* pSemaphore);
#endif  /* MA_NO_THREADING */


/*
Fence
=====
This locks while the counter is larger than 0. Counter can be incremented and decremented by any
thread, but care needs to be taken when waiting. It is possible for one thread to acquire the
fence just as another thread returns from ma_fence_wait().

The idea behind a fence is to allow you to wait for a group of operations to complete. When an
operation starts, the counter is incremented which locks the fence. When the operation completes,
the fence will be released which decrements the counter. ma_fence_wait() will block until the
counter hits zero.

If threading is disabled, ma_fence_wait() will spin on the counter.
*/
typedef struct
{
#ifndef MA_NO_THREADING
    ma_event e;
#endif
    ma_uint32 counter;
} ma_fence;

MA_API ma_result ma_fence_init(ma_fence* pFence);
MA_API void ma_fence_uninit(ma_fence* pFence);
MA_API ma_result ma_fence_acquire(ma_fence* pFence);    /* Increment counter. */
MA_API ma_result ma_fence_release(ma_fence* pFence);    /* Decrement counter. */
MA_API ma_result ma_fence_wait(ma_fence* pFence);       /* Wait for counter to reach 0. */



/*
Notification callback for asynchronous operations.
*/
typedef void ma_async_notification;

typedef struct
{
    void (* onSignal)(ma_async_notification* pNotification);
} ma_async_notification_callbacks;

MA_API ma_result ma_async_notification_signal(ma_async_notification* pNotification);


/*
Simple polling notification.

This just sets a variable when the notification has been signalled which is then polled with ma_async_notification_poll_is_signalled()
*/
typedef struct
{
    ma_async_notification_callbacks cb;
    ma_bool32 signalled;
} ma_async_notification_poll;

MA_API ma_result ma_async_notification_poll_init(ma_async_notification_poll* pNotificationPoll);
MA_API ma_bool32 ma_async_notification_poll_is_signalled(const ma_async_notification_poll* pNotificationPoll);


/*
Event Notification

This uses an ma_event. If threading is disabled (MA_NO_THREADING), initialization will fail.
*/
typedef struct
{
    ma_async_notification_callbacks cb;
#ifndef MA_NO_THREADING
    ma_event e;
#endif
} ma_async_notification_event;

MA_API ma_result ma_async_notification_event_init(ma_async_notification_event* pNotificationEvent);
MA_API ma_result ma_async_notification_event_uninit(ma_async_notification_event* pNotificationEvent);
MA_API ma_result ma_async_notification_event_wait(ma_async_notification_event* pNotificationEvent);
MA_API ma_result ma_async_notification_event_signal(ma_async_notification_event* pNotificationEvent);




/************************************************************************************************************************************************************

Job Queue

************************************************************************************************************************************************************/

/*
Slot Allocator
--------------
The idea of the slot allocator is for it to be used in conjunction with a fixed sized buffer. You use the slot allocator to allocate an index that can be used
as the insertion point for an object.

Slots are reference counted to help mitigate the ABA problem in the lock-free queue we use for tracking jobs.

The slot index is stored in the low 32 bits. The reference counter is stored in the high 32 bits:

    +-----------------+-----------------+
    | 32 Bits         | 32 Bits         |
    +-----------------+-----------------+
    | Reference Count | Slot Index      |
    +-----------------+-----------------+
*/
typedef struct
{
    ma_uint32 capacity;    /* The number of slots to make available. */
} ma_slot_allocator_config;

MA_API ma_slot_allocator_config ma_slot_allocator_config_init(ma_uint32 capacity);


typedef struct
{
    MA_ATOMIC(4, ma_uint32) bitfield;   /* Must be used atomically because the allocation and freeing routines need to make copies of this which must never be optimized away by the compiler. */
} ma_slot_allocator_group;

typedef struct
{
    ma_slot_allocator_group* pGroups;   /* Slots are grouped in chunks of 32. */
    ma_uint32* pSlots;                  /* 32 bits for reference counting for ABA mitigation. */
    ma_uint32 count;                    /* Allocation count. */
    ma_uint32 capacity;

    /* Memory management. */
    ma_bool32 _ownsHeap;
    void* _pHeap;
} ma_slot_allocator;

MA_API ma_result ma_slot_allocator_get_heap_size(const ma_slot_allocator_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_slot_allocator_init_preallocated(const ma_slot_allocator_config* pConfig, void* pHeap, ma_slot_allocator* pAllocator);
MA_API ma_result ma_slot_allocator_init(const ma_slot_allocator_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_slot_allocator* pAllocator);
MA_API void ma_slot_allocator_uninit(ma_slot_allocator* pAllocator, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_slot_allocator_alloc(ma_slot_allocator* pAllocator, ma_uint64* pSlot);
MA_API ma_result ma_slot_allocator_free(ma_slot_allocator* pAllocator, ma_uint64 slot);


typedef struct ma_job ma_job;

/*
Callback for processing a job. Each job type will have their own processing callback which will be
called by ma_job_process().
*/
typedef ma_result (* ma_job_proc)(ma_job* pJob);

/* When a job type is added here an callback needs to be added go "g_jobVTable" in the implementation section. */
typedef enum
{
    /* Miscellaneous. */
    MA_JOB_TYPE_QUIT = 0,
    MA_JOB_TYPE_CUSTOM,

    /* Resource Manager. */
    MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_BUFFER_NODE,
    MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_BUFFER_NODE,
    MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_BUFFER_NODE,
    MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_BUFFER,
    MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_BUFFER,
    MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_STREAM,
    MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_STREAM,
    MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_STREAM,
    MA_JOB_TYPE_RESOURCE_MANAGER_SEEK_DATA_STREAM,

    /* Device. */
    MA_JOB_TYPE_DEVICE_AAUDIO_REROUTE,

    /* Count. Must always be last. */
    MA_JOB_TYPE_COUNT
} ma_job_type;

struct ma_job
{
    union
    {
        struct
        {
            ma_uint16 code;         /* Job type. */
            ma_uint16 slot;         /* Index into a ma_slot_allocator. */
            ma_uint32 refcount;
        } breakup;
        ma_uint64 allocation;
    } toc;  /* 8 bytes. We encode the job code into the slot allocation data to save space. */
    MA_ATOMIC(8, ma_uint64) next; /* refcount + slot for the next item. Does not include the job code. */
    ma_uint32 order;    /* Execution order. Used to create a data dependency and ensure a job is executed in order. Usage is contextual depending on the job type. */

    union
    {
        /* Miscellaneous. */
        struct
        {
            ma_job_proc proc;
            ma_uintptr data0;
            ma_uintptr data1;
        } custom;

        /* Resource Manager */
        union
        {
            struct
            {
                /*ma_resource_manager**/ void* pResourceManager;
                /*ma_resource_manager_data_buffer_node**/ void* pDataBufferNode;
                char* pFilePath;
                wchar_t* pFilePathW;
                ma_uint32 flags;                                /* Resource manager data source flags that were used when initializing the data buffer. */
                ma_async_notification* pInitNotification;       /* Signalled when the data buffer has been initialized and the format/channels/rate can be retrieved. */
                ma_async_notification* pDoneNotification;       /* Signalled when the data buffer has been fully decoded. Will be passed through to MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_BUFFER_NODE when decoding. */
                ma_fence* pInitFence;                           /* Released when initialization of the decoder is complete. */
                ma_fence* pDoneFence;                           /* Released if initialization of the decoder fails. Passed through to PAGE_DATA_BUFFER_NODE untouched if init is successful. */
            } loadDataBufferNode;
            struct
            {
                /*ma_resource_manager**/ void* pResourceManager;
                /*ma_resource_manager_data_buffer_node**/ void* pDataBufferNode;
                ma_async_notification* pDoneNotification;
                ma_fence* pDoneFence;
            } freeDataBufferNode;
            struct
            {
                /*ma_resource_manager**/ void* pResourceManager;
                /*ma_resource_manager_data_buffer_node**/ void* pDataBufferNode;
                /*ma_decoder**/ void* pDecoder;
                ma_async_notification* pDoneNotification;       /* Signalled when the data buffer has been fully decoded. */
                ma_fence* pDoneFence;                           /* Passed through from LOAD_DATA_BUFFER_NODE and released when the data buffer completes decoding or an error occurs. */
            } pageDataBufferNode;

            struct
            {
                /*ma_resource_manager_data_buffer**/ void* pDataBuffer;
                ma_async_notification* pInitNotification;       /* Signalled when the data buffer has been initialized and the format/channels/rate can be retrieved. */
                ma_async_notification* pDoneNotification;       /* Signalled when the data buffer has been fully decoded. */
                ma_fence* pInitFence;                           /* Released when the data buffer has been initialized and the format/channels/rate can be retrieved. */
                ma_fence* pDoneFence;                           /* Released when the data buffer has been fully decoded. */
                ma_uint64 rangeBegInPCMFrames;
                ma_uint64 rangeEndInPCMFrames;
                ma_uint64 loopPointBegInPCMFrames;
                ma_uint64 loopPointEndInPCMFrames;
                ma_uint32 isLooping;
            } loadDataBuffer;
            struct
            {
                /*ma_resource_manager_data_buffer**/ void* pDataBuffer;
                ma_async_notification* pDoneNotification;
                ma_fence* pDoneFence;
            } freeDataBuffer;

            struct
            {
                /*ma_resource_manager_data_stream**/ void* pDataStream;
                char* pFilePath;                            /* Allocated when the job is posted, freed by the job thread after loading. */
                wchar_t* pFilePathW;                        /* ^ As above ^. Only used if pFilePath is NULL. */
                ma_uint64 initialSeekPoint;
                ma_async_notification* pInitNotification;   /* Signalled after the first two pages have been decoded and frames can be read from the stream. */
                ma_fence* pInitFence;
            } loadDataStream;
            struct
            {
                /*ma_resource_manager_data_stream**/ void* pDataStream;
                ma_async_notification* pDoneNotification;
                ma_fence* pDoneFence;
            } freeDataStream;
            struct
            {
                /*ma_resource_manager_data_stream**/ void* pDataStream;
                ma_uint32 pageIndex;                    /* The index of the page to decode into. */
            } pageDataStream;
            struct
            {
                /*ma_resource_manager_data_stream**/ void* pDataStream;
                ma_uint64 frameIndex;
            } seekDataStream;
        } resourceManager;

        /* Device. */
        union
        {
            union
            {
                struct
                {
                    /*ma_device**/ void* pDevice;
                    /*ma_device_type*/ ma_uint32 deviceType;
                } reroute;
            } aaudio;
        } device;
    } data;
};

MA_API ma_job ma_job_init(ma_uint16 code);
MA_API ma_result ma_job_process(ma_job* pJob);


/*
When set, ma_job_queue_next() will not wait and no semaphore will be signaled in
ma_job_queue_post(). ma_job_queue_next() will return MA_NO_DATA_AVAILABLE if nothing is available.

This flag should always be used for platforms that do not support multithreading.
*/
typedef enum
{
    MA_JOB_QUEUE_FLAG_NON_BLOCKING = 0x00000001
} ma_job_queue_flags;

typedef struct
{
    ma_uint32 flags;
    ma_uint32 capacity; /* The maximum number of jobs that can fit in the queue at a time. */
} ma_job_queue_config;

MA_API ma_job_queue_config ma_job_queue_config_init(ma_uint32 flags, ma_uint32 capacity);


typedef struct
{
    ma_uint32 flags;                /* Flags passed in at initialization time. */
    ma_uint32 capacity;             /* The maximum number of jobs that can fit in the queue at a time. Set by the config. */
    MA_ATOMIC(8, ma_uint64) head;   /* The first item in the list. Required for removing from the top of the list. */
    MA_ATOMIC(8, ma_uint64) tail;   /* The last item in the list. Required for appending to the end of the list. */
#ifndef MA_NO_THREADING
    ma_semaphore sem;               /* Only used when MA_JOB_QUEUE_FLAG_NON_BLOCKING is unset. */
#endif
    ma_slot_allocator allocator;
    ma_job* pJobs;
#ifndef MA_USE_EXPERIMENTAL_LOCK_FREE_JOB_QUEUE
    ma_spinlock lock;
#endif

    /* Memory management. */
    void* _pHeap;
    ma_bool32 _ownsHeap;
} ma_job_queue;

MA_API ma_result ma_job_queue_get_heap_size(const ma_job_queue_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_job_queue_init_preallocated(const ma_job_queue_config* pConfig, void* pHeap, ma_job_queue* pQueue);
MA_API ma_result ma_job_queue_init(const ma_job_queue_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_job_queue* pQueue);
MA_API void ma_job_queue_uninit(ma_job_queue* pQueue, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_job_queue_post(ma_job_queue* pQueue, const ma_job* pJob);
MA_API ma_result ma_job_queue_next(ma_job_queue* pQueue, ma_job* pJob); /* Returns MA_CANCELLED if the next job is a quit job. */



/************************************************************************************************************************************************************
*************************************************************************************************************************************************************

DEVICE I/O
==========

This section contains the APIs for device playback and capture. Here is where you'll find ma_device_init(), etc.

*************************************************************************************************************************************************************
************************************************************************************************************************************************************/



/************************************************************************************************************************************************************

Utilities

************************************************************************************************************************************************************/

/*
Calculates a buffer size in milliseconds (rounded up) from the specified number of frames and sample rate.
*/
MA_API ma_uint32 ma_calculate_buffer_size_in_milliseconds_from_frames(ma_uint32 bufferSizeInFrames, ma_uint32 sampleRate);

/*
Calculates a buffer size in frames from the specified number of milliseconds and sample rate.
*/
MA_API ma_uint32 ma_calculate_buffer_size_in_frames_from_milliseconds(ma_uint32 bufferSizeInMilliseconds, ma_uint32 sampleRate);

/*
Copies PCM frames from one buffer to another.
*/
MA_API void ma_copy_pcm_frames(void* dst, const void* src, ma_uint64 frameCount, ma_format format, ma_uint32 channels);

/*
Copies silent frames into the given buffer.

Remarks
-------
For all formats except `ma_format_u8`, the output buffer will be filled with 0. For `ma_format_u8` it will be filled with 128. The reason for this is that it
makes more sense for the purpose of mixing to initialize it to the center point.
*/
MA_API void ma_silence_pcm_frames(void* p, ma_uint64 frameCount, ma_format format, ma_uint32 channels);


/*
Offsets a pointer by the specified number of PCM frames.
*/
MA_API void* ma_offset_pcm_frames_ptr(void* p, ma_uint64 offsetInFrames, ma_format format, ma_uint32 channels);
MA_API const void* ma_offset_pcm_frames_const_ptr(const void* p, ma_uint64 offsetInFrames, ma_format format, ma_uint32 channels);
static MA_INLINE float* ma_offset_pcm_frames_ptr_f32(float* p, ma_uint64 offsetInFrames, ma_uint32 channels) { return (float*)ma_offset_pcm_frames_ptr((void*)p, offsetInFrames, ma_format_f32, channels); }
static MA_INLINE const float* ma_offset_pcm_frames_const_ptr_f32(const float* p, ma_uint64 offsetInFrames, ma_uint32 channels) { return (const float*)ma_offset_pcm_frames_const_ptr((const void*)p, offsetInFrames, ma_format_f32, channels); }


/*
Clips samples.
*/
MA_API void ma_clip_samples_u8(ma_uint8* pDst, const ma_int16* pSrc, ma_uint64 count);
MA_API void ma_clip_samples_s16(ma_int16* pDst, const ma_int32* pSrc, ma_uint64 count);
MA_API void ma_clip_samples_s24(ma_uint8* pDst, const ma_int64* pSrc, ma_uint64 count);
MA_API void ma_clip_samples_s32(ma_int32* pDst, const ma_int64* pSrc, ma_uint64 count);
MA_API void ma_clip_samples_f32(float* pDst, const float* pSrc, ma_uint64 count);
MA_API void ma_clip_pcm_frames(void* pDst, const void* pSrc, ma_uint64 frameCount, ma_format format, ma_uint32 channels);

/*
Helper for applying a volume factor to samples.

Note that the source and destination buffers can be the same, in which case it'll perform the operation in-place.
*/
MA_API void ma_copy_and_apply_volume_factor_u8(ma_uint8* pSamplesOut, const ma_uint8* pSamplesIn, ma_uint64 sampleCount, float factor);
MA_API void ma_copy_and_apply_volume_factor_s16(ma_int16* pSamplesOut, const ma_int16* pSamplesIn, ma_uint64 sampleCount, float factor);
MA_API void ma_copy_and_apply_volume_factor_s24(void* pSamplesOut, const void* pSamplesIn, ma_uint64 sampleCount, float factor);
MA_API void ma_copy_and_apply_volume_factor_s32(ma_int32* pSamplesOut, const ma_int32* pSamplesIn, ma_uint64 sampleCount, float factor);
MA_API void ma_copy_and_apply_volume_factor_f32(float* pSamplesOut, const float* pSamplesIn, ma_uint64 sampleCount, float factor);

MA_API void ma_apply_volume_factor_u8(ma_uint8* pSamples, ma_uint64 sampleCount, float factor);
MA_API void ma_apply_volume_factor_s16(ma_int16* pSamples, ma_uint64 sampleCount, float factor);
MA_API void ma_apply_volume_factor_s24(void* pSamples, ma_uint64 sampleCount, float factor);
MA_API void ma_apply_volume_factor_s32(ma_int32* pSamples, ma_uint64 sampleCount, float factor);
MA_API void ma_apply_volume_factor_f32(float* pSamples, ma_uint64 sampleCount, float factor);

MA_API void ma_copy_and_apply_volume_factor_pcm_frames_u8(ma_uint8* pFramesOut, const ma_uint8* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float factor);
MA_API void ma_copy_and_apply_volume_factor_pcm_frames_s16(ma_int16* pFramesOut, const ma_int16* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float factor);
MA_API void ma_copy_and_apply_volume_factor_pcm_frames_s24(void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float factor);
MA_API void ma_copy_and_apply_volume_factor_pcm_frames_s32(ma_int32* pFramesOut, const ma_int32* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float factor);
MA_API void ma_copy_and_apply_volume_factor_pcm_frames_f32(float* pFramesOut, const float* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float factor);
MA_API void ma_copy_and_apply_volume_factor_pcm_frames(void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount, ma_format format, ma_uint32 channels, float factor);

MA_API void ma_apply_volume_factor_pcm_frames_u8(ma_uint8* pFrames, ma_uint64 frameCount, ma_uint32 channels, float factor);
MA_API void ma_apply_volume_factor_pcm_frames_s16(ma_int16* pFrames, ma_uint64 frameCount, ma_uint32 channels, float factor);
MA_API void ma_apply_volume_factor_pcm_frames_s24(void* pFrames, ma_uint64 frameCount, ma_uint32 channels, float factor);
MA_API void ma_apply_volume_factor_pcm_frames_s32(ma_int32* pFrames, ma_uint64 frameCount, ma_uint32 channels, float factor);
MA_API void ma_apply_volume_factor_pcm_frames_f32(float* pFrames, ma_uint64 frameCount, ma_uint32 channels, float factor);
MA_API void ma_apply_volume_factor_pcm_frames(void* pFrames, ma_uint64 frameCount, ma_format format, ma_uint32 channels, float factor);

MA_API void ma_copy_and_apply_volume_factor_per_channel_f32(float* pFramesOut, const float* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float* pChannelGains);


MA_API void ma_copy_and_apply_volume_and_clip_samples_u8(ma_uint8* pDst, const ma_int16* pSrc, ma_uint64 count, float volume);
MA_API void ma_copy_and_apply_volume_and_clip_samples_s16(ma_int16* pDst, const ma_int32* pSrc, ma_uint64 count, float volume);
MA_API void ma_copy_and_apply_volume_and_clip_samples_s24(ma_uint8* pDst, const ma_int64* pSrc, ma_uint64 count, float volume);
MA_API void ma_copy_and_apply_volume_and_clip_samples_s32(ma_int32* pDst, const ma_int64* pSrc, ma_uint64 count, float volume);
MA_API void ma_copy_and_apply_volume_and_clip_samples_f32(float* pDst, const float* pSrc, ma_uint64 count, float volume);
MA_API void ma_copy_and_apply_volume_and_clip_pcm_frames(void* pDst, const void* pSrc, ma_uint64 frameCount, ma_format format, ma_uint32 channels, float volume);


/*
Helper for converting a linear factor to gain in decibels.
*/
MA_API float ma_volume_linear_to_db(float factor);

/*
Helper for converting gain in decibels to a linear factor.
*/
MA_API float ma_volume_db_to_linear(float gain);


/*
Mixes the specified number of frames in floating point format with a volume factor.

This will run on an optimized path when the volume is equal to 1.
*/
MA_API ma_result ma_mix_pcm_frames_f32(float* pDst, const float* pSrc, ma_uint64 frameCount, ma_uint32 channels, float volume);




/************************************************************************************************************************************************************

VFS
===

The VFS object (virtual file system) is what's used to customize file access. This is useful in cases where stdio FILE* based APIs may not be entirely
appropriate for a given situation.

************************************************************************************************************************************************************/
typedef void      ma_vfs;
typedef ma_handle ma_vfs_file;

typedef enum
{
    MA_OPEN_MODE_READ  = 0x00000001,
    MA_OPEN_MODE_WRITE = 0x00000002
} ma_open_mode_flags;

typedef enum
{
    ma_seek_origin_start,
    ma_seek_origin_current,
    ma_seek_origin_end  /* Not used by decoders. */
} ma_seek_origin;

typedef struct
{
    ma_uint64 sizeInBytes;
} ma_file_info;

typedef struct
{
    ma_result (* onOpen) (ma_vfs* pVFS, const char* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile);
    ma_result (* onOpenW)(ma_vfs* pVFS, const wchar_t* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile);
    ma_result (* onClose)(ma_vfs* pVFS, ma_vfs_file file);
    ma_result (* onRead) (ma_vfs* pVFS, ma_vfs_file file, void* pDst, size_t sizeInBytes, size_t* pBytesRead);
    ma_result (* onWrite)(ma_vfs* pVFS, ma_vfs_file file, const void* pSrc, size_t sizeInBytes, size_t* pBytesWritten);
    ma_result (* onSeek) (ma_vfs* pVFS, ma_vfs_file file, ma_int64 offset, ma_seek_origin origin);
    ma_result (* onTell) (ma_vfs* pVFS, ma_vfs_file file, ma_int64* pCursor);
    ma_result (* onInfo) (ma_vfs* pVFS, ma_vfs_file file, ma_file_info* pInfo);
} ma_vfs_callbacks;

MA_API ma_result ma_vfs_open(ma_vfs* pVFS, const char* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile);
MA_API ma_result ma_vfs_open_w(ma_vfs* pVFS, const wchar_t* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile);
MA_API ma_result ma_vfs_close(ma_vfs* pVFS, ma_vfs_file file);
MA_API ma_result ma_vfs_read(ma_vfs* pVFS, ma_vfs_file file, void* pDst, size_t sizeInBytes, size_t* pBytesRead);
MA_API ma_result ma_vfs_write(ma_vfs* pVFS, ma_vfs_file file, const void* pSrc, size_t sizeInBytes, size_t* pBytesWritten);
MA_API ma_result ma_vfs_seek(ma_vfs* pVFS, ma_vfs_file file, ma_int64 offset, ma_seek_origin origin);
MA_API ma_result ma_vfs_tell(ma_vfs* pVFS, ma_vfs_file file, ma_int64* pCursor);
MA_API ma_result ma_vfs_info(ma_vfs* pVFS, ma_vfs_file file, ma_file_info* pInfo);
MA_API ma_result ma_vfs_open_and_read_file(ma_vfs* pVFS, const char* pFilePath, void** ppData, size_t* pSize, const ma_allocation_callbacks* pAllocationCallbacks);

typedef struct
{
    ma_vfs_callbacks cb;
    ma_allocation_callbacks allocationCallbacks;    /* Only used for the wchar_t version of open() on non-Windows platforms. */
} ma_default_vfs;

MA_API ma_result ma_default_vfs_init(ma_default_vfs* pVFS, const ma_allocation_callbacks* pAllocationCallbacks);



typedef ma_result (* ma_read_proc)(void* pUserData, void* pBufferOut, size_t bytesToRead, size_t* pBytesRead);
typedef ma_result (* ma_seek_proc)(void* pUserData, ma_int64 offset, ma_seek_origin origin);
typedef ma_result (* ma_tell_proc)(void* pUserData, ma_int64* pCursor);



#if !defined(MA_NO_DECODING) || !defined(MA_NO_ENCODING)
typedef enum
{
    ma_encoding_format_unknown = 0,
    ma_encoding_format_wav,
    ma_encoding_format_flac,
    ma_encoding_format_mp3,
    ma_encoding_format_vorbis
} ma_encoding_format;
#endif

/************************************************************************************************************************************************************

Decoding
========

Decoders are independent of the main device API. Decoding APIs can be called freely inside the device's data callback, but they are not thread safe unless
you do your own synchronization.

************************************************************************************************************************************************************/
#ifndef MA_NO_DECODING
typedef struct ma_decoder ma_decoder;


typedef struct
{
    ma_format preferredFormat;
    ma_uint32 seekPointCount;   /* Set to > 0 to generate a seektable if the decoding backend supports it. */
} ma_decoding_backend_config;

MA_API ma_decoding_backend_config ma_decoding_backend_config_init(ma_format preferredFormat, ma_uint32 seekPointCount);


typedef struct
{
    ma_result (* onInit      )(void* pUserData, ma_read_proc onRead, ma_seek_proc onSeek, ma_tell_proc onTell, void* pReadSeekTellUserData, const ma_decoding_backend_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_data_source** ppBackend);
    ma_result (* onInitFile  )(void* pUserData, const char* pFilePath, const ma_decoding_backend_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_data_source** ppBackend);               /* Optional. */
    ma_result (* onInitFileW )(void* pUserData, const wchar_t* pFilePath, const ma_decoding_backend_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_data_source** ppBackend);            /* Optional. */
    ma_result (* onInitMemory)(void* pUserData, const void* pData, size_t dataSize, const ma_decoding_backend_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_data_source** ppBackend);  /* Optional. */
    void      (* onUninit    )(void* pUserData, ma_data_source* pBackend, const ma_allocation_callbacks* pAllocationCallbacks);
} ma_decoding_backend_vtable;


typedef ma_result (* ma_decoder_read_proc)(ma_decoder* pDecoder, void* pBufferOut, size_t bytesToRead, size_t* pBytesRead);         /* Returns the number of bytes read. */
typedef ma_result (* ma_decoder_seek_proc)(ma_decoder* pDecoder, ma_int64 byteOffset, ma_seek_origin origin);
typedef ma_result (* ma_decoder_tell_proc)(ma_decoder* pDecoder, ma_int64* pCursor);

typedef struct
{
    ma_format format;      /* Set to 0 or ma_format_unknown to use the stream's internal format. */
    ma_uint32 channels;    /* Set to 0 to use the stream's internal channels. */
    ma_uint32 sampleRate;  /* Set to 0 to use the stream's internal sample rate. */
    ma_channel* pChannelMap;
    ma_channel_mix_mode channelMixMode;
    ma_dither_mode ditherMode;
    ma_resampler_config resampling;
    ma_allocation_callbacks allocationCallbacks;
    ma_encoding_format encodingFormat;
    ma_uint32 seekPointCount;   /* When set to > 0, specifies the number of seek points to use for the generation of a seek table. Not all decoding backends support this. */
    ma_decoding_backend_vtable** ppCustomBackendVTables;
    ma_uint32 customBackendCount;
    void* pCustomBackendUserData;
} ma_decoder_config;

struct ma_decoder
{
    ma_data_source_base ds;
    ma_data_source* pBackend;                   /* The decoding backend we'll be pulling data from. */
    const ma_decoding_backend_vtable* pBackendVTable; /* The vtable for the decoding backend. This needs to be stored so we can access the onUninit() callback. */
    void* pBackendUserData;
    ma_decoder_read_proc onRead;
    ma_decoder_seek_proc onSeek;
    ma_decoder_tell_proc onTell;
    void* pUserData;
    ma_uint64 readPointerInPCMFrames;      /* In output sample rate. Used for keeping track of how many frames are available for decoding. */
    ma_format outputFormat;
    ma_uint32 outputChannels;
    ma_uint32 outputSampleRate;
    ma_data_converter converter;    /* Data conversion is achieved by running frames through this. */
    void* pInputCache;              /* In input format. Can be null if it's not needed. */
    ma_uint64 inputCacheCap;        /* The capacity of the input cache. */
    ma_uint64 inputCacheConsumed;   /* The number of frames that have been consumed in the cache. Used for determining the next valid frame. */
    ma_uint64 inputCacheRemaining;  /* The number of valid frames remaining in the cache. */
    ma_allocation_callbacks allocationCallbacks;
    union
    {
        struct
        {
            ma_vfs* pVFS;
            ma_vfs_file file;
        } vfs;
        struct
        {
            const ma_uint8* pData;
            size_t dataSize;
            size_t currentReadPos;
        } memory;               /* Only used for decoders that were opened against a block of memory. */
    } data;
};

MA_API ma_decoder_config ma_decoder_config_init(ma_format outputFormat, ma_uint32 outputChannels, ma_uint32 outputSampleRate);
MA_API ma_decoder_config ma_decoder_config_init_default(void);

MA_API ma_result ma_decoder_init(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
MA_API ma_result ma_decoder_init_memory(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
MA_API ma_result ma_decoder_init_vfs(ma_vfs* pVFS, const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
MA_API ma_result ma_decoder_init_vfs_w(ma_vfs* pVFS, const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
MA_API ma_result ma_decoder_init_file(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
MA_API ma_result ma_decoder_init_file_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);

/*
Uninitializes a decoder.
*/
MA_API ma_result ma_decoder_uninit(ma_decoder* pDecoder);

/*
Reads PCM frames from the given decoder.

This is not thread safe without your own synchronization.
*/
MA_API ma_result ma_decoder_read_pcm_frames(ma_decoder* pDecoder, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead);

/*
Seeks to a PCM frame based on its absolute index.

This is not thread safe without your own synchronization.
*/
MA_API ma_result ma_decoder_seek_to_pcm_frame(ma_decoder* pDecoder, ma_uint64 frameIndex);

/*
Retrieves the decoder's output data format.
*/
MA_API ma_result ma_decoder_get_data_format(ma_decoder* pDecoder, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap);

/*
Retrieves the current position of the read cursor in PCM frames.
*/
MA_API ma_result ma_decoder_get_cursor_in_pcm_frames(ma_decoder* pDecoder, ma_uint64* pCursor);

/*
Retrieves the length of the decoder in PCM frames.

Do not call this on streams of an undefined length, such as internet radio.

If the length is unknown or an error occurs, 0 will be returned.

This will always return 0 for Vorbis decoders. This is due to a limitation with stb_vorbis in push mode which is what miniaudio
uses internally.

For MP3's, this will decode the entire file. Do not call this in time critical scenarios.

This function is not thread safe without your own synchronization.
*/
MA_API ma_result ma_decoder_get_length_in_pcm_frames(ma_decoder* pDecoder, ma_uint64* pLength);

/*
Retrieves the number of frames that can be read before reaching the end.

This calls `ma_decoder_get_length_in_pcm_frames()` so you need to be aware of the rules for that function, in
particular ensuring you do not call it on streams of an undefined length, such as internet radio.

If the total length of the decoder cannot be retrieved, such as with Vorbis decoders, `MA_NOT_IMPLEMENTED` will be
returned.
*/
MA_API ma_result ma_decoder_get_available_frames(ma_decoder* pDecoder, ma_uint64* pAvailableFrames);

/*
Helper for opening and decoding a file into a heap allocated block of memory. Free the returned pointer with ma_free(). On input,
pConfig should be set to what you want. On output it will be set to what you got.
*/
MA_API ma_result ma_decode_from_vfs(ma_vfs* pVFS, const char* pFilePath, ma_decoder_config* pConfig, ma_uint64* pFrameCountOut, void** ppPCMFramesOut);
MA_API ma_result ma_decode_file(const char* pFilePath, ma_decoder_config* pConfig, ma_uint64* pFrameCountOut, void** ppPCMFramesOut);
MA_API ma_result ma_decode_memory(const void* pData, size_t dataSize, ma_decoder_config* pConfig, ma_uint64* pFrameCountOut, void** ppPCMFramesOut);

#endif  /* MA_NO_DECODING */


/************************************************************************************************************************************************************

Encoding
========

Encoders do not perform any format conversion for you. If your target format does not support the format, and error will be returned.

************************************************************************************************************************************************************/


/************************************************************************************************************************************************************

Generation

************************************************************************************************************************************************************/



/************************************************************************************************************************************************************

Resource Manager

************************************************************************************************************************************************************/
/* The resource manager cannot be enabled if there is no decoder. */
#if !defined(MA_NO_RESOURCE_MANAGER) && defined(MA_NO_DECODING)
#define MA_NO_RESOURCE_MANAGER
#endif

#ifndef MA_NO_RESOURCE_MANAGER
typedef struct ma_resource_manager                  ma_resource_manager;
typedef struct ma_resource_manager_data_buffer_node ma_resource_manager_data_buffer_node;
typedef struct ma_resource_manager_data_buffer      ma_resource_manager_data_buffer;
typedef struct ma_resource_manager_data_stream      ma_resource_manager_data_stream;
typedef struct ma_resource_manager_data_source      ma_resource_manager_data_source;

typedef enum
{
    MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM         = 0x00000001,   /* When set, does not load the entire data source in memory. Disk I/O will happen on job threads. */
    MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_DECODE         = 0x00000002,   /* Decode data before storing in memory. When set, decoding is done at the resource manager level rather than the mixing thread. Results in faster mixing, but higher memory usage. */
    MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC          = 0x00000004,   /* When set, the resource manager will load the data source asynchronously. */
    MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT      = 0x00000008,   /* When set, waits for initialization of the underlying data source before returning from ma_resource_manager_data_source_init(). */
    MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_UNKNOWN_LENGTH = 0x00000010,   /* Gives the resource manager a hint that the length of the data source is unknown and calling `ma_data_source_get_length_in_pcm_frames()` should be avoided. */
    MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_LOOPING        = 0x00000020    /* When set, configures the data source to loop by default. */
} ma_resource_manager_data_source_flags;


/*
Pipeline notifications used by the resource manager. Made up of both an async notification and a fence, both of which are optional.
*/
typedef struct
{
    ma_async_notification* pNotification;
    ma_fence* pFence;
} ma_resource_manager_pipeline_stage_notification;

typedef struct
{
    ma_resource_manager_pipeline_stage_notification init;    /* Initialization of the decoder. */
    ma_resource_manager_pipeline_stage_notification done;    /* Decoding fully completed. */
} ma_resource_manager_pipeline_notifications;

MA_API ma_resource_manager_pipeline_notifications ma_resource_manager_pipeline_notifications_init(void);



/* BEGIN BACKWARDS COMPATIBILITY */
/* TODO: Remove this block in version 0.12. */
#if 1
#define ma_resource_manager_job                         ma_job
#define ma_resource_manager_job_init                    ma_job_init
#define MA_JOB_TYPE_RESOURCE_MANAGER_QUEUE_FLAG_NON_BLOCKING MA_JOB_QUEUE_FLAG_NON_BLOCKING
#define ma_resource_manager_job_queue_config            ma_job_queue_config
#define ma_resource_manager_job_queue_config_init       ma_job_queue_config_init
#define ma_resource_manager_job_queue                   ma_job_queue
#define ma_resource_manager_job_queue_get_heap_size     ma_job_queue_get_heap_size
#define ma_resource_manager_job_queue_init_preallocated ma_job_queue_init_preallocated
#define ma_resource_manager_job_queue_init              ma_job_queue_init
#define ma_resource_manager_job_queue_uninit            ma_job_queue_uninit
#define ma_resource_manager_job_queue_post              ma_job_queue_post
#define ma_resource_manager_job_queue_next              ma_job_queue_next
#endif
/* END BACKWARDS COMPATIBILITY */




/* Maximum job thread count will be restricted to this, but this may be removed later and replaced with a heap allocation thereby removing any limitation. */
#ifndef MA_RESOURCE_MANAGER_MAX_JOB_THREAD_COUNT
#define MA_RESOURCE_MANAGER_MAX_JOB_THREAD_COUNT    64
#endif

typedef enum
{
    /* Indicates ma_resource_manager_next_job() should not block. Only valid when the job thread count is 0. */
    MA_RESOURCE_MANAGER_FLAG_NON_BLOCKING = 0x00000001,

    /* Disables any kind of multithreading. Implicitly enables MA_RESOURCE_MANAGER_FLAG_NON_BLOCKING. */
    MA_RESOURCE_MANAGER_FLAG_NO_THREADING = 0x00000002
} ma_resource_manager_flags;

typedef struct
{
    const char* pFilePath;
    const wchar_t* pFilePathW;
    const ma_resource_manager_pipeline_notifications* pNotifications;
    ma_uint64 initialSeekPointInPCMFrames;
    ma_uint64 rangeBegInPCMFrames;
    ma_uint64 rangeEndInPCMFrames;
    ma_uint64 loopPointBegInPCMFrames;
    ma_uint64 loopPointEndInPCMFrames;
    ma_uint32 flags;
    ma_bool32 isLooping;    /* Deprecated. Use the MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_LOOPING flag in `flags` instead. */
} ma_resource_manager_data_source_config;

MA_API ma_resource_manager_data_source_config ma_resource_manager_data_source_config_init(void);


typedef enum
{
    ma_resource_manager_data_supply_type_unknown = 0,   /* Used for determining whether or the data supply has been initialized. */
    ma_resource_manager_data_supply_type_encoded,       /* Data supply is an encoded buffer. Connector is ma_decoder. */
    ma_resource_manager_data_supply_type_decoded,       /* Data supply is a decoded buffer. Connector is ma_audio_buffer. */
    ma_resource_manager_data_supply_type_decoded_paged  /* Data supply is a linked list of decoded buffers. Connector is ma_paged_audio_buffer. */
} ma_resource_manager_data_supply_type;

typedef struct
{
    MA_ATOMIC(4, ma_resource_manager_data_supply_type) type;    /* Read and written from different threads so needs to be accessed atomically. */
    union
    {
        struct
        {
            const void* pData;
            size_t sizeInBytes;
        } encoded;
        struct
        {
            const void* pData;
            ma_uint64 totalFrameCount;
            ma_uint64 decodedFrameCount;
            ma_format format;
            ma_uint32 channels;
            ma_uint32 sampleRate;
        } decoded;
        struct
        {
            ma_paged_audio_buffer_data data;
            ma_uint64 decodedFrameCount;
            ma_uint32 sampleRate;
        } decodedPaged;
    } backend;
} ma_resource_manager_data_supply;

struct ma_resource_manager_data_buffer_node
{
    ma_uint32 hashedName32;                         /* The hashed name. This is the key. */
    ma_uint32 refCount;
    MA_ATOMIC(4, ma_result) result;                 /* Result from asynchronous loading. When loading set to MA_BUSY. When fully loaded set to MA_SUCCESS. When deleting set to MA_UNAVAILABLE. */
    MA_ATOMIC(4, ma_uint32) executionCounter;       /* For allocating execution orders for jobs. */
    MA_ATOMIC(4, ma_uint32) executionPointer;       /* For managing the order of execution for asynchronous jobs relating to this object. Incremented as jobs complete processing. */
    ma_bool32 isDataOwnedByResourceManager;         /* Set to true when the underlying data buffer was allocated the resource manager. Set to false if it is owned by the application (via ma_resource_manager_register_*()). */
    ma_resource_manager_data_supply data;
    ma_resource_manager_data_buffer_node* pParent;
    ma_resource_manager_data_buffer_node* pChildLo;
    ma_resource_manager_data_buffer_node* pChildHi;
};

struct ma_resource_manager_data_buffer
{
    ma_data_source_base ds;                         /* Base data source. A data buffer is a data source. */
    ma_resource_manager* pResourceManager;          /* A pointer to the resource manager that owns this buffer. */
    ma_resource_manager_data_buffer_node* pNode;    /* The data node. This is reference counted and is what supplies the data. */
    ma_uint32 flags;                                /* The flags that were passed used to initialize the buffer. */
    MA_ATOMIC(4, ma_uint32) executionCounter;       /* For allocating execution orders for jobs. */
    MA_ATOMIC(4, ma_uint32) executionPointer;       /* For managing the order of execution for asynchronous jobs relating to this object. Incremented as jobs complete processing. */
    ma_uint64 seekTargetInPCMFrames;                /* Only updated by the public API. Never written nor read from the job thread. */
    ma_bool32 seekToCursorOnNextRead;               /* On the next read we need to seek to the frame cursor. */
    MA_ATOMIC(4, ma_result) result;                 /* Keeps track of a result of decoding. Set to MA_BUSY while the buffer is still loading. Set to MA_SUCCESS when loading is finished successfully. Otherwise set to some other code. */
    MA_ATOMIC(4, ma_bool32) isLooping;              /* Can be read and written by different threads at the same time. Must be used atomically. */
    ma_atomic_bool32 isConnectorInitialized;        /* Used for asynchronous loading to ensure we don't try to initialize the connector multiple times while waiting for the node to fully load. */
    union
    {
        ma_decoder decoder;                 /* Supply type is ma_resource_manager_data_supply_type_encoded */
        ma_audio_buffer buffer;             /* Supply type is ma_resource_manager_data_supply_type_decoded */
        ma_paged_audio_buffer pagedBuffer;  /* Supply type is ma_resource_manager_data_supply_type_decoded_paged */
    } connector;    /* Connects this object to the node's data supply. */
};

struct ma_resource_manager_data_stream
{
    ma_data_source_base ds;                     /* Base data source. A data stream is a data source. */
    ma_resource_manager* pResourceManager;      /* A pointer to the resource manager that owns this data stream. */
    ma_uint32 flags;                            /* The flags that were passed used to initialize the stream. */
    ma_decoder decoder;                         /* Used for filling pages with data. This is only ever accessed by the job thread. The public API should never touch this. */
    ma_bool32 isDecoderInitialized;             /* Required for determining whether or not the decoder should be uninitialized in MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_STREAM. */
    ma_uint64 totalLengthInPCMFrames;           /* This is calculated when first loaded by the MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_STREAM. */
    ma_uint32 relativeCursor;                   /* The playback cursor, relative to the current page. Only ever accessed by the public API. Never accessed by the job thread. */
    MA_ATOMIC(8, ma_uint64) absoluteCursor;     /* The playback cursor, in absolute position starting from the start of the file. */
    ma_uint32 currentPageIndex;                 /* Toggles between 0 and 1. Index 0 is the first half of pPageData. Index 1 is the second half. Only ever accessed by the public API. Never accessed by the job thread. */
    MA_ATOMIC(4, ma_uint32) executionCounter;   /* For allocating execution orders for jobs. */
    MA_ATOMIC(4, ma_uint32) executionPointer;   /* For managing the order of execution for asynchronous jobs relating to this object. Incremented as jobs complete processing. */

    /* Written by the public API, read by the job thread. */
    MA_ATOMIC(4, ma_bool32) isLooping;          /* Whether or not the stream is looping. It's important to set the looping flag at the data stream level for smooth loop transitions. */

    /* Written by the job thread, read by the public API. */
    void* pPageData;                            /* Buffer containing the decoded data of each page. Allocated once at initialization time. */
    MA_ATOMIC(4, ma_uint32) pageFrameCount[2];  /* The number of valid PCM frames in each page. Used to determine the last valid frame. */

    /* Written and read by both the public API and the job thread. These must be atomic. */
    MA_ATOMIC(4, ma_result) result;             /* Result from asynchronous loading. When loading set to MA_BUSY. When initialized set to MA_SUCCESS. When deleting set to MA_UNAVAILABLE. If an error occurs when loading, set to an error code. */
    MA_ATOMIC(4, ma_bool32) isDecoderAtEnd;     /* Whether or not the decoder has reached the end. */
    MA_ATOMIC(4, ma_bool32) isPageValid[2];     /* Booleans to indicate whether or not a page is valid. Set to false by the public API, set to true by the job thread. Set to false as the pages are consumed, true when they are filled. */
    MA_ATOMIC(4, ma_bool32) seekCounter;        /* When 0, no seeking is being performed. When > 0, a seek is being performed and reading should be delayed with MA_BUSY. */
};

struct ma_resource_manager_data_source
{
    union
    {
        ma_resource_manager_data_buffer buffer;
        ma_resource_manager_data_stream stream;
    } backend;  /* Must be the first item because we need the first item to be the data source callbacks for the buffer or stream. */

    ma_uint32 flags;                          /* The flags that were passed in to ma_resource_manager_data_source_init(). */
    MA_ATOMIC(4, ma_uint32) executionCounter;     /* For allocating execution orders for jobs. */
    MA_ATOMIC(4, ma_uint32) executionPointer;     /* For managing the order of execution for asynchronous jobs relating to this object. Incremented as jobs complete processing. */
};

typedef struct
{
    ma_allocation_callbacks allocationCallbacks;
    ma_log* pLog;
    ma_format decodedFormat;        /* The decoded format to use. Set to ma_format_unknown (default) to use the file's native format. */
    ma_uint32 decodedChannels;      /* The decoded channel count to use. Set to 0 (default) to use the file's native channel count. */
    ma_uint32 decodedSampleRate;    /* the decoded sample rate to use. Set to 0 (default) to use the file's native sample rate. */
    ma_uint32 jobThreadCount;       /* Set to 0 if you want to self-manage your job threads. Defaults to 1. */
    size_t jobThreadStackSize;
    ma_uint32 jobQueueCapacity;     /* The maximum number of jobs that can fit in the queue at a time. Defaults to MA_JOB_TYPE_RESOURCE_MANAGER_QUEUE_CAPACITY. Cannot be zero. */
    ma_uint32 flags;
    ma_vfs* pVFS;                   /* Can be NULL in which case defaults will be used. */
    ma_decoding_backend_vtable** ppCustomDecodingBackendVTables;
    ma_uint32 customDecodingBackendCount;
    void* pCustomDecodingBackendUserData;
} ma_resource_manager_config;

MA_API ma_resource_manager_config ma_resource_manager_config_init(void);

struct ma_resource_manager
{
    ma_resource_manager_config config;
    ma_resource_manager_data_buffer_node* pRootDataBufferNode;      /* The root buffer in the binary tree. */
#ifndef MA_NO_THREADING
    ma_mutex dataBufferBSTLock;                                     /* For synchronizing access to the data buffer binary tree. */
    ma_thread jobThreads[MA_RESOURCE_MANAGER_MAX_JOB_THREAD_COUNT]; /* The threads for executing jobs. */
#endif
    ma_job_queue jobQueue;                                          /* Multi-consumer, multi-producer job queue for managing jobs for asynchronous decoding and streaming. */
    ma_default_vfs defaultVFS;                                      /* Only used if a custom VFS is not specified. */
    ma_log log;                                                     /* Only used if no log was specified in the config. */
};

/* Init. */
MA_API ma_result ma_resource_manager_init(const ma_resource_manager_config* pConfig, ma_resource_manager* pResourceManager);
MA_API void ma_resource_manager_uninit(ma_resource_manager* pResourceManager);
MA_API ma_log* ma_resource_manager_get_log(ma_resource_manager* pResourceManager);

/* Registration. */
MA_API ma_result ma_resource_manager_register_file(ma_resource_manager* pResourceManager, const char* pFilePath, ma_uint32 flags);
MA_API ma_result ma_resource_manager_register_file_w(ma_resource_manager* pResourceManager, const wchar_t* pFilePath, ma_uint32 flags);
MA_API ma_result ma_resource_manager_register_decoded_data(ma_resource_manager* pResourceManager, const char* pName, const void* pData, ma_uint64 frameCount, ma_format format, ma_uint32 channels, ma_uint32 sampleRate);  /* Does not copy. Increments the reference count if already exists and returns MA_SUCCESS. */
MA_API ma_result ma_resource_manager_register_decoded_data_w(ma_resource_manager* pResourceManager, const wchar_t* pName, const void* pData, ma_uint64 frameCount, ma_format format, ma_uint32 channels, ma_uint32 sampleRate);
MA_API ma_result ma_resource_manager_register_encoded_data(ma_resource_manager* pResourceManager, const char* pName, const void* pData, size_t sizeInBytes);    /* Does not copy. Increments the reference count if already exists and returns MA_SUCCESS. */
MA_API ma_result ma_resource_manager_register_encoded_data_w(ma_resource_manager* pResourceManager, const wchar_t* pName, const void* pData, size_t sizeInBytes);
MA_API ma_result ma_resource_manager_unregister_file(ma_resource_manager* pResourceManager, const char* pFilePath);
MA_API ma_result ma_resource_manager_unregister_file_w(ma_resource_manager* pResourceManager, const wchar_t* pFilePath);
MA_API ma_result ma_resource_manager_unregister_data(ma_resource_manager* pResourceManager, const char* pName);
MA_API ma_result ma_resource_manager_unregister_data_w(ma_resource_manager* pResourceManager, const wchar_t* pName);

/* Data Buffers. */
MA_API ma_result ma_resource_manager_data_buffer_init_ex(ma_resource_manager* pResourceManager, const ma_resource_manager_data_source_config* pConfig, ma_resource_manager_data_buffer* pDataBuffer);
MA_API ma_result ma_resource_manager_data_buffer_init(ma_resource_manager* pResourceManager, const char* pFilePath, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_buffer* pDataBuffer);
MA_API ma_result ma_resource_manager_data_buffer_init_w(ma_resource_manager* pResourceManager, const wchar_t* pFilePath, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_buffer* pDataBuffer);
MA_API ma_result ma_resource_manager_data_buffer_init_copy(ma_resource_manager* pResourceManager, const ma_resource_manager_data_buffer* pExistingDataBuffer, ma_resource_manager_data_buffer* pDataBuffer);
MA_API ma_result ma_resource_manager_data_buffer_uninit(ma_resource_manager_data_buffer* pDataBuffer);
MA_API ma_result ma_resource_manager_data_buffer_read_pcm_frames(ma_resource_manager_data_buffer* pDataBuffer, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead);
MA_API ma_result ma_resource_manager_data_buffer_seek_to_pcm_frame(ma_resource_manager_data_buffer* pDataBuffer, ma_uint64 frameIndex);
MA_API ma_result ma_resource_manager_data_buffer_get_data_format(ma_resource_manager_data_buffer* pDataBuffer, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap);
MA_API ma_result ma_resource_manager_data_buffer_get_cursor_in_pcm_frames(ma_resource_manager_data_buffer* pDataBuffer, ma_uint64* pCursor);
MA_API ma_result ma_resource_manager_data_buffer_get_length_in_pcm_frames(ma_resource_manager_data_buffer* pDataBuffer, ma_uint64* pLength);
MA_API ma_result ma_resource_manager_data_buffer_result(const ma_resource_manager_data_buffer* pDataBuffer);
MA_API ma_result ma_resource_manager_data_buffer_set_looping(ma_resource_manager_data_buffer* pDataBuffer, ma_bool32 isLooping);
MA_API ma_bool32 ma_resource_manager_data_buffer_is_looping(const ma_resource_manager_data_buffer* pDataBuffer);
MA_API ma_result ma_resource_manager_data_buffer_get_available_frames(ma_resource_manager_data_buffer* pDataBuffer, ma_uint64* pAvailableFrames);

/* Data Streams. */
MA_API ma_result ma_resource_manager_data_stream_init_ex(ma_resource_manager* pResourceManager, const ma_resource_manager_data_source_config* pConfig, ma_resource_manager_data_stream* pDataStream);
MA_API ma_result ma_resource_manager_data_stream_init(ma_resource_manager* pResourceManager, const char* pFilePath, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_stream* pDataStream);
MA_API ma_result ma_resource_manager_data_stream_init_w(ma_resource_manager* pResourceManager, const wchar_t* pFilePath, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_stream* pDataStream);
MA_API ma_result ma_resource_manager_data_stream_uninit(ma_resource_manager_data_stream* pDataStream);
MA_API ma_result ma_resource_manager_data_stream_read_pcm_frames(ma_resource_manager_data_stream* pDataStream, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead);
MA_API ma_result ma_resource_manager_data_stream_seek_to_pcm_frame(ma_resource_manager_data_stream* pDataStream, ma_uint64 frameIndex);
MA_API ma_result ma_resource_manager_data_stream_get_data_format(ma_resource_manager_data_stream* pDataStream, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap);
MA_API ma_result ma_resource_manager_data_stream_get_cursor_in_pcm_frames(ma_resource_manager_data_stream* pDataStream, ma_uint64* pCursor);
MA_API ma_result ma_resource_manager_data_stream_get_length_in_pcm_frames(ma_resource_manager_data_stream* pDataStream, ma_uint64* pLength);
MA_API ma_result ma_resource_manager_data_stream_result(const ma_resource_manager_data_stream* pDataStream);
MA_API ma_result ma_resource_manager_data_stream_set_looping(ma_resource_manager_data_stream* pDataStream, ma_bool32 isLooping);
MA_API ma_bool32 ma_resource_manager_data_stream_is_looping(const ma_resource_manager_data_stream* pDataStream);
MA_API ma_result ma_resource_manager_data_stream_get_available_frames(ma_resource_manager_data_stream* pDataStream, ma_uint64* pAvailableFrames);

/* Data Sources. */
MA_API ma_result ma_resource_manager_data_source_init_ex(ma_resource_manager* pResourceManager, const ma_resource_manager_data_source_config* pConfig, ma_resource_manager_data_source* pDataSource);
MA_API ma_result ma_resource_manager_data_source_init(ma_resource_manager* pResourceManager, const char* pName, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_source* pDataSource);
MA_API ma_result ma_resource_manager_data_source_init_w(ma_resource_manager* pResourceManager, const wchar_t* pName, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_source* pDataSource);
MA_API ma_result ma_resource_manager_data_source_init_copy(ma_resource_manager* pResourceManager, const ma_resource_manager_data_source* pExistingDataSource, ma_resource_manager_data_source* pDataSource);
MA_API ma_result ma_resource_manager_data_source_uninit(ma_resource_manager_data_source* pDataSource);
MA_API ma_result ma_resource_manager_data_source_read_pcm_frames(ma_resource_manager_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead);
MA_API ma_result ma_resource_manager_data_source_seek_to_pcm_frame(ma_resource_manager_data_source* pDataSource, ma_uint64 frameIndex);
MA_API ma_result ma_resource_manager_data_source_get_data_format(ma_resource_manager_data_source* pDataSource, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap);
MA_API ma_result ma_resource_manager_data_source_get_cursor_in_pcm_frames(ma_resource_manager_data_source* pDataSource, ma_uint64* pCursor);
MA_API ma_result ma_resource_manager_data_source_get_length_in_pcm_frames(ma_resource_manager_data_source* pDataSource, ma_uint64* pLength);
MA_API ma_result ma_resource_manager_data_source_result(const ma_resource_manager_data_source* pDataSource);
MA_API ma_result ma_resource_manager_data_source_set_looping(ma_resource_manager_data_source* pDataSource, ma_bool32 isLooping);
MA_API ma_bool32 ma_resource_manager_data_source_is_looping(const ma_resource_manager_data_source* pDataSource);
MA_API ma_result ma_resource_manager_data_source_get_available_frames(ma_resource_manager_data_source* pDataSource, ma_uint64* pAvailableFrames);

/* Job management. */
MA_API ma_result ma_resource_manager_post_job(ma_resource_manager* pResourceManager, const ma_job* pJob);
MA_API ma_result ma_resource_manager_post_job_quit(ma_resource_manager* pResourceManager);  /* Helper for posting a quit job. */
MA_API ma_result ma_resource_manager_next_job(ma_resource_manager* pResourceManager, ma_job* pJob);
MA_API ma_result ma_resource_manager_process_job(ma_resource_manager* pResourceManager, ma_job* pJob);  /* DEPRECATED. Use ma_job_process(). Will be removed in version 0.12. */
MA_API ma_result ma_resource_manager_process_next_job(ma_resource_manager* pResourceManager);   /* Returns MA_CANCELLED if a MA_JOB_TYPE_QUIT job is found. In non-blocking mode, returns MA_NO_DATA_AVAILABLE if no jobs are available. */
#endif  /* MA_NO_RESOURCE_MANAGER */



/************************************************************************************************************************************************************

Node Graph

************************************************************************************************************************************************************/
#ifndef MA_NO_NODE_GRAPH
/* Must never exceed 254. */
#ifndef MA_MAX_NODE_BUS_COUNT
#define MA_MAX_NODE_BUS_COUNT       254
#endif

/* Used internally by miniaudio for memory management. Must never exceed MA_MAX_NODE_BUS_COUNT. */
#ifndef MA_MAX_NODE_LOCAL_BUS_COUNT
#define MA_MAX_NODE_LOCAL_BUS_COUNT 2
#endif

/* Use this when the bus count is determined by the node instance rather than the vtable. */
#define MA_NODE_BUS_COUNT_UNKNOWN   255


/* For some internal memory management of ma_node_graph. */
typedef struct
{
    size_t offset;
    size_t sizeInBytes;
    unsigned char _data[1];
} ma_stack;


typedef struct ma_node_graph ma_node_graph;
typedef void ma_node;


/* Node flags. */
typedef enum
{
    MA_NODE_FLAG_PASSTHROUGH                = 0x00000001,
    MA_NODE_FLAG_CONTINUOUS_PROCESSING      = 0x00000002,
    MA_NODE_FLAG_ALLOW_NULL_INPUT           = 0x00000004,
    MA_NODE_FLAG_DIFFERENT_PROCESSING_RATES = 0x00000008,
    MA_NODE_FLAG_SILENT_OUTPUT              = 0x00000010
} ma_node_flags;


/* The playback state of a node. Either started or stopped. */
typedef enum
{
    ma_node_state_started = 0,
    ma_node_state_stopped = 1
} ma_node_state;


typedef struct
{
    /*
    Extended processing callback. This callback is used for effects that process input and output
    at different rates (i.e. they perform resampling). This is similar to the simple version, only
    they take two separate frame counts: one for input, and one for output.

    On input, `pFrameCountOut` is equal to the capacity of the output buffer for each bus, whereas
    `pFrameCountIn` will be equal to the number of PCM frames in each of the buffers in `ppFramesIn`.

    On output, set `pFrameCountOut` to the number of PCM frames that were actually output and set
    `pFrameCountIn` to the number of input frames that were consumed.
    */
    void (* onProcess)(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut);

    /*
    A callback for retrieving the number of input frames that are required to output the
    specified number of output frames. You would only want to implement this when the node performs
    resampling. This is optional, even for nodes that perform resampling, but it does offer a
    small reduction in latency as it allows miniaudio to calculate the exact number of input frames
    to read at a time instead of having to estimate.
    */
    ma_result (* onGetRequiredInputFrameCount)(ma_node* pNode, ma_uint32 outputFrameCount, ma_uint32* pInputFrameCount);

    /*
    The number of input buses. This is how many sub-buffers will be contained in the `ppFramesIn`
    parameters of the callbacks above.
    */
    ma_uint8 inputBusCount;

    /*
    The number of output buses. This is how many sub-buffers will be contained in the `ppFramesOut`
    parameters of the callbacks above.
    */
    ma_uint8 outputBusCount;

    /*
    Flags describing characteristics of the node. This is currently just a placeholder for some
    ideas for later on.
    */
    ma_uint32 flags;
} ma_node_vtable;

typedef struct
{
    const ma_node_vtable* vtable;       /* Should never be null. Initialization of the node will fail if so. */
    ma_node_state initialState;         /* Defaults to ma_node_state_started. */
    ma_uint32 inputBusCount;            /* Only used if the vtable specifies an input bus count of `MA_NODE_BUS_COUNT_UNKNOWN`, otherwise must be set to `MA_NODE_BUS_COUNT_UNKNOWN` (default). */
    ma_uint32 outputBusCount;           /* Only used if the vtable specifies an output bus count of `MA_NODE_BUS_COUNT_UNKNOWN`, otherwise  be set to `MA_NODE_BUS_COUNT_UNKNOWN` (default). */
    const ma_uint32* pInputChannels;    /* The number of elements are determined by the input bus count as determined by the vtable, or `inputBusCount` if the vtable specifies `MA_NODE_BUS_COUNT_UNKNOWN`. */
    const ma_uint32* pOutputChannels;   /* The number of elements are determined by the output bus count as determined by the vtable, or `outputBusCount` if the vtable specifies `MA_NODE_BUS_COUNT_UNKNOWN`. */
} ma_node_config;

MA_API ma_node_config ma_node_config_init(void);


/*
A node has multiple output buses. An output bus is attached to an input bus as an item in a linked
list. Think of the input bus as a linked list, with the output bus being an item in that list.
*/
typedef struct ma_node_output_bus ma_node_output_bus;
struct ma_node_output_bus
{
    /* Immutable. */
    ma_node* pNode;                                         /* The node that owns this output bus. The input node. Will be null for dummy head and tail nodes. */
    ma_uint8 outputBusIndex;                                /* The index of the output bus on pNode that this output bus represents. */
    ma_uint8 channels;                                      /* The number of channels in the audio stream for this bus. */

    /* Mutable via multiple threads. Must be used atomically. The weird ordering here is for packing reasons. */
    ma_uint8 inputNodeInputBusIndex;                        /* The index of the input bus on the input. Required for detaching. Will only be used within the spinlock so does not need to be atomic. */
    MA_ATOMIC(4, ma_uint32) flags;                          /* Some state flags for tracking the read state of the output buffer. A combination of MA_NODE_OUTPUT_BUS_FLAG_*. */
    MA_ATOMIC(4, ma_uint32) refCount;                       /* Reference count for some thread-safety when detaching. */
    MA_ATOMIC(4, ma_bool32) isAttached;                     /* This is used to prevent iteration of nodes that are in the middle of being detached. Used for thread safety. */
    MA_ATOMIC(4, ma_spinlock) lock;                         /* Unfortunate lock, but significantly simplifies the implementation. Required for thread-safe attaching and detaching. */
    MA_ATOMIC(4, float) volume;                             /* Linear. */
    MA_ATOMIC(MA_SIZEOF_PTR, ma_node_output_bus*) pNext;    /* If null, it's the tail node or detached. */
    MA_ATOMIC(MA_SIZEOF_PTR, ma_node_output_bus*) pPrev;    /* If null, it's the head node or detached. */
    MA_ATOMIC(MA_SIZEOF_PTR, ma_node*) pInputNode;          /* The node that this output bus is attached to. Required for detaching. */
};

/*
A node has multiple input buses. The output buses of a node are connecting to the input busses of
another. An input bus is essentially just a linked list of output buses.
*/
typedef struct ma_node_input_bus ma_node_input_bus;
struct ma_node_input_bus
{
    /* Mutable via multiple threads. */
    ma_node_output_bus head;                /* Dummy head node for simplifying some lock-free thread-safety stuff. */
    MA_ATOMIC(4, ma_uint32) nextCounter;    /* This is used to determine whether or not the input bus is finding the next node in the list. Used for thread safety when detaching output buses. */
    MA_ATOMIC(4, ma_spinlock) lock;         /* Unfortunate lock, but significantly simplifies the implementation. Required for thread-safe attaching and detaching. */

    /* Set once at startup. */
    ma_uint8 channels;                      /* The number of channels in the audio stream for this bus. */
};


typedef struct ma_node_base ma_node_base;
struct ma_node_base
{
    /* These variables are set once at startup. */
    ma_node_graph* pNodeGraph;                  /* The graph this node belongs to. */
    const ma_node_vtable* vtable;
    ma_uint32 inputBusCount;
    ma_uint32 outputBusCount;
    ma_node_input_bus* pInputBuses;
    ma_node_output_bus* pOutputBuses;
    float* pCachedData;                         /* Allocated on the heap. Fixed size. Needs to be stored on the heap because reading from output buses is done in separate function calls. */
    ma_uint16 cachedDataCapInFramesPerBus;      /* The capacity of the input data cache in frames, per bus. */

    /* These variables are read and written only from the audio thread. */
    ma_uint16 cachedFrameCountOut;
    ma_uint16 cachedFrameCountIn;
    ma_uint16 consumedFrameCountIn;

    /* These variables are read and written between different threads. */
    MA_ATOMIC(4, ma_node_state) state;          /* When set to stopped, nothing will be read, regardless of the times in stateTimes. */
    MA_ATOMIC(8, ma_uint64) stateTimes[2];      /* Indexed by ma_node_state. Specifies the time based on the global clock that a node should be considered to be in the relevant state. */
    MA_ATOMIC(8, ma_uint64) localTime;          /* The node's local clock. This is just a running sum of the number of output frames that have been processed. Can be modified by any thread with `ma_node_set_time()`. */

    /* Memory management. */
    ma_node_input_bus _inputBuses[MA_MAX_NODE_LOCAL_BUS_COUNT];
    ma_node_output_bus _outputBuses[MA_MAX_NODE_LOCAL_BUS_COUNT];
    void* _pHeap;   /* A heap allocation for internal use only. pInputBuses and/or pOutputBuses will point to this if the bus count exceeds MA_MAX_NODE_LOCAL_BUS_COUNT. */
    ma_bool32 _ownsHeap;    /* If set to true, the node owns the heap allocation and _pHeap will be freed in ma_node_uninit(). */
};

MA_API ma_result ma_node_get_heap_size(ma_node_graph* pNodeGraph, const ma_node_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_node_init_preallocated(ma_node_graph* pNodeGraph, const ma_node_config* pConfig, void* pHeap, ma_node* pNode);
MA_API ma_result ma_node_init(ma_node_graph* pNodeGraph, const ma_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_node* pNode);
MA_API void ma_node_uninit(ma_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_node_graph* ma_node_get_node_graph(const ma_node* pNode);
MA_API ma_uint32 ma_node_get_input_bus_count(const ma_node* pNode);
MA_API ma_uint32 ma_node_get_output_bus_count(const ma_node* pNode);
MA_API ma_uint32 ma_node_get_input_channels(const ma_node* pNode, ma_uint32 inputBusIndex);
MA_API ma_uint32 ma_node_get_output_channels(const ma_node* pNode, ma_uint32 outputBusIndex);
MA_API ma_result ma_node_attach_output_bus(ma_node* pNode, ma_uint32 outputBusIndex, ma_node* pOtherNode, ma_uint32 otherNodeInputBusIndex);
MA_API ma_result ma_node_detach_output_bus(ma_node* pNode, ma_uint32 outputBusIndex);
MA_API ma_result ma_node_detach_all_output_buses(ma_node* pNode);
MA_API ma_result ma_node_set_output_bus_volume(ma_node* pNode, ma_uint32 outputBusIndex, float volume);
MA_API float ma_node_get_output_bus_volume(const ma_node* pNode, ma_uint32 outputBusIndex);
MA_API ma_result ma_node_set_state(ma_node* pNode, ma_node_state state);
MA_API ma_node_state ma_node_get_state(const ma_node* pNode);
MA_API ma_result ma_node_set_state_time(ma_node* pNode, ma_node_state state, ma_uint64 globalTime);
MA_API ma_uint64 ma_node_get_state_time(const ma_node* pNode, ma_node_state state);
MA_API ma_node_state ma_node_get_state_by_time(const ma_node* pNode, ma_uint64 globalTime);
MA_API ma_node_state ma_node_get_state_by_time_range(const ma_node* pNode, ma_uint64 globalTimeBeg, ma_uint64 globalTimeEnd);
MA_API ma_uint64 ma_node_get_time(const ma_node* pNode);
MA_API ma_result ma_node_set_time(ma_node* pNode, ma_uint64 localTime);


typedef struct
{
    ma_uint32 channels;
    ma_uint32 processingSizeInFrames;   /* This is the preferred processing size for node processing callbacks unless overridden by a node itself. Can be 0 in which case it will be based on the frame count passed into ma_node_graph_read_pcm_frames(), but will not be well defined. */
    size_t preMixStackSizeInBytes;      /* Defaults to 512KB per channel. Reducing this will save memory, but the depth of your node graph will be more restricted. */
} ma_node_graph_config;

MA_API ma_node_graph_config ma_node_graph_config_init(ma_uint32 channels);


struct ma_node_graph
{
    /* Immutable. */
    ma_node_base base;                  /* The node graph itself is a node so it can be connected as an input to different node graph. This has zero inputs and calls ma_node_graph_read_pcm_frames() to generate it's output. */
    ma_node_base endpoint;              /* Special node that all nodes eventually connect to. Data is read from this node in ma_node_graph_read_pcm_frames(). */
    float* pProcessingCache;            /* This will be allocated when processingSizeInFrames is non-zero. This is needed because ma_node_graph_read_pcm_frames() can be called with a variable number of frames, and we may need to do some buffering in situations where the caller requests a frame count that's not a multiple of processingSizeInFrames. */
    ma_uint32 processingCacheFramesRemaining;
    ma_uint32 processingSizeInFrames;

    /* Read and written by multiple threads. */
    MA_ATOMIC(4, ma_bool32) isReading;

    /* Modified only by the audio thread. */
    ma_stack* pPreMixStack;
};

MA_API ma_result ma_node_graph_init(const ma_node_graph_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_node_graph* pNodeGraph);
MA_API void ma_node_graph_uninit(ma_node_graph* pNodeGraph, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_node* ma_node_graph_get_endpoint(ma_node_graph* pNodeGraph);
MA_API ma_result ma_node_graph_read_pcm_frames(ma_node_graph* pNodeGraph, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead);
MA_API ma_uint32 ma_node_graph_get_channels(const ma_node_graph* pNodeGraph);
MA_API ma_uint64 ma_node_graph_get_time(const ma_node_graph* pNodeGraph);
MA_API ma_result ma_node_graph_set_time(ma_node_graph* pNodeGraph, ma_uint64 globalTime);



/* Data source node. 0 input buses, 1 output bus. Used for reading from a data source. */
typedef struct
{
    ma_node_config nodeConfig;
    ma_data_source* pDataSource;
} ma_data_source_node_config;

MA_API ma_data_source_node_config ma_data_source_node_config_init(ma_data_source* pDataSource);


typedef struct
{
    ma_node_base base;
    ma_data_source* pDataSource;
} ma_data_source_node;

MA_API ma_result ma_data_source_node_init(ma_node_graph* pNodeGraph, const ma_data_source_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_data_source_node* pDataSourceNode);
MA_API void ma_data_source_node_uninit(ma_data_source_node* pDataSourceNode, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_data_source_node_set_looping(ma_data_source_node* pDataSourceNode, ma_bool32 isLooping);
MA_API ma_bool32 ma_data_source_node_is_looping(ma_data_source_node* pDataSourceNode);


/* Splitter Node. 1 input, many outputs. Used for splitting/copying a stream so it can be as input into two separate output nodes. */
typedef struct
{
    ma_node_config nodeConfig;
    ma_uint32 channels;
    ma_uint32 outputBusCount;
} ma_splitter_node_config;

MA_API ma_splitter_node_config ma_splitter_node_config_init(ma_uint32 channels);


typedef struct
{
    ma_node_base base;
} ma_splitter_node;

MA_API ma_result ma_splitter_node_init(ma_node_graph* pNodeGraph, const ma_splitter_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_splitter_node* pSplitterNode);
MA_API void ma_splitter_node_uninit(ma_splitter_node* pSplitterNode, const ma_allocation_callbacks* pAllocationCallbacks);


/*
Biquad Node
*/
typedef struct
{
    ma_node_config nodeConfig;
    ma_biquad_config biquad;
} ma_biquad_node_config;

MA_API ma_biquad_node_config ma_biquad_node_config_init(ma_uint32 channels, float b0, float b1, float b2, float a0, float a1, float a2);


typedef struct
{
    ma_node_base baseNode;
    ma_biquad biquad;
} ma_biquad_node;

MA_API ma_result ma_biquad_node_init(ma_node_graph* pNodeGraph, const ma_biquad_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_biquad_node* pNode);
MA_API ma_result ma_biquad_node_reinit(const ma_biquad_config* pConfig, ma_biquad_node* pNode);
MA_API void ma_biquad_node_uninit(ma_biquad_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks);


/*
Low Pass Filter Node
*/
typedef struct
{
    ma_node_config nodeConfig;
    ma_lpf_config lpf;
} ma_lpf_node_config;

MA_API ma_lpf_node_config ma_lpf_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order);


typedef struct
{
    ma_node_base baseNode;
    ma_lpf lpf;
} ma_lpf_node;

MA_API ma_result ma_lpf_node_init(ma_node_graph* pNodeGraph, const ma_lpf_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_lpf_node* pNode);
MA_API ma_result ma_lpf_node_reinit(const ma_lpf_config* pConfig, ma_lpf_node* pNode);
MA_API void ma_lpf_node_uninit(ma_lpf_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks);


/*
High Pass Filter Node
*/
typedef struct
{
    ma_node_config nodeConfig;
    ma_hpf_config hpf;
} ma_hpf_node_config;

MA_API ma_hpf_node_config ma_hpf_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order);


typedef struct
{
    ma_node_base baseNode;
    ma_hpf hpf;
} ma_hpf_node;

MA_API ma_result ma_hpf_node_init(ma_node_graph* pNodeGraph, const ma_hpf_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hpf_node* pNode);
MA_API ma_result ma_hpf_node_reinit(const ma_hpf_config* pConfig, ma_hpf_node* pNode);
MA_API void ma_hpf_node_uninit(ma_hpf_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks);


/*
Band Pass Filter Node
*/
typedef struct
{
    ma_node_config nodeConfig;
    ma_bpf_config bpf;
} ma_bpf_node_config;

MA_API ma_bpf_node_config ma_bpf_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order);


typedef struct
{
    ma_node_base baseNode;
    ma_bpf bpf;
} ma_bpf_node;

MA_API ma_result ma_bpf_node_init(ma_node_graph* pNodeGraph, const ma_bpf_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_bpf_node* pNode);
MA_API ma_result ma_bpf_node_reinit(const ma_bpf_config* pConfig, ma_bpf_node* pNode);
MA_API void ma_bpf_node_uninit(ma_bpf_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks);


/*
Notching Filter Node
*/
typedef struct
{
    ma_node_config nodeConfig;
    ma_notch_config notch;
} ma_notch_node_config;

MA_API ma_notch_node_config ma_notch_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double q, double frequency);


typedef struct
{
    ma_node_base baseNode;
    ma_notch2 notch;
} ma_notch_node;

MA_API ma_result ma_notch_node_init(ma_node_graph* pNodeGraph, const ma_notch_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_notch_node* pNode);
MA_API ma_result ma_notch_node_reinit(const ma_notch_config* pConfig, ma_notch_node* pNode);
MA_API void ma_notch_node_uninit(ma_notch_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks);


/*
Peaking Filter Node
*/
typedef struct
{
    ma_node_config nodeConfig;
    ma_peak_config peak;
} ma_peak_node_config;

MA_API ma_peak_node_config ma_peak_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double q, double frequency);


typedef struct
{
    ma_node_base baseNode;
    ma_peak2 peak;
} ma_peak_node;

MA_API ma_result ma_peak_node_init(ma_node_graph* pNodeGraph, const ma_peak_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_peak_node* pNode);
MA_API ma_result ma_peak_node_reinit(const ma_peak_config* pConfig, ma_peak_node* pNode);
MA_API void ma_peak_node_uninit(ma_peak_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks);


/*
Low Shelf Filter Node
*/
typedef struct
{
    ma_node_config nodeConfig;
    ma_loshelf_config loshelf;
} ma_loshelf_node_config;

MA_API ma_loshelf_node_config ma_loshelf_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double q, double frequency);


typedef struct
{
    ma_node_base baseNode;
    ma_loshelf2 loshelf;
} ma_loshelf_node;

MA_API ma_result ma_loshelf_node_init(ma_node_graph* pNodeGraph, const ma_loshelf_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_loshelf_node* pNode);
MA_API ma_result ma_loshelf_node_reinit(const ma_loshelf_config* pConfig, ma_loshelf_node* pNode);
MA_API void ma_loshelf_node_uninit(ma_loshelf_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks);


/*
High Shelf Filter Node
*/
typedef struct
{
    ma_node_config nodeConfig;
    ma_hishelf_config hishelf;
} ma_hishelf_node_config;

MA_API ma_hishelf_node_config ma_hishelf_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double q, double frequency);


typedef struct
{
    ma_node_base baseNode;
    ma_hishelf2 hishelf;
} ma_hishelf_node;

MA_API ma_result ma_hishelf_node_init(ma_node_graph* pNodeGraph, const ma_hishelf_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hishelf_node* pNode);
MA_API ma_result ma_hishelf_node_reinit(const ma_hishelf_config* pConfig, ma_hishelf_node* pNode);
MA_API void ma_hishelf_node_uninit(ma_hishelf_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks);


typedef struct
{
    ma_node_config nodeConfig;
    ma_delay_config delay;
} ma_delay_node_config;

MA_API ma_delay_node_config ma_delay_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, ma_uint32 delayInFrames, float decay);


typedef struct
{
    ma_node_base baseNode;
    ma_delay delay;
} ma_delay_node;

MA_API ma_result ma_delay_node_init(ma_node_graph* pNodeGraph, const ma_delay_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_delay_node* pDelayNode);
MA_API void ma_delay_node_uninit(ma_delay_node* pDelayNode, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API void ma_delay_node_set_wet(ma_delay_node* pDelayNode, float value);
MA_API float ma_delay_node_get_wet(const ma_delay_node* pDelayNode);
MA_API void ma_delay_node_set_dry(ma_delay_node* pDelayNode, float value);
MA_API float ma_delay_node_get_dry(const ma_delay_node* pDelayNode);
MA_API void ma_delay_node_set_decay(ma_delay_node* pDelayNode, float value);
MA_API float ma_delay_node_get_decay(const ma_delay_node* pDelayNode);
#endif  /* MA_NO_NODE_GRAPH */


/* SECTION: miniaudio_engine.h */
/************************************************************************************************************************************************************

Engine

************************************************************************************************************************************************************/
#if !defined(MA_NO_ENGINE) && !defined(MA_NO_NODE_GRAPH)
typedef struct ma_engine ma_engine;
typedef struct ma_sound  ma_sound;


/* Sound flags. */
typedef enum
{
    /* Resource manager flags. */
    MA_SOUND_FLAG_STREAM                = 0x00000001,   /* MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM */
    MA_SOUND_FLAG_DECODE                = 0x00000002,   /* MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_DECODE */
    MA_SOUND_FLAG_ASYNC                 = 0x00000004,   /* MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC */
    MA_SOUND_FLAG_WAIT_INIT             = 0x00000008,   /* MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT */
    MA_SOUND_FLAG_UNKNOWN_LENGTH        = 0x00000010,   /* MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_UNKNOWN_LENGTH */
    MA_SOUND_FLAG_LOOPING               = 0x00000020,   /* MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_LOOPING */

    /* ma_sound specific flags. */
    MA_SOUND_FLAG_NO_DEFAULT_ATTACHMENT = 0x00001000,   /* Do not attach to the endpoint by default. Useful for when setting up nodes in a complex graph system. */
    MA_SOUND_FLAG_NO_PITCH              = 0x00002000,   /* Disable pitch shifting with ma_sound_set_pitch() and ma_sound_group_set_pitch(). This is an optimization. */
    MA_SOUND_FLAG_NO_SPATIALIZATION     = 0x00004000    /* Disable spatialization. */
} ma_sound_flags;

#ifndef MA_ENGINE_MAX_LISTENERS
#define MA_ENGINE_MAX_LISTENERS             4
#endif

#define MA_LISTENER_INDEX_CLOSEST           ((ma_uint8)-1)

typedef enum
{
    ma_engine_node_type_sound,
    ma_engine_node_type_group
} ma_engine_node_type;

typedef struct
{
    ma_engine* pEngine;
    ma_engine_node_type type;
    ma_uint32 channelsIn;
    ma_uint32 channelsOut;
    ma_uint32 sampleRate;               /* Only used when the type is set to ma_engine_node_type_sound. */
    ma_uint32 volumeSmoothTimeInPCMFrames;  /* The number of frames to smooth over volume changes. Defaults to 0 in which case no smoothing is used. */
    ma_mono_expansion_mode monoExpansionMode;
    ma_bool8 isPitchDisabled;           /* Pitching can be explicitly disabled with MA_SOUND_FLAG_NO_PITCH to optimize processing. */
    ma_bool8 isSpatializationDisabled;  /* Spatialization can be explicitly disabled with MA_SOUND_FLAG_NO_SPATIALIZATION. */
    ma_uint8 pinnedListenerIndex;       /* The index of the listener this node should always use for spatialization. If set to MA_LISTENER_INDEX_CLOSEST the engine will use the closest listener. */
} ma_engine_node_config;

MA_API ma_engine_node_config ma_engine_node_config_init(ma_engine* pEngine, ma_engine_node_type type, ma_uint32 flags);


/* Base node object for both ma_sound and ma_sound_group. */
typedef struct
{
    ma_node_base baseNode;                              /* Must be the first member for compatibility with the ma_node API. */
    ma_engine* pEngine;                                 /* A pointer to the engine. Set based on the value from the config. */
    ma_uint32 sampleRate;                               /* The sample rate of the input data. For sounds backed by a data source, this will be the data source's sample rate. Otherwise it'll be the engine's sample rate. */
    ma_uint32 volumeSmoothTimeInPCMFrames;
    ma_mono_expansion_mode monoExpansionMode;
    ma_fader fader;
    ma_linear_resampler resampler;                      /* For pitch shift. */
    ma_spatializer spatializer;
    ma_panner panner;
    ma_gainer volumeGainer;                             /* This will only be used if volumeSmoothTimeInPCMFrames is > 0. */
    ma_atomic_float volume;                             /* Defaults to 1. */
    MA_ATOMIC(4, float) pitch;
    float oldPitch;                                     /* For determining whether or not the resampler needs to be updated to reflect the new pitch. The resampler will be updated on the mixing thread. */
    float oldDopplerPitch;                              /* For determining whether or not the resampler needs to be updated to take a new doppler pitch into account. */
    MA_ATOMIC(4, ma_bool32) isPitchDisabled;            /* When set to true, pitching will be disabled which will allow the resampler to be bypassed to save some computation. */
    MA_ATOMIC(4, ma_bool32) isSpatializationDisabled;   /* Set to false by default. When set to false, will not have spatialisation applied. */
    MA_ATOMIC(4, ma_uint32) pinnedListenerIndex;        /* The index of the listener this node should always use for spatialization. If set to MA_LISTENER_INDEX_CLOSEST the engine will use the closest listener. */

    /* When setting a fade, it's not done immediately in ma_sound_set_fade(). It's deferred to the audio thread which means we need to store the settings here. */
    struct
    {
        ma_atomic_float volumeBeg;
        ma_atomic_float volumeEnd;
        ma_atomic_uint64 fadeLengthInFrames;            /* <-- Defaults to (~(ma_uint64)0) which is used to indicate that no fade should be applied. */
        ma_atomic_uint64 absoluteGlobalTimeInFrames;    /* <-- The time to start the fade. */
    } fadeSettings;

    /* Memory management. */
    ma_bool8 _ownsHeap;
    void* _pHeap;
} ma_engine_node;

MA_API ma_result ma_engine_node_get_heap_size(const ma_engine_node_config* pConfig, size_t* pHeapSizeInBytes);
MA_API ma_result ma_engine_node_init_preallocated(const ma_engine_node_config* pConfig, void* pHeap, ma_engine_node* pEngineNode);
MA_API ma_result ma_engine_node_init(const ma_engine_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_engine_node* pEngineNode);
MA_API void ma_engine_node_uninit(ma_engine_node* pEngineNode, const ma_allocation_callbacks* pAllocationCallbacks);


#define MA_SOUND_SOURCE_CHANNEL_COUNT   0xFFFFFFFF

/* Callback for when a sound reaches the end. */
typedef void (* ma_sound_end_proc)(void* pUserData, ma_sound* pSound);

typedef struct
{
    const char* pFilePath;                      /* Set this to load from the resource manager. */
    const wchar_t* pFilePathW;                  /* Set this to load from the resource manager. */
    ma_data_source* pDataSource;                /* Set this to load from an existing data source. */
    ma_node* pInitialAttachment;                /* If set, the sound will be attached to an input of this node. This can be set to a ma_sound. If set to NULL, the sound will be attached directly to the endpoint unless MA_SOUND_FLAG_NO_DEFAULT_ATTACHMENT is set in `flags`. */
    ma_uint32 initialAttachmentInputBusIndex;   /* The index of the input bus of pInitialAttachment to attach the sound to. */
    ma_uint32 channelsIn;                       /* Ignored if using a data source as input (the data source's channel count will be used always). Otherwise, setting to 0 will cause the engine's channel count to be used. */
    ma_uint32 channelsOut;                      /* Set this to 0 (default) to use the engine's channel count. Set to MA_SOUND_SOURCE_CHANNEL_COUNT to use the data source's channel count (only used if using a data source as input). */
    ma_mono_expansion_mode monoExpansionMode;   /* Controls how the mono channel should be expanded to other channels when spatialization is disabled on a sound. */
    ma_uint32 flags;                            /* A combination of MA_SOUND_FLAG_* flags. */
    ma_uint32 volumeSmoothTimeInPCMFrames;      /* The number of frames to smooth over volume changes. Defaults to 0 in which case no smoothing is used. */
    ma_uint64 initialSeekPointInPCMFrames;      /* Initializes the sound such that it's seeked to this location by default. */
    ma_uint64 rangeBegInPCMFrames;
    ma_uint64 rangeEndInPCMFrames;
    ma_uint64 loopPointBegInPCMFrames;
    ma_uint64 loopPointEndInPCMFrames;
    ma_sound_end_proc endCallback;              /* Fired when the sound reaches the end. Will be fired from the audio thread. Do not restart, uninitialize or otherwise change the state of the sound from here. Instead fire an event or set a variable to indicate to a different thread to change the start of the sound. Will not be fired in response to a scheduled stop with ma_sound_set_stop_time_*(). */
    void* pEndCallbackUserData;
#ifndef MA_NO_RESOURCE_MANAGER
    ma_resource_manager_pipeline_notifications initNotifications;
#endif
    ma_fence* pDoneFence;                       /* Deprecated. Use initNotifications instead. Released when the resource manager has finished decoding the entire sound. Not used with streams. */
    ma_bool32 isLooping;                        /* Deprecated. Use the MA_SOUND_FLAG_LOOPING flag in `flags` instead. */
} ma_sound_config;

MA_API ma_sound_config ma_sound_config_init(void);                  /* Deprecated. Will be removed in version 0.12. Use ma_sound_config_2() instead. */
MA_API ma_sound_config ma_sound_config_init_2(ma_engine* pEngine);  /* Will be renamed to ma_sound_config_init() in version 0.12. */

struct ma_sound
{
    ma_engine_node engineNode;          /* Must be the first member for compatibility with the ma_node API. */
    ma_data_source* pDataSource;
    MA_ATOMIC(8, ma_uint64) seekTarget; /* The PCM frame index to seek to in the mixing thread. Set to (~(ma_uint64)0) to not perform any seeking. */
    MA_ATOMIC(4, ma_bool32) atEnd;
    ma_sound_end_proc endCallback;
    void* pEndCallbackUserData;
    ma_bool8 ownsDataSource;

    /*
    We're declaring a resource manager data source object here to save us a malloc when loading a
    sound via the resource manager, which I *think* will be the most common scenario.
    */
#ifndef MA_NO_RESOURCE_MANAGER
    ma_resource_manager_data_source* pResourceManagerDataSource;
#endif
};

/* Structure specifically for sounds played with ma_engine_play_sound(). Making this a separate structure to reduce overhead. */
typedef struct ma_sound_inlined ma_sound_inlined;
struct ma_sound_inlined
{
    ma_sound sound;
    ma_sound_inlined* pNext;
    ma_sound_inlined* pPrev;
};

/* A sound group is just a sound. */
typedef ma_sound_config ma_sound_group_config;
typedef ma_sound        ma_sound_group;

MA_API ma_sound_group_config ma_sound_group_config_init(void);                  /* Deprecated. Will be removed in version 0.12. Use ma_sound_config_2() instead. */
MA_API ma_sound_group_config ma_sound_group_config_init_2(ma_engine* pEngine);  /* Will be renamed to ma_sound_config_init() in version 0.12. */

typedef void (* ma_engine_process_proc)(void* pUserData, float* pFramesOut, ma_uint64 frameCount);

typedef struct
{
#if !defined(MA_NO_RESOURCE_MANAGER)
    ma_resource_manager* pResourceManager;          /* Can be null in which case a resource manager will be created for you. */
#endif
    ma_log* pLog;                                   /* When set to NULL, will use the context's log. */
    ma_uint32 listenerCount;                        /* Must be between 1 and MA_ENGINE_MAX_LISTENERS. */
    ma_uint32 channels;                             /* The number of channels to use when mixing and spatializing. When set to 0, will use the native channel count of the device. */
    ma_uint32 sampleRate;                           /* The sample rate. When set to 0 will use the native channel count of the device. */
    ma_uint32 periodSizeInFrames;                   /* If set to something other than 0, updates will always be exactly this size. The underlying device may be a different size, but from the perspective of the mixer that won't matter.*/
    ma_uint32 periodSizeInMilliseconds;             /* Used if periodSizeInFrames is unset. */
    ma_uint32 gainSmoothTimeInFrames;               /* The number of frames to interpolate the gain of spatialized sounds across. If set to 0, will use gainSmoothTimeInMilliseconds. */
    ma_uint32 gainSmoothTimeInMilliseconds;         /* When set to 0, gainSmoothTimeInFrames will be used. If both are set to 0, a default value will be used. */
    ma_uint32 defaultVolumeSmoothTimeInPCMFrames;   /* Defaults to 0. Controls the default amount of smoothing to apply to volume changes to sounds. High values means more smoothing at the expense of high latency (will take longer to reach the new volume). */
    ma_uint32 preMixStackSizeInBytes;               /* A stack is used for internal processing in the node graph. This allows you to configure the size of this stack. Smaller values will reduce the maximum depth of your node graph. You should rarely need to modify this. */
    ma_allocation_callbacks allocationCallbacks;
    ma_bool32 noAutoStart;                          /* When set to true, requires an explicit call to ma_engine_start(). This is false by default, meaning the engine will be started automatically in ma_engine_init(). */
    ma_bool32 noDevice;                             /* When set to true, don't create a default device. ma_engine_read_pcm_frames() can be called manually to read data. */
    ma_mono_expansion_mode monoExpansionMode;       /* Controls how the mono channel should be expanded to other channels when spatialization is disabled on a sound. */
    ma_vfs* pResourceManagerVFS;                    /* A pointer to a pre-allocated VFS object to use with the resource manager. This is ignored if pResourceManager is not NULL. */
    ma_engine_process_proc onProcess;               /* Fired at the end of each call to ma_engine_read_pcm_frames(). For engine's that manage their own internal device (the default configuration), this will be fired from the audio thread, and you do not need to call ma_engine_read_pcm_frames() manually in order to trigger this. */
    void* pProcessUserData;                         /* User data that's passed into onProcess. */
} ma_engine_config;

MA_API ma_engine_config ma_engine_config_init(void);


struct ma_engine
{
    ma_node_graph nodeGraph;                        /* An engine is a node graph. It should be able to be plugged into any ma_node_graph API (with a cast) which means this must be the first member of this struct. */
#if !defined(MA_NO_RESOURCE_MANAGER)
    ma_resource_manager* pResourceManager;
#endif
    ma_log* pLog;
    ma_uint32 sampleRate;
    ma_uint32 listenerCount;
    ma_spatializer_listener listeners[MA_ENGINE_MAX_LISTENERS];
    ma_allocation_callbacks allocationCallbacks;
    ma_bool8 ownsResourceManager;
    ma_bool8 ownsDevice;
    ma_spinlock inlinedSoundLock;                   /* For synchronizing access to the inlined sound list. */
    ma_sound_inlined* pInlinedSoundHead;            /* The first inlined sound. Inlined sounds are tracked in a linked list. */
    MA_ATOMIC(4, ma_uint32) inlinedSoundCount;      /* The total number of allocated inlined sound objects. Used for debugging. */
    ma_uint32 gainSmoothTimeInFrames;               /* The number of frames to interpolate the gain of spatialized sounds across. */
    ma_uint32 defaultVolumeSmoothTimeInPCMFrames;
    ma_mono_expansion_mode monoExpansionMode;
    ma_engine_process_proc onProcess;
    void* pProcessUserData;
};

MA_API ma_result ma_engine_init(const ma_engine_config* pConfig, ma_engine* pEngine);
MA_API void ma_engine_uninit(ma_engine* pEngine);
MA_API ma_result ma_engine_read_pcm_frames(ma_engine* pEngine, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead);
MA_API ma_node_graph* ma_engine_get_node_graph(ma_engine* pEngine);
#if !defined(MA_NO_RESOURCE_MANAGER)
MA_API ma_resource_manager* ma_engine_get_resource_manager(ma_engine* pEngine);
#endif
MA_API ma_device* ma_engine_get_device(ma_engine* pEngine);
MA_API ma_log* ma_engine_get_log(ma_engine* pEngine);
MA_API ma_node* ma_engine_get_endpoint(ma_engine* pEngine);
MA_API ma_uint64 ma_engine_get_time_in_pcm_frames(const ma_engine* pEngine);
MA_API ma_uint64 ma_engine_get_time_in_milliseconds(const ma_engine* pEngine);
MA_API ma_result ma_engine_set_time_in_pcm_frames(ma_engine* pEngine, ma_uint64 globalTime);
MA_API ma_result ma_engine_set_time_in_milliseconds(ma_engine* pEngine, ma_uint64 globalTime);
MA_API ma_uint64 ma_engine_get_time(const ma_engine* pEngine);                  /* Deprecated. Use ma_engine_get_time_in_pcm_frames(). Will be removed in version 0.12. */
MA_API ma_result ma_engine_set_time(ma_engine* pEngine, ma_uint64 globalTime);  /* Deprecated. Use ma_engine_set_time_in_pcm_frames(). Will be removed in version 0.12. */
MA_API ma_uint32 ma_engine_get_channels(const ma_engine* pEngine);
MA_API ma_uint32 ma_engine_get_sample_rate(const ma_engine* pEngine);

MA_API ma_result ma_engine_start(ma_engine* pEngine);
MA_API ma_result ma_engine_stop(ma_engine* pEngine);
MA_API ma_result ma_engine_set_volume(ma_engine* pEngine, float volume);
MA_API float ma_engine_get_volume(ma_engine* pEngine);
MA_API ma_result ma_engine_set_gain_db(ma_engine* pEngine, float gainDB);
MA_API float ma_engine_get_gain_db(ma_engine* pEngine);

MA_API ma_uint32 ma_engine_get_listener_count(const ma_engine* pEngine);
MA_API ma_uint32 ma_engine_find_closest_listener(const ma_engine* pEngine, float absolutePosX, float absolutePosY, float absolutePosZ);
MA_API void ma_engine_listener_set_position(ma_engine* pEngine, ma_uint32 listenerIndex, float x, float y, float z);
MA_API ma_vec3f ma_engine_listener_get_position(const ma_engine* pEngine, ma_uint32 listenerIndex);
MA_API void ma_engine_listener_set_direction(ma_engine* pEngine, ma_uint32 listenerIndex, float x, float y, float z);
MA_API ma_vec3f ma_engine_listener_get_direction(const ma_engine* pEngine, ma_uint32 listenerIndex);
MA_API void ma_engine_listener_set_velocity(ma_engine* pEngine, ma_uint32 listenerIndex, float x, float y, float z);
MA_API ma_vec3f ma_engine_listener_get_velocity(const ma_engine* pEngine, ma_uint32 listenerIndex);
MA_API void ma_engine_listener_set_cone(ma_engine* pEngine, ma_uint32 listenerIndex, float innerAngleInRadians, float outerAngleInRadians, float outerGain);
MA_API void ma_engine_listener_get_cone(const ma_engine* pEngine, ma_uint32 listenerIndex, float* pInnerAngleInRadians, float* pOuterAngleInRadians, float* pOuterGain);
MA_API void ma_engine_listener_set_world_up(ma_engine* pEngine, ma_uint32 listenerIndex, float x, float y, float z);
MA_API ma_vec3f ma_engine_listener_get_world_up(const ma_engine* pEngine, ma_uint32 listenerIndex);
MA_API void ma_engine_listener_set_enabled(ma_engine* pEngine, ma_uint32 listenerIndex, ma_bool32 isEnabled);
MA_API ma_bool32 ma_engine_listener_is_enabled(const ma_engine* pEngine, ma_uint32 listenerIndex);

#ifndef MA_NO_RESOURCE_MANAGER
MA_API ma_result ma_engine_play_sound_ex(ma_engine* pEngine, const char* pFilePath, ma_node* pNode, ma_uint32 nodeInputBusIndex);
MA_API ma_result ma_engine_play_sound(ma_engine* pEngine, const char* pFilePath, ma_sound_group* pGroup);   /* Fire and forget. */
#endif

#ifndef MA_NO_RESOURCE_MANAGER
MA_API ma_result ma_sound_init_from_file(ma_engine* pEngine, const char* pFilePath, ma_uint32 flags, ma_sound_group* pGroup, ma_fence* pDoneFence, ma_sound* pSound);
MA_API ma_result ma_sound_init_from_file_w(ma_engine* pEngine, const wchar_t* pFilePath, ma_uint32 flags, ma_sound_group* pGroup, ma_fence* pDoneFence, ma_sound* pSound);
MA_API ma_result ma_sound_init_copy(ma_engine* pEngine, const ma_sound* pExistingSound, ma_uint32 flags, ma_sound_group* pGroup, ma_sound* pSound);
#endif
MA_API ma_result ma_sound_init_from_data_source(ma_engine* pEngine, ma_data_source* pDataSource, ma_uint32 flags, ma_sound_group* pGroup, ma_sound* pSound);
MA_API ma_result ma_sound_init_ex(ma_engine* pEngine, const ma_sound_config* pConfig, ma_sound* pSound);
MA_API void ma_sound_uninit(ma_sound* pSound);
MA_API ma_engine* ma_sound_get_engine(const ma_sound* pSound);
MA_API ma_data_source* ma_sound_get_data_source(const ma_sound* pSound);
MA_API ma_result ma_sound_start(ma_sound* pSound);
MA_API ma_result ma_sound_stop(ma_sound* pSound);
MA_API ma_result ma_sound_stop_with_fade_in_pcm_frames(ma_sound* pSound, ma_uint64 fadeLengthInFrames);     /* Will overwrite any scheduled stop and fade. */
MA_API ma_result ma_sound_stop_with_fade_in_milliseconds(ma_sound* pSound, ma_uint64 fadeLengthInFrames);   /* Will overwrite any scheduled stop and fade. */
MA_API void ma_sound_set_volume(ma_sound* pSound, float volume);
MA_API float ma_sound_get_volume(const ma_sound* pSound);
MA_API void ma_sound_set_pan(ma_sound* pSound, float pan);
MA_API float ma_sound_get_pan(const ma_sound* pSound);
MA_API void ma_sound_set_pan_mode(ma_sound* pSound, ma_pan_mode panMode);
MA_API ma_pan_mode ma_sound_get_pan_mode(const ma_sound* pSound);
MA_API void ma_sound_set_pitch(ma_sound* pSound, float pitch);
MA_API float ma_sound_get_pitch(const ma_sound* pSound);
MA_API void ma_sound_set_spatialization_enabled(ma_sound* pSound, ma_bool32 enabled);
MA_API ma_bool32 ma_sound_is_spatialization_enabled(const ma_sound* pSound);
MA_API void ma_sound_set_pinned_listener_index(ma_sound* pSound, ma_uint32 listenerIndex);
MA_API ma_uint32 ma_sound_get_pinned_listener_index(const ma_sound* pSound);
MA_API ma_uint32 ma_sound_get_listener_index(const ma_sound* pSound);
MA_API ma_vec3f ma_sound_get_direction_to_listener(const ma_sound* pSound);
MA_API void ma_sound_set_position(ma_sound* pSound, float x, float y, float z);
MA_API ma_vec3f ma_sound_get_position(const ma_sound* pSound);
MA_API void ma_sound_set_direction(ma_sound* pSound, float x, float y, float z);
MA_API ma_vec3f ma_sound_get_direction(const ma_sound* pSound);
MA_API void ma_sound_set_velocity(ma_sound* pSound, float x, float y, float z);
MA_API ma_vec3f ma_sound_get_velocity(const ma_sound* pSound);
MA_API void ma_sound_set_attenuation_model(ma_sound* pSound, ma_attenuation_model attenuationModel);
MA_API ma_attenuation_model ma_sound_get_attenuation_model(const ma_sound* pSound);
MA_API void ma_sound_set_positioning(ma_sound* pSound, ma_positioning positioning);
MA_API ma_positioning ma_sound_get_positioning(const ma_sound* pSound);
MA_API void ma_sound_set_rolloff(ma_sound* pSound, float rolloff);
MA_API float ma_sound_get_rolloff(const ma_sound* pSound);
MA_API void ma_sound_set_min_gain(ma_sound* pSound, float minGain);
MA_API float ma_sound_get_min_gain(const ma_sound* pSound);
MA_API void ma_sound_set_max_gain(ma_sound* pSound, float maxGain);
MA_API float ma_sound_get_max_gain(const ma_sound* pSound);
MA_API void ma_sound_set_min_distance(ma_sound* pSound, float minDistance);
MA_API float ma_sound_get_min_distance(const ma_sound* pSound);
MA_API void ma_sound_set_max_distance(ma_sound* pSound, float maxDistance);
MA_API float ma_sound_get_max_distance(const ma_sound* pSound);
MA_API void ma_sound_set_cone(ma_sound* pSound, float innerAngleInRadians, float outerAngleInRadians, float outerGain);
MA_API void ma_sound_get_cone(const ma_sound* pSound, float* pInnerAngleInRadians, float* pOuterAngleInRadians, float* pOuterGain);
MA_API void ma_sound_set_doppler_factor(ma_sound* pSound, float dopplerFactor);
MA_API float ma_sound_get_doppler_factor(const ma_sound* pSound);
MA_API void ma_sound_set_directional_attenuation_factor(ma_sound* pSound, float directionalAttenuationFactor);
MA_API float ma_sound_get_directional_attenuation_factor(const ma_sound* pSound);
MA_API void ma_sound_set_fade_in_pcm_frames(ma_sound* pSound, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInFrames);
MA_API void ma_sound_set_fade_in_milliseconds(ma_sound* pSound, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInMilliseconds);
MA_API void ma_sound_set_fade_start_in_pcm_frames(ma_sound* pSound, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInFrames, ma_uint64 absoluteGlobalTimeInFrames);
MA_API void ma_sound_set_fade_start_in_milliseconds(ma_sound* pSound, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInMilliseconds, ma_uint64 absoluteGlobalTimeInMilliseconds);
MA_API float ma_sound_get_current_fade_volume(const ma_sound* pSound);
MA_API void ma_sound_set_start_time_in_pcm_frames(ma_sound* pSound, ma_uint64 absoluteGlobalTimeInFrames);
MA_API void ma_sound_set_start_time_in_milliseconds(ma_sound* pSound, ma_uint64 absoluteGlobalTimeInMilliseconds);
MA_API void ma_sound_set_stop_time_in_pcm_frames(ma_sound* pSound, ma_uint64 absoluteGlobalTimeInFrames);
MA_API void ma_sound_set_stop_time_in_milliseconds(ma_sound* pSound, ma_uint64 absoluteGlobalTimeInMilliseconds);
MA_API void ma_sound_set_stop_time_with_fade_in_pcm_frames(ma_sound* pSound, ma_uint64 stopAbsoluteGlobalTimeInFrames, ma_uint64 fadeLengthInFrames);
MA_API void ma_sound_set_stop_time_with_fade_in_milliseconds(ma_sound* pSound, ma_uint64 stopAbsoluteGlobalTimeInMilliseconds, ma_uint64 fadeLengthInMilliseconds);
MA_API ma_bool32 ma_sound_is_playing(const ma_sound* pSound);
MA_API ma_uint64 ma_sound_get_time_in_pcm_frames(const ma_sound* pSound);
MA_API ma_uint64 ma_sound_get_time_in_milliseconds(const ma_sound* pSound);
MA_API void ma_sound_set_looping(ma_sound* pSound, ma_bool32 isLooping);
MA_API ma_bool32 ma_sound_is_looping(const ma_sound* pSound);
MA_API ma_bool32 ma_sound_at_end(const ma_sound* pSound);
MA_API ma_result ma_sound_seek_to_pcm_frame(ma_sound* pSound, ma_uint64 frameIndex); /* Just a wrapper around ma_data_source_seek_to_pcm_frame(). */
MA_API ma_result ma_sound_seek_to_second(ma_sound* pSound, float seekPointInSeconds); /* Abstraction to ma_sound_seek_to_pcm_frame() */
MA_API ma_result ma_sound_get_data_format(ma_sound* pSound, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap);
MA_API ma_result ma_sound_get_cursor_in_pcm_frames(ma_sound* pSound, ma_uint64* pCursor);
MA_API ma_result ma_sound_get_length_in_pcm_frames(ma_sound* pSound, ma_uint64* pLength);
MA_API ma_result ma_sound_get_cursor_in_seconds(ma_sound* pSound, float* pCursor);
MA_API ma_result ma_sound_get_length_in_seconds(ma_sound* pSound, float* pLength);
MA_API ma_result ma_sound_set_end_callback(ma_sound* pSound, ma_sound_end_proc callback, void* pUserData);

MA_API ma_result ma_sound_group_init(ma_engine* pEngine, ma_uint32 flags, ma_sound_group* pParentGroup, ma_sound_group* pGroup);
MA_API ma_result ma_sound_group_init_ex(ma_engine* pEngine, const ma_sound_group_config* pConfig, ma_sound_group* pGroup);
MA_API void ma_sound_group_uninit(ma_sound_group* pGroup);
MA_API ma_engine* ma_sound_group_get_engine(const ma_sound_group* pGroup);
MA_API ma_result ma_sound_group_start(ma_sound_group* pGroup);
MA_API ma_result ma_sound_group_stop(ma_sound_group* pGroup);
MA_API void ma_sound_group_set_volume(ma_sound_group* pGroup, float volume);
MA_API float ma_sound_group_get_volume(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_pan(ma_sound_group* pGroup, float pan);
MA_API float ma_sound_group_get_pan(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_pan_mode(ma_sound_group* pGroup, ma_pan_mode panMode);
MA_API ma_pan_mode ma_sound_group_get_pan_mode(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_pitch(ma_sound_group* pGroup, float pitch);
MA_API float ma_sound_group_get_pitch(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_spatialization_enabled(ma_sound_group* pGroup, ma_bool32 enabled);
MA_API ma_bool32 ma_sound_group_is_spatialization_enabled(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_pinned_listener_index(ma_sound_group* pGroup, ma_uint32 listenerIndex);
MA_API ma_uint32 ma_sound_group_get_pinned_listener_index(const ma_sound_group* pGroup);
MA_API ma_uint32 ma_sound_group_get_listener_index(const ma_sound_group* pGroup);
MA_API ma_vec3f ma_sound_group_get_direction_to_listener(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_position(ma_sound_group* pGroup, float x, float y, float z);
MA_API ma_vec3f ma_sound_group_get_position(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_direction(ma_sound_group* pGroup, float x, float y, float z);
MA_API ma_vec3f ma_sound_group_get_direction(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_velocity(ma_sound_group* pGroup, float x, float y, float z);
MA_API ma_vec3f ma_sound_group_get_velocity(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_attenuation_model(ma_sound_group* pGroup, ma_attenuation_model attenuationModel);
MA_API ma_attenuation_model ma_sound_group_get_attenuation_model(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_positioning(ma_sound_group* pGroup, ma_positioning positioning);
MA_API ma_positioning ma_sound_group_get_positioning(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_rolloff(ma_sound_group* pGroup, float rolloff);
MA_API float ma_sound_group_get_rolloff(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_min_gain(ma_sound_group* pGroup, float minGain);
MA_API float ma_sound_group_get_min_gain(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_max_gain(ma_sound_group* pGroup, float maxGain);
MA_API float ma_sound_group_get_max_gain(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_min_distance(ma_sound_group* pGroup, float minDistance);
MA_API float ma_sound_group_get_min_distance(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_max_distance(ma_sound_group* pGroup, float maxDistance);
MA_API float ma_sound_group_get_max_distance(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_cone(ma_sound_group* pGroup, float innerAngleInRadians, float outerAngleInRadians, float outerGain);
MA_API void ma_sound_group_get_cone(const ma_sound_group* pGroup, float* pInnerAngleInRadians, float* pOuterAngleInRadians, float* pOuterGain);
MA_API void ma_sound_group_set_doppler_factor(ma_sound_group* pGroup, float dopplerFactor);
MA_API float ma_sound_group_get_doppler_factor(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_directional_attenuation_factor(ma_sound_group* pGroup, float directionalAttenuationFactor);
MA_API float ma_sound_group_get_directional_attenuation_factor(const ma_sound_group* pGroup);
MA_API void ma_sound_group_set_fade_in_pcm_frames(ma_sound_group* pGroup, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInFrames);
MA_API void ma_sound_group_set_fade_in_milliseconds(ma_sound_group* pGroup, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInMilliseconds);
MA_API float ma_sound_group_get_current_fade_volume(ma_sound_group* pGroup);
MA_API void ma_sound_group_set_start_time_in_pcm_frames(ma_sound_group* pGroup, ma_uint64 absoluteGlobalTimeInFrames);
MA_API void ma_sound_group_set_start_time_in_milliseconds(ma_sound_group* pGroup, ma_uint64 absoluteGlobalTimeInMilliseconds);
MA_API void ma_sound_group_set_stop_time_in_pcm_frames(ma_sound_group* pGroup, ma_uint64 absoluteGlobalTimeInFrames);
MA_API void ma_sound_group_set_stop_time_in_milliseconds(ma_sound_group* pGroup, ma_uint64 absoluteGlobalTimeInMilliseconds);
MA_API ma_bool32 ma_sound_group_is_playing(const ma_sound_group* pGroup);
MA_API ma_uint64 ma_sound_group_get_time_in_pcm_frames(const ma_sound_group* pGroup);
#endif  /* MA_NO_ENGINE */
/* END SECTION: miniaudio_engine.h */

#ifdef __cplusplus
}
#endif
#endif  /* miniaudio_h */


/*
This is for preventing greying out of the implementation section.
*/
#if defined(Q_CREATOR_RUN) || defined(__INTELLISENSE__) || defined(__CDT_PARSER__)
#define MINIAUDIO_IMPLEMENTATION
#endif

/************************************************************************************************************************************************************
*************************************************************************************************************************************************************

IMPLEMENTATION

*************************************************************************************************************************************************************
************************************************************************************************************************************************************/
#if defined(MINIAUDIO_IMPLEMENTATION) || defined(MA_IMPLEMENTATION)
#ifndef miniaudio_c
#define miniaudio_c

#include <assert.h>
#include <limits.h>         /* For INT_MAX */
#include <math.h>           /* sin(), etc. */
#include <stdlib.h>         /* For malloc(), free(), wcstombs(). */
#include <string.h>         /* For memset() */

#include <stdarg.h>
#include <stdio.h>
#if !defined(_MSC_VER) && !defined(__DMC__)
    #include <strings.h>    /* For strcasecmp(). */
    #include <wchar.h>      /* For wcslen(), wcsrtombs() */
#endif
#ifdef _MSC_VER
    #include <float.h>      /* For _controlfp_s constants */
#endif

#if defined(MA_WIN32)
    #include <windows.h>

    /*
    There's a possibility that WIN32_LEAN_AND_MEAN has been defined which will exclude some symbols
    such as STGM_READ and CLSCTL_ALL. We need to check these and define them ourselves if they're
    unavailable.
    */
    #ifndef STGM_READ
    #define STGM_READ   0x00000000L
    #endif
    #ifndef CLSCTX_ALL
    #define CLSCTX_ALL  23
    #endif

    /* IUnknown is used by both the WASAPI and DirectSound backends. It easier to just declare our version here. */
    typedef struct ma_IUnknown  ma_IUnknown;
#endif

#if !defined(MA_WIN32)
#include <sched.h>
#include <sys/time.h>   /* select() (used for ma_sleep()). */
#include <pthread.h>
#endif

#ifdef MA_NX
#include <time.h>       /* For nanosleep() */
#endif

#include <sys/stat.h>   /* For fstat(), etc. */

#ifdef MA_EMSCRIPTEN
#include <emscripten/emscripten.h>
#endif


/* Architecture Detection */
#if !defined(MA_64BIT) && !defined(MA_32BIT)
#ifdef _WIN32
#ifdef _WIN64
#define MA_64BIT
#else
#define MA_32BIT
#endif
#endif
#endif

#if !defined(MA_64BIT) && !defined(MA_32BIT)
#ifdef __GNUC__
#ifdef __LP64__
#define MA_64BIT
#else
#define MA_32BIT
#endif
#endif
#endif

#if !defined(MA_64BIT) && !defined(MA_32BIT)
#include <stdint.h>
#if INTPTR_MAX == INT64_MAX
#define MA_64BIT
#else
#define MA_32BIT
#endif
#endif

#if defined(__arm__) || defined(_M_ARM)
#define MA_ARM32
#endif
#if defined(__arm64) || defined(__arm64__) || defined(__aarch64__) || defined(_M_ARM64)
#define MA_ARM64
#endif

#if defined(__x86_64__) || defined(_M_X64)
#define MA_X64
#elif defined(__i386) || defined(_M_IX86)
#define MA_X86
#elif defined(MA_ARM32) || defined(MA_ARM64)
#define MA_ARM
#endif

/* Intrinsics Support */
#if (defined(MA_X64) || defined(MA_X86)) && !defined(__COSMOPOLITAN__)
    #if defined(_MSC_VER) && !defined(__clang__)
        /* MSVC. */
        #if _MSC_VER >= 1400 && !defined(MA_NO_SSE2)   /* 2005 */
            #define MA_SUPPORT_SSE2
        #endif
        /*#if _MSC_VER >= 1600 && !defined(MA_NO_AVX)*/    /* 2010 */
        /*    #define MA_SUPPORT_AVX*/
        /*#endif*/
        #if _MSC_VER >= 1700 && !defined(MA_NO_AVX2)   /* 2012 */
            #define MA_SUPPORT_AVX2
        #endif
    #else
        /* Assume GNUC-style. */
        #if defined(__SSE2__) && !defined(MA_NO_SSE2)
            #define MA_SUPPORT_SSE2
        #endif
        /*#if defined(__AVX__) && !defined(MA_NO_AVX)*/
        /*    #define MA_SUPPORT_AVX*/
        /*#endif*/
        #if defined(__AVX2__) && !defined(MA_NO_AVX2)
            #define MA_SUPPORT_AVX2
        #endif
    #endif

    /* If at this point we still haven't determined compiler support for the intrinsics just fall back to __has_include. */
    #if !defined(__GNUC__) && !defined(__clang__) && defined(__has_include)
        #if !defined(MA_SUPPORT_SSE2)   && !defined(MA_NO_SSE2)   && __has_include(<emmintrin.h>)
            #define MA_SUPPORT_SSE2
        #endif
        /*#if !defined(MA_SUPPORT_AVX)    && !defined(MA_NO_AVX)    && __has_include(<immintrin.h>)*/
        /*    #define MA_SUPPORT_AVX*/
        /*#endif*/
        #if !defined(MA_SUPPORT_AVX2)   && !defined(MA_NO_AVX2)   && __has_include(<immintrin.h>)
            #define MA_SUPPORT_AVX2
        #endif
    #endif

    #if defined(MA_SUPPORT_AVX2) || defined(MA_SUPPORT_AVX)
        #include <immintrin.h>
    #elif defined(MA_SUPPORT_SSE2)
        #include <emmintrin.h>
    #endif
#endif

#if defined(MA_ARM)
    #if !defined(MA_NO_NEON) && (defined(__ARM_NEON) || defined(__aarch64__) || defined(_M_ARM64))
        #define MA_SUPPORT_NEON
        #include <arm_neon.h>
    #endif
#endif

/* Begin globally disabled warnings. */
#if defined(_MSC_VER)
    #pragma warning(push)
    #pragma warning(disable:4752)   /* found Intel(R) Advanced Vector Extensions; consider using /arch:AVX */
    #pragma warning(disable:4049)   /* compiler limit : terminating line number emission */
#endif

#if defined(MA_X64) || defined(MA_X86)
    #if defined(_MSC_VER) && !defined(__clang__)
        #if _MSC_VER >= 1400
            #include <intrin.h>
            static MA_INLINE void ma_cpuid(int info[4], int fid)
            {
                __cpuid(info, fid);
            }
        #else
            #define MA_NO_CPUID
        #endif

        #if _MSC_VER >= 1600 && (defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 160040219)
            static MA_INLINE unsigned __int64 ma_xgetbv(int reg)
            {
                return _xgetbv(reg);
            }
        #else
            #define MA_NO_XGETBV
        #endif
    #elif (defined(__GNUC__) || defined(__clang__)) && !defined(MA_ANDROID)
        static MA_INLINE void ma_cpuid(int info[4], int fid)
        {
            /*
            It looks like the -fPIC option uses the ebx register which GCC complains about. We can work around this by just using a different register, the
            specific register of which I'm letting the compiler decide on. The "k" prefix is used to specify a 32-bit register. The {...} syntax is for
            supporting different assembly dialects.

            What's basically happening is that we're saving and restoring the ebx register manually.
            */
            #if defined(MA_X86) && defined(__PIC__)
                __asm__ __volatile__ (
                    "xchg{l} {%%}ebx, %k1;"
                    "cpuid;"
                    "xchg{l} {%%}ebx, %k1;"
                    : "=a"(info[0]), "=&r"(info[1]), "=c"(info[2]), "=d"(info[3]) : "a"(fid), "c"(0)
                );
            #else
                __asm__ __volatile__ (
                    "cpuid" : "=a"(info[0]), "=b"(info[1]), "=c"(info[2]), "=d"(info[3]) : "a"(fid), "c"(0)
                );
            #endif
        }

        static MA_INLINE ma_uint64 ma_xgetbv(int reg)
        {
            unsigned int hi;
            unsigned int lo;

            __asm__ __volatile__ (
                "xgetbv" : "=a"(lo), "=d"(hi) : "c"(reg)
            );

            return ((ma_uint64)hi << 32) | (ma_uint64)lo;
        }
    #else
        #define MA_NO_CPUID
        #define MA_NO_XGETBV
    #endif
#else
    #define MA_NO_CPUID
    #define MA_NO_XGETBV
#endif

static MA_INLINE ma_bool32 ma_has_sse2(void)
{
#if defined(MA_SUPPORT_SSE2)
    #if (defined(MA_X64) || defined(MA_X86)) && !defined(MA_NO_SSE2)
        #if defined(MA_X64)
            return MA_TRUE;    /* 64-bit targets always support SSE2. */
        #elif (defined(_M_IX86_FP) && _M_IX86_FP == 2) || defined(__SSE2__)
            return MA_TRUE;    /* If the compiler is allowed to freely generate SSE2 code we can assume support. */
        #else
            #if defined(MA_NO_CPUID)
                return MA_FALSE;
            #else
                int info[4];
                ma_cpuid(info, 1);
                return (info[3] & (1 << 26)) != 0;
            #endif
        #endif
    #else
        return MA_FALSE;       /* SSE2 is only supported on x86 and x64 architectures. */
    #endif
#else
    return MA_FALSE;           /* No compiler support. */
#endif
}

#if 0
static MA_INLINE ma_bool32 ma_has_avx()
{
#if defined(MA_SUPPORT_AVX)
    #if (defined(MA_X64) || defined(MA_X86)) && !defined(MA_NO_AVX)
        #if defined(_AVX_) || defined(__AVX__)
            return MA_TRUE;    /* If the compiler is allowed to freely generate AVX code we can assume support. */
        #else
            /* AVX requires both CPU and OS support. */
            #if defined(MA_NO_CPUID) || defined(MA_NO_XGETBV)
                return MA_FALSE;
            #else
                int info[4];
                ma_cpuid(info, 1);
                if (((info[2] & (1 << 27)) != 0) && ((info[2] & (1 << 28)) != 0)) {
                    ma_uint64 xrc = ma_xgetbv(0);
                    if ((xrc & 0x06) == 0x06) {
                        return MA_TRUE;
                    } else {
                        return MA_FALSE;
                    }
                } else {
                    return MA_FALSE;
                }
            #endif
        #endif
    #else
        return MA_FALSE;       /* AVX is only supported on x86 and x64 architectures. */
    #endif
#else
    return MA_FALSE;           /* No compiler support. */
#endif
}
#endif

static MA_INLINE ma_bool32 ma_has_avx2(void)
{
#if defined(MA_SUPPORT_AVX2)
    #if (defined(MA_X64) || defined(MA_X86)) && !defined(MA_NO_AVX2)
        #if defined(_AVX2_) || defined(__AVX2__)
            return MA_TRUE;    /* If the compiler is allowed to freely generate AVX2 code we can assume support. */
        #else
            /* AVX2 requires both CPU and OS support. */
            #if defined(MA_NO_CPUID) || defined(MA_NO_XGETBV)
                return MA_FALSE;
            #else
                int info1[4];
                int info7[4];
                ma_cpuid(info1, 1);
                ma_cpuid(info7, 7);
                if (((info1[2] & (1 << 27)) != 0) && ((info7[1] & (1 << 5)) != 0)) {
                    ma_uint64 xrc = ma_xgetbv(0);
                    if ((xrc & 0x06) == 0x06) {
                        return MA_TRUE;
                    } else {
                        return MA_FALSE;
                    }
                } else {
                    return MA_FALSE;
                }
            #endif
        #endif
    #else
        return MA_FALSE;       /* AVX2 is only supported on x86 and x64 architectures. */
    #endif
#else
    return MA_FALSE;           /* No compiler support. */
#endif
}

static MA_INLINE ma_bool32 ma_has_neon(void)
{
#if defined(MA_SUPPORT_NEON)
    #if defined(MA_ARM) && !defined(MA_NO_NEON)
        #if (defined(__ARM_NEON) || defined(__aarch64__) || defined(_M_ARM64))
            return MA_TRUE;    /* If the compiler is allowed to freely generate NEON code we can assume support. */
        #else
            /* TODO: Runtime check. */
            return MA_FALSE;
        #endif
    #else
        return MA_FALSE;       /* NEON is only supported on ARM architectures. */
    #endif
#else
    return MA_FALSE;           /* No compiler support. */
#endif
}

#if defined(__has_builtin)
    #define MA_COMPILER_HAS_BUILTIN(x) __has_builtin(x)
#else
    #define MA_COMPILER_HAS_BUILTIN(x) 0
#endif

#ifndef MA_ASSUME
    #if MA_COMPILER_HAS_BUILTIN(__builtin_assume)
        #define MA_ASSUME(x) __builtin_assume(x)
    #elif MA_COMPILER_HAS_BUILTIN(__builtin_unreachable)
        #define MA_ASSUME(x) do { if (!(x)) __builtin_unreachable(); } while (0)
    #elif defined(_MSC_VER)
        #define MA_ASSUME(x) __assume(x)
    #else
        #define MA_ASSUME(x) (void)(x)
    #endif
#endif

#ifndef MA_RESTRICT
    #if defined(__clang__) || defined(__GNUC__) || defined(_MSC_VER)
        #define MA_RESTRICT __restrict
    #else
        #define MA_RESTRICT
    #endif
#endif

#if defined(_MSC_VER) && _MSC_VER >= 1400
    #define MA_HAS_BYTESWAP16_INTRINSIC
    #define MA_HAS_BYTESWAP32_INTRINSIC
    #define MA_HAS_BYTESWAP64_INTRINSIC
#elif defined(__clang__)
    #if MA_COMPILER_HAS_BUILTIN(__builtin_bswap16)
        #define MA_HAS_BYTESWAP16_INTRINSIC
    #endif
    #if MA_COMPILER_HAS_BUILTIN(__builtin_bswap32)
        #define MA_HAS_BYTESWAP32_INTRINSIC
    #endif
    #if MA_COMPILER_HAS_BUILTIN(__builtin_bswap64)
        #define MA_HAS_BYTESWAP64_INTRINSIC
    #endif
#elif defined(__GNUC__)
    #if ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
        #define MA_HAS_BYTESWAP32_INTRINSIC
        #define MA_HAS_BYTESWAP64_INTRINSIC
    #endif
    #if ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8))
        #define MA_HAS_BYTESWAP16_INTRINSIC
    #endif
#endif


static MA_INLINE ma_bool32 ma_is_little_endian(void)
{
#if defined(MA_X86) || defined(MA_X64)
    return MA_TRUE;
#else
    int n = 1;
    return (*(char*)&n) == 1;
#endif
}

static MA_INLINE ma_bool32 ma_is_big_endian(void)
{
    return !ma_is_little_endian();
}


static MA_INLINE ma_uint32 ma_swap_endian_uint32(ma_uint32 n)
{
#ifdef MA_HAS_BYTESWAP32_INTRINSIC
    #if defined(_MSC_VER)
        return _byteswap_ulong(n);
    #elif defined(__GNUC__) || defined(__clang__)
        #if defined(MA_ARM) && (defined(__ARM_ARCH) && __ARM_ARCH >= 6) && !defined(MA_64BIT)   /* <-- 64-bit inline assembly has not been tested, so disabling for now. */
            /* Inline assembly optimized implementation for ARM. In my testing, GCC does not generate optimized code with __builtin_bswap32(). */
            ma_uint32 r;
            __asm__ __volatile__ (
            #if defined(MA_64BIT)
                "rev %w[out], %w[in]" : [out]"=r"(r) : [in]"r"(n)   /* <-- This is untested. If someone in the community could test this, that would be appreciated! */
            #else
                "rev %[out], %[in]" : [out]"=r"(r) : [in]"r"(n)
            #endif
            );
            return r;
        #else
            return __builtin_bswap32(n);
        #endif
    #else
        #error "This compiler does not support the byte swap intrinsic."
    #endif
#else
    return ((n & 0xFF000000) >> 24) |
           ((n & 0x00FF0000) >>  8) |
           ((n & 0x0000FF00) <<  8) |
           ((n & 0x000000FF) << 24);
#endif
}


#if !defined(MA_EMSCRIPTEN)
#ifdef MA_WIN32
static void ma_sleep__win32(ma_uint32 milliseconds)
{
    Sleep((DWORD)milliseconds);
}
#endif
#ifdef MA_POSIX
static void ma_sleep__posix(ma_uint32 milliseconds)
{
#ifdef MA_EMSCRIPTEN
    (void)milliseconds;
    MA_ASSERT(MA_FALSE);  /* The Emscripten build should never sleep. */
#else
    #if (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 199309L) || defined(MA_NX)
        struct timespec ts;
        ts.tv_sec  = milliseconds / 1000;
        ts.tv_nsec = milliseconds % 1000 * 1000000;
        nanosleep(&ts, NULL);
    #else
        struct timeval tv;
        tv.tv_sec  = milliseconds / 1000;
        tv.tv_usec = milliseconds % 1000 * 1000;
        select(0, NULL, NULL, NULL, &tv);
    #endif
#endif
}
#endif

static MA_INLINE void ma_sleep(ma_uint32 milliseconds)
{
#ifdef MA_WIN32
    ma_sleep__win32(milliseconds);
#endif
#ifdef MA_POSIX
    ma_sleep__posix(milliseconds);
#endif
}
#endif

static MA_INLINE void ma_yield(void)
{
#if defined(__i386) || defined(_M_IX86) || defined(__x86_64__) || defined(_M_X64)
    /* x86/x64 */
    #if (defined(_MSC_VER) || defined(__WATCOMC__) || defined(__DMC__)) && !defined(__clang__)
        #if _MSC_VER >= 1400
            _mm_pause();
        #else
            #if defined(__DMC__)
                /* Digital Mars does not recognize the PAUSE opcode. Fall back to NOP. */
                __asm nop;
            #else
                __asm pause;
            #endif
        #endif
    #else
        __asm__ __volatile__ ("pause");
    #endif
#elif (defined(__arm__) && defined(__ARM_ARCH) && __ARM_ARCH >= 7) || defined(_M_ARM64) || (defined(_M_ARM) && _M_ARM >= 7) || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6T2__)
    /* ARM */
    #if defined(_MSC_VER)
        /* Apparently there is a __yield() intrinsic that's compatible with ARM, but I cannot find documentation for it nor can I find where it's declared. */
        __yield();
    #else
        __asm__ __volatile__ ("yield"); /* ARMv6K/ARMv6T2 and above. */
    #endif
#else
    /* Unknown or unsupported architecture. No-op. */
#endif
}


#define MA_MM_DENORMALS_ZERO_MASK   0x0040
#define MA_MM_FLUSH_ZERO_MASK       0x8000

static MA_INLINE unsigned int ma_disable_denormals(void)
{
    unsigned int prevState;

    #if defined(_MSC_VER)
    {
        /*
        Older versions of Visual Studio don't support the "safe" versions of _controlfp_s(). I don't
        know which version of Visual Studio first added support for _controlfp_s(), but I do know
        that VC6 lacks support. _MSC_VER = 1200 is VC6, but if you get compilation errors on older
        versions of Visual Studio, let me know and I'll make the necessary adjustment.
        */
        #if _MSC_VER <= 1200
        {
            prevState = _statusfp();
            _controlfp(prevState | _DN_FLUSH, _MCW_DN);
        }
        #else
        {
            unsigned int unused;
            _controlfp_s(&prevState, 0, 0);
            _controlfp_s(&unused, prevState | _DN_FLUSH, _MCW_DN);
        }
        #endif
    }
    #elif defined(MA_X86) || defined(MA_X64)
    {
        #if defined(__SSE2__) && !(defined(__TINYC__) || defined(__WATCOMC__) || defined(__COSMOPOLITAN__)) /* <-- Add compilers that lack support for _mm_getcsr() and _mm_setcsr() to this list. */
        {
            prevState = _mm_getcsr();
            _mm_setcsr(prevState | MA_MM_DENORMALS_ZERO_MASK | MA_MM_FLUSH_ZERO_MASK);
        }
        #else
        {
            /* x88/64, but no support for _mm_getcsr()/_mm_setcsr(). May need to fall back to inlined assembly here. */
            prevState = 0;
        }
        #endif
    }
    #else
    {
        /* Unknown or unsupported architecture. No-op. */
        prevState = 0;
    }
    #endif

    return prevState;
}

static MA_INLINE void ma_restore_denormals(unsigned int prevState)
{
    #if defined(_MSC_VER)
    {
        /* Older versions of Visual Studio do not support _controlfp_s(). See ma_disable_denormals(). */
        #if _MSC_VER <= 1200
        {
            _controlfp(prevState, _MCW_DN);
        }
        #else
        {
            unsigned int unused;
            _controlfp_s(&unused, prevState, _MCW_DN);
        }
        #endif
    }
    #elif defined(MA_X86) || defined(MA_X64)
    {
        #if defined(__SSE2__) && !(defined(__TINYC__) || defined(__WATCOMC__) || defined(__COSMOPOLITAN__))   /* <-- Add compilers that lack support for _mm_getcsr() and _mm_setcsr() to this list. */
        {
            _mm_setcsr(prevState);
        }
        #else
        {
            /* x88/64, but no support for _mm_getcsr()/_mm_setcsr(). May need to fall back to inlined assembly here. */
            (void)prevState;
        }
        #endif
    }
    #else
    {
        /* Unknown or unsupported architecture. No-op. */
        (void)prevState;
    }
    #endif
}


#ifdef MA_ANDROID
#include <sys/system_properties.h>

int ma_android_sdk_version()
{
    char sdkVersion[PROP_VALUE_MAX + 1] = {0, };
    if (__system_property_get("ro.build.version.sdk", sdkVersion)) {
        return atoi(sdkVersion);
    }

    return 0;
}
#endif


#ifndef MA_COINIT_VALUE
#define MA_COINIT_VALUE    0   /* 0 = COINIT_MULTITHREADED */
#endif


#ifndef MA_FLT_MAX
    #ifdef FLT_MAX
        #define MA_FLT_MAX FLT_MAX
    #else
        #define MA_FLT_MAX 3.402823466e+38F
    #endif
#endif


#ifndef MA_PI
#define MA_PI      3.14159265358979323846264f
#endif
#ifndef MA_PI_D
#define MA_PI_D    3.14159265358979323846264
#endif
#ifndef MA_TAU
#define MA_TAU     6.28318530717958647693f
#endif
#ifndef MA_TAU_D
#define MA_TAU_D   6.28318530717958647693
#endif


/* The default format when ma_format_unknown (0) is requested when initializing a device. */
#ifndef MA_DEFAULT_FORMAT
#define MA_DEFAULT_FORMAT                                   ma_format_f32
#endif

/* The default channel count to use when 0 is used when initializing a device. */
#ifndef MA_DEFAULT_CHANNELS
#define MA_DEFAULT_CHANNELS                                 2
#endif

/* The default sample rate to use when 0 is used when initializing a device. */
#ifndef MA_DEFAULT_SAMPLE_RATE
#define MA_DEFAULT_SAMPLE_RATE                              48000
#endif

/* Default periods when none is specified in ma_device_init(). More periods means more work on the CPU. */
#ifndef MA_DEFAULT_PERIODS
#define MA_DEFAULT_PERIODS                                  3
#endif

/* The default period size in milliseconds for low latency mode. */
#ifndef MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_LOW_LATENCY
#define MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_LOW_LATENCY  10
#endif

/* The default buffer size in milliseconds for conservative mode. */
#ifndef MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_CONSERVATIVE
#define MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_CONSERVATIVE 100
#endif

/* The default LPF filter order for linear resampling. Note that this is clamped to MA_MAX_FILTER_ORDER. */
#ifndef MA_DEFAULT_RESAMPLER_LPF_ORDER
    #if MA_MAX_FILTER_ORDER >= 4
        #define MA_DEFAULT_RESAMPLER_LPF_ORDER  4
    #else
        #define MA_DEFAULT_RESAMPLER_LPF_ORDER  MA_MAX_FILTER_ORDER
    #endif
#endif


#if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)))
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
#endif

/* Standard sample rates, in order of priority. */
static ma_uint32 g_maStandardSampleRatePriorities[] = {
    (ma_uint32)ma_standard_sample_rate_48000,
    (ma_uint32)ma_standard_sample_rate_44100,

    (ma_uint32)ma_standard_sample_rate_32000,
    (ma_uint32)ma_standard_sample_rate_24000,
    (ma_uint32)ma_standard_sample_rate_22050,

    (ma_uint32)ma_standard_sample_rate_88200,
    (ma_uint32)ma_standard_sample_rate_96000,
    (ma_uint32)ma_standard_sample_rate_176400,
    (ma_uint32)ma_standard_sample_rate_192000,

    (ma_uint32)ma_standard_sample_rate_16000,
    (ma_uint32)ma_standard_sample_rate_11025,
    (ma_uint32)ma_standard_sample_rate_8000,

    (ma_uint32)ma_standard_sample_rate_352800,
    (ma_uint32)ma_standard_sample_rate_384000
};

static MA_INLINE ma_bool32 ma_is_standard_sample_rate(ma_uint32 sampleRate)
{
    ma_uint32 iSampleRate;

    for (iSampleRate = 0; iSampleRate < sizeof(g_maStandardSampleRatePriorities) / sizeof(g_maStandardSampleRatePriorities[0]); iSampleRate += 1) {
        if (g_maStandardSampleRatePriorities[iSampleRate] == sampleRate) {
            return MA_TRUE;
        }
    }

    /* Getting here means the sample rate is not supported. */
    return MA_FALSE;
}


static ma_format g_maFormatPriorities[] = {
    ma_format_s16,         /* Most common */
    ma_format_f32,

    /*ma_format_s24_32,*/    /* Clean alignment */
    ma_format_s32,

    ma_format_s24,         /* Unclean alignment */

    ma_format_u8           /* Low quality */
};
#if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)))
    #pragma GCC diagnostic pop
#endif


MA_API void ma_version(ma_uint32* pMajor, ma_uint32* pMinor, ma_uint32* pRevision)
{
    if (pMajor) {
        *pMajor = MA_VERSION_MAJOR;
    }

    if (pMinor) {
        *pMinor = MA_VERSION_MINOR;
    }

    if (pRevision) {
        *pRevision = MA_VERSION_REVISION;
    }
}

MA_API const char* ma_version_string(void)
{
    return MA_VERSION_STRING;
}


/******************************************************************************

Standard Library Stuff

******************************************************************************/
#ifndef MA_ASSERT
#define MA_ASSERT(condition)            assert(condition)
#endif

#ifndef MA_MALLOC
#define MA_MALLOC(sz)                   malloc((sz))
#endif
#ifndef MA_REALLOC
#define MA_REALLOC(p, sz)               realloc((p), (sz))
#endif
#ifndef MA_FREE
#define MA_FREE(p)                      free((p))
#endif

static MA_INLINE void ma_zero_memory_default(void* p, size_t sz)
{
    if (p == NULL) {
        MA_ASSERT(sz == 0); /* If this is triggered there's an error with the calling code. */
        return;
    }

    if (sz > 0) {
        memset(p, 0, sz);
    }
}


#ifndef MA_ZERO_MEMORY
#define MA_ZERO_MEMORY(p, sz)           ma_zero_memory_default((p), (sz))
#endif
#ifndef MA_COPY_MEMORY
#define MA_COPY_MEMORY(dst, src, sz)    memcpy((dst), (src), (sz))
#endif
#ifndef MA_MOVE_MEMORY
#define MA_MOVE_MEMORY(dst, src, sz)    memmove((dst), (src), (sz))
#endif

#define MA_ZERO_OBJECT(p)               MA_ZERO_MEMORY((p), sizeof(*(p)))

#define ma_countof(x)                   (sizeof(x) / sizeof(x[0]))
#define ma_max(x, y)                    (((x) > (y)) ? (x) : (y))
#define ma_min(x, y)                    (((x) < (y)) ? (x) : (y))
#define ma_abs(x)                       (((x) > 0) ? (x) : -(x))
#define ma_clamp(x, lo, hi)             (ma_max(lo, ma_min(x, hi)))
#define ma_offset_ptr(p, offset)        (((ma_uint8*)(p)) + (offset))
#define ma_align(x, a)                  (((x) + ((a)-1)) & ~((a)-1))
#define ma_align_64(x)                  ma_align(x, 8)

#define ma_buffer_frame_capacity(buffer, channels, format) (sizeof(buffer) / ma_get_bytes_per_sample(format) / (channels))

static MA_INLINE double ma_sind(double x)
{
    /* TODO: Implement custom sin(x). */
    return sin(x);
}

static MA_INLINE double ma_expd(double x)
{
    /* TODO: Implement custom exp(x). */
    return exp(x);
}

static MA_INLINE double ma_logd(double x)
{
    /* TODO: Implement custom log(x). */
    return log(x);
}

static MA_INLINE double ma_powd(double x, double y)
{
    /* TODO: Implement custom pow(x, y). */
    return pow(x, y);
}

static MA_INLINE double ma_sqrtd(double x)
{
    /* TODO: Implement custom sqrt(x). */
    return sqrt(x);
}


static MA_INLINE float ma_rsqrtf(float x)
{
    #if defined(MA_SUPPORT_SSE2) && !defined(MA_NO_SSE2) && (defined(MA_X64) || (defined(_M_IX86_FP) && _M_IX86_FP == 2) || defined(__SSE2__))
    {
        /*
        For SSE we can use RSQRTSS.

        This Stack Overflow post suggests that compilers don't necessarily generate optimal code
        when using intrinsics:

            https://web.archive.org/web/20221211012522/https://stackoverflow.com/questions/32687079/getting-fewest-instructions-for-rsqrtss-wrapper

        I'm going to do something similar here, but a bit simpler.
        */
        #if defined(__GNUC__) || defined(__clang__)
        {
            float result;
            __asm__ __volatile__("rsqrtss %1, %0" : "=x"(result) : "x"(x));
            return result;
        }
        #else
        {
            return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ps1(x)));
        }
        #endif
    }
    #else
    {
        return 1 / (float)ma_sqrtd(x);
    }
    #endif
}


static MA_INLINE float ma_sinf(float x)
{
    return (float)ma_sind((float)x);
}

static MA_INLINE double ma_cosd(double x)
{
    return ma_sind((MA_PI_D*0.5) - x);
}

static MA_INLINE float ma_cosf(float x)
{
    return (float)ma_cosd((float)x);
}

static MA_INLINE double ma_log10d(double x)
{
    return ma_logd(x) * 0.43429448190325182765;
}

static MA_INLINE float ma_powf(float x, float y)
{
    return (float)ma_powd((double)x, (double)y);
}

static MA_INLINE float ma_log10f(float x)
{
    return (float)ma_log10d((double)x);
}


static MA_INLINE double ma_degrees_to_radians(double degrees)
{
    return degrees * 0.01745329252;
}

static MA_INLINE double ma_radians_to_degrees(double radians)
{
    return radians * 57.295779512896;
}

static MA_INLINE float ma_degrees_to_radians_f(float degrees)
{
    return degrees * 0.01745329252f;
}

static MA_INLINE float ma_radians_to_degrees_f(float radians)
{
    return radians * 57.295779512896f;
}


/*
Return Values:
  0:  Success
  22: EINVAL
  34: ERANGE

Not using symbolic constants for errors because I want to avoid #including errno.h

These are marked as no-inline because of some bad code generation by Clang. None of these functions
are used in any performance-critical code within miniaudio.
*/
MA_API MA_NO_INLINE int ma_strcpy_s(char* dst, size_t dstSizeInBytes, const char* src)
{
    size_t i;

    if (dst == 0) {
        return 22;
    }
    if (dstSizeInBytes == 0) {
        return 34;
    }
    if (src == 0) {
        dst[0] = '\0';
        return 22;
    }

    for (i = 0; i < dstSizeInBytes && src[i] != '\0'; ++i) {
        dst[i] = src[i];
    }

    if (i < dstSizeInBytes) {
        dst[i] = '\0';
        return 0;
    }

    dst[0] = '\0';
    return 34;
}

MA_API MA_NO_INLINE int ma_wcscpy_s(wchar_t* dst, size_t dstCap, const wchar_t* src)
{
    size_t i;

    if (dst == 0) {
        return 22;
    }
    if (dstCap == 0) {
        return 34;
    }
    if (src == 0) {
        dst[0] = '\0';
        return 22;
    }

    for (i = 0; i < dstCap && src[i] != '\0'; ++i) {
        dst[i] = src[i];
    }

    if (i < dstCap) {
        dst[i] = '\0';
        return 0;
    }

    dst[0] = '\0';
    return 34;
}


MA_API MA_NO_INLINE int ma_strncpy_s(char* dst, size_t dstSizeInBytes, const char* src, size_t count)
{
    size_t maxcount;
    size_t i;

    if (dst == 0) {
        return 22;
    }
    if (dstSizeInBytes == 0) {
        return 34;
    }
    if (src == 0) {
        dst[0] = '\0';
        return 22;
    }

    maxcount = count;
    if (count == ((size_t)-1) || count >= dstSizeInBytes) {        /* -1 = _TRUNCATE */
        maxcount = dstSizeInBytes - 1;
    }

    for (i = 0; i < maxcount && src[i] != '\0'; ++i) {
        dst[i] = src[i];
    }

    if (src[i] == '\0' || i == count || count == ((size_t)-1)) {
        dst[i] = '\0';
        return 0;
    }

    dst[0] = '\0';
    return 34;
}

MA_API MA_NO_INLINE int ma_strcat_s(char* dst, size_t dstSizeInBytes, const char* src)
{
    char* dstorig;

    if (dst == 0) {
        return 22;
    }
    if (dstSizeInBytes == 0) {
        return 34;
    }
    if (src == 0) {
        dst[0] = '\0';
        return 22;
    }

    dstorig = dst;

    while (dstSizeInBytes > 0 && dst[0] != '\0') {
        dst += 1;
        dstSizeInBytes -= 1;
    }

    if (dstSizeInBytes == 0) {
        return 22;  /* Unterminated. */
    }


    while (dstSizeInBytes > 0 && src[0] != '\0') {
        *dst++ = *src++;
        dstSizeInBytes -= 1;
    }

    if (dstSizeInBytes > 0) {
        dst[0] = '\0';
    } else {
        dstorig[0] = '\0';
        return 34;
    }

    return 0;
}

MA_API MA_NO_INLINE int ma_strncat_s(char* dst, size_t dstSizeInBytes, const char* src, size_t count)
{
    char* dstorig;

    if (dst == 0) {
        return 22;
    }
    if (dstSizeInBytes == 0) {
        return 34;
    }
    if (src == 0) {
        return 22;
    }

    dstorig = dst;

    while (dstSizeInBytes > 0 && dst[0] != '\0') {
        dst += 1;
        dstSizeInBytes -= 1;
    }

    if (dstSizeInBytes == 0) {
        return 22;  /* Unterminated. */
    }


    if (count == ((size_t)-1)) {        /* _TRUNCATE */
        count = dstSizeInBytes - 1;
    }

    while (dstSizeInBytes > 0 && src[0] != '\0' && count > 0) {
        *dst++ = *src++;
        dstSizeInBytes -= 1;
        count -= 1;
    }

    if (dstSizeInBytes > 0) {
        dst[0] = '\0';
    } else {
        dstorig[0] = '\0';
        return 34;
    }

    return 0;
}

MA_API MA_NO_INLINE int ma_itoa_s(int value, char* dst, size_t dstSizeInBytes, int radix)
{
    int sign;
    unsigned int valueU;
    char* dstEnd;

    if (dst == NULL || dstSizeInBytes == 0) {
        return 22;
    }
    if (radix < 2 || radix > 36) {
        dst[0] = '\0';
        return 22;
    }

    sign = (value < 0 && radix == 10) ? -1 : 1;     /* The negative sign is only used when the base is 10. */

    if (value < 0) {
        valueU = -value;
    } else {
        valueU = value;
    }

    dstEnd = dst;
    do
    {
        int remainder = valueU % radix;
        if (remainder > 9) {
            *dstEnd = (char)((remainder - 10) + 'a');
        } else {
            *dstEnd = (char)(remainder + '0');
        }

        dstEnd += 1;
        dstSizeInBytes -= 1;
        valueU /= radix;
    } while (dstSizeInBytes > 0 && valueU > 0);

    if (dstSizeInBytes == 0) {
        dst[0] = '\0';
        return 22;  /* Ran out of room in the output buffer. */
    }

    if (sign < 0) {
        *dstEnd++ = '-';
        dstSizeInBytes -= 1;
    }

    if (dstSizeInBytes == 0) {
        dst[0] = '\0';
        return 22;  /* Ran out of room in the output buffer. */
    }

    *dstEnd = '\0';


    /* At this point the string will be reversed. */
    dstEnd -= 1;
    while (dst < dstEnd) {
        char temp = *dst;
        *dst = *dstEnd;
        *dstEnd = temp;

        dst += 1;
        dstEnd -= 1;
    }

    return 0;
}

MA_API MA_NO_INLINE int ma_strcmp(const char* str1, const char* str2)
{
    if (str1 == str2) return  0;

    /* These checks differ from the standard implementation. It's not important, but I prefer it just for sanity. */
    if (str1 == NULL) return -1;
    if (str2 == NULL) return  1;

    for (;;) {
        if (str1[0] == '\0') {
            break;
        }
        if (str1[0] != str2[0]) {
            break;
        }

        str1 += 1;
        str2 += 1;
    }

    return ((unsigned char*)str1)[0] - ((unsigned char*)str2)[0];
}

MA_API MA_NO_INLINE int ma_strappend(char* dst, size_t dstSize, const char* srcA, const char* srcB)
{
    int result;

    result = ma_strncpy_s(dst, dstSize, srcA, (size_t)-1);
    if (result != 0) {
        return result;
    }

    result = ma_strncat_s(dst, dstSize, srcB, (size_t)-1);
    if (result != 0) {
        return result;
    }

    return result;
}

MA_API MA_NO_INLINE char* ma_copy_string(const char* src, const ma_allocation_callbacks* pAllocationCallbacks)
{
    size_t sz;
    char* dst;

    if (src == NULL) {
        return NULL;
    }

    sz = strlen(src)+1;
    dst = (char*)ma_malloc(sz, pAllocationCallbacks);
    if (dst == NULL) {
        return NULL;
    }

    ma_strcpy_s(dst, sz, src);

    return dst;
}

MA_API MA_NO_INLINE wchar_t* ma_copy_string_w(const wchar_t* src, const ma_allocation_callbacks* pAllocationCallbacks)
{
    size_t sz = wcslen(src)+1;
    wchar_t* dst = (wchar_t*)ma_malloc(sz * sizeof(*dst), pAllocationCallbacks);
    if (dst == NULL) {
        return NULL;
    }

    ma_wcscpy_s(dst, sz, src);

    return dst;
}



#include <errno.h>
static ma_result ma_result_from_errno(int e)
{
    if (e == 0) {
        return MA_SUCCESS;
    }
#ifdef EPERM
    else if (e == EPERM) { return MA_INVALID_OPERATION; }
#endif
#ifdef ENOENT
    else if (e == ENOENT) { return MA_DOES_NOT_EXIST; }
#endif
#ifdef ESRCH
    else if (e == ESRCH) { return MA_DOES_NOT_EXIST; }
#endif
#ifdef EINTR
    else if (e == EINTR) { return MA_INTERRUPT; }
#endif
#ifdef EIO
    else if (e == EIO) { return MA_IO_ERROR; }
#endif
#ifdef ENXIO
    else if (e == ENXIO) { return MA_DOES_NOT_EXIST; }
#endif
#ifdef E2BIG
    else if (e == E2BIG) { return MA_INVALID_ARGS; }
#endif
#ifdef ENOEXEC
    else if (e == ENOEXEC) { return MA_INVALID_FILE; }
#endif
#ifdef EBADF
    else if (e == EBADF) { return MA_INVALID_FILE; }
#endif
#ifdef ECHILD
    else if (e == ECHILD) { return MA_ERROR; }
#endif
#ifdef EAGAIN
    else if (e == EAGAIN) { return MA_UNAVAILABLE; }
#endif
#ifdef ENOMEM
    else if (e == ENOMEM) { return MA_OUT_OF_MEMORY; }
#endif
#ifdef EACCES
    else if (e == EACCES) { return MA_ACCESS_DENIED; }
#endif
#ifdef EFAULT
    else if (e == EFAULT) { return MA_BAD_ADDRESS; }
#endif
#ifdef ENOTBLK
    else if (e == ENOTBLK) { return MA_ERROR; }
#endif
#ifdef EBUSY
    else if (e == EBUSY) { return MA_BUSY; }
#endif
#ifdef EEXIST
    else if (e == EEXIST) { return MA_ALREADY_EXISTS; }
#endif
#ifdef EXDEV
    else if (e == EXDEV) { return MA_ERROR; }
#endif
#ifdef ENODEV
    else if (e == ENODEV) { return MA_DOES_NOT_EXIST; }
#endif
#ifdef ENOTDIR
    else if (e == ENOTDIR) { return MA_NOT_DIRECTORY; }
#endif
#ifdef EISDIR
    else if (e == EISDIR) { return MA_IS_DIRECTORY; }
#endif
#ifdef EINVAL
    else if (e == EINVAL) { return MA_INVALID_ARGS; }
#endif
#ifdef ENFILE
    else if (e == ENFILE) { return MA_TOO_MANY_OPEN_FILES; }
#endif
#ifdef EMFILE
    else if (e == EMFILE) { return MA_TOO_MANY_OPEN_FILES; }
#endif
#ifdef ENOTTY
    else if (e == ENOTTY) { return MA_INVALID_OPERATION; }
#endif
#ifdef ETXTBSY
    else if (e == ETXTBSY) { return MA_BUSY; }
#endif
#ifdef EFBIG
    else if (e == EFBIG) { return MA_TOO_BIG; }
#endif
#ifdef ENOSPC
    else if (e == ENOSPC) { return MA_NO_SPACE; }
#endif
#ifdef ESPIPE
    else if (e == ESPIPE) { return MA_BAD_SEEK; }
#endif
#ifdef EROFS
    else if (e == EROFS) { return MA_ACCESS_DENIED; }
#endif
#ifdef EMLINK
    else if (e == EMLINK) { return MA_TOO_MANY_LINKS; }
#endif
#ifdef EPIPE
    else if (e == EPIPE) { return MA_BAD_PIPE; }
#endif
#ifdef EDOM
    else if (e == EDOM) { return MA_OUT_OF_RANGE; }
#endif
#ifdef ERANGE
    else if (e == ERANGE) { return MA_OUT_OF_RANGE; }
#endif
#ifdef EDEADLK
    else if (e == EDEADLK) { return MA_DEADLOCK; }
#endif
#ifdef ENAMETOOLONG
    else if (e == ENAMETOOLONG) { return MA_PATH_TOO_LONG; }
#endif
#ifdef ENOLCK
    else if (e == ENOLCK) { return MA_ERROR; }
#endif
#ifdef ENOSYS
    else if (e == ENOSYS) { return MA_NOT_IMPLEMENTED; }
#endif
#ifdef ENOTEMPTY
    else if (e == ENOTEMPTY) { return MA_DIRECTORY_NOT_EMPTY; }
#endif
#ifdef ELOOP
    else if (e == ELOOP) { return MA_TOO_MANY_LINKS; }
#endif
#ifdef ENOMSG
    else if (e == ENOMSG) { return MA_NO_MESSAGE; }
#endif
#ifdef EIDRM
    else if (e == EIDRM) { return MA_ERROR; }
#endif
#ifdef ECHRNG
    else if (e == ECHRNG) { return MA_ERROR; }
#endif
#ifdef EL2NSYNC
    else if (e == EL2NSYNC) { return MA_ERROR; }
#endif
#ifdef EL3HLT
    else if (e == EL3HLT) { return MA_ERROR; }
#endif
#ifdef EL3RST
    else if (e == EL3RST) { return MA_ERROR; }
#endif
#ifdef ELNRNG
    else if (e == ELNRNG) { return MA_OUT_OF_RANGE; }
#endif
#ifdef EUNATCH
    else if (e == EUNATCH) { return MA_ERROR; }
#endif
#ifdef ENOCSI
    else if (e == ENOCSI) { return MA_ERROR; }
#endif
#ifdef EL2HLT
    else if (e == EL2HLT) { return MA_ERROR; }
#endif
#ifdef EBADE
    else if (e == EBADE) { return MA_ERROR; }
#endif
#ifdef EBADR
    else if (e == EBADR) { return MA_ERROR; }
#endif
#ifdef EXFULL
    else if (e == EXFULL) { return MA_ERROR; }
#endif
#ifdef ENOANO
    else if (e == ENOANO) { return MA_ERROR; }
#endif
#ifdef EBADRQC
    else if (e == EBADRQC) { return MA_ERROR; }
#endif
#ifdef EBADSLT
    else if (e == EBADSLT) { return MA_ERROR; }
#endif
#ifdef EBFONT
    else if (e == EBFONT) { return MA_INVALID_FILE; }
#endif
#ifdef ENOSTR
    else if (e == ENOSTR) { return MA_ERROR; }
#endif
#ifdef ENODATA
    else if (e == ENODATA) { return MA_NO_DATA_AVAILABLE; }
#endif
#ifdef ETIME
    else if (e == ETIME) { return MA_TIMEOUT; }
#endif
#ifdef ENOSR
    else if (e == ENOSR) { return MA_NO_DATA_AVAILABLE; }
#endif
#ifdef ENONET
    else if (e == ENONET) { return MA_NO_NETWORK; }
#endif
#ifdef ENOPKG
    else if (e == ENOPKG) { return MA_ERROR; }
#endif
#ifdef EREMOTE
    else if (e == EREMOTE) { return MA_ERROR; }
#endif
#ifdef ENOLINK
    else if (e == ENOLINK) { return MA_ERROR; }
#endif
#ifdef EADV
    else if (e == EADV) { return MA_ERROR; }
#endif
#ifdef ESRMNT
    else if (e == ESRMNT) { return MA_ERROR; }
#endif
#ifdef ECOMM
    else if (e == ECOMM) { return MA_ERROR; }
#endif
#ifdef EPROTO
    else if (e == EPROTO) { return MA_ERROR; }
#endif
#ifdef EMULTIHOP
    else if (e == EMULTIHOP) { return MA_ERROR; }
#endif
#ifdef EDOTDOT
    else if (e == EDOTDOT) { return MA_ERROR; }
#endif
#ifdef EBADMSG
    else if (e == EBADMSG) { return MA_BAD_MESSAGE; }
#endif
#ifdef EOVERFLOW
    else if (e == EOVERFLOW) { return MA_TOO_BIG; }
#endif
#ifdef ENOTUNIQ
    else if (e == ENOTUNIQ) { return MA_NOT_UNIQUE; }
#endif
#ifdef EBADFD
    else if (e == EBADFD) { return MA_ERROR; }
#endif
#ifdef EREMCHG
    else if (e == EREMCHG) { return MA_ERROR; }
#endif
#ifdef ELIBACC
    else if (e == ELIBACC) { return MA_ACCESS_DENIED; }
#endif
#ifdef ELIBBAD
    else if (e == ELIBBAD) { return MA_INVALID_FILE; }
#endif
#ifdef ELIBSCN
    else if (e == ELIBSCN) { return MA_INVALID_FILE; }
#endif
#ifdef ELIBMAX
    else if (e == ELIBMAX) { return MA_ERROR; }
#endif
#ifdef ELIBEXEC
    else if (e == ELIBEXEC) { return MA_ERROR; }
#endif
#ifdef EILSEQ
    else if (e == EILSEQ) { return MA_INVALID_DATA; }
#endif
#ifdef ERESTART
    else if (e == ERESTART) { return MA_ERROR; }
#endif
#ifdef ESTRPIPE
    else if (e == ESTRPIPE) { return MA_ERROR; }
#endif
#ifdef EUSERS
    else if (e == EUSERS) { return MA_ERROR; }
#endif
#ifdef ENOTSOCK
    else if (e == ENOTSOCK) { return MA_NOT_SOCKET; }
#endif
#ifdef EDESTADDRREQ
    else if (e == EDESTADDRREQ) { return MA_NO_ADDRESS; }
#endif
#ifdef EMSGSIZE
    else if (e == EMSGSIZE) { return MA_TOO_BIG; }
#endif
#ifdef EPROTOTYPE
    else if (e == EPROTOTYPE) { return MA_BAD_PROTOCOL; }
#endif
#ifdef ENOPROTOOPT
    else if (e == ENOPROTOOPT) { return MA_PROTOCOL_UNAVAILABLE; }
#endif
#ifdef EPROTONOSUPPORT
    else if (e == EPROTONOSUPPORT) { return MA_PROTOCOL_NOT_SUPPORTED; }
#endif
#ifdef ESOCKTNOSUPPORT
    else if (e == ESOCKTNOSUPPORT) { return MA_SOCKET_NOT_SUPPORTED; }
#endif
#ifdef EOPNOTSUPP
    else if (e == EOPNOTSUPP) { return MA_INVALID_OPERATION; }
#endif
#ifdef EPFNOSUPPORT
    else if (e == EPFNOSUPPORT) { return MA_PROTOCOL_FAMILY_NOT_SUPPORTED; }
#endif
#ifdef EAFNOSUPPORT
    else if (e == EAFNOSUPPORT) { return MA_ADDRESS_FAMILY_NOT_SUPPORTED; }
#endif
#ifdef EADDRINUSE
    else if (e == EADDRINUSE) { return MA_ALREADY_IN_USE; }
#endif
#ifdef EADDRNOTAVAIL
    else if (e == EADDRNOTAVAIL) { return MA_ERROR; }
#endif
#ifdef ENETDOWN
    else if (e == ENETDOWN) { return MA_NO_NETWORK; }
#endif
#ifdef ENETUNREACH
    else if (e == ENETUNREACH) { return MA_NO_NETWORK; }
#endif
#ifdef ENETRESET
    else if (e == ENETRESET) { return MA_NO_NETWORK; }
#endif
#ifdef ECONNABORTED
    else if (e == ECONNABORTED) { return MA_NO_NETWORK; }
#endif
#ifdef ECONNRESET
    else if (e == ECONNRESET) { return MA_CONNECTION_RESET; }
#endif
#ifdef ENOBUFS
    else if (e == ENOBUFS) { return MA_NO_SPACE; }
#endif
#ifdef EISCONN
    else if (e == EISCONN) { return MA_ALREADY_CONNECTED; }
#endif
#ifdef ENOTCONN
    else if (e == ENOTCONN) { return MA_NOT_CONNECTED; }
#endif
#ifdef ESHUTDOWN
    else if (e == ESHUTDOWN) { return MA_ERROR; }
#endif
#ifdef ETOOMANYREFS
    else if (e == ETOOMANYREFS) { return MA_ERROR; }
#endif
#ifdef ETIMEDOUT
    else if (e == ETIMEDOUT) { return MA_TIMEOUT; }
#endif
#ifdef ECONNREFUSED
    else if (e == ECONNREFUSED) { return MA_CONNECTION_REFUSED; }
#endif
#ifdef EHOSTDOWN
    else if (e == EHOSTDOWN) { return MA_NO_HOST; }
#endif
#ifdef EHOSTUNREACH
    else if (e == EHOSTUNREACH) { return MA_NO_HOST; }
#endif
#ifdef EALREADY
    else if (e == EALREADY) { return MA_IN_PROGRESS; }
#endif
#ifdef EINPROGRESS
    else if (e == EINPROGRESS) { return MA_IN_PROGRESS; }
#endif
#ifdef ESTALE
    else if (e == ESTALE) { return MA_INVALID_FILE; }
#endif
#ifdef EUCLEAN
    else if (e == EUCLEAN) { return MA_ERROR; }
#endif
#ifdef ENOTNAM
    else if (e == ENOTNAM) { return MA_ERROR; }
#endif
#ifdef ENAVAIL
    else if (e == ENAVAIL) { return MA_ERROR; }
#endif
#ifdef EISNAM
    else if (e == EISNAM) { return MA_ERROR; }
#endif
#ifdef EREMOTEIO
    else if (e == EREMOTEIO) { return MA_IO_ERROR; }
#endif
#ifdef EDQUOT
    else if (e == EDQUOT) { return MA_NO_SPACE; }
#endif
#ifdef ENOMEDIUM
    else if (e == ENOMEDIUM) { return MA_DOES_NOT_EXIST; }
#endif
#ifdef EMEDIUMTYPE
    else if (e == EMEDIUMTYPE) { return MA_ERROR; }
#endif
#ifdef ECANCELED
    else if (e == ECANCELED) { return MA_CANCELLED; }
#endif
#ifdef ENOKEY
    else if (e == ENOKEY) { return MA_ERROR; }
#endif
#ifdef EKEYEXPIRED
    else if (e == EKEYEXPIRED) { return MA_ERROR; }
#endif
#ifdef EKEYREVOKED
    else if (e == EKEYREVOKED) { return MA_ERROR; }
#endif
#ifdef EKEYREJECTED
    else if (e == EKEYREJECTED) { return MA_ERROR; }
#endif
#ifdef EOWNERDEAD
    else if (e == EOWNERDEAD) { return MA_ERROR; }
#endif
#ifdef ENOTRECOVERABLE
    else if (e == ENOTRECOVERABLE) { return MA_ERROR; }
#endif
#ifdef ERFKILL
    else if (e == ERFKILL) { return MA_ERROR; }
#endif
#ifdef EHWPOISON
    else if (e == EHWPOISON) { return MA_ERROR; }
#endif
    else {
        return MA_ERROR;
    }
}

MA_API ma_result ma_fopen(FILE** ppFile, const char* pFilePath, const char* pOpenMode)
{
#if defined(_MSC_VER) && _MSC_VER >= 1400
    errno_t err;
#endif

    if (ppFile != NULL) {
        *ppFile = NULL;  /* Safety. */
    }

    if (pFilePath == NULL || pOpenMode == NULL || ppFile == NULL) {
        return MA_INVALID_ARGS;
    }

#if defined(_MSC_VER) && _MSC_VER >= 1400
    err = fopen_s(ppFile, pFilePath, pOpenMode);
    if (err != 0) {
        return ma_result_from_errno(err);
    }
#else
#if defined(_WIN32) || defined(__APPLE__)
    *ppFile = fopen(pFilePath, pOpenMode);
#else
    #if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64 && defined(_LARGEFILE64_SOURCE)
        *ppFile = fopen64(pFilePath, pOpenMode);
    #else
        *ppFile = fopen(pFilePath, pOpenMode);
    #endif
#endif
    if (*ppFile == NULL) {
        ma_result result = ma_result_from_errno(errno);
        if (result == MA_SUCCESS) {
            result = MA_ERROR;   /* Just a safety check to make sure we never ever return success when pFile == NULL. */
        }

        return result;
    }
#endif

    return MA_SUCCESS;
}



/*
_wfopen() isn't always available in all compilation environments.

    * Windows only.
    * MSVC seems to support it universally as far back as VC6 from what I can tell (haven't checked further back).
    * MinGW-64 (both 32- and 64-bit) seems to support it.
    * MinGW wraps it in !defined(__STRICT_ANSI__).
    * OpenWatcom wraps it in !defined(_NO_EXT_KEYS).

This can be reviewed as compatibility issues arise. The preference is to use _wfopen_s() and _wfopen() as opposed to the wcsrtombs()
fallback, so if you notice your compiler not detecting this properly I'm happy to look at adding support.
*/
#if defined(_WIN32)
    #if defined(_MSC_VER) || defined(__MINGW64__) || (!defined(__STRICT_ANSI__) && !defined(_NO_EXT_KEYS))
        #define MA_HAS_WFOPEN
    #endif
#endif

MA_API ma_result ma_wfopen(FILE** ppFile, const wchar_t* pFilePath, const wchar_t* pOpenMode, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (ppFile != NULL) {
        *ppFile = NULL;  /* Safety. */
    }

    if (pFilePath == NULL || pOpenMode == NULL || ppFile == NULL) {
        return MA_INVALID_ARGS;
    }

#if defined(MA_HAS_WFOPEN)
    {
        /* Use _wfopen() on Windows. */
    #if defined(_MSC_VER) && _MSC_VER >= 1400
        errno_t err = _wfopen_s(ppFile, pFilePath, pOpenMode);
        if (err != 0) {
            return ma_result_from_errno(err);
        }
    #else
        *ppFile = _wfopen(pFilePath, pOpenMode);
        if (*ppFile == NULL) {
            return ma_result_from_errno(errno);
        }
    #endif
        (void)pAllocationCallbacks;
    }
#else
    /*
    Use fopen() on anything other than Windows. Requires a conversion. This is annoying because fopen() is locale specific. The only real way I can
    think of to do this is with wcsrtombs(). Note that wcstombs() is apparently not thread-safe because it uses a static global mbstate_t object for
    maintaining state. I've checked this with -std=c89 and it works, but if somebody get's a compiler error I'll look into improving compatibility.
    */
    {
        mbstate_t mbs;
        size_t lenMB;
        const wchar_t* pFilePathTemp = pFilePath;
        char* pFilePathMB = NULL;
        char pOpenModeMB[32] = {0};

        /* Get the length first. */
        MA_ZERO_OBJECT(&mbs);
        lenMB = wcsrtombs(NULL, &pFilePathTemp, 0, &mbs);
        if (lenMB == (size_t)-1) {
            return ma_result_from_errno(errno);
        }

        pFilePathMB = (char*)ma_malloc(lenMB + 1, pAllocationCallbacks);
        if (pFilePathMB == NULL) {
            return MA_OUT_OF_MEMORY;
        }

        pFilePathTemp = pFilePath;
        MA_ZERO_OBJECT(&mbs);
        wcsrtombs(pFilePathMB, &pFilePathTemp, lenMB + 1, &mbs);

        /* The open mode should always consist of ASCII characters so we should be able to do a trivial conversion. */
        {
            size_t i = 0;
            for (;;) {
                if (pOpenMode[i] == 0) {
                    pOpenModeMB[i] = '\0';
                    break;
                }

                pOpenModeMB[i] = (char)pOpenMode[i];
                i += 1;
            }
        }

        *ppFile = fopen(pFilePathMB, pOpenModeMB);

        ma_free(pFilePathMB, pAllocationCallbacks);
    }

    if (*ppFile == NULL) {
        return MA_ERROR;
    }
#endif

    return MA_SUCCESS;
}



static MA_INLINE void ma_copy_memory_64(void* dst, const void* src, ma_uint64 sizeInBytes)
{
#if 0xFFFFFFFFFFFFFFFF <= MA_SIZE_MAX
    MA_COPY_MEMORY(dst, src, (size_t)sizeInBytes);
#else
    while (sizeInBytes > 0) {
        ma_uint64 bytesToCopyNow = sizeInBytes;
        if (bytesToCopyNow > MA_SIZE_MAX) {
            bytesToCopyNow = MA_SIZE_MAX;
        }

        MA_COPY_MEMORY(dst, src, (size_t)bytesToCopyNow);  /* Safe cast to size_t. */

        sizeInBytes -= bytesToCopyNow;
        dst = (      void*)((      ma_uint8*)dst + bytesToCopyNow);
        src = (const void*)((const ma_uint8*)src + bytesToCopyNow);
    }
#endif
}

static MA_INLINE void ma_zero_memory_64(void* dst, ma_uint64 sizeInBytes)
{
#if 0xFFFFFFFFFFFFFFFF <= MA_SIZE_MAX
    MA_ZERO_MEMORY(dst, (size_t)sizeInBytes);
#else
    while (sizeInBytes > 0) {
        ma_uint64 bytesToZeroNow = sizeInBytes;
        if (bytesToZeroNow > MA_SIZE_MAX) {
            bytesToZeroNow = MA_SIZE_MAX;
        }

        MA_ZERO_MEMORY(dst, (size_t)bytesToZeroNow);  /* Safe cast to size_t. */

        sizeInBytes -= bytesToZeroNow;
        dst = (void*)((ma_uint8*)dst + bytesToZeroNow);
    }
#endif
}


/* Thanks to good old Bit Twiddling Hacks for this one: http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2 */
static MA_INLINE unsigned int ma_next_power_of_2(unsigned int x)
{
    x--;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x++;

    return x;
}

static MA_INLINE unsigned int ma_prev_power_of_2(unsigned int x)
{
    return ma_next_power_of_2(x) >> 1;
}

static MA_INLINE unsigned int ma_round_to_power_of_2(unsigned int x)
{
    unsigned int prev = ma_prev_power_of_2(x);
    unsigned int next = ma_next_power_of_2(x);
    if ((next - x) > (x - prev)) {
        return prev;
    } else {
        return next;
    }
}

static MA_INLINE unsigned int ma_count_set_bits(unsigned int x)
{
    unsigned int count = 0;
    while (x != 0) {
        if (x & 1) {
            count += 1;
        }

        x = x >> 1;
    }

    return count;
}



/**************************************************************************************************************************************************************

Allocation Callbacks

**************************************************************************************************************************************************************/
static void* ma__malloc_default(size_t sz, void* pUserData)
{
    (void)pUserData;
    return MA_MALLOC(sz);
}

static void* ma__realloc_default(void* p, size_t sz, void* pUserData)
{
    (void)pUserData;
    return MA_REALLOC(p, sz);
}

static void ma__free_default(void* p, void* pUserData)
{
    (void)pUserData;
    MA_FREE(p);
}

static ma_allocation_callbacks ma_allocation_callbacks_init_default(void)
{
    ma_allocation_callbacks callbacks;
    callbacks.pUserData = NULL;
    callbacks.onMalloc  = ma__malloc_default;
    callbacks.onRealloc = ma__realloc_default;
    callbacks.onFree    = ma__free_default;

    return callbacks;
}

static ma_result ma_allocation_callbacks_init_copy(ma_allocation_callbacks* pDst, const ma_allocation_callbacks* pSrc)
{
    if (pDst == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pSrc == NULL) {
        *pDst = ma_allocation_callbacks_init_default();
    } else {
        if (pSrc->pUserData == NULL && pSrc->onFree == NULL && pSrc->onMalloc == NULL && pSrc->onRealloc == NULL) {
            *pDst = ma_allocation_callbacks_init_default();
        } else {
            if (pSrc->onFree == NULL || (pSrc->onMalloc == NULL && pSrc->onRealloc == NULL)) {
                return MA_INVALID_ARGS;    /* Invalid allocation callbacks. */
            } else {
                *pDst = *pSrc;
            }
        }
    }

    return MA_SUCCESS;
}




/**************************************************************************************************************************************************************

Logging

**************************************************************************************************************************************************************/
MA_API const char* ma_log_level_to_string(ma_uint32 logLevel)
{
    switch (logLevel)
    {
        case MA_LOG_LEVEL_DEBUG:   return "DEBUG";
        case MA_LOG_LEVEL_INFO:    return "INFO";
        case MA_LOG_LEVEL_WARNING: return "WARNING";
        case MA_LOG_LEVEL_ERROR:   return "ERROR";
        default:                   return "ERROR";
    }
}

#if defined(MA_DEBUG_OUTPUT)
#if defined(MA_ANDROID)
    #include <android/log.h>
#endif

/* Customize this to use a specific tag in __android_log_print() for debug output messages. */
#ifndef MA_ANDROID_LOG_TAG
#define MA_ANDROID_LOG_TAG  "miniaudio"
#endif

void ma_log_callback_debug(void* pUserData, ma_uint32 level, const char* pMessage)
{
    (void)pUserData;

    /* Special handling for some platforms. */
    #if defined(MA_ANDROID)
    {
        /* Android. */
        __android_log_print(ANDROID_LOG_DEBUG, MA_ANDROID_LOG_TAG, "%s: %s", ma_log_level_to_string(level), pMessage);
    }
    #else
    {
        /* Everything else. */
        printf("%s: %s", ma_log_level_to_string(level), pMessage);
    }
    #endif
}
#endif

MA_API ma_log_callback ma_log_callback_init(ma_log_callback_proc onLog, void* pUserData)
{
    ma_log_callback callback;

    MA_ZERO_OBJECT(&callback);
    callback.onLog     = onLog;
    callback.pUserData = pUserData;

    return callback;
}


MA_API ma_result ma_log_init(const ma_allocation_callbacks* pAllocationCallbacks, ma_log* pLog)
{
    if (pLog == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pLog);
    ma_allocation_callbacks_init_copy(&pLog->allocationCallbacks, pAllocationCallbacks);

    /* We need a mutex for thread safety. */
    #ifndef MA_NO_THREADING
    {
        ma_result result = ma_mutex_init(&pLog->lock);
        if (result != MA_SUCCESS) {
            return result;
        }
    }
    #endif

    /* If we're using debug output, enable it. */
    #if defined(MA_DEBUG_OUTPUT)
    {
        ma_log_register_callback(pLog, ma_log_callback_init(ma_log_callback_debug, NULL)); /* Doesn't really matter if this fails. */
    }
    #endif

    return MA_SUCCESS;
}

MA_API void ma_log_uninit(ma_log* pLog)
{
    if (pLog == NULL) {
        return;
    }

#ifndef MA_NO_THREADING
    ma_mutex_uninit(&pLog->lock);
#endif
}

static void ma_log_lock(ma_log* pLog)
{
#ifndef MA_NO_THREADING
    ma_mutex_lock(&pLog->lock);
#else
    (void)pLog;
#endif
}

static void ma_log_unlock(ma_log* pLog)
{
#ifndef MA_NO_THREADING
    ma_mutex_unlock(&pLog->lock);
#else
    (void)pLog;
#endif
}

MA_API ma_result ma_log_register_callback(ma_log* pLog, ma_log_callback callback)
{
    ma_result result = MA_SUCCESS;

    if (pLog == NULL || callback.onLog == NULL) {
        return MA_INVALID_ARGS;
    }

    ma_log_lock(pLog);
    {
        if (pLog->callbackCount == ma_countof(pLog->callbacks)) {
            result = MA_OUT_OF_MEMORY;  /* Reached the maximum allowed log callbacks. */
        } else {
            pLog->callbacks[pLog->callbackCount] = callback;
            pLog->callbackCount += 1;
        }
    }
    ma_log_unlock(pLog);

    return result;
}

MA_API ma_result ma_log_unregister_callback(ma_log* pLog, ma_log_callback callback)
{
    if (pLog == NULL) {
        return MA_INVALID_ARGS;
    }

    ma_log_lock(pLog);
    {
        ma_uint32 iLog;
        for (iLog = 0; iLog < pLog->callbackCount; ) {
            if (pLog->callbacks[iLog].onLog == callback.onLog) {
                /* Found. Move everything down a slot. */
                ma_uint32 jLog;
                for (jLog = iLog; jLog < pLog->callbackCount-1; jLog += 1) {
                    pLog->callbacks[jLog] = pLog->callbacks[jLog + 1];
                }

                pLog->callbackCount -= 1;
            } else {
                /* Not found. */
                iLog += 1;
            }
        }
    }
    ma_log_unlock(pLog);

    return MA_SUCCESS;
}

MA_API ma_result ma_log_post(ma_log* pLog, ma_uint32 level, const char* pMessage)
{
    if (pLog == NULL || pMessage == NULL) {
        return MA_INVALID_ARGS;
    }

    ma_log_lock(pLog);
    {
        ma_uint32 iLog;
        for (iLog = 0; iLog < pLog->callbackCount; iLog += 1) {
            if (pLog->callbacks[iLog].onLog) {
                pLog->callbacks[iLog].onLog(pLog->callbacks[iLog].pUserData, level, pMessage);
            }
        }
    }
    ma_log_unlock(pLog);

    return MA_SUCCESS;
}


/*
We need to emulate _vscprintf() for the VC6 build. This can be more efficient, but since it's only VC6, and it's just a
logging function, I'm happy to keep this simple. In the VC6 build we can implement this in terms of _vsnprintf().
*/
#if defined(_MSC_VER) && _MSC_VER < 1900
static int ma_vscprintf(const ma_allocation_callbacks* pAllocationCallbacks, const char* format, va_list args)
{
#if _MSC_VER > 1200
    return _vscprintf(format, args);
#else
    int result;
    char* pTempBuffer = NULL;
    size_t tempBufferCap = 1024;

    if (format == NULL) {
        errno = EINVAL;
        return -1;
    }

    for (;;) {
        char* pNewTempBuffer = (char*)ma_realloc(pTempBuffer, tempBufferCap, pAllocationCallbacks);
        if (pNewTempBuffer == NULL) {
            ma_free(pTempBuffer, pAllocationCallbacks);
            errno = ENOMEM;
            return -1;  /* Out of memory. */
        }

        pTempBuffer = pNewTempBuffer;

        result = _vsnprintf(pTempBuffer, tempBufferCap, format, args);
        ma_free(pTempBuffer, NULL);

        if (result != -1) {
            break;  /* Got it. */
        }

        /* Buffer wasn't big enough. Ideally it'd be nice to use an error code to know the reason for sure, but this is reliable enough. */
        tempBufferCap *= 2;
    }

    return result;
#endif
}
#endif

MA_API ma_result ma_log_postv(ma_log* pLog, ma_uint32 level, const char* pFormat, va_list args)
{
    if (pLog == NULL || pFormat == NULL) {
        return MA_INVALID_ARGS;
    }

    #if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || ((!defined(_MSC_VER) || _MSC_VER >= 1900) && !defined(__STRICT_ANSI__) && !defined(_NO_EXT_KEYS)) || (defined(__cplusplus) && __cplusplus >= 201103L)
    {
        ma_result result;
        int length;
        char  pFormattedMessageStack[1024];
        char* pFormattedMessageHeap = NULL;

        /* First try formatting into our fixed sized stack allocated buffer. If this is too small we'll fallback to a heap allocation. */
        length = vsnprintf(pFormattedMessageStack, sizeof(pFormattedMessageStack), pFormat, args);
        if (length < 0) {
            return MA_INVALID_OPERATION;    /* An error occurred when trying to convert the buffer. */
        }

        if ((size_t)length < sizeof(pFormattedMessageStack)) {
            /* The string was written to the stack. */
            result = ma_log_post(pLog, level, pFormattedMessageStack);
        } else {
            /* The stack buffer was too small, try the heap. */
            pFormattedMessageHeap = (char*)ma_malloc(length + 1, &pLog->allocationCallbacks);
            if (pFormattedMessageHeap == NULL) {
                return MA_OUT_OF_MEMORY;
            }

            length = vsnprintf(pFormattedMessageHeap, length + 1, pFormat, args);
            if (length < 0) {
                ma_free(pFormattedMessageHeap, &pLog->allocationCallbacks);
                return MA_INVALID_OPERATION;
            }

            result = ma_log_post(pLog, level, pFormattedMessageHeap);
            ma_free(pFormattedMessageHeap, &pLog->allocationCallbacks);
        }

        return result;
    }
    #else
    {
        /*
        Without snprintf() we need to first measure the string and then heap allocate it. I'm only aware of Visual Studio having support for this without snprintf(), so we'll
        need to restrict this branch to Visual Studio. For other compilers we need to just not support formatted logging because I don't want the security risk of overflowing
        a fixed sized stack allocated buffer.
        */
        #if defined(_MSC_VER) && _MSC_VER >= 1200   /* 1200 = VC6 */
        {
            ma_result result;
            int formattedLen;
            char* pFormattedMessage = NULL;
            va_list args2;

            #if _MSC_VER >= 1800
            {
                va_copy(args2, args);
            }
            #else
            {
                args2 = args;
            }
            #endif

            formattedLen = ma_vscprintf(&pLog->allocationCallbacks, pFormat, args2);
            va_end(args2);

            if (formattedLen <= 0) {
                return MA_INVALID_OPERATION;
            }

            pFormattedMessage = (char*)ma_malloc(formattedLen + 1, &pLog->allocationCallbacks);
            if (pFormattedMessage == NULL) {
                return MA_OUT_OF_MEMORY;
            }

            /* We'll get errors on newer versions of Visual Studio if we try to use vsprintf().  */
            #if _MSC_VER >= 1400    /* 1400 = Visual Studio 2005 */
            {
                vsprintf_s(pFormattedMessage, formattedLen + 1, pFormat, args);
            }
            #else
            {
                vsprintf(pFormattedMessage, pFormat, args);
            }
            #endif

            result = ma_log_post(pLog, level, pFormattedMessage);
            ma_free(pFormattedMessage, &pLog->allocationCallbacks);

            return result;
        }
        #else
        {
            /* Can't do anything because we don't have a safe way of to emulate vsnprintf() without a manual solution. */
            (void)level;
            (void)args;

            return MA_INVALID_OPERATION;
        }
        #endif
    }
    #endif
}

MA_API ma_result ma_log_postf(ma_log* pLog, ma_uint32 level, const char* pFormat, ...)
{
    ma_result result;
    va_list args;

    if (pLog == NULL || pFormat == NULL) {
        return MA_INVALID_ARGS;
    }

    va_start(args, pFormat);
    {
        result = ma_log_postv(pLog, level, pFormat, args);
    }
    va_end(args);

    return result;
}



static MA_INLINE ma_uint8 ma_clip_u8(ma_int32 x)
{
    return (ma_uint8)(ma_clamp(x, -128, 127) + 128);
}

static MA_INLINE ma_int16 ma_clip_s16(ma_int32 x)
{
    return (ma_int16)ma_clamp(x, -32768, 32767);
}

static MA_INLINE ma_int64 ma_clip_s24(ma_int64 x)
{
    return (ma_int64)ma_clamp(x, -8388608, 8388607);
}

static MA_INLINE ma_int32 ma_clip_s32(ma_int64 x)
{
    /* This dance is to silence warnings with -std=c89. A good compiler should be able to optimize this away. */
    ma_int64 clipMin;
    ma_int64 clipMax;
    clipMin = -((ma_int64)2147483647 + 1);
    clipMax =   (ma_int64)2147483647;

    return (ma_int32)ma_clamp(x, clipMin, clipMax);
}

static MA_INLINE float ma_clip_f32(float x)
{
    if (x < -1) return -1;
    if (x > +1) return +1;
    return x;
}


static MA_INLINE float ma_mix_f32(float x, float y, float a)
{
    return x*(1-a) + y*a;
}
static MA_INLINE float ma_mix_f32_fast(float x, float y, float a)
{
    float r0 = (y - x);
    float r1 = r0*a;
    return x + r1;
    /*return x + (y - x)*a;*/
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE __m128 ma_mix_f32_fast__sse2(__m128 x, __m128 y, __m128 a)
{
    return _mm_add_ps(x, _mm_mul_ps(_mm_sub_ps(y, x), a));
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE __m256 ma_mix_f32_fast__avx2(__m256 x, __m256 y, __m256 a)
{
    return _mm256_add_ps(x, _mm256_mul_ps(_mm256_sub_ps(y, x), a));
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE float32x4_t ma_mix_f32_fast__neon(float32x4_t x, float32x4_t y, float32x4_t a)
{
    return vaddq_f32(x, vmulq_f32(vsubq_f32(y, x), a));
}
#endif


static MA_INLINE double ma_mix_f64(double x, double y, double a)
{
    return x*(1-a) + y*a;
}
static MA_INLINE double ma_mix_f64_fast(double x, double y, double a)
{
    return x + (y - x)*a;
}

static MA_INLINE float ma_scale_to_range_f32(float x, float lo, float hi)
{
    return lo + x*(hi-lo);
}


/*
Greatest common factor using Euclid's algorithm iteratively.
*/
static MA_INLINE ma_uint32 ma_gcf_u32(ma_uint32 a, ma_uint32 b)
{
    for (;;) {
        if (b == 0) {
            break;
        } else {
            ma_uint32 t = a;
            a = b;
            b = t % a;
        }
    }

    return a;
}


static ma_uint32 ma_ffs_32(ma_uint32 x)
{
    ma_uint32 i;

    /* Just a naive implementation just to get things working for now. Will optimize this later. */
    for (i = 0; i < 32; i += 1) {
        if ((x & (1U << i)) != 0) {
            return i;
        }
    }

    return i;
}

static MA_INLINE ma_int16 ma_float_to_fixed_16(float x)
{
    return (ma_int16)(x * (1 << 8));
}



/*
Random Number Generation

miniaudio uses the LCG random number generation algorithm. This is good enough for audio.

Note that miniaudio's global LCG implementation uses global state which is _not_ thread-local. When this is called across
multiple threads, results will be unpredictable. However, it won't crash and results will still be random enough for
miniaudio's purposes.
*/
#ifndef MA_DEFAULT_LCG_SEED
#define MA_DEFAULT_LCG_SEED 4321
#endif

#define MA_LCG_M   2147483647
#define MA_LCG_A   48271
#define MA_LCG_C   0

static ma_lcg g_maLCG = {MA_DEFAULT_LCG_SEED}; /* Non-zero initial seed. Use ma_seed() to use an explicit seed. */

static MA_INLINE void ma_lcg_seed(ma_lcg* pLCG, ma_int32 seed)
{
    MA_ASSERT(pLCG != NULL);
    pLCG->state = seed;
}

static MA_INLINE ma_int32 ma_lcg_rand_s32(ma_lcg* pLCG)
{
    pLCG->state = (MA_LCG_A * pLCG->state + MA_LCG_C) % MA_LCG_M;
    return pLCG->state;
}

static MA_INLINE ma_uint32 ma_lcg_rand_u32(ma_lcg* pLCG)
{
    return (ma_uint32)ma_lcg_rand_s32(pLCG);
}

static MA_INLINE ma_int16 ma_lcg_rand_s16(ma_lcg* pLCG)
{
    return (ma_int16)(ma_lcg_rand_s32(pLCG) & 0xFFFF);
}

static MA_INLINE double ma_lcg_rand_f64(ma_lcg* pLCG)
{
    return ma_lcg_rand_s32(pLCG) / (double)0x7FFFFFFF;
}

static MA_INLINE float ma_lcg_rand_f32(ma_lcg* pLCG)
{
    return (float)ma_lcg_rand_f64(pLCG);
}

static MA_INLINE float ma_lcg_rand_range_f32(ma_lcg* pLCG, float lo, float hi)
{
    return ma_scale_to_range_f32(ma_lcg_rand_f32(pLCG), lo, hi);
}

static MA_INLINE ma_int32 ma_lcg_rand_range_s32(ma_lcg* pLCG, ma_int32 lo, ma_int32 hi)
{
    if (lo == hi) {
        return lo;
    }

    return lo + ma_lcg_rand_u32(pLCG) / (0xFFFFFFFF / (hi - lo + 1) + 1);
}



static MA_INLINE void ma_seed(ma_int32 seed)
{
    ma_lcg_seed(&g_maLCG, seed);
}

static MA_INLINE ma_int32 ma_rand_s32(void)
{
    return ma_lcg_rand_s32(&g_maLCG);
}

static MA_INLINE ma_uint32 ma_rand_u32(void)
{
    return ma_lcg_rand_u32(&g_maLCG);
}

static MA_INLINE double ma_rand_f64(void)
{
    return ma_lcg_rand_f64(&g_maLCG);
}

static MA_INLINE float ma_rand_f32(void)
{
    return ma_lcg_rand_f32(&g_maLCG);
}

static MA_INLINE float ma_rand_range_f32(float lo, float hi)
{
    return ma_lcg_rand_range_f32(&g_maLCG, lo, hi);
}

static MA_INLINE ma_int32 ma_rand_range_s32(ma_int32 lo, ma_int32 hi)
{
    return ma_lcg_rand_range_s32(&g_maLCG, lo, hi);
}


static MA_INLINE float ma_dither_f32_rectangle(float ditherMin, float ditherMax)
{
    return ma_rand_range_f32(ditherMin, ditherMax);
}

static MA_INLINE float ma_dither_f32_triangle(float ditherMin, float ditherMax)
{
    float a = ma_rand_range_f32(ditherMin, 0);
    float b = ma_rand_range_f32(0, ditherMax);
    return a + b;
}

static MA_INLINE float ma_dither_f32(ma_dither_mode ditherMode, float ditherMin, float ditherMax)
{
    if (ditherMode == ma_dither_mode_rectangle) {
        return ma_dither_f32_rectangle(ditherMin, ditherMax);
    }
    if (ditherMode == ma_dither_mode_triangle) {
        return ma_dither_f32_triangle(ditherMin, ditherMax);
    }

    return 0;
}

static MA_INLINE ma_int32 ma_dither_s32(ma_dither_mode ditherMode, ma_int32 ditherMin, ma_int32 ditherMax)
{
    if (ditherMode == ma_dither_mode_rectangle) {
        ma_int32 a = ma_rand_range_s32(ditherMin, ditherMax);
        return a;
    }
    if (ditherMode == ma_dither_mode_triangle) {
        ma_int32 a = ma_rand_range_s32(ditherMin, 0);
        ma_int32 b = ma_rand_range_s32(0, ditherMax);
        return a + b;
    }

    return 0;
}


/**************************************************************************************************************************************************************

Atomics

**************************************************************************************************************************************************************/
/* c89atomic.h begin */
#ifndef ma_atomic_h
#if defined(__cplusplus)
extern "C" {
#endif
#if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)))
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wlong-long"
    #if defined(__clang__)
        #pragma GCC diagnostic ignored "-Wc++11-long-long"
    #endif
#endif
typedef int ma_atomic_memory_order;
#define MA_ATOMIC_HAS_8
#define MA_ATOMIC_HAS_16
#define MA_ATOMIC_HAS_32
#define MA_ATOMIC_HAS_64
#if (defined(_MSC_VER) ) || defined(__WATCOMC__) || defined(__DMC__)
    #define MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, intrin, ma_atomicType, msvcType)   \
        ma_atomicType result; \
        switch (order) \
        { \
            case ma_atomic_memory_order_relaxed: \
            { \
                result = (ma_atomicType)intrin##_nf((volatile msvcType*)dst, (msvcType)src); \
            } break; \
            case ma_atomic_memory_order_consume: \
            case ma_atomic_memory_order_acquire: \
            { \
                result = (ma_atomicType)intrin##_acq((volatile msvcType*)dst, (msvcType)src); \
            } break; \
            case ma_atomic_memory_order_release: \
            { \
                result = (ma_atomicType)intrin##_rel((volatile msvcType*)dst, (msvcType)src); \
            } break; \
            case ma_atomic_memory_order_acq_rel: \
            case ma_atomic_memory_order_seq_cst: \
            default: \
            { \
                result = (ma_atomicType)intrin((volatile msvcType*)dst, (msvcType)src); \
            } break; \
        } \
        return result;
    #define MA_ATOMIC_MSVC_ARM_INTRINSIC_COMPARE_EXCHANGE(ptr, expected, desired, order, intrin, ma_atomicType, msvcType)   \
        ma_atomicType result; \
        switch (order) \
        { \
            case ma_atomic_memory_order_relaxed: \
            { \
                result = (ma_atomicType)intrin##_nf((volatile msvcType*)ptr, (msvcType)expected, (msvcType)desired); \
            } break; \
            case ma_atomic_memory_order_consume: \
            case ma_atomic_memory_order_acquire: \
            { \
                result = (ma_atomicType)intrin##_acq((volatile msvcType*)ptr, (msvcType)expected, (msvcType)desired); \
            } break; \
            case ma_atomic_memory_order_release: \
            { \
                result = (ma_atomicType)intrin##_rel((volatile msvcType*)ptr, (msvcType)expected, (msvcType)desired); \
            } break; \
            case ma_atomic_memory_order_acq_rel: \
            case ma_atomic_memory_order_seq_cst: \
            default: \
            { \
                result = (ma_atomicType)intrin((volatile msvcType*)ptr, (msvcType)expected, (msvcType)desired); \
            } break; \
        } \
        return result;
    #define ma_atomic_memory_order_relaxed  0
    #define ma_atomic_memory_order_consume  1
    #define ma_atomic_memory_order_acquire  2
    #define ma_atomic_memory_order_release  3
    #define ma_atomic_memory_order_acq_rel  4
    #define ma_atomic_memory_order_seq_cst  5
    #if _MSC_VER < 1600 && defined(MA_X86)
        #define MA_ATOMIC_MSVC_USE_INLINED_ASSEMBLY
    #endif
    #if _MSC_VER < 1600
        #undef MA_ATOMIC_HAS_8
        #undef MA_ATOMIC_HAS_16
    #endif
    #if !defined(MA_ATOMIC_MSVC_USE_INLINED_ASSEMBLY)
        #include <intrin.h>
    #endif
    #if defined(MA_ATOMIC_MSVC_USE_INLINED_ASSEMBLY)
        #if defined(MA_ATOMIC_HAS_8)
            static MA_INLINE ma_uint8 __stdcall ma_atomic_compare_and_swap_8(volatile ma_uint8* dst, ma_uint8 expected, ma_uint8 desired)
            {
                ma_uint8 result = 0;
                __asm {
                    mov ecx, dst
                    mov al,  expected
                    mov dl,  desired
                    lock cmpxchg [ecx], dl
                    mov result, al
                }
                return result;
            }
        #endif
        #if defined(MA_ATOMIC_HAS_16)
            static MA_INLINE ma_uint16 __stdcall ma_atomic_compare_and_swap_16(volatile ma_uint16* dst, ma_uint16 expected, ma_uint16 desired)
            {
                ma_uint16 result = 0;
                __asm {
                    mov ecx, dst
                    mov ax,  expected
                    mov dx,  desired
                    lock cmpxchg [ecx], dx
                    mov result, ax
                }
                return result;
            }
        #endif
        #if defined(MA_ATOMIC_HAS_32)
            static MA_INLINE ma_uint32 __stdcall ma_atomic_compare_and_swap_32(volatile ma_uint32* dst, ma_uint32 expected, ma_uint32 desired)
            {
                ma_uint32 result = 0;
                __asm {
                    mov ecx, dst
                    mov eax, expected
                    mov edx, desired
                    lock cmpxchg [ecx], edx
                    mov result, eax
                }
                return result;
            }
        #endif
        #if defined(MA_ATOMIC_HAS_64)
            static MA_INLINE ma_uint64 __stdcall ma_atomic_compare_and_swap_64(volatile ma_uint64* dst, ma_uint64 expected, ma_uint64 desired)
            {
                ma_uint32 resultEAX = 0;
                ma_uint32 resultEDX = 0;
                __asm {
                    mov esi, dst
                    mov eax, dword ptr expected
                    mov edx, dword ptr expected + 4
                    mov ebx, dword ptr desired
                    mov ecx, dword ptr desired + 4
                    lock cmpxchg8b qword ptr [esi]
                    mov resultEAX, eax
                    mov resultEDX, edx
                }
                return ((ma_uint64)resultEDX << 32) | resultEAX;
            }
        #endif
    #else
        #if defined(MA_ATOMIC_HAS_8)
            #define ma_atomic_compare_and_swap_8( dst, expected, desired) (ma_uint8 )_InterlockedCompareExchange8((volatile char*)dst, (char)desired, (char)expected)
        #endif
        #if defined(MA_ATOMIC_HAS_16)
            #define ma_atomic_compare_and_swap_16(dst, expected, desired) (ma_uint16)_InterlockedCompareExchange16((volatile short*)dst, (short)desired, (short)expected)
        #endif
        #if defined(MA_ATOMIC_HAS_32)
            #define ma_atomic_compare_and_swap_32(dst, expected, desired) (ma_uint32)_InterlockedCompareExchange((volatile long*)dst, (long)desired, (long)expected)
        #endif
        #if defined(MA_ATOMIC_HAS_64)
            #define ma_atomic_compare_and_swap_64(dst, expected, desired) (ma_uint64)_InterlockedCompareExchange64((volatile ma_int64*)dst, (ma_int64)desired, (ma_int64)expected)
        #endif
    #endif
    #if defined(MA_ATOMIC_MSVC_USE_INLINED_ASSEMBLY)
        #if defined(MA_ATOMIC_HAS_8)
            static MA_INLINE ma_uint8 __stdcall ma_atomic_exchange_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
            {
                ma_uint8 result = 0;
                (void)order;
                __asm {
                    mov ecx, dst
                    mov al,  src
                    lock xchg [ecx], al
                    mov result, al
                }
                return result;
            }
        #endif
        #if defined(MA_ATOMIC_HAS_16)
            static MA_INLINE ma_uint16 __stdcall ma_atomic_exchange_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
            {
                ma_uint16 result = 0;
                (void)order;
                __asm {
                    mov ecx, dst
                    mov ax,  src
                    lock xchg [ecx], ax
                    mov result, ax
                }
                return result;
            }
        #endif
        #if defined(MA_ATOMIC_HAS_32)
            static MA_INLINE ma_uint32 __stdcall ma_atomic_exchange_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
            {
                ma_uint32 result = 0;
                (void)order;
                __asm {
                    mov ecx, dst
                    mov eax, src
                    lock xchg [ecx], eax
                    mov result, eax
                }
                return result;
            }
        #endif
    #else
        #if defined(MA_ATOMIC_HAS_8)
            static MA_INLINE ma_uint8 __stdcall ma_atomic_exchange_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
            {
            #if defined(MA_ARM)
                MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedExchange8, ma_uint8, char);
            #else
                (void)order;
                return (ma_uint8)_InterlockedExchange8((volatile char*)dst, (char)src);
            #endif
            }
        #endif
        #if defined(MA_ATOMIC_HAS_16)
            static MA_INLINE ma_uint16 __stdcall ma_atomic_exchange_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
            {
            #if defined(MA_ARM)
                MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedExchange16, ma_uint16, short);
            #else
                (void)order;
                return (ma_uint16)_InterlockedExchange16((volatile short*)dst, (short)src);
            #endif
            }
        #endif
        #if defined(MA_ATOMIC_HAS_32)
            static MA_INLINE ma_uint32 __stdcall ma_atomic_exchange_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
            {
            #if defined(MA_ARM)
                MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedExchange, ma_uint32, long);
            #else
                (void)order;
                return (ma_uint32)_InterlockedExchange((volatile long*)dst, (long)src);
            #endif
            }
        #endif
        #if defined(MA_ATOMIC_HAS_64) && defined(MA_64BIT)
            static MA_INLINE ma_uint64 __stdcall ma_atomic_exchange_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
            {
            #if defined(MA_ARM)
                MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedExchange64, ma_uint64, long long);
            #else
                (void)order;
                return (ma_uint64)_InterlockedExchange64((volatile long long*)dst, (long long)src);
            #endif
            }
        #else
        #endif
    #endif
    #if defined(MA_ATOMIC_HAS_64) && !defined(MA_64BIT)
        static MA_INLINE ma_uint64 __stdcall ma_atomic_exchange_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
            ma_uint64 oldValue;
            do {
                oldValue = *dst;
            } while (ma_atomic_compare_and_swap_64(dst, oldValue, src) != oldValue);
            (void)order;
            return oldValue;
        }
    #endif
    #if defined(MA_ATOMIC_MSVC_USE_INLINED_ASSEMBLY)
        #if defined(MA_ATOMIC_HAS_8)
            static MA_INLINE ma_uint8 __stdcall ma_atomic_fetch_add_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
            {
                ma_uint8 result = 0;
                (void)order;
                __asm {
                    mov ecx, dst
                    mov al,  src
                    lock xadd [ecx], al
                    mov result, al
                }
                return result;
            }
        #endif
        #if defined(MA_ATOMIC_HAS_16)
            static MA_INLINE ma_uint16 __stdcall ma_atomic_fetch_add_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
            {
                ma_uint16 result = 0;
                (void)order;
                __asm {
                    mov ecx, dst
                    mov ax,  src
                    lock xadd [ecx], ax
                    mov result, ax
                }
                return result;
            }
        #endif
        #if defined(MA_ATOMIC_HAS_32)
            static MA_INLINE ma_uint32 __stdcall ma_atomic_fetch_add_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
            {
                ma_uint32 result = 0;
                (void)order;
                __asm {
                    mov ecx, dst
                    mov eax, src
                    lock xadd [ecx], eax
                    mov result, eax
                }
                return result;
            }
        #endif
    #else
        #if defined(MA_ATOMIC_HAS_8)
            static MA_INLINE ma_uint8 __stdcall ma_atomic_fetch_add_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
            {
            #if defined(MA_ARM)
                MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedExchangeAdd8, ma_uint8, char);
            #else
                (void)order;
                return (ma_uint8)_InterlockedExchangeAdd8((volatile char*)dst, (char)src);
            #endif
            }
        #endif
        #if defined(MA_ATOMIC_HAS_16)
            static MA_INLINE ma_uint16 __stdcall ma_atomic_fetch_add_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
            {
            #if defined(MA_ARM)
                MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedExchangeAdd16, ma_uint16, short);
            #else
                (void)order;
                return (ma_uint16)_InterlockedExchangeAdd16((volatile short*)dst, (short)src);
            #endif
            }
        #endif
        #if defined(MA_ATOMIC_HAS_32)
            static MA_INLINE ma_uint32 __stdcall ma_atomic_fetch_add_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
            {
            #if defined(MA_ARM)
                MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedExchangeAdd, ma_uint32, long);
            #else
                (void)order;
                return (ma_uint32)_InterlockedExchangeAdd((volatile long*)dst, (long)src);
            #endif
            }
        #endif
        #if defined(MA_ATOMIC_HAS_64) && defined(MA_64BIT)
            static MA_INLINE ma_uint64 __stdcall ma_atomic_fetch_add_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
            {
            #if defined(MA_ARM)
                MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedExchangeAdd64, ma_uint64, long long);
            #else
                (void)order;
                return (ma_uint64)_InterlockedExchangeAdd64((volatile long long*)dst, (long long)src);
            #endif
            }
        #else
        #endif
    #endif
    #if defined(MA_ATOMIC_HAS_64) && !defined(MA_64BIT)
        static MA_INLINE ma_uint64 __stdcall ma_atomic_fetch_add_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
            ma_uint64 oldValue;
            ma_uint64 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue + src;
            } while (ma_atomic_compare_and_swap_64(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
    #endif
    #if defined(MA_ATOMIC_MSVC_USE_INLINED_ASSEMBLY)
        static MA_INLINE void __stdcall ma_atomic_thread_fence(ma_atomic_memory_order order)
        {
            (void)order;
            __asm {
                lock add [esp], 0
            }
        }
    #else
        #if defined(MA_X64)
            #define ma_atomic_thread_fence(order)   __faststorefence(), (void)order
        #elif defined(MA_ARM64)
            #define ma_atomic_thread_fence(order)   __dmb(_ARM64_BARRIER_ISH), (void)order
        #else
            static MA_INLINE void ma_atomic_thread_fence(ma_atomic_memory_order order)
            {
                volatile ma_uint32 barrier = 0;
                ma_atomic_fetch_add_explicit_32(&barrier, 0, order);
            }
        #endif
    #endif
    #define ma_atomic_compiler_fence()      ma_atomic_thread_fence(ma_atomic_memory_order_seq_cst)
    #define ma_atomic_signal_fence(order)   ma_atomic_thread_fence(order)
    #if defined(MA_ATOMIC_HAS_8)
        static MA_INLINE ma_uint8 ma_atomic_load_explicit_8(volatile const ma_uint8* ptr, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC_COMPARE_EXCHANGE(ptr, 0, 0, order, _InterlockedCompareExchange8, ma_uint8, char);
        #else
            (void)order;
            return ma_atomic_compare_and_swap_8((volatile ma_uint8*)ptr, 0, 0);
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_16)
        static MA_INLINE ma_uint16 ma_atomic_load_explicit_16(volatile const ma_uint16* ptr, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC_COMPARE_EXCHANGE(ptr, 0, 0, order, _InterlockedCompareExchange16, ma_uint16, short);
        #else
            (void)order;
            return ma_atomic_compare_and_swap_16((volatile ma_uint16*)ptr, 0, 0);
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_32)
        static MA_INLINE ma_uint32 ma_atomic_load_explicit_32(volatile const ma_uint32* ptr, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC_COMPARE_EXCHANGE(ptr, 0, 0, order, _InterlockedCompareExchange, ma_uint32, long);
        #else
            (void)order;
            return ma_atomic_compare_and_swap_32((volatile ma_uint32*)ptr, 0, 0);
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_64)
        static MA_INLINE ma_uint64 ma_atomic_load_explicit_64(volatile const ma_uint64* ptr, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC_COMPARE_EXCHANGE(ptr, 0, 0, order, _InterlockedCompareExchange64, ma_uint64, long long);
        #else
            (void)order;
            return ma_atomic_compare_and_swap_64((volatile ma_uint64*)ptr, 0, 0);
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_8)
        #define ma_atomic_store_explicit_8( dst, src, order) (void)ma_atomic_exchange_explicit_8 (dst, src, order)
    #endif
    #if defined(MA_ATOMIC_HAS_16)
        #define ma_atomic_store_explicit_16(dst, src, order) (void)ma_atomic_exchange_explicit_16(dst, src, order)
    #endif
    #if defined(MA_ATOMIC_HAS_32)
        #define ma_atomic_store_explicit_32(dst, src, order) (void)ma_atomic_exchange_explicit_32(dst, src, order)
    #endif
    #if defined(MA_ATOMIC_HAS_64)
        #define ma_atomic_store_explicit_64(dst, src, order) (void)ma_atomic_exchange_explicit_64(dst, src, order)
    #endif
    #if defined(MA_ATOMIC_HAS_8)
        static MA_INLINE ma_uint8 __stdcall ma_atomic_fetch_sub_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
            ma_uint8 oldValue;
            ma_uint8 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint8)(oldValue - src);
            } while (ma_atomic_compare_and_swap_8(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
    #endif
    #if defined(MA_ATOMIC_HAS_16)
        static MA_INLINE ma_uint16 __stdcall ma_atomic_fetch_sub_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
            ma_uint16 oldValue;
            ma_uint16 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint16)(oldValue - src);
            } while (ma_atomic_compare_and_swap_16(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
    #endif
    #if defined(MA_ATOMIC_HAS_32)
        static MA_INLINE ma_uint32 __stdcall ma_atomic_fetch_sub_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
            ma_uint32 oldValue;
            ma_uint32 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue - src;
            } while (ma_atomic_compare_and_swap_32(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
    #endif
    #if defined(MA_ATOMIC_HAS_64)
        static MA_INLINE ma_uint64 __stdcall ma_atomic_fetch_sub_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
            ma_uint64 oldValue;
            ma_uint64 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue - src;
            } while (ma_atomic_compare_and_swap_64(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
    #endif
    #if defined(MA_ATOMIC_HAS_8)
        static MA_INLINE ma_uint8 __stdcall ma_atomic_fetch_and_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedAnd8, ma_uint8, char);
        #else
            ma_uint8 oldValue;
            ma_uint8 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint8)(oldValue & src);
            } while (ma_atomic_compare_and_swap_8(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_16)
        static MA_INLINE ma_uint16 __stdcall ma_atomic_fetch_and_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedAnd16, ma_uint16, short);
        #else
            ma_uint16 oldValue;
            ma_uint16 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint16)(oldValue & src);
            } while (ma_atomic_compare_and_swap_16(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_32)
        static MA_INLINE ma_uint32 __stdcall ma_atomic_fetch_and_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedAnd, ma_uint32, long);
        #else
            ma_uint32 oldValue;
            ma_uint32 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue & src;
            } while (ma_atomic_compare_and_swap_32(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_64)
        static MA_INLINE ma_uint64 __stdcall ma_atomic_fetch_and_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedAnd64, ma_uint64, long long);
        #else
            ma_uint64 oldValue;
            ma_uint64 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue & src;
            } while (ma_atomic_compare_and_swap_64(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_8)
        static MA_INLINE ma_uint8 __stdcall ma_atomic_fetch_xor_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedXor8, ma_uint8, char);
        #else
            ma_uint8 oldValue;
            ma_uint8 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint8)(oldValue ^ src);
            } while (ma_atomic_compare_and_swap_8(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_16)
        static MA_INLINE ma_uint16 __stdcall ma_atomic_fetch_xor_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedXor16, ma_uint16, short);
        #else
            ma_uint16 oldValue;
            ma_uint16 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint16)(oldValue ^ src);
            } while (ma_atomic_compare_and_swap_16(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_32)
        static MA_INLINE ma_uint32 __stdcall ma_atomic_fetch_xor_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedXor, ma_uint32, long);
        #else
            ma_uint32 oldValue;
            ma_uint32 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue ^ src;
            } while (ma_atomic_compare_and_swap_32(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_64)
        static MA_INLINE ma_uint64 __stdcall ma_atomic_fetch_xor_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedXor64, ma_uint64, long long);
        #else
            ma_uint64 oldValue;
            ma_uint64 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue ^ src;
            } while (ma_atomic_compare_and_swap_64(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_8)
        static MA_INLINE ma_uint8 __stdcall ma_atomic_fetch_or_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedOr8, ma_uint8, char);
        #else
            ma_uint8 oldValue;
            ma_uint8 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint8)(oldValue | src);
            } while (ma_atomic_compare_and_swap_8(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_16)
        static MA_INLINE ma_uint16 __stdcall ma_atomic_fetch_or_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedOr16, ma_uint16, short);
        #else
            ma_uint16 oldValue;
            ma_uint16 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint16)(oldValue | src);
            } while (ma_atomic_compare_and_swap_16(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_32)
        static MA_INLINE ma_uint32 __stdcall ma_atomic_fetch_or_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedOr, ma_uint32, long);
        #else
            ma_uint32 oldValue;
            ma_uint32 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue | src;
            } while (ma_atomic_compare_and_swap_32(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_64)
        static MA_INLINE ma_uint64 __stdcall ma_atomic_fetch_or_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
        #if defined(MA_ARM)
            MA_ATOMIC_MSVC_ARM_INTRINSIC(dst, src, order, _InterlockedOr64, ma_uint64, long long);
        #else
            ma_uint64 oldValue;
            ma_uint64 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue | src;
            } while (ma_atomic_compare_and_swap_64(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        #endif
        }
    #endif
    #if defined(MA_ATOMIC_HAS_8)
        #define ma_atomic_test_and_set_explicit_8( dst, order) ma_atomic_exchange_explicit_8 (dst, 1, order)
    #endif
    #if defined(MA_ATOMIC_HAS_16)
        #define ma_atomic_test_and_set_explicit_16(dst, order) ma_atomic_exchange_explicit_16(dst, 1, order)
    #endif
    #if defined(MA_ATOMIC_HAS_32)
        #define ma_atomic_test_and_set_explicit_32(dst, order) ma_atomic_exchange_explicit_32(dst, 1, order)
    #endif
    #if defined(MA_ATOMIC_HAS_64)
        #define ma_atomic_test_and_set_explicit_64(dst, order) ma_atomic_exchange_explicit_64(dst, 1, order)
    #endif
    #if defined(MA_ATOMIC_HAS_8)
        #define ma_atomic_clear_explicit_8( dst, order) ma_atomic_store_explicit_8 (dst, 0, order)
    #endif
    #if defined(MA_ATOMIC_HAS_16)
        #define ma_atomic_clear_explicit_16(dst, order) ma_atomic_store_explicit_16(dst, 0, order)
    #endif
    #if defined(MA_ATOMIC_HAS_32)
        #define ma_atomic_clear_explicit_32(dst, order) ma_atomic_store_explicit_32(dst, 0, order)
    #endif
    #if defined(MA_ATOMIC_HAS_64)
        #define ma_atomic_clear_explicit_64(dst, order) ma_atomic_store_explicit_64(dst, 0, order)
    #endif
    #if defined(MA_ATOMIC_HAS_8)
        typedef ma_uint8 ma_atomic_flag;
        #define ma_atomic_flag_test_and_set_explicit(ptr, order)    (ma_bool32)ma_atomic_test_and_set_explicit_8(ptr, order)
        #define ma_atomic_flag_clear_explicit(ptr, order)           ma_atomic_clear_explicit_8(ptr, order)
        #define ma_atomic_flag_load_explicit(ptr, order)            ma_atomic_load_explicit_8(ptr, order)
    #else
        typedef ma_uint32 ma_atomic_flag;
        #define ma_atomic_flag_test_and_set_explicit(ptr, order)    (ma_bool32)ma_atomic_test_and_set_explicit_32(ptr, order)
        #define ma_atomic_flag_clear_explicit(ptr, order)           ma_atomic_clear_explicit_32(ptr, order)
        #define ma_atomic_flag_load_explicit(ptr, order)            ma_atomic_load_explicit_32(ptr, order)
    #endif
#elif defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)))
    #define MA_ATOMIC_HAS_NATIVE_COMPARE_EXCHANGE
    #define MA_ATOMIC_HAS_NATIVE_IS_LOCK_FREE
    #define ma_atomic_memory_order_relaxed                          __ATOMIC_RELAXED
    #define ma_atomic_memory_order_consume                          __ATOMIC_CONSUME
    #define ma_atomic_memory_order_acquire                          __ATOMIC_ACQUIRE
    #define ma_atomic_memory_order_release                          __ATOMIC_RELEASE
    #define ma_atomic_memory_order_acq_rel                          __ATOMIC_ACQ_REL
    #define ma_atomic_memory_order_seq_cst                          __ATOMIC_SEQ_CST
    #define ma_atomic_compiler_fence()                              __asm__ __volatile__("":::"memory")
    #define ma_atomic_thread_fence(order)                           __atomic_thread_fence(order)
    #define ma_atomic_signal_fence(order)                           __atomic_signal_fence(order)
    #define ma_atomic_is_lock_free_8(ptr)                           __atomic_is_lock_free(1, ptr)
    #define ma_atomic_is_lock_free_16(ptr)                          __atomic_is_lock_free(2, ptr)
    #define ma_atomic_is_lock_free_32(ptr)                          __atomic_is_lock_free(4, ptr)
    #define ma_atomic_is_lock_free_64(ptr)                          __atomic_is_lock_free(8, ptr)
    #define ma_atomic_test_and_set_explicit_8( dst, order)          __atomic_exchange_n(dst, 1, order)
    #define ma_atomic_test_and_set_explicit_16(dst, order)          __atomic_exchange_n(dst, 1, order)
    #define ma_atomic_test_and_set_explicit_32(dst, order)          __atomic_exchange_n(dst, 1, order)
    #define ma_atomic_test_and_set_explicit_64(dst, order)          __atomic_exchange_n(dst, 1, order)
    #define ma_atomic_clear_explicit_8( dst, order)                 __atomic_store_n(dst, 0, order)
    #define ma_atomic_clear_explicit_16(dst, order)                 __atomic_store_n(dst, 0, order)
    #define ma_atomic_clear_explicit_32(dst, order)                 __atomic_store_n(dst, 0, order)
    #define ma_atomic_clear_explicit_64(dst, order)                 __atomic_store_n(dst, 0, order)
    #define ma_atomic_store_explicit_8( dst, src, order)            __atomic_store_n(dst, src, order)
    #define ma_atomic_store_explicit_16(dst, src, order)            __atomic_store_n(dst, src, order)
    #define ma_atomic_store_explicit_32(dst, src, order)            __atomic_store_n(dst, src, order)
    #define ma_atomic_store_explicit_64(dst, src, order)            __atomic_store_n(dst, src, order)
    #define ma_atomic_load_explicit_8( dst, order)                  __atomic_load_n(dst, order)
    #define ma_atomic_load_explicit_16(dst, order)                  __atomic_load_n(dst, order)
    #define ma_atomic_load_explicit_32(dst, order)                  __atomic_load_n(dst, order)
    #define ma_atomic_load_explicit_64(dst, order)                  __atomic_load_n(dst, order)
    #define ma_atomic_exchange_explicit_8( dst, src, order)         __atomic_exchange_n(dst, src, order)
    #define ma_atomic_exchange_explicit_16(dst, src, order)         __atomic_exchange_n(dst, src, order)
    #define ma_atomic_exchange_explicit_32(dst, src, order)         __atomic_exchange_n(dst, src, order)
    #define ma_atomic_exchange_explicit_64(dst, src, order)         __atomic_exchange_n(dst, src, order)
    #define ma_atomic_compare_exchange_strong_explicit_8( dst, expected, desired, successOrder, failureOrder)   __atomic_compare_exchange_n(dst, expected, desired, 0, successOrder, failureOrder)
    #define ma_atomic_compare_exchange_strong_explicit_16(dst, expected, desired, successOrder, failureOrder)   __atomic_compare_exchange_n(dst, expected, desired, 0, successOrder, failureOrder)
    #define ma_atomic_compare_exchange_strong_explicit_32(dst, expected, desired, successOrder, failureOrder)   __atomic_compare_exchange_n(dst, expected, desired, 0, successOrder, failureOrder)
    #define ma_atomic_compare_exchange_strong_explicit_64(dst, expected, desired, successOrder, failureOrder)   __atomic_compare_exchange_n(dst, expected, desired, 0, successOrder, failureOrder)
    #define ma_atomic_compare_exchange_weak_explicit_8( dst, expected, desired, successOrder, failureOrder)     __atomic_compare_exchange_n(dst, expected, desired, 1, successOrder, failureOrder)
    #define ma_atomic_compare_exchange_weak_explicit_16(dst, expected, desired, successOrder, failureOrder)     __atomic_compare_exchange_n(dst, expected, desired, 1, successOrder, failureOrder)
    #define ma_atomic_compare_exchange_weak_explicit_32(dst, expected, desired, successOrder, failureOrder)     __atomic_compare_exchange_n(dst, expected, desired, 1, successOrder, failureOrder)
    #define ma_atomic_compare_exchange_weak_explicit_64(dst, expected, desired, successOrder, failureOrder)     __atomic_compare_exchange_n(dst, expected, desired, 1, successOrder, failureOrder)
    #define ma_atomic_fetch_add_explicit_8( dst, src, order)        __atomic_fetch_add(dst, src, order)
    #define ma_atomic_fetch_add_explicit_16(dst, src, order)        __atomic_fetch_add(dst, src, order)
    #define ma_atomic_fetch_add_explicit_32(dst, src, order)        __atomic_fetch_add(dst, src, order)
    #define ma_atomic_fetch_add_explicit_64(dst, src, order)        __atomic_fetch_add(dst, src, order)
    #define ma_atomic_fetch_sub_explicit_8( dst, src, order)        __atomic_fetch_sub(dst, src, order)
    #define ma_atomic_fetch_sub_explicit_16(dst, src, order)        __atomic_fetch_sub(dst, src, order)
    #define ma_atomic_fetch_sub_explicit_32(dst, src, order)        __atomic_fetch_sub(dst, src, order)
    #define ma_atomic_fetch_sub_explicit_64(dst, src, order)        __atomic_fetch_sub(dst, src, order)
    #define ma_atomic_fetch_or_explicit_8( dst, src, order)         __atomic_fetch_or(dst, src, order)
    #define ma_atomic_fetch_or_explicit_16(dst, src, order)         __atomic_fetch_or(dst, src, order)
    #define ma_atomic_fetch_or_explicit_32(dst, src, order)         __atomic_fetch_or(dst, src, order)
    #define ma_atomic_fetch_or_explicit_64(dst, src, order)         __atomic_fetch_or(dst, src, order)
    #define ma_atomic_fetch_xor_explicit_8( dst, src, order)        __atomic_fetch_xor(dst, src, order)
    #define ma_atomic_fetch_xor_explicit_16(dst, src, order)        __atomic_fetch_xor(dst, src, order)
    #define ma_atomic_fetch_xor_explicit_32(dst, src, order)        __atomic_fetch_xor(dst, src, order)
    #define ma_atomic_fetch_xor_explicit_64(dst, src, order)        __atomic_fetch_xor(dst, src, order)
    #define ma_atomic_fetch_and_explicit_8( dst, src, order)        __atomic_fetch_and(dst, src, order)
    #define ma_atomic_fetch_and_explicit_16(dst, src, order)        __atomic_fetch_and(dst, src, order)
    #define ma_atomic_fetch_and_explicit_32(dst, src, order)        __atomic_fetch_and(dst, src, order)
    #define ma_atomic_fetch_and_explicit_64(dst, src, order)        __atomic_fetch_and(dst, src, order)
    static MA_INLINE ma_uint8 ma_atomic_compare_and_swap_8(volatile ma_uint8* dst, ma_uint8 expected, ma_uint8 desired)
    {
        __atomic_compare_exchange_n(dst, &expected, desired, 0, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);
        return expected;
    }
    static MA_INLINE ma_uint16 ma_atomic_compare_and_swap_16(volatile ma_uint16* dst, ma_uint16 expected, ma_uint16 desired)
    {
        __atomic_compare_exchange_n(dst, &expected, desired, 0, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);
        return expected;
    }
    static MA_INLINE ma_uint32 ma_atomic_compare_and_swap_32(volatile ma_uint32* dst, ma_uint32 expected, ma_uint32 desired)
    {
        __atomic_compare_exchange_n(dst, &expected, desired, 0, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);
        return expected;
    }
    #if defined(__clang__)
        #pragma clang diagnostic push
        #if __clang_major__ >= 8
            #pragma clang diagnostic ignored "-Watomic-alignment"
        #endif
    #endif
    static MA_INLINE ma_uint64 ma_atomic_compare_and_swap_64(volatile ma_uint64* dst, ma_uint64 expected, ma_uint64 desired)
    {
        __atomic_compare_exchange_n(dst, &expected, desired, 0, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);
        return expected;
    }
    #if defined(__clang__)
        #pragma clang diagnostic pop
    #endif
    typedef ma_uint8 ma_atomic_flag;
    #define ma_atomic_flag_test_and_set_explicit(dst, order)        (ma_bool32)__atomic_test_and_set(dst, order)
    #define ma_atomic_flag_clear_explicit(dst, order)               __atomic_clear(dst, order)
    #define ma_atomic_flag_load_explicit(ptr, order)                ma_atomic_load_explicit_8(ptr, order)
#else
    #define ma_atomic_memory_order_relaxed  1
    #define ma_atomic_memory_order_consume  2
    #define ma_atomic_memory_order_acquire  3
    #define ma_atomic_memory_order_release  4
    #define ma_atomic_memory_order_acq_rel  5
    #define ma_atomic_memory_order_seq_cst  6
    #define ma_atomic_compiler_fence() __asm__ __volatile__("":::"memory")
    #if defined(__GNUC__)
        #define ma_atomic_thread_fence(order) __sync_synchronize(), (void)order
        static MA_INLINE ma_uint8 ma_atomic_exchange_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
            if (order > ma_atomic_memory_order_acquire) {
                __sync_synchronize();
            }
            return __sync_lock_test_and_set(dst, src);
        }
        static MA_INLINE ma_uint16 ma_atomic_exchange_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
            ma_uint16 oldValue;
            do {
                oldValue = *dst;
            } while (__sync_val_compare_and_swap(dst, oldValue, src) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint32 ma_atomic_exchange_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
            ma_uint32 oldValue;
            do {
                oldValue = *dst;
            } while (__sync_val_compare_and_swap(dst, oldValue, src) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint64 ma_atomic_exchange_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
            ma_uint64 oldValue;
            do {
                oldValue = *dst;
            } while (__sync_val_compare_and_swap(dst, oldValue, src) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint8 ma_atomic_fetch_add_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_add(dst, src);
        }
        static MA_INLINE ma_uint16 ma_atomic_fetch_add_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_add(dst, src);
        }
        static MA_INLINE ma_uint32 ma_atomic_fetch_add_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_add(dst, src);
        }
        static MA_INLINE ma_uint64 ma_atomic_fetch_add_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_add(dst, src);
        }
        static MA_INLINE ma_uint8 ma_atomic_fetch_sub_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_sub(dst, src);
        }
        static MA_INLINE ma_uint16 ma_atomic_fetch_sub_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_sub(dst, src);
        }
        static MA_INLINE ma_uint32 ma_atomic_fetch_sub_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_sub(dst, src);
        }
        static MA_INLINE ma_uint64 ma_atomic_fetch_sub_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_sub(dst, src);
        }
        static MA_INLINE ma_uint8 ma_atomic_fetch_or_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_or(dst, src);
        }
        static MA_INLINE ma_uint16 ma_atomic_fetch_or_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_or(dst, src);
        }
        static MA_INLINE ma_uint32 ma_atomic_fetch_or_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_or(dst, src);
        }
        static MA_INLINE ma_uint64 ma_atomic_fetch_or_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_or(dst, src);
        }
        static MA_INLINE ma_uint8 ma_atomic_fetch_xor_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_xor(dst, src);
        }
        static MA_INLINE ma_uint16 ma_atomic_fetch_xor_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_xor(dst, src);
        }
        static MA_INLINE ma_uint32 ma_atomic_fetch_xor_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_xor(dst, src);
        }
        static MA_INLINE ma_uint64 ma_atomic_fetch_xor_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_xor(dst, src);
        }
        static MA_INLINE ma_uint8 ma_atomic_fetch_and_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_and(dst, src);
        }
        static MA_INLINE ma_uint16 ma_atomic_fetch_and_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_and(dst, src);
        }
        static MA_INLINE ma_uint32 ma_atomic_fetch_and_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_and(dst, src);
        }
        static MA_INLINE ma_uint64 ma_atomic_fetch_and_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
            (void)order;
            return __sync_fetch_and_and(dst, src);
        }
        #define ma_atomic_compare_and_swap_8( dst, expected, desired)   __sync_val_compare_and_swap(dst, expected, desired)
        #define ma_atomic_compare_and_swap_16(dst, expected, desired)   __sync_val_compare_and_swap(dst, expected, desired)
        #define ma_atomic_compare_and_swap_32(dst, expected, desired)   __sync_val_compare_and_swap(dst, expected, desired)
        #define ma_atomic_compare_and_swap_64(dst, expected, desired)   __sync_val_compare_and_swap(dst, expected, desired)
    #else
        #if defined(MA_X86)
            #define ma_atomic_thread_fence(order) __asm__ __volatile__("lock; addl $0, (%%esp)" ::: "memory", "cc")
        #elif defined(MA_X64)
            #define ma_atomic_thread_fence(order) __asm__ __volatile__("lock; addq $0, (%%rsp)" ::: "memory", "cc")
        #else
            #error Unsupported architecture. Please submit a feature request.
        #endif
        static MA_INLINE ma_uint8 ma_atomic_compare_and_swap_8(volatile ma_uint8* dst, ma_uint8 expected, ma_uint8 desired)
        {
            ma_uint8 result;
        #if defined(MA_X86) || defined(MA_X64)
            __asm__ __volatile__("lock; cmpxchg %3, %0" : "+m"(*dst), "=a"(result) : "a"(expected), "d"(desired) : "cc");
        #else
            #error Unsupported architecture. Please submit a feature request.
        #endif
            return result;
        }
        static MA_INLINE ma_uint16 ma_atomic_compare_and_swap_16(volatile ma_uint16* dst, ma_uint16 expected, ma_uint16 desired)
        {
            ma_uint16 result;
        #if defined(MA_X86) || defined(MA_X64)
            __asm__ __volatile__("lock; cmpxchg %3, %0" : "+m"(*dst), "=a"(result) : "a"(expected), "d"(desired) : "cc");
        #else
            #error Unsupported architecture. Please submit a feature request.
        #endif
            return result;
        }
        static MA_INLINE ma_uint32 ma_atomic_compare_and_swap_32(volatile ma_uint32* dst, ma_uint32 expected, ma_uint32 desired)
        {
            ma_uint32 result;
        #if defined(MA_X86) || defined(MA_X64)
            __asm__ __volatile__("lock; cmpxchg %3, %0" : "+m"(*dst), "=a"(result) : "a"(expected), "d"(desired) : "cc");
        #else
            #error Unsupported architecture. Please submit a feature request.
        #endif
            return result;
        }
        static MA_INLINE ma_uint64 ma_atomic_compare_and_swap_64(volatile ma_uint64* dst, ma_uint64 expected, ma_uint64 desired)
        {
            volatile ma_uint64 result;
        #if defined(MA_X86)
            ma_uint32 resultEAX;
            ma_uint32 resultEDX;
            __asm__ __volatile__("push %%ebx; xchg %5, %%ebx; lock; cmpxchg8b %0; pop %%ebx" : "+m"(*dst), "=a"(resultEAX), "=d"(resultEDX) : "a"(expected & 0xFFFFFFFF), "d"(expected >> 32), "r"(desired & 0xFFFFFFFF), "c"(desired >> 32) : "cc");
            result = ((ma_uint64)resultEDX << 32) | resultEAX;
        #elif defined(MA_X64)
            __asm__ __volatile__("lock; cmpxchg %3, %0" : "+m"(*dst), "=a"(result) : "a"(expected), "d"(desired) : "cc");
        #else
            #error Unsupported architecture. Please submit a feature request.
        #endif
            return result;
        }
        static MA_INLINE ma_uint8 ma_atomic_exchange_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
            ma_uint8 result = 0;
            (void)order;
        #if defined(MA_X86) || defined(MA_X64)
            __asm__ __volatile__("lock; xchg %1, %0" : "+m"(*dst), "=a"(result) : "a"(src));
        #else
            #error Unsupported architecture. Please submit a feature request.
        #endif
            return result;
        }
        static MA_INLINE ma_uint16 ma_atomic_exchange_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
            ma_uint16 result = 0;
            (void)order;
        #if defined(MA_X86) || defined(MA_X64)
            __asm__ __volatile__("lock; xchg %1, %0" : "+m"(*dst), "=a"(result) : "a"(src));
        #else
            #error Unsupported architecture. Please submit a feature request.
        #endif
            return result;
        }
        static MA_INLINE ma_uint32 ma_atomic_exchange_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
            ma_uint32 result;
            (void)order;
        #if defined(MA_X86) || defined(MA_X64)
            __asm__ __volatile__("lock; xchg %1, %0" : "+m"(*dst), "=a"(result) : "a"(src));
        #else
            #error Unsupported architecture. Please submit a feature request.
        #endif
            return result;
        }
        static MA_INLINE ma_uint64 ma_atomic_exchange_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
            ma_uint64 result;
            (void)order;
        #if defined(MA_X86)
            do {
                result = *dst;
            } while (ma_atomic_compare_and_swap_64(dst, result, src) != result);
        #elif defined(MA_X64)
            __asm__ __volatile__("lock; xchg %1, %0" : "+m"(*dst), "=a"(result) : "a"(src));
        #else
            #error Unsupported architecture. Please submit a feature request.
        #endif
            return result;
        }
        static MA_INLINE ma_uint8 ma_atomic_fetch_add_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
            ma_uint8 result;
            (void)order;
        #if defined(MA_X86) || defined(MA_X64)
            __asm__ __volatile__("lock; xadd %1, %0" : "+m"(*dst), "=a"(result) : "a"(src) : "cc");
        #else
            #error Unsupported architecture. Please submit a feature request.
        #endif
            return result;
        }
        static MA_INLINE ma_uint16 ma_atomic_fetch_add_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
            ma_uint16 result;
            (void)order;
        #if defined(MA_X86) || defined(MA_X64)
            __asm__ __volatile__("lock; xadd %1, %0" : "+m"(*dst), "=a"(result) : "a"(src) : "cc");
        #else
            #error Unsupported architecture. Please submit a feature request.
        #endif
            return result;
        }
        static MA_INLINE ma_uint32 ma_atomic_fetch_add_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
            ma_uint32 result;
            (void)order;
        #if defined(MA_X86) || defined(MA_X64)
            __asm__ __volatile__("lock; xadd %1, %0" : "+m"(*dst), "=a"(result) : "a"(src) : "cc");
        #else
            #error Unsupported architecture. Please submit a feature request.
        #endif
            return result;
        }
        static MA_INLINE ma_uint64 ma_atomic_fetch_add_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
        #if defined(MA_X86)
            ma_uint64 oldValue;
            ma_uint64 newValue;
            (void)order;
            do {
                oldValue = *dst;
                newValue = oldValue + src;
            } while (ma_atomic_compare_and_swap_64(dst, oldValue, newValue) != oldValue);
            return oldValue;
        #elif defined(MA_X64)
            ma_uint64 result;
            (void)order;
            __asm__ __volatile__("lock; xadd %1, %0" : "+m"(*dst), "=a"(result) : "a"(src) : "cc");
            return result;
        #endif
        }
        static MA_INLINE ma_uint8 ma_atomic_fetch_sub_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
            ma_uint8 oldValue;
            ma_uint8 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint8)(oldValue - src);
            } while (ma_atomic_compare_and_swap_8(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint16 ma_atomic_fetch_sub_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
            ma_uint16 oldValue;
            ma_uint16 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint16)(oldValue - src);
            } while (ma_atomic_compare_and_swap_16(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint32 ma_atomic_fetch_sub_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
            ma_uint32 oldValue;
            ma_uint32 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue - src;
            } while (ma_atomic_compare_and_swap_32(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint64 ma_atomic_fetch_sub_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
            ma_uint64 oldValue;
            ma_uint64 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue - src;
            } while (ma_atomic_compare_and_swap_64(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint8 ma_atomic_fetch_and_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
            ma_uint8 oldValue;
            ma_uint8 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint8)(oldValue & src);
            } while (ma_atomic_compare_and_swap_8(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint16 ma_atomic_fetch_and_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
            ma_uint16 oldValue;
            ma_uint16 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint16)(oldValue & src);
            } while (ma_atomic_compare_and_swap_16(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint32 ma_atomic_fetch_and_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
            ma_uint32 oldValue;
            ma_uint32 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue & src;
            } while (ma_atomic_compare_and_swap_32(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint64 ma_atomic_fetch_and_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
            ma_uint64 oldValue;
            ma_uint64 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue & src;
            } while (ma_atomic_compare_and_swap_64(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint8 ma_atomic_fetch_xor_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
            ma_uint8 oldValue;
            ma_uint8 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint8)(oldValue ^ src);
            } while (ma_atomic_compare_and_swap_8(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint16 ma_atomic_fetch_xor_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
            ma_uint16 oldValue;
            ma_uint16 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint16)(oldValue ^ src);
            } while (ma_atomic_compare_and_swap_16(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint32 ma_atomic_fetch_xor_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
            ma_uint32 oldValue;
            ma_uint32 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue ^ src;
            } while (ma_atomic_compare_and_swap_32(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint64 ma_atomic_fetch_xor_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
            ma_uint64 oldValue;
            ma_uint64 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue ^ src;
            } while (ma_atomic_compare_and_swap_64(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint8 ma_atomic_fetch_or_explicit_8(volatile ma_uint8* dst, ma_uint8 src, ma_atomic_memory_order order)
        {
            ma_uint8 oldValue;
            ma_uint8 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint8)(oldValue | src);
            } while (ma_atomic_compare_and_swap_8(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint16 ma_atomic_fetch_or_explicit_16(volatile ma_uint16* dst, ma_uint16 src, ma_atomic_memory_order order)
        {
            ma_uint16 oldValue;
            ma_uint16 newValue;
            do {
                oldValue = *dst;
                newValue = (ma_uint16)(oldValue | src);
            } while (ma_atomic_compare_and_swap_16(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint32 ma_atomic_fetch_or_explicit_32(volatile ma_uint32* dst, ma_uint32 src, ma_atomic_memory_order order)
        {
            ma_uint32 oldValue;
            ma_uint32 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue | src;
            } while (ma_atomic_compare_and_swap_32(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
        static MA_INLINE ma_uint64 ma_atomic_fetch_or_explicit_64(volatile ma_uint64* dst, ma_uint64 src, ma_atomic_memory_order order)
        {
            ma_uint64 oldValue;
            ma_uint64 newValue;
            do {
                oldValue = *dst;
                newValue = oldValue | src;
            } while (ma_atomic_compare_and_swap_64(dst, oldValue, newValue) != oldValue);
            (void)order;
            return oldValue;
        }
    #endif
    #define ma_atomic_signal_fence(order)                           ma_atomic_thread_fence(order)
    static MA_INLINE ma_uint8 ma_atomic_load_explicit_8(volatile const ma_uint8* ptr, ma_atomic_memory_order order)
    {
        (void)order;
        return ma_atomic_compare_and_swap_8((ma_uint8*)ptr, 0, 0);
    }
    static MA_INLINE ma_uint16 ma_atomic_load_explicit_16(volatile const ma_uint16* ptr, ma_atomic_memory_order order)
    {
        (void)order;
        return ma_atomic_compare_and_swap_16((ma_uint16*)ptr, 0, 0);
    }
    static MA_INLINE ma_uint32 ma_atomic_load_explicit_32(volatile const ma_uint32* ptr, ma_atomic_memory_order order)
    {
        (void)order;
        return ma_atomic_compare_and_swap_32((ma_uint32*)ptr, 0, 0);
    }
    static MA_INLINE ma_uint64 ma_atomic_load_explicit_64(volatile const ma_uint64* ptr, ma_atomic_memory_order order)
    {
        (void)order;
        return ma_atomic_compare_and_swap_64((ma_uint64*)ptr, 0, 0);
    }
    #define ma_atomic_store_explicit_8( dst, src, order)            (void)ma_atomic_exchange_explicit_8 (dst, src, order)
    #define ma_atomic_store_explicit_16(dst, src, order)            (void)ma_atomic_exchange_explicit_16(dst, src, order)
    #define ma_atomic_store_explicit_32(dst, src, order)            (void)ma_atomic_exchange_explicit_32(dst, src, order)
    #define ma_atomic_store_explicit_64(dst, src, order)            (void)ma_atomic_exchange_explicit_64(dst, src, order)
    #define ma_atomic_test_and_set_explicit_8( dst, order)          ma_atomic_exchange_explicit_8 (dst, 1, order)
    #define ma_atomic_test_and_set_explicit_16(dst, order)          ma_atomic_exchange_explicit_16(dst, 1, order)
    #define ma_atomic_test_and_set_explicit_32(dst, order)          ma_atomic_exchange_explicit_32(dst, 1, order)
    #define ma_atomic_test_and_set_explicit_64(dst, order)          ma_atomic_exchange_explicit_64(dst, 1, order)
    #define ma_atomic_clear_explicit_8( dst, order)                 ma_atomic_store_explicit_8 (dst, 0, order)
    #define ma_atomic_clear_explicit_16(dst, order)                 ma_atomic_store_explicit_16(dst, 0, order)
    #define ma_atomic_clear_explicit_32(dst, order)                 ma_atomic_store_explicit_32(dst, 0, order)
    #define ma_atomic_clear_explicit_64(dst, order)                 ma_atomic_store_explicit_64(dst, 0, order)
    typedef ma_uint8 ma_atomic_flag;
    #define ma_atomic_flag_test_and_set_explicit(ptr, order)        (ma_bool32)ma_atomic_test_and_set_explicit_8(ptr, order)
    #define ma_atomic_flag_clear_explicit(ptr, order)               ma_atomic_clear_explicit_8(ptr, order)
    #define ma_atomic_flag_load_explicit(ptr, order)                ma_atomic_load_explicit_8(ptr, order)
#endif
#if !defined(MA_ATOMIC_HAS_NATIVE_COMPARE_EXCHANGE)
    #if defined(MA_ATOMIC_HAS_8)
        static MA_INLINE ma_bool32 ma_atomic_compare_exchange_strong_explicit_8(volatile ma_uint8* dst, ma_uint8* expected, ma_uint8 desired, ma_atomic_memory_order successOrder, ma_atomic_memory_order failureOrder)
        {
            ma_uint8 expectedValue;
            ma_uint8 result;
            (void)successOrder;
            (void)failureOrder;
            expectedValue = ma_atomic_load_explicit_8(expected, ma_atomic_memory_order_seq_cst);
            result = ma_atomic_compare_and_swap_8(dst, expectedValue, desired);
            if (result == expectedValue) {
                return 1;
            } else {
                ma_atomic_store_explicit_8(expected, result, failureOrder);
                return 0;
            }
        }
    #endif
    #if defined(MA_ATOMIC_HAS_16)
        static MA_INLINE ma_bool32 ma_atomic_compare_exchange_strong_explicit_16(volatile ma_uint16* dst, ma_uint16* expected, ma_uint16 desired, ma_atomic_memory_order successOrder, ma_atomic_memory_order failureOrder)
        {
            ma_uint16 expectedValue;
            ma_uint16 result;
            (void)successOrder;
            (void)failureOrder;
            expectedValue = ma_atomic_load_explicit_16(expected, ma_atomic_memory_order_seq_cst);
            result = ma_atomic_compare_and_swap_16(dst, expectedValue, desired);
            if (result == expectedValue) {
                return 1;
            } else {
                ma_atomic_store_explicit_16(expected, result, failureOrder);
                return 0;
            }
        }
    #endif
    #if defined(MA_ATOMIC_HAS_32)
        static MA_INLINE ma_bool32 ma_atomic_compare_exchange_strong_explicit_32(volatile ma_uint32* dst, ma_uint32* expected, ma_uint32 desired, ma_atomic_memory_order successOrder, ma_atomic_memory_order failureOrder)
        {
            ma_uint32 expectedValue;
            ma_uint32 result;
            (void)successOrder;
            (void)failureOrder;
            expectedValue = ma_atomic_load_explicit_32(expected, ma_atomic_memory_order_seq_cst);
            result = ma_atomic_compare_and_swap_32(dst, expectedValue, desired);
            if (result == expectedValue) {
                return 1;
            } else {
                ma_atomic_store_explicit_32(expected, result, failureOrder);
                return 0;
            }
        }
    #endif
    #if defined(MA_ATOMIC_HAS_64)
        static MA_INLINE ma_bool32 ma_atomic_compare_exchange_strong_explicit_64(volatile ma_uint64* dst, volatile ma_uint64* expected, ma_uint64 desired, ma_atomic_memory_order successOrder, ma_atomic_memory_order failureOrder)
        {
            ma_uint64 expectedValue;
            ma_uint64 result;
            (void)successOrder;
            (void)failureOrder;
            expectedValue = ma_atomic_load_explicit_64(expected, ma_atomic_memory_order_seq_cst);
            result = ma_atomic_compare_and_swap_64(dst, expectedValue, desired);
            if (result == expectedValue) {
                return 1;
            } else {
                ma_atomic_store_explicit_64(expected, result, failureOrder);
                return 0;
            }
        }
    #endif
    #define ma_atomic_compare_exchange_weak_explicit_8( dst, expected, desired, successOrder, failureOrder) ma_atomic_compare_exchange_strong_explicit_8 (dst, expected, desired, successOrder, failureOrder)
    #define ma_atomic_compare_exchange_weak_explicit_16(dst, expected, desired, successOrder, failureOrder) ma_atomic_compare_exchange_strong_explicit_16(dst, expected, desired, successOrder, failureOrder)
    #define ma_atomic_compare_exchange_weak_explicit_32(dst, expected, desired, successOrder, failureOrder) ma_atomic_compare_exchange_strong_explicit_32(dst, expected, desired, successOrder, failureOrder)
    #define ma_atomic_compare_exchange_weak_explicit_64(dst, expected, desired, successOrder, failureOrder) ma_atomic_compare_exchange_strong_explicit_64(dst, expected, desired, successOrder, failureOrder)
#endif
#if !defined(MA_ATOMIC_HAS_NATIVE_IS_LOCK_FREE)
    static MA_INLINE ma_bool32 ma_atomic_is_lock_free_8(volatile void* ptr)
    {
        (void)ptr;
        return 1;
    }
    static MA_INLINE ma_bool32 ma_atomic_is_lock_free_16(volatile void* ptr)
    {
        (void)ptr;
        return 1;
    }
    static MA_INLINE ma_bool32 ma_atomic_is_lock_free_32(volatile void* ptr)
    {
        (void)ptr;
        return 1;
    }
    static MA_INLINE ma_bool32 ma_atomic_is_lock_free_64(volatile void* ptr)
    {
        (void)ptr;
    #if defined(MA_64BIT)
        return 1;
    #else
        #if defined(MA_X86) || defined(MA_X64)
            return 1;
        #else
            return 0;
        #endif
    #endif
    }
#endif
#if defined(MA_64BIT)
    static MA_INLINE ma_bool32 ma_atomic_is_lock_free_ptr(volatile void** ptr)
    {
        return ma_atomic_is_lock_free_64((volatile ma_uint64*)ptr);
    }
    static MA_INLINE void* ma_atomic_load_explicit_ptr(volatile void** ptr, ma_atomic_memory_order order)
    {
        return (void*)ma_atomic_load_explicit_64((volatile ma_uint64*)ptr, order);
    }
    static MA_INLINE void ma_atomic_store_explicit_ptr(volatile void** dst, void* src, ma_atomic_memory_order order)
    {
        ma_atomic_store_explicit_64((volatile ma_uint64*)dst, (ma_uint64)src, order);
    }
    static MA_INLINE void* ma_atomic_exchange_explicit_ptr(volatile void** dst, void* src, ma_atomic_memory_order order)
    {
        return (void*)ma_atomic_exchange_explicit_64((volatile ma_uint64*)dst, (ma_uint64)src, order);
    }
    static MA_INLINE ma_bool32 ma_atomic_compare_exchange_strong_explicit_ptr(volatile void** dst, void** expected, void* desired, ma_atomic_memory_order successOrder, ma_atomic_memory_order failureOrder)
    {
        return ma_atomic_compare_exchange_strong_explicit_64((volatile ma_uint64*)dst, (ma_uint64*)expected, (ma_uint64)desired, successOrder, failureOrder);
    }
    static MA_INLINE ma_bool32 ma_atomic_compare_exchange_weak_explicit_ptr(volatile void** dst, void** expected, void* desired, ma_atomic_memory_order successOrder, ma_atomic_memory_order failureOrder)
    {
        return ma_atomic_compare_exchange_weak_explicit_64((volatile ma_uint64*)dst, (ma_uint64*)expected, (ma_uint64)desired, successOrder, failureOrder);
    }
    static MA_INLINE void* ma_atomic_compare_and_swap_ptr(volatile void** dst, void* expected, void* desired)
    {
        return (void*)ma_atomic_compare_and_swap_64((volatile ma_uint64*)dst, (ma_uint64)expected, (ma_uint64)desired);
    }
#elif defined(MA_32BIT)
    static MA_INLINE ma_bool32 ma_atomic_is_lock_free_ptr(volatile void** ptr)
    {
        return ma_atomic_is_lock_free_32((volatile ma_uint32*)ptr);
    }
    static MA_INLINE void* ma_atomic_load_explicit_ptr(volatile void** ptr, ma_atomic_memory_order order)
    {
        return (void*)ma_atomic_load_explicit_32((volatile ma_uint32*)ptr, order);
    }
    static MA_INLINE void ma_atomic_store_explicit_ptr(volatile void** dst, void* src, ma_atomic_memory_order order)
    {
        ma_atomic_store_explicit_32((volatile ma_uint32*)dst, (ma_uint32)src, order);
    }
    static MA_INLINE void* ma_atomic_exchange_explicit_ptr(volatile void** dst, void* src, ma_atomic_memory_order order)
    {
        return (void*)ma_atomic_exchange_explicit_32((volatile ma_uint32*)dst, (ma_uint32)src, order);
    }
    static MA_INLINE ma_bool32 ma_atomic_compare_exchange_strong_explicit_ptr(volatile void** dst, void** expected, void* desired, ma_atomic_memory_order successOrder, ma_atomic_memory_order failureOrder)
    {
        return ma_atomic_compare_exchange_strong_explicit_32((volatile ma_uint32*)dst, (ma_uint32*)expected, (ma_uint32)desired, successOrder, failureOrder);
    }
    static MA_INLINE ma_bool32 ma_atomic_compare_exchange_weak_explicit_ptr(volatile void** dst, void** expected, void* desired, ma_atomic_memory_order successOrder, ma_atomic_memory_order failureOrder)
    {
        return ma_atomic_compare_exchange_weak_explicit_32((volatile ma_uint32*)dst, (ma_uint32*)expected, (ma_uint32)desired, successOrder, failureOrder);
    }
    static MA_INLINE void* ma_atomic_compare_and_swap_ptr(volatile void** dst, void* expected, void* desired)
    {
        return (void*)ma_atomic_compare_and_swap_32((volatile ma_uint32*)dst, (ma_uint32)expected, (ma_uint32)desired);
    }
#else
    #error Unsupported architecture.
#endif
#define ma_atomic_flag_test_and_set(ptr)                                ma_atomic_flag_test_and_set_explicit(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_flag_clear(ptr)                                       ma_atomic_flag_clear_explicit(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_store_ptr(dst, src)                                   ma_atomic_store_explicit_ptr((volatile void**)dst, (void*)src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_load_ptr(ptr)                                         ma_atomic_load_explicit_ptr((volatile void**)ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_exchange_ptr(dst, src)                                ma_atomic_exchange_explicit_ptr((volatile void**)dst, (void*)src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_strong_ptr(dst, expected, desired)   ma_atomic_compare_exchange_strong_explicit_ptr((volatile void**)dst, (void**)expected, (void*)desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_weak_ptr(dst, expected, desired)     ma_atomic_compare_exchange_weak_explicit_ptr((volatile void**)dst, (void**)expected, (void*)desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_test_and_set_8( ptr)                                  ma_atomic_test_and_set_explicit_8( ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_test_and_set_16(ptr)                                  ma_atomic_test_and_set_explicit_16(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_test_and_set_32(ptr)                                  ma_atomic_test_and_set_explicit_32(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_test_and_set_64(ptr)                                  ma_atomic_test_and_set_explicit_64(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_clear_8( ptr)                                         ma_atomic_clear_explicit_8( ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_clear_16(ptr)                                         ma_atomic_clear_explicit_16(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_clear_32(ptr)                                         ma_atomic_clear_explicit_32(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_clear_64(ptr)                                         ma_atomic_clear_explicit_64(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_store_8( dst, src)                                    ma_atomic_store_explicit_8( dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_store_16(dst, src)                                    ma_atomic_store_explicit_16(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_store_32(dst, src)                                    ma_atomic_store_explicit_32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_store_64(dst, src)                                    ma_atomic_store_explicit_64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_load_8( ptr)                                          ma_atomic_load_explicit_8( ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_load_16(ptr)                                          ma_atomic_load_explicit_16(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_load_32(ptr)                                          ma_atomic_load_explicit_32(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_load_64(ptr)                                          ma_atomic_load_explicit_64(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_exchange_8( dst, src)                                 ma_atomic_exchange_explicit_8( dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_exchange_16(dst, src)                                 ma_atomic_exchange_explicit_16(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_exchange_32(dst, src)                                 ma_atomic_exchange_explicit_32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_exchange_64(dst, src)                                 ma_atomic_exchange_explicit_64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_strong_8( dst, expected, desired)    ma_atomic_compare_exchange_strong_explicit_8( dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_strong_16(dst, expected, desired)    ma_atomic_compare_exchange_strong_explicit_16(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_strong_32(dst, expected, desired)    ma_atomic_compare_exchange_strong_explicit_32(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_strong_64(dst, expected, desired)    ma_atomic_compare_exchange_strong_explicit_64(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_weak_8(  dst, expected, desired)     ma_atomic_compare_exchange_weak_explicit_8( dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_weak_16( dst, expected, desired)     ma_atomic_compare_exchange_weak_explicit_16(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_weak_32( dst, expected, desired)     ma_atomic_compare_exchange_weak_explicit_32(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_weak_64( dst, expected, desired)     ma_atomic_compare_exchange_weak_explicit_64(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_add_8( dst, src)                                ma_atomic_fetch_add_explicit_8( dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_add_16(dst, src)                                ma_atomic_fetch_add_explicit_16(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_add_32(dst, src)                                ma_atomic_fetch_add_explicit_32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_add_64(dst, src)                                ma_atomic_fetch_add_explicit_64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_sub_8( dst, src)                                ma_atomic_fetch_sub_explicit_8( dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_sub_16(dst, src)                                ma_atomic_fetch_sub_explicit_16(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_sub_32(dst, src)                                ma_atomic_fetch_sub_explicit_32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_sub_64(dst, src)                                ma_atomic_fetch_sub_explicit_64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_or_8( dst, src)                                 ma_atomic_fetch_or_explicit_8( dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_or_16(dst, src)                                 ma_atomic_fetch_or_explicit_16(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_or_32(dst, src)                                 ma_atomic_fetch_or_explicit_32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_or_64(dst, src)                                 ma_atomic_fetch_or_explicit_64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_xor_8( dst, src)                                ma_atomic_fetch_xor_explicit_8( dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_xor_16(dst, src)                                ma_atomic_fetch_xor_explicit_16(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_xor_32(dst, src)                                ma_atomic_fetch_xor_explicit_32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_xor_64(dst, src)                                ma_atomic_fetch_xor_explicit_64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_and_8( dst, src)                                ma_atomic_fetch_and_explicit_8 (dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_and_16(dst, src)                                ma_atomic_fetch_and_explicit_16(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_and_32(dst, src)                                ma_atomic_fetch_and_explicit_32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_and_64(dst, src)                                ma_atomic_fetch_and_explicit_64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_test_and_set_explicit_i8( ptr, order)                 (ma_int8 )ma_atomic_test_and_set_explicit_8( (ma_uint8* )ptr, order)
#define ma_atomic_test_and_set_explicit_i16(ptr, order)                 (ma_int16)ma_atomic_test_and_set_explicit_16((ma_uint16*)ptr, order)
#define ma_atomic_test_and_set_explicit_i32(ptr, order)                 (ma_int32)ma_atomic_test_and_set_explicit_32((ma_uint32*)ptr, order)
#define ma_atomic_test_and_set_explicit_i64(ptr, order)                 (ma_int64)ma_atomic_test_and_set_explicit_64((ma_uint64*)ptr, order)
#define ma_atomic_clear_explicit_i8( ptr, order)                        ma_atomic_clear_explicit_8( (ma_uint8* )ptr, order)
#define ma_atomic_clear_explicit_i16(ptr, order)                        ma_atomic_clear_explicit_16((ma_uint16*)ptr, order)
#define ma_atomic_clear_explicit_i32(ptr, order)                        ma_atomic_clear_explicit_32((ma_uint32*)ptr, order)
#define ma_atomic_clear_explicit_i64(ptr, order)                        ma_atomic_clear_explicit_64((ma_uint64*)ptr, order)
#define ma_atomic_store_explicit_i8( dst, src, order)                   ma_atomic_store_explicit_8( (ma_uint8* )dst, (ma_uint8 )src, order)
#define ma_atomic_store_explicit_i16(dst, src, order)                   ma_atomic_store_explicit_16((ma_uint16*)dst, (ma_uint16)src, order)
#define ma_atomic_store_explicit_i32(dst, src, order)                   ma_atomic_store_explicit_32((ma_uint32*)dst, (ma_uint32)src, order)
#define ma_atomic_store_explicit_i64(dst, src, order)                   ma_atomic_store_explicit_64((ma_uint64*)dst, (ma_uint64)src, order)
#define ma_atomic_load_explicit_i8( ptr, order)                         (ma_int8 )ma_atomic_load_explicit_8( (ma_uint8* )ptr, order)
#define ma_atomic_load_explicit_i16(ptr, order)                         (ma_int16)ma_atomic_load_explicit_16((ma_uint16*)ptr, order)
#define ma_atomic_load_explicit_i32(ptr, order)                         (ma_int32)ma_atomic_load_explicit_32((ma_uint32*)ptr, order)
#define ma_atomic_load_explicit_i64(ptr, order)                         (ma_int64)ma_atomic_load_explicit_64((ma_uint64*)ptr, order)
#define ma_atomic_exchange_explicit_i8( dst, src, order)                (ma_int8 )ma_atomic_exchange_explicit_8 ((ma_uint8* )dst, (ma_uint8 )src, order)
#define ma_atomic_exchange_explicit_i16(dst, src, order)                (ma_int16)ma_atomic_exchange_explicit_16((ma_uint16*)dst, (ma_uint16)src, order)
#define ma_atomic_exchange_explicit_i32(dst, src, order)                (ma_int32)ma_atomic_exchange_explicit_32((ma_uint32*)dst, (ma_uint32)src, order)
#define ma_atomic_exchange_explicit_i64(dst, src, order)                (ma_int64)ma_atomic_exchange_explicit_64((ma_uint64*)dst, (ma_uint64)src, order)
#define ma_atomic_compare_exchange_strong_explicit_i8( dst, expected, desired, successOrder, failureOrder)  ma_atomic_compare_exchange_strong_explicit_8( (ma_uint8* )dst, (ma_uint8* )expected, (ma_uint8 )desired, successOrder, failureOrder)
#define ma_atomic_compare_exchange_strong_explicit_i16(dst, expected, desired, successOrder, failureOrder)  ma_atomic_compare_exchange_strong_explicit_16((ma_uint16*)dst, (ma_uint16*)expected, (ma_uint16)desired, successOrder, failureOrder)
#define ma_atomic_compare_exchange_strong_explicit_i32(dst, expected, desired, successOrder, failureOrder)  ma_atomic_compare_exchange_strong_explicit_32((ma_uint32*)dst, (ma_uint32*)expected, (ma_uint32)desired, successOrder, failureOrder)
#define ma_atomic_compare_exchange_strong_explicit_i64(dst, expected, desired, successOrder, failureOrder)  ma_atomic_compare_exchange_strong_explicit_64((ma_uint64*)dst, (ma_uint64*)expected, (ma_uint64)desired, successOrder, failureOrder)
#define ma_atomic_compare_exchange_weak_explicit_i8( dst, expected, desired, successOrder, failureOrder)    ma_atomic_compare_exchange_weak_explicit_8( (ma_uint8* )dst, (ma_uint8* )expected, (ma_uint8 )desired, successOrder, failureOrder)
#define ma_atomic_compare_exchange_weak_explicit_i16(dst, expected, desired, successOrder, failureOrder)    ma_atomic_compare_exchange_weak_explicit_16((ma_uint16*)dst, (ma_uint16*)expected, (ma_uint16)desired, successOrder, failureOrder)
#define ma_atomic_compare_exchange_weak_explicit_i32(dst, expected, desired, successOrder, failureOrder)    ma_atomic_compare_exchange_weak_explicit_32((ma_uint32*)dst, (ma_uint32*)expected, (ma_uint32)desired, successOrder, failureOrder)
#define ma_atomic_compare_exchange_weak_explicit_i64(dst, expected, desired, successOrder, failureOrder)    ma_atomic_compare_exchange_weak_explicit_64((ma_uint64*)dst, (ma_uint64*)expected, (ma_uint64)desired, successOrder, failureOrder)
#define ma_atomic_fetch_add_explicit_i8( dst, src, order)               (ma_int8 )ma_atomic_fetch_add_explicit_8( (ma_uint8* )dst, (ma_uint8 )src, order)
#define ma_atomic_fetch_add_explicit_i16(dst, src, order)               (ma_int16)ma_atomic_fetch_add_explicit_16((ma_uint16*)dst, (ma_uint16)src, order)
#define ma_atomic_fetch_add_explicit_i32(dst, src, order)               (ma_int32)ma_atomic_fetch_add_explicit_32((ma_uint32*)dst, (ma_uint32)src, order)
#define ma_atomic_fetch_add_explicit_i64(dst, src, order)               (ma_int64)ma_atomic_fetch_add_explicit_64((ma_uint64*)dst, (ma_uint64)src, order)
#define ma_atomic_fetch_sub_explicit_i8( dst, src, order)               (ma_int8 )ma_atomic_fetch_sub_explicit_8( (ma_uint8* )dst, (ma_uint8 )src, order)
#define ma_atomic_fetch_sub_explicit_i16(dst, src, order)               (ma_int16)ma_atomic_fetch_sub_explicit_16((ma_uint16*)dst, (ma_uint16)src, order)
#define ma_atomic_fetch_sub_explicit_i32(dst, src, order)               (ma_int32)ma_atomic_fetch_sub_explicit_32((ma_uint32*)dst, (ma_uint32)src, order)
#define ma_atomic_fetch_sub_explicit_i64(dst, src, order)               (ma_int64)ma_atomic_fetch_sub_explicit_64((ma_uint64*)dst, (ma_uint64)src, order)
#define ma_atomic_fetch_or_explicit_i8( dst, src, order)                (ma_int8 )ma_atomic_fetch_or_explicit_8( (ma_uint8* )dst, (ma_uint8 )src, order)
#define ma_atomic_fetch_or_explicit_i16(dst, src, order)                (ma_int16)ma_atomic_fetch_or_explicit_16((ma_uint16*)dst, (ma_uint16)src, order)
#define ma_atomic_fetch_or_explicit_i32(dst, src, order)                (ma_int32)ma_atomic_fetch_or_explicit_32((ma_uint32*)dst, (ma_uint32)src, order)
#define ma_atomic_fetch_or_explicit_i64(dst, src, order)                (ma_int64)ma_atomic_fetch_or_explicit_64((ma_uint64*)dst, (ma_uint64)src, order)
#define ma_atomic_fetch_xor_explicit_i8( dst, src, order)               (ma_int8 )ma_atomic_fetch_xor_explicit_8( (ma_uint8* )dst, (ma_uint8 )src, order)
#define ma_atomic_fetch_xor_explicit_i16(dst, src, order)               (ma_int16)ma_atomic_fetch_xor_explicit_16((ma_uint16*)dst, (ma_uint16)src, order)
#define ma_atomic_fetch_xor_explicit_i32(dst, src, order)               (ma_int32)ma_atomic_fetch_xor_explicit_32((ma_uint32*)dst, (ma_uint32)src, order)
#define ma_atomic_fetch_xor_explicit_i64(dst, src, order)               (ma_int64)ma_atomic_fetch_xor_explicit_64((ma_uint64*)dst, (ma_uint64)src, order)
#define ma_atomic_fetch_and_explicit_i8( dst, src, order)               (ma_int8 )ma_atomic_fetch_and_explicit_8( (ma_uint8* )dst, (ma_uint8 )src, order)
#define ma_atomic_fetch_and_explicit_i16(dst, src, order)               (ma_int16)ma_atomic_fetch_and_explicit_16((ma_uint16*)dst, (ma_uint16)src, order)
#define ma_atomic_fetch_and_explicit_i32(dst, src, order)               (ma_int32)ma_atomic_fetch_and_explicit_32((ma_uint32*)dst, (ma_uint32)src, order)
#define ma_atomic_fetch_and_explicit_i64(dst, src, order)               (ma_int64)ma_atomic_fetch_and_explicit_64((ma_uint64*)dst, (ma_uint64)src, order)
#define ma_atomic_test_and_set_i8( ptr)                                 ma_atomic_test_and_set_explicit_i8( ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_test_and_set_i16(ptr)                                 ma_atomic_test_and_set_explicit_i16(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_test_and_set_i32(ptr)                                 ma_atomic_test_and_set_explicit_i32(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_test_and_set_i64(ptr)                                 ma_atomic_test_and_set_explicit_i64(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_clear_i8( ptr)                                        ma_atomic_clear_explicit_i8( ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_clear_i16(ptr)                                        ma_atomic_clear_explicit_i16(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_clear_i32(ptr)                                        ma_atomic_clear_explicit_i32(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_clear_i64(ptr)                                        ma_atomic_clear_explicit_i64(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_store_i8( dst, src)                                   ma_atomic_store_explicit_i8( dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_store_i16(dst, src)                                   ma_atomic_store_explicit_i16(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_store_i32(dst, src)                                   ma_atomic_store_explicit_i32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_store_i64(dst, src)                                   ma_atomic_store_explicit_i64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_load_i8( ptr)                                         ma_atomic_load_explicit_i8( ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_load_i16(ptr)                                         ma_atomic_load_explicit_i16(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_load_i32(ptr)                                         ma_atomic_load_explicit_i32(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_load_i64(ptr)                                         ma_atomic_load_explicit_i64(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_exchange_i8( dst, src)                                ma_atomic_exchange_explicit_i8( dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_exchange_i16(dst, src)                                ma_atomic_exchange_explicit_i16(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_exchange_i32(dst, src)                                ma_atomic_exchange_explicit_i32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_exchange_i64(dst, src)                                ma_atomic_exchange_explicit_i64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_strong_i8( dst, expected, desired)   ma_atomic_compare_exchange_strong_explicit_i8( dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_strong_i16(dst, expected, desired)   ma_atomic_compare_exchange_strong_explicit_i16(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_strong_i32(dst, expected, desired)   ma_atomic_compare_exchange_strong_explicit_i32(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_strong_i64(dst, expected, desired)   ma_atomic_compare_exchange_strong_explicit_i64(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_weak_i8( dst, expected, desired)     ma_atomic_compare_exchange_weak_explicit_i8( dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_weak_i16(dst, expected, desired)     ma_atomic_compare_exchange_weak_explicit_i16(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_weak_i32(dst, expected, desired)     ma_atomic_compare_exchange_weak_explicit_i32(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_weak_i64(dst, expected, desired)     ma_atomic_compare_exchange_weak_explicit_i64(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_add_i8( dst, src)                               ma_atomic_fetch_add_explicit_i8( dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_add_i16(dst, src)                               ma_atomic_fetch_add_explicit_i16(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_add_i32(dst, src)                               ma_atomic_fetch_add_explicit_i32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_add_i64(dst, src)                               ma_atomic_fetch_add_explicit_i64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_sub_i8( dst, src)                               ma_atomic_fetch_sub_explicit_i8( dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_sub_i16(dst, src)                               ma_atomic_fetch_sub_explicit_i16(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_sub_i32(dst, src)                               ma_atomic_fetch_sub_explicit_i32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_sub_i64(dst, src)                               ma_atomic_fetch_sub_explicit_i64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_or_i8( dst, src)                                ma_atomic_fetch_or_explicit_i8( dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_or_i16(dst, src)                                ma_atomic_fetch_or_explicit_i16(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_or_i32(dst, src)                                ma_atomic_fetch_or_explicit_i32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_or_i64(dst, src)                                ma_atomic_fetch_or_explicit_i64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_xor_i8( dst, src)                               ma_atomic_fetch_xor_explicit_i8( dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_xor_i16(dst, src)                               ma_atomic_fetch_xor_explicit_i16(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_xor_i32(dst, src)                               ma_atomic_fetch_xor_explicit_i32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_xor_i64(dst, src)                               ma_atomic_fetch_xor_explicit_i64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_and_i8( dst, src)                               ma_atomic_fetch_and_explicit_i8( dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_and_i16(dst, src)                               ma_atomic_fetch_and_explicit_i16(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_and_i32(dst, src)                               ma_atomic_fetch_and_explicit_i32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_and_i64(dst, src)                               ma_atomic_fetch_and_explicit_i64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_and_swap_i8( dst, expected, dedsired)         (ma_int8 )ma_atomic_compare_and_swap_8( (ma_uint8* )dst, (ma_uint8 )expected, (ma_uint8 )dedsired)
#define ma_atomic_compare_and_swap_i16(dst, expected, dedsired)         (ma_int16)ma_atomic_compare_and_swap_16((ma_uint16*)dst, (ma_uint16)expected, (ma_uint16)dedsired)
#define ma_atomic_compare_and_swap_i32(dst, expected, dedsired)         (ma_int32)ma_atomic_compare_and_swap_32((ma_uint32*)dst, (ma_uint32)expected, (ma_uint32)dedsired)
#define ma_atomic_compare_and_swap_i64(dst, expected, dedsired)         (ma_int64)ma_atomic_compare_and_swap_64((ma_uint64*)dst, (ma_uint64)expected, (ma_uint64)dedsired)
typedef union
{
    ma_uint32 i;
    float f;
} ma_atomic_if32;
typedef union
{
    ma_uint64 i;
    double f;
} ma_atomic_if64;
#define ma_atomic_clear_explicit_f32(ptr, order)                        ma_atomic_clear_explicit_32((ma_uint32*)ptr, order)
#define ma_atomic_clear_explicit_f64(ptr, order)                        ma_atomic_clear_explicit_64((ma_uint64*)ptr, order)
static MA_INLINE void ma_atomic_store_explicit_f32(volatile float* dst, float src, ma_atomic_memory_order order)
{
    ma_atomic_if32 x;
    x.f = src;
    ma_atomic_store_explicit_32((volatile ma_uint32*)dst, x.i, order);
}
static MA_INLINE void ma_atomic_store_explicit_f64(volatile double* dst, double src, ma_atomic_memory_order order)
{
    ma_atomic_if64 x;
    x.f = src;
    ma_atomic_store_explicit_64((volatile ma_uint64*)dst, x.i, order);
}
static MA_INLINE float ma_atomic_load_explicit_f32(volatile const float* ptr, ma_atomic_memory_order order)
{
    ma_atomic_if32 r;
    r.i = ma_atomic_load_explicit_32((volatile const ma_uint32*)ptr, order);
    return r.f;
}
static MA_INLINE double ma_atomic_load_explicit_f64(volatile const double* ptr, ma_atomic_memory_order order)
{
    ma_atomic_if64 r;
    r.i = ma_atomic_load_explicit_64((volatile const ma_uint64*)ptr, order);
    return r.f;
}
static MA_INLINE float ma_atomic_exchange_explicit_f32(volatile float* dst, float src, ma_atomic_memory_order order)
{
    ma_atomic_if32 r;
    ma_atomic_if32 x;
    x.f = src;
    r.i = ma_atomic_exchange_explicit_32((volatile ma_uint32*)dst, x.i, order);
    return r.f;
}
static MA_INLINE double ma_atomic_exchange_explicit_f64(volatile double* dst, double src, ma_atomic_memory_order order)
{
    ma_atomic_if64 r;
    ma_atomic_if64 x;
    x.f = src;
    r.i = ma_atomic_exchange_explicit_64((volatile ma_uint64*)dst, x.i, order);
    return r.f;
}
static MA_INLINE ma_bool32 ma_atomic_compare_exchange_strong_explicit_f32(volatile float* dst, float* expected, float desired, ma_atomic_memory_order successOrder, ma_atomic_memory_order failureOrder)
{
    ma_atomic_if32 d;
    d.f = desired;
    return ma_atomic_compare_exchange_strong_explicit_32((volatile ma_uint32*)dst, (ma_uint32*)expected, d.i, successOrder, failureOrder);
}
static MA_INLINE ma_bool32 ma_atomic_compare_exchange_strong_explicit_f64(volatile double* dst, double* expected, double desired, ma_atomic_memory_order successOrder, ma_atomic_memory_order failureOrder)
{
    ma_atomic_if64 d;
    d.f = desired;
    return ma_atomic_compare_exchange_strong_explicit_64((volatile ma_uint64*)dst, (ma_uint64*)expected, d.i, successOrder, failureOrder);
}
static MA_INLINE ma_bool32 ma_atomic_compare_exchange_weak_explicit_f32(volatile float* dst, float* expected, float desired, ma_atomic_memory_order successOrder, ma_atomic_memory_order failureOrder)
{
    ma_atomic_if32 d;
    d.f = desired;
    return ma_atomic_compare_exchange_weak_explicit_32((volatile ma_uint32*)dst, (ma_uint32*)expected, d.i, successOrder, failureOrder);
}
static MA_INLINE ma_bool32 ma_atomic_compare_exchange_weak_explicit_f64(volatile double* dst, double* expected, double desired, ma_atomic_memory_order successOrder, ma_atomic_memory_order failureOrder)
{
    ma_atomic_if64 d;
    d.f = desired;
    return ma_atomic_compare_exchange_weak_explicit_64((volatile ma_uint64*)dst, (ma_uint64*)expected, d.i, successOrder, failureOrder);
}
static MA_INLINE float ma_atomic_fetch_add_explicit_f32(volatile float* dst, float src, ma_atomic_memory_order order)
{
    ma_atomic_if32 r;
    ma_atomic_if32 x;
    x.f = src;
    r.i = ma_atomic_fetch_add_explicit_32((volatile ma_uint32*)dst, x.i, order);
    return r.f;
}
static MA_INLINE double ma_atomic_fetch_add_explicit_f64(volatile double* dst, double src, ma_atomic_memory_order order)
{
    ma_atomic_if64 r;
    ma_atomic_if64 x;
    x.f = src;
    r.i = ma_atomic_fetch_add_explicit_64((volatile ma_uint64*)dst, x.i, order);
    return r.f;
}
static MA_INLINE float ma_atomic_fetch_sub_explicit_f32(volatile float* dst, float src, ma_atomic_memory_order order)
{
    ma_atomic_if32 r;
    ma_atomic_if32 x;
    x.f = src;
    r.i = ma_atomic_fetch_sub_explicit_32((volatile ma_uint32*)dst, x.i, order);
    return r.f;
}
static MA_INLINE double ma_atomic_fetch_sub_explicit_f64(volatile double* dst, double src, ma_atomic_memory_order order)
{
    ma_atomic_if64 r;
    ma_atomic_if64 x;
    x.f = src;
    r.i = ma_atomic_fetch_sub_explicit_64((volatile ma_uint64*)dst, x.i, order);
    return r.f;
}
static MA_INLINE float ma_atomic_fetch_or_explicit_f32(volatile float* dst, float src, ma_atomic_memory_order order)
{
    ma_atomic_if32 r;
    ma_atomic_if32 x;
    x.f = src;
    r.i = ma_atomic_fetch_or_explicit_32((volatile ma_uint32*)dst, x.i, order);
    return r.f;
}
static MA_INLINE double ma_atomic_fetch_or_explicit_f64(volatile double* dst, double src, ma_atomic_memory_order order)
{
    ma_atomic_if64 r;
    ma_atomic_if64 x;
    x.f = src;
    r.i = ma_atomic_fetch_or_explicit_64((volatile ma_uint64*)dst, x.i, order);
    return r.f;
}
static MA_INLINE float ma_atomic_fetch_xor_explicit_f32(volatile float* dst, float src, ma_atomic_memory_order order)
{
    ma_atomic_if32 r;
    ma_atomic_if32 x;
    x.f = src;
    r.i = ma_atomic_fetch_xor_explicit_32((volatile ma_uint32*)dst, x.i, order);
    return r.f;
}
static MA_INLINE double ma_atomic_fetch_xor_explicit_f64(volatile double* dst, double src, ma_atomic_memory_order order)
{
    ma_atomic_if64 r;
    ma_atomic_if64 x;
    x.f = src;
    r.i = ma_atomic_fetch_xor_explicit_64((volatile ma_uint64*)dst, x.i, order);
    return r.f;
}
static MA_INLINE float ma_atomic_fetch_and_explicit_f32(volatile float* dst, float src, ma_atomic_memory_order order)
{
    ma_atomic_if32 r;
    ma_atomic_if32 x;
    x.f = src;
    r.i = ma_atomic_fetch_and_explicit_32((volatile ma_uint32*)dst, x.i, order);
    return r.f;
}
static MA_INLINE double ma_atomic_fetch_and_explicit_f64(volatile double* dst, double src, ma_atomic_memory_order order)
{
    ma_atomic_if64 r;
    ma_atomic_if64 x;
    x.f = src;
    r.i = ma_atomic_fetch_and_explicit_64((volatile ma_uint64*)dst, x.i, order);
    return r.f;
}
#define ma_atomic_clear_f32(ptr)                                        (float )ma_atomic_clear_explicit_f32(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_clear_f64(ptr)                                        (double)ma_atomic_clear_explicit_f64(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_store_f32(dst, src)                                   ma_atomic_store_explicit_f32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_store_f64(dst, src)                                   ma_atomic_store_explicit_f64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_load_f32(ptr)                                         (float )ma_atomic_load_explicit_f32(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_load_f64(ptr)                                         (double)ma_atomic_load_explicit_f64(ptr, ma_atomic_memory_order_seq_cst)
#define ma_atomic_exchange_f32(dst, src)                                (float )ma_atomic_exchange_explicit_f32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_exchange_f64(dst, src)                                (double)ma_atomic_exchange_explicit_f64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_strong_f32(dst, expected, desired)   ma_atomic_compare_exchange_strong_explicit_f32(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_strong_f64(dst, expected, desired)   ma_atomic_compare_exchange_strong_explicit_f64(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_weak_f32(dst, expected, desired)     ma_atomic_compare_exchange_weak_explicit_f32(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_compare_exchange_weak_f64(dst, expected, desired)     ma_atomic_compare_exchange_weak_explicit_f64(dst, expected, desired, ma_atomic_memory_order_seq_cst, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_add_f32(dst, src)                               ma_atomic_fetch_add_explicit_f32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_add_f64(dst, src)                               ma_atomic_fetch_add_explicit_f64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_sub_f32(dst, src)                               ma_atomic_fetch_sub_explicit_f32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_sub_f64(dst, src)                               ma_atomic_fetch_sub_explicit_f64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_or_f32(dst, src)                                ma_atomic_fetch_or_explicit_f32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_or_f64(dst, src)                                ma_atomic_fetch_or_explicit_f64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_xor_f32(dst, src)                               ma_atomic_fetch_xor_explicit_f32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_xor_f64(dst, src)                               ma_atomic_fetch_xor_explicit_f64(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_and_f32(dst, src)                               ma_atomic_fetch_and_explicit_f32(dst, src, ma_atomic_memory_order_seq_cst)
#define ma_atomic_fetch_and_f64(dst, src)                               ma_atomic_fetch_and_explicit_f64(dst, src, ma_atomic_memory_order_seq_cst)
static MA_INLINE float ma_atomic_compare_and_swap_f32(volatile float* dst, float expected, float desired)
{
    ma_atomic_if32 r;
    ma_atomic_if32 e, d;
    e.f = expected;
    d.f = desired;
    r.i = ma_atomic_compare_and_swap_32((volatile ma_uint32*)dst, e.i, d.i);
    return r.f;
}
static MA_INLINE double ma_atomic_compare_and_swap_f64(volatile double* dst, double expected, double desired)
{
    ma_atomic_if64 r;
    ma_atomic_if64 e, d;
    e.f = expected;
    d.f = desired;
    r.i = ma_atomic_compare_and_swap_64((volatile ma_uint64*)dst, e.i, d.i);
    return r.f;
}
typedef ma_atomic_flag ma_atomic_spinlock;
static MA_INLINE void ma_atomic_spinlock_lock(volatile ma_atomic_spinlock* pSpinlock)
{
    for (;;) {
        if (ma_atomic_flag_test_and_set_explicit(pSpinlock, ma_atomic_memory_order_acquire) == 0) {
            break;
        }
        while (ma_atomic_flag_load_explicit(pSpinlock, ma_atomic_memory_order_relaxed) == 1) {
        }
    }
}
static MA_INLINE void ma_atomic_spinlock_unlock(volatile ma_atomic_spinlock* pSpinlock)
{
    ma_atomic_flag_clear_explicit(pSpinlock, ma_atomic_memory_order_release);
}
#if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)))
    #pragma GCC diagnostic pop
#endif
#if defined(__cplusplus)
}
#endif
#endif
/* c89atomic.h end */

#define MA_ATOMIC_SAFE_TYPE_IMPL(c89TypeExtension, type) \
    static MA_INLINE ma_##type ma_atomic_##type##_get(ma_atomic_##type* x) \
    { \
        return (ma_##type)ma_atomic_load_##c89TypeExtension(&x->value); \
    } \
    static MA_INLINE void ma_atomic_##type##_set(ma_atomic_##type* x, ma_##type value) \
    { \
        ma_atomic_store_##c89TypeExtension(&x->value, value); \
    } \
    static MA_INLINE ma_##type ma_atomic_##type##_exchange(ma_atomic_##type* x, ma_##type value) \
    { \
        return (ma_##type)ma_atomic_exchange_##c89TypeExtension(&x->value, value); \
    } \
    static MA_INLINE ma_bool32 ma_atomic_##type##_compare_exchange(ma_atomic_##type* x, ma_##type* expected, ma_##type desired) \
    { \
        return ma_atomic_compare_exchange_weak_##c89TypeExtension(&x->value, expected, desired); \
    } \
    static MA_INLINE ma_##type ma_atomic_##type##_fetch_add(ma_atomic_##type* x, ma_##type y) \
    { \
        return (ma_##type)ma_atomic_fetch_add_##c89TypeExtension(&x->value, y); \
    } \
    static MA_INLINE ma_##type ma_atomic_##type##_fetch_sub(ma_atomic_##type* x, ma_##type y) \
    { \
        return (ma_##type)ma_atomic_fetch_sub_##c89TypeExtension(&x->value, y); \
    } \
    static MA_INLINE ma_##type ma_atomic_##type##_fetch_or(ma_atomic_##type* x, ma_##type y) \
    { \
        return (ma_##type)ma_atomic_fetch_or_##c89TypeExtension(&x->value, y); \
    } \
    static MA_INLINE ma_##type ma_atomic_##type##_fetch_xor(ma_atomic_##type* x, ma_##type y) \
    { \
        return (ma_##type)ma_atomic_fetch_xor_##c89TypeExtension(&x->value, y); \
    } \
    static MA_INLINE ma_##type ma_atomic_##type##_fetch_and(ma_atomic_##type* x, ma_##type y) \
    { \
        return (ma_##type)ma_atomic_fetch_and_##c89TypeExtension(&x->value, y); \
    } \
    static MA_INLINE ma_##type ma_atomic_##type##_compare_and_swap(ma_atomic_##type* x, ma_##type expected, ma_##type desired) \
    { \
        return (ma_##type)ma_atomic_compare_and_swap_##c89TypeExtension(&x->value, expected, desired); \
    } \

#define MA_ATOMIC_SAFE_TYPE_IMPL_PTR(type) \
    static MA_INLINE ma_##type* ma_atomic_ptr_##type##_get(ma_atomic_ptr_##type* x) \
    { \
        return ma_atomic_load_ptr((void**)&x->value); \
    } \
    static MA_INLINE void ma_atomic_ptr_##type##_set(ma_atomic_ptr_##type* x, ma_##type* value) \
    { \
        ma_atomic_store_ptr((void**)&x->value, (void*)value); \
    } \
    static MA_INLINE ma_##type* ma_atomic_ptr_##type##_exchange(ma_atomic_ptr_##type* x, ma_##type* value) \
    { \
        return ma_atomic_exchange_ptr((void**)&x->value, (void*)value); \
    } \
    static MA_INLINE ma_bool32 ma_atomic_ptr_##type##_compare_exchange(ma_atomic_ptr_##type* x, ma_##type** expected, ma_##type* desired) \
    { \
        return ma_atomic_compare_exchange_weak_ptr((void**)&x->value, (void*)expected, (void*)desired); \
    } \
    static MA_INLINE ma_##type* ma_atomic_ptr_##type##_compare_and_swap(ma_atomic_ptr_##type* x, ma_##type* expected, ma_##type* desired) \
    { \
        return (ma_##type*)ma_atomic_compare_and_swap_ptr((void**)&x->value, (void*)expected, (void*)desired); \
    } \

MA_ATOMIC_SAFE_TYPE_IMPL(32,  uint32)
MA_ATOMIC_SAFE_TYPE_IMPL(i32, int32)
MA_ATOMIC_SAFE_TYPE_IMPL(64,  uint64)
MA_ATOMIC_SAFE_TYPE_IMPL(f32, float)
MA_ATOMIC_SAFE_TYPE_IMPL(32,  bool32)



MA_API ma_uint64 ma_calculate_frame_count_after_resampling(ma_uint32 sampleRateOut, ma_uint32 sampleRateIn, ma_uint64 frameCountIn)
{
    /* This is based on the calculation in ma_linear_resampler_get_expected_output_frame_count(). */
    ma_uint64 outputFrameCount;
    ma_uint64 preliminaryInputFrameCountFromFrac;
    ma_uint64 preliminaryInputFrameCount;

    if (sampleRateIn == 0 || sampleRateOut == 0 || frameCountIn == 0) {
        return 0;
    }

    if (sampleRateOut == sampleRateIn) {
        return frameCountIn;
    }

    outputFrameCount = (frameCountIn * sampleRateOut) / sampleRateIn;

    preliminaryInputFrameCountFromFrac = (outputFrameCount * (sampleRateIn / sampleRateOut)) / sampleRateOut;
    preliminaryInputFrameCount         = (outputFrameCount * (sampleRateIn % sampleRateOut)) + preliminaryInputFrameCountFromFrac;

    if (preliminaryInputFrameCount <= frameCountIn) {
        outputFrameCount += 1;
    }

    return outputFrameCount;
}

#ifndef MA_DATA_CONVERTER_STACK_BUFFER_SIZE
#define MA_DATA_CONVERTER_STACK_BUFFER_SIZE     4096
#endif



#if defined(MA_WIN32)
static ma_result ma_result_from_GetLastError(DWORD error)
{
    switch (error)
    {
        case ERROR_SUCCESS:             return MA_SUCCESS;
        case ERROR_PATH_NOT_FOUND:      return MA_DOES_NOT_EXIST;
        case ERROR_TOO_MANY_OPEN_FILES: return MA_TOO_MANY_OPEN_FILES;
        case ERROR_NOT_ENOUGH_MEMORY:   return MA_OUT_OF_MEMORY;
        case ERROR_DISK_FULL:           return MA_NO_SPACE;
        case ERROR_HANDLE_EOF:          return MA_AT_END;
        case ERROR_NEGATIVE_SEEK:       return MA_BAD_SEEK;
        case ERROR_INVALID_PARAMETER:   return MA_INVALID_ARGS;
        case ERROR_ACCESS_DENIED:       return MA_ACCESS_DENIED;
        case ERROR_SEM_TIMEOUT:         return MA_TIMEOUT;
        case ERROR_FILE_NOT_FOUND:      return MA_DOES_NOT_EXIST;
        default: break;
    }

    return MA_ERROR;
}
#endif  /* MA_WIN32 */


/*******************************************************************************

Threading

*******************************************************************************/
static MA_INLINE ma_result ma_spinlock_lock_ex(volatile ma_spinlock* pSpinlock, ma_bool32 yield)
{
    if (pSpinlock == NULL) {
        return MA_INVALID_ARGS;
    }

    for (;;) {
        if (ma_atomic_exchange_explicit_32(pSpinlock, 1, ma_atomic_memory_order_acquire) == 0) {
            break;
        }

        while (ma_atomic_load_explicit_32(pSpinlock, ma_atomic_memory_order_relaxed) == 1) {
            if (yield) {
                ma_yield();
            }
        }
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_spinlock_lock(volatile ma_spinlock* pSpinlock)
{
    return ma_spinlock_lock_ex(pSpinlock, MA_TRUE);
}

MA_API ma_result ma_spinlock_lock_noyield(volatile ma_spinlock* pSpinlock)
{
    return ma_spinlock_lock_ex(pSpinlock, MA_FALSE);
}

MA_API ma_result ma_spinlock_unlock(volatile ma_spinlock* pSpinlock)
{
    if (pSpinlock == NULL) {
        return MA_INVALID_ARGS;
    }

    ma_atomic_store_explicit_32(pSpinlock, 0, ma_atomic_memory_order_release);
    return MA_SUCCESS;
}


#ifndef MA_NO_THREADING
#if defined(MA_POSIX)
    #define MA_THREADCALL
    typedef void* ma_thread_result;
#elif defined(MA_WIN32)
    #define MA_THREADCALL WINAPI
    typedef unsigned long ma_thread_result;
#endif

typedef ma_thread_result (MA_THREADCALL * ma_thread_entry_proc)(void* pData);

#ifdef MA_POSIX
static ma_result ma_thread_create__posix(ma_thread* pThread, ma_thread_priority priority, size_t stackSize, ma_thread_entry_proc entryProc, void* pData)
{
    int result;
    pthread_attr_t* pAttr = NULL;

#if !defined(__EMSCRIPTEN__) && !defined(__3DS__)
    /* Try setting the thread priority. It's not critical if anything fails here. */
    pthread_attr_t attr;
    if (pthread_attr_init(&attr) == 0) {
        int scheduler = -1;

        /* We successfully initialized our attributes object so we can assign the pointer so it's passed into pthread_create(). */
        pAttr = &attr;

        /* We need to set the scheduler policy. Only do this if the OS supports pthread_attr_setschedpolicy() */
        #if !defined(MA_BEOS)
        {
            if (priority == ma_thread_priority_idle) {
            #ifdef SCHED_IDLE
                if (pthread_attr_setschedpolicy(&attr, SCHED_IDLE) == 0) {
                    scheduler = SCHED_IDLE;
                }
            #endif
            } else if (priority == ma_thread_priority_realtime) {
            #ifdef SCHED_FIFO
                if (pthread_attr_setschedpolicy(&attr, SCHED_FIFO) == 0) {
                    scheduler = SCHED_FIFO;
                }
            #endif
            #ifdef MA_LINUX
            } else {
                scheduler = sched_getscheduler(0);
            #endif
            }
        }
        #endif

        if (stackSize > 0) {
            pthread_attr_setstacksize(&attr, stackSize);
        }

        if (scheduler != -1) {
            int priorityMin = sched_get_priority_min(scheduler);
            int priorityMax = sched_get_priority_max(scheduler);
            int priorityStep = (priorityMax - priorityMin) / 7;  /* 7 = number of priorities supported by miniaudio. */

            struct sched_param sched;
            if (pthread_attr_getschedparam(&attr, &sched) == 0) {
                if (priority == ma_thread_priority_idle) {
                    sched.sched_priority = priorityMin;
                } else if (priority == ma_thread_priority_realtime) {
                    #if defined(MA_PTHREAD_REALTIME_THREAD_PRIORITY)
                    {
                        sched.sched_priority = MA_PTHREAD_REALTIME_THREAD_PRIORITY;
                    }
                    #else
                    {
                        sched.sched_priority = priorityMax;
                    }
                    #endif
                } else {
                    sched.sched_priority += ((int)priority + 5) * priorityStep;  /* +5 because the lowest priority is -5. */
                }

                if (sched.sched_priority < priorityMin) {
                    sched.sched_priority = priorityMin;
                }
                if (sched.sched_priority > priorityMax) {
                    sched.sched_priority = priorityMax;
                }

                /* I'm not treating a failure of setting the priority as a critical error so not aborting on failure here. */
                if (pthread_attr_setschedparam(&attr, &sched) == 0) {
                    #if !defined(MA_ANDROID) || (defined(__ANDROID_API__) && __ANDROID_API__ >= 28)
                    {
                        pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
                    }
                    #endif
                }
            }
        }
    }
#else
    /* It's the emscripten build. We'll have a few unused parameters. */
    (void)priority;
    (void)stackSize;
#endif

    result = pthread_create((pthread_t*)pThread, pAttr, entryProc, pData);

    /* The thread attributes object is no longer required. */
    if (pAttr != NULL) {
        pthread_attr_destroy(pAttr);
    }

    if (result != 0) {
        return ma_result_from_errno(result);
    }

    return MA_SUCCESS;
}

static void ma_thread_wait__posix(ma_thread* pThread)
{
    pthread_join((pthread_t)*pThread, NULL);
}


static ma_result ma_mutex_init__posix(ma_mutex* pMutex)
{
    int result;

    if (pMutex == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pMutex);

    result = pthread_mutex_init((pthread_mutex_t*)pMutex, NULL);
    if (result != 0) {
        return ma_result_from_errno(result);
    }

    return MA_SUCCESS;
}

static void ma_mutex_uninit__posix(ma_mutex* pMutex)
{
    pthread_mutex_destroy((pthread_mutex_t*)pMutex);
}

static void ma_mutex_lock__posix(ma_mutex* pMutex)
{
    pthread_mutex_lock((pthread_mutex_t*)pMutex);
}

static void ma_mutex_unlock__posix(ma_mutex* pMutex)
{
    pthread_mutex_unlock((pthread_mutex_t*)pMutex);
}


static ma_result ma_event_init__posix(ma_event* pEvent)
{
    int result;

    result = pthread_mutex_init((pthread_mutex_t*)&pEvent->lock, NULL);
    if (result != 0) {
        return ma_result_from_errno(result);
    }

    result = pthread_cond_init((pthread_cond_t*)&pEvent->cond, NULL);
    if (result != 0) {
        pthread_mutex_destroy((pthread_mutex_t*)&pEvent->lock);
        return ma_result_from_errno(result);
    }

    pEvent->value = 0;
    return MA_SUCCESS;
}

static void ma_event_uninit__posix(ma_event* pEvent)
{
    pthread_cond_destroy((pthread_cond_t*)&pEvent->cond);
    pthread_mutex_destroy((pthread_mutex_t*)&pEvent->lock);
}

static ma_result ma_event_wait__posix(ma_event* pEvent)
{
    pthread_mutex_lock((pthread_mutex_t*)&pEvent->lock);
    {
        while (pEvent->value == 0) {
            pthread_cond_wait((pthread_cond_t*)&pEvent->cond, (pthread_mutex_t*)&pEvent->lock);
        }
        pEvent->value = 0;  /* Auto-reset. */
    }
    pthread_mutex_unlock((pthread_mutex_t*)&pEvent->lock);

    return MA_SUCCESS;
}

static ma_result ma_event_signal__posix(ma_event* pEvent)
{
    pthread_mutex_lock((pthread_mutex_t*)&pEvent->lock);
    {
        pEvent->value = 1;
        pthread_cond_signal((pthread_cond_t*)&pEvent->cond);
    }
    pthread_mutex_unlock((pthread_mutex_t*)&pEvent->lock);

    return MA_SUCCESS;
}


static ma_result ma_semaphore_init__posix(int initialValue, ma_semaphore* pSemaphore)
{
    int result;

    if (pSemaphore == NULL) {
        return MA_INVALID_ARGS;
    }

    pSemaphore->value = initialValue;

    result = pthread_mutex_init((pthread_mutex_t*)&pSemaphore->lock, NULL);
    if (result != 0) {
        return ma_result_from_errno(result);  /* Failed to create mutex. */
    }

    result = pthread_cond_init((pthread_cond_t*)&pSemaphore->cond, NULL);
    if (result != 0) {
        pthread_mutex_destroy((pthread_mutex_t*)&pSemaphore->lock);
        return ma_result_from_errno(result);  /* Failed to create condition variable. */
    }

    return MA_SUCCESS;
}

static void ma_semaphore_uninit__posix(ma_semaphore* pSemaphore)
{
    if (pSemaphore == NULL) {
        return;
    }

    pthread_cond_destroy((pthread_cond_t*)&pSemaphore->cond);
    pthread_mutex_destroy((pthread_mutex_t*)&pSemaphore->lock);
}

static ma_result ma_semaphore_wait__posix(ma_semaphore* pSemaphore)
{
    if (pSemaphore == NULL) {
        return MA_INVALID_ARGS;
    }

    pthread_mutex_lock((pthread_mutex_t*)&pSemaphore->lock);
    {
        /* We need to wait on a condition variable before escaping. We can't return from this function until the semaphore has been signaled. */
        while (pSemaphore->value == 0) {
            pthread_cond_wait((pthread_cond_t*)&pSemaphore->cond, (pthread_mutex_t*)&pSemaphore->lock);
        }

        pSemaphore->value -= 1;
    }
    pthread_mutex_unlock((pthread_mutex_t*)&pSemaphore->lock);

    return MA_SUCCESS;
}

static ma_result ma_semaphore_release__posix(ma_semaphore* pSemaphore)
{
    if (pSemaphore == NULL) {
        return MA_INVALID_ARGS;
    }

    pthread_mutex_lock((pthread_mutex_t*)&pSemaphore->lock);
    {
        pSemaphore->value += 1;
        pthread_cond_signal((pthread_cond_t*)&pSemaphore->cond);
    }
    pthread_mutex_unlock((pthread_mutex_t*)&pSemaphore->lock);

    return MA_SUCCESS;
}
#elif defined(MA_WIN32)
static int ma_thread_priority_to_win32(ma_thread_priority priority)
{
    switch (priority) {
        case ma_thread_priority_idle:     return THREAD_PRIORITY_IDLE;
        case ma_thread_priority_lowest:   return THREAD_PRIORITY_LOWEST;
        case ma_thread_priority_low:      return THREAD_PRIORITY_BELOW_NORMAL;
        case ma_thread_priority_normal:   return THREAD_PRIORITY_NORMAL;
        case ma_thread_priority_high:     return THREAD_PRIORITY_ABOVE_NORMAL;
        case ma_thread_priority_highest:  return THREAD_PRIORITY_HIGHEST;
        case ma_thread_priority_realtime: return THREAD_PRIORITY_TIME_CRITICAL;
        default:                          return THREAD_PRIORITY_NORMAL;
    }
}

static ma_result ma_thread_create__win32(ma_thread* pThread, ma_thread_priority priority, size_t stackSize, ma_thread_entry_proc entryProc, void* pData)
{
    DWORD threadID; /* Not used. Only used for passing into CreateThread() so it doesn't fail on Windows 98. */

    *pThread = CreateThread(NULL, stackSize, entryProc, pData, 0, &threadID);
    if (*pThread == NULL) {
        return ma_result_from_GetLastError(GetLastError());
    }

    SetThreadPriority((HANDLE)*pThread, ma_thread_priority_to_win32(priority));

    return MA_SUCCESS;
}

static void ma_thread_wait__win32(ma_thread* pThread)
{
    WaitForSingleObject((HANDLE)*pThread, INFINITE);
    CloseHandle((HANDLE)*pThread);
}


static ma_result ma_mutex_init__win32(ma_mutex* pMutex)
{
    *pMutex = CreateEventA(NULL, FALSE, TRUE, NULL);
    if (*pMutex == NULL) {
        return ma_result_from_GetLastError(GetLastError());
    }

    return MA_SUCCESS;
}

static void ma_mutex_uninit__win32(ma_mutex* pMutex)
{
    CloseHandle((HANDLE)*pMutex);
}

static void ma_mutex_lock__win32(ma_mutex* pMutex)
{
    WaitForSingleObject((HANDLE)*pMutex, INFINITE);
}

static void ma_mutex_unlock__win32(ma_mutex* pMutex)
{
    SetEvent((HANDLE)*pMutex);
}


static ma_result ma_event_init__win32(ma_event* pEvent)
{
    *pEvent = CreateEventA(NULL, FALSE, FALSE, NULL);
    if (*pEvent == NULL) {
        return ma_result_from_GetLastError(GetLastError());
    }

    return MA_SUCCESS;
}

static void ma_event_uninit__win32(ma_event* pEvent)
{
    CloseHandle((HANDLE)*pEvent);
}

static ma_result ma_event_wait__win32(ma_event* pEvent)
{
    DWORD result = WaitForSingleObject((HANDLE)*pEvent, INFINITE);
    if (result == WAIT_OBJECT_0) {
        return MA_SUCCESS;
    }

    if (result == WAIT_TIMEOUT) {
        return MA_TIMEOUT;
    }

    return ma_result_from_GetLastError(GetLastError());
}

static ma_result ma_event_signal__win32(ma_event* pEvent)
{
    BOOL result = SetEvent((HANDLE)*pEvent);
    if (result == 0) {
        return ma_result_from_GetLastError(GetLastError());
    }

    return MA_SUCCESS;
}


static ma_result ma_semaphore_init__win32(int initialValue, ma_semaphore* pSemaphore)
{
    *pSemaphore = CreateSemaphoreW(NULL, (LONG)initialValue, LONG_MAX, NULL);
    if (*pSemaphore == NULL) {
        return ma_result_from_GetLastError(GetLastError());
    }

    return MA_SUCCESS;
}

static void ma_semaphore_uninit__win32(ma_semaphore* pSemaphore)
{
    CloseHandle((HANDLE)*pSemaphore);
}

static ma_result ma_semaphore_wait__win32(ma_semaphore* pSemaphore)
{
    DWORD result = WaitForSingleObject((HANDLE)*pSemaphore, INFINITE);
    if (result == WAIT_OBJECT_0) {
        return MA_SUCCESS;
    }

    if (result == WAIT_TIMEOUT) {
        return MA_TIMEOUT;
    }

    return ma_result_from_GetLastError(GetLastError());
}

static ma_result ma_semaphore_release__win32(ma_semaphore* pSemaphore)
{
    BOOL result = ReleaseSemaphore((HANDLE)*pSemaphore, 1, NULL);
    if (result == 0) {
        return ma_result_from_GetLastError(GetLastError());
    }

    return MA_SUCCESS;
}
#endif

typedef struct
{
    ma_thread_entry_proc entryProc;
    void* pData;
    ma_allocation_callbacks allocationCallbacks;
} ma_thread_proxy_data;

static ma_thread_result MA_THREADCALL ma_thread_entry_proxy(void* pData)
{
    ma_thread_proxy_data* pProxyData = (ma_thread_proxy_data*)pData;
    ma_thread_entry_proc entryProc;
    void* pEntryProcData;
    ma_thread_result result;

    #if defined(MA_ON_THREAD_ENTRY)
        MA_ON_THREAD_ENTRY
    #endif

    entryProc = pProxyData->entryProc;
    pEntryProcData = pProxyData->pData;

    /* Free the proxy data before getting into the real thread entry proc. */
    ma_free(pProxyData, &pProxyData->allocationCallbacks);

    result = entryProc(pEntryProcData);

    #if defined(MA_ON_THREAD_EXIT)
        MA_ON_THREAD_EXIT
    #endif

    return result;
}

static ma_result ma_thread_create(ma_thread* pThread, ma_thread_priority priority, size_t stackSize, ma_thread_entry_proc entryProc, void* pData, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_result result;
    ma_thread_proxy_data* pProxyData;

    if (pThread == NULL || entryProc == NULL) {
        return MA_INVALID_ARGS;
    }

    pProxyData = (ma_thread_proxy_data*)ma_malloc(sizeof(*pProxyData), pAllocationCallbacks);   /* Will be freed by the proxy entry proc. */
    if (pProxyData == NULL) {
        return MA_OUT_OF_MEMORY;
    }

#if defined(MA_THREAD_DEFAULT_STACK_SIZE)
    if (stackSize == 0) {
        stackSize = MA_THREAD_DEFAULT_STACK_SIZE;
    }
#endif

    pProxyData->entryProc = entryProc;
    pProxyData->pData     = pData;
    ma_allocation_callbacks_init_copy(&pProxyData->allocationCallbacks, pAllocationCallbacks);

#if defined(MA_POSIX)
    result = ma_thread_create__posix(pThread, priority, stackSize, ma_thread_entry_proxy, pProxyData);
#elif defined(MA_WIN32)
    result = ma_thread_create__win32(pThread, priority, stackSize, ma_thread_entry_proxy, pProxyData);
#endif

    if (result != MA_SUCCESS) {
        ma_free(pProxyData, pAllocationCallbacks);
        return result;
    }

    return MA_SUCCESS;
}

static void ma_thread_wait(ma_thread* pThread)
{
    if (pThread == NULL) {
        return;
    }

#if defined(MA_POSIX)
    ma_thread_wait__posix(pThread);
#elif defined(MA_WIN32)
    ma_thread_wait__win32(pThread);
#endif
}


MA_API ma_result ma_mutex_init(ma_mutex* pMutex)
{
    if (pMutex == NULL) {
        MA_ASSERT(MA_FALSE);    /* Fire an assert so the caller is aware of this bug. */
        return MA_INVALID_ARGS;
    }

#if defined(MA_POSIX)
    return ma_mutex_init__posix(pMutex);
#elif defined(MA_WIN32)
    return ma_mutex_init__win32(pMutex);
#endif
}

MA_API void ma_mutex_uninit(ma_mutex* pMutex)
{
    if (pMutex == NULL) {
        return;
    }

#if defined(MA_POSIX)
    ma_mutex_uninit__posix(pMutex);
#elif defined(MA_WIN32)
    ma_mutex_uninit__win32(pMutex);
#endif
}

MA_API void ma_mutex_lock(ma_mutex* pMutex)
{
    if (pMutex == NULL) {
        MA_ASSERT(MA_FALSE);    /* Fire an assert so the caller is aware of this bug. */
        return;
    }

#if defined(MA_POSIX)
    ma_mutex_lock__posix(pMutex);
#elif defined(MA_WIN32)
    ma_mutex_lock__win32(pMutex);
#endif
}

MA_API void ma_mutex_unlock(ma_mutex* pMutex)
{
    if (pMutex == NULL) {
        MA_ASSERT(MA_FALSE);    /* Fire an assert so the caller is aware of this bug. */
        return;
    }

#if defined(MA_POSIX)
    ma_mutex_unlock__posix(pMutex);
#elif defined(MA_WIN32)
    ma_mutex_unlock__win32(pMutex);
#endif
}


MA_API ma_result ma_event_init(ma_event* pEvent)
{
    if (pEvent == NULL) {
        MA_ASSERT(MA_FALSE);    /* Fire an assert so the caller is aware of this bug. */
        return MA_INVALID_ARGS;
    }

#if defined(MA_POSIX)
    return ma_event_init__posix(pEvent);
#elif defined(MA_WIN32)
    return ma_event_init__win32(pEvent);
#endif
}

#if 0
static ma_result ma_event_alloc_and_init(ma_event** ppEvent, ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_result result;
    ma_event* pEvent;

    if (ppEvent == NULL) {
        return MA_INVALID_ARGS;
    }

    *ppEvent = NULL;

    pEvent = ma_malloc(sizeof(*pEvent), pAllocationCallbacks);
    if (pEvent == NULL) {
        return MA_OUT_OF_MEMORY;
    }

    result = ma_event_init(pEvent);
    if (result != MA_SUCCESS) {
        ma_free(pEvent, pAllocationCallbacks);
        return result;
    }

    *ppEvent = pEvent;
    return result;
}
#endif

MA_API void ma_event_uninit(ma_event* pEvent)
{
    if (pEvent == NULL) {
        return;
    }

#if defined(MA_POSIX)
    ma_event_uninit__posix(pEvent);
#elif defined(MA_WIN32)
    ma_event_uninit__win32(pEvent);
#endif
}

#if 0
static void ma_event_uninit_and_free(ma_event* pEvent, ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pEvent == NULL) {
        return;
    }

    ma_event_uninit(pEvent);
    ma_free(pEvent, pAllocationCallbacks);
}
#endif

MA_API ma_result ma_event_wait(ma_event* pEvent)
{
    if (pEvent == NULL) {
        MA_ASSERT(MA_FALSE);    /* Fire an assert to the caller is aware of this bug. */
        return MA_INVALID_ARGS;
    }

#if defined(MA_POSIX)
    return ma_event_wait__posix(pEvent);
#elif defined(MA_WIN32)
    return ma_event_wait__win32(pEvent);
#endif
}

MA_API ma_result ma_event_signal(ma_event* pEvent)
{
    if (pEvent == NULL) {
        MA_ASSERT(MA_FALSE);    /* Fire an assert to the caller is aware of this bug. */
        return MA_INVALID_ARGS;
    }

#if defined(MA_POSIX)
    return ma_event_signal__posix(pEvent);
#elif defined(MA_WIN32)
    return ma_event_signal__win32(pEvent);
#endif
}


MA_API ma_result ma_semaphore_init(int initialValue, ma_semaphore* pSemaphore)
{
    if (pSemaphore == NULL) {
        MA_ASSERT(MA_FALSE);    /* Fire an assert so the caller is aware of this bug. */
        return MA_INVALID_ARGS;
    }

#if defined(MA_POSIX)
    return ma_semaphore_init__posix(initialValue, pSemaphore);
#elif defined(MA_WIN32)
    return ma_semaphore_init__win32(initialValue, pSemaphore);
#endif
}

MA_API void ma_semaphore_uninit(ma_semaphore* pSemaphore)
{
    if (pSemaphore == NULL) {
        MA_ASSERT(MA_FALSE);    /* Fire an assert so the caller is aware of this bug. */
        return;
    }

#if defined(MA_POSIX)
    ma_semaphore_uninit__posix(pSemaphore);
#elif defined(MA_WIN32)
    ma_semaphore_uninit__win32(pSemaphore);
#endif
}

MA_API ma_result ma_semaphore_wait(ma_semaphore* pSemaphore)
{
    if (pSemaphore == NULL) {
        MA_ASSERT(MA_FALSE);    /* Fire an assert so the caller is aware of this bug. */
        return MA_INVALID_ARGS;
    }

#if defined(MA_POSIX)
    return ma_semaphore_wait__posix(pSemaphore);
#elif defined(MA_WIN32)
    return ma_semaphore_wait__win32(pSemaphore);
#endif
}

MA_API ma_result ma_semaphore_release(ma_semaphore* pSemaphore)
{
    if (pSemaphore == NULL) {
        MA_ASSERT(MA_FALSE);    /* Fire an assert so the caller is aware of this bug. */
        return MA_INVALID_ARGS;
    }

#if defined(MA_POSIX)
    return ma_semaphore_release__posix(pSemaphore);
#elif defined(MA_WIN32)
    return ma_semaphore_release__win32(pSemaphore);
#endif
}
#else
/* MA_NO_THREADING is set which means threading is disabled. Threading is required by some API families. If any of these are enabled we need to throw an error. */
#endif  /* MA_NO_THREADING */



#define MA_FENCE_COUNTER_MAX    0x7FFFFFFF

MA_API ma_result ma_fence_init(ma_fence* pFence)
{
    if (pFence == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pFence);
    pFence->counter = 0;

    #ifndef MA_NO_THREADING
    {
        ma_result result;

        result = ma_event_init(&pFence->e);
        if (result != MA_SUCCESS) {
            return result;
        }
    }
    #endif

    return MA_SUCCESS;
}

MA_API void ma_fence_uninit(ma_fence* pFence)
{
    if (pFence == NULL) {
        return;
    }

    #ifndef MA_NO_THREADING
    {
        ma_event_uninit(&pFence->e);
    }
    #endif

    MA_ZERO_OBJECT(pFence);
}

MA_API ma_result ma_fence_acquire(ma_fence* pFence)
{
    if (pFence == NULL) {
        return MA_INVALID_ARGS;
    }

    for (;;) {
        ma_uint32 oldCounter = ma_atomic_load_32(&pFence->counter);
        ma_uint32 newCounter = oldCounter + 1;

        /* Make sure we're not about to exceed our maximum value. */
        if (newCounter > MA_FENCE_COUNTER_MAX) {
            MA_ASSERT(MA_FALSE);
            return MA_OUT_OF_RANGE;
        }

        if (ma_atomic_compare_exchange_weak_32(&pFence->counter, &oldCounter, newCounter)) {
            return MA_SUCCESS;
        } else {
            if (oldCounter == MA_FENCE_COUNTER_MAX) {
                MA_ASSERT(MA_FALSE);
                return MA_OUT_OF_RANGE; /* The other thread took the last available slot. Abort. */
            }
        }
    }

    /* Should never get here. */
    /*return MA_SUCCESS;*/
}

MA_API ma_result ma_fence_release(ma_fence* pFence)
{
    if (pFence == NULL) {
        return MA_INVALID_ARGS;
    }

    for (;;) {
        ma_uint32 oldCounter = ma_atomic_load_32(&pFence->counter);
        ma_uint32 newCounter = oldCounter - 1;

        if (oldCounter == 0) {
            MA_ASSERT(MA_FALSE);
            return MA_INVALID_OPERATION;    /* Acquire/release mismatch. */
        }

        if (ma_atomic_compare_exchange_weak_32(&pFence->counter, &oldCounter, newCounter)) {
            #ifndef MA_NO_THREADING
            {
                if (newCounter == 0) {
                    ma_event_signal(&pFence->e);    /* <-- ma_fence_wait() will be waiting on this. */
                }
            }
            #endif

            return MA_SUCCESS;
        } else {
            if (oldCounter == 0) {
                MA_ASSERT(MA_FALSE);
                return MA_INVALID_OPERATION;    /* Another thread has taken the 0 slot. Acquire/release mismatch. */
            }
        }
    }

    /* Should never get here. */
    /*return MA_SUCCESS;*/
}

MA_API ma_result ma_fence_wait(ma_fence* pFence)
{
    if (pFence == NULL) {
        return MA_INVALID_ARGS;
    }

    for (;;) {
        ma_uint32 counter;

        counter = ma_atomic_load_32(&pFence->counter);
        if (counter == 0) {
            /*
            Counter has hit zero. By the time we get here some other thread may have acquired the
            fence again, but that is where the caller needs to take care with how they se the fence.
            */
            return MA_SUCCESS;
        }

        /* Getting here means the counter is > 0. We'll need to wait for something to happen. */
        #ifndef MA_NO_THREADING
        {
            ma_result result;

            result = ma_event_wait(&pFence->e);
            if (result != MA_SUCCESS) {
                return result;
            }
        }
        #endif
    }

    /* Should never get here. */
    /*return MA_INVALID_OPERATION;*/
}


MA_API ma_result ma_async_notification_signal(ma_async_notification* pNotification)
{
    ma_async_notification_callbacks* pNotificationCallbacks = (ma_async_notification_callbacks*)pNotification;

    if (pNotification == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pNotificationCallbacks->onSignal == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    pNotificationCallbacks->onSignal(pNotification);
    return MA_INVALID_ARGS;
}


static void ma_async_notification_poll__on_signal(ma_async_notification* pNotification)
{
    ((ma_async_notification_poll*)pNotification)->signalled = MA_TRUE;
}

MA_API ma_result ma_async_notification_poll_init(ma_async_notification_poll* pNotificationPoll)
{
    if (pNotificationPoll == NULL) {
        return MA_INVALID_ARGS;
    }

    pNotificationPoll->cb.onSignal = ma_async_notification_poll__on_signal;
    pNotificationPoll->signalled = MA_FALSE;

    return MA_SUCCESS;
}

MA_API ma_bool32 ma_async_notification_poll_is_signalled(const ma_async_notification_poll* pNotificationPoll)
{
    if (pNotificationPoll == NULL) {
        return MA_FALSE;
    }

    return pNotificationPoll->signalled;
}


static void ma_async_notification_event__on_signal(ma_async_notification* pNotification)
{
    ma_async_notification_event_signal((ma_async_notification_event*)pNotification);
}

MA_API ma_result ma_async_notification_event_init(ma_async_notification_event* pNotificationEvent)
{
    if (pNotificationEvent == NULL) {
        return MA_INVALID_ARGS;
    }

    pNotificationEvent->cb.onSignal = ma_async_notification_event__on_signal;

    #ifndef MA_NO_THREADING
    {
        ma_result result;

        result = ma_event_init(&pNotificationEvent->e);
        if (result != MA_SUCCESS) {
            return result;
        }

        return MA_SUCCESS;
    }
    #else
    {
        return MA_NOT_IMPLEMENTED;  /* Threading is disabled. */
    }
    #endif
}

MA_API ma_result ma_async_notification_event_uninit(ma_async_notification_event* pNotificationEvent)
{
    if (pNotificationEvent == NULL) {
        return MA_INVALID_ARGS;
    }

    #ifndef MA_NO_THREADING
    {
        ma_event_uninit(&pNotificationEvent->e);
        return MA_SUCCESS;
    }
    #else
    {
        return MA_NOT_IMPLEMENTED;  /* Threading is disabled. */
    }
    #endif
}

MA_API ma_result ma_async_notification_event_wait(ma_async_notification_event* pNotificationEvent)
{
    if (pNotificationEvent == NULL) {
        return MA_INVALID_ARGS;
    }

    #ifndef MA_NO_THREADING
    {
        return ma_event_wait(&pNotificationEvent->e);
    }
    #else
    {
        return MA_NOT_IMPLEMENTED;  /* Threading is disabled. */
    }
    #endif
}

MA_API ma_result ma_async_notification_event_signal(ma_async_notification_event* pNotificationEvent)
{
    if (pNotificationEvent == NULL) {
        return MA_INVALID_ARGS;
    }

    #ifndef MA_NO_THREADING
    {
        return ma_event_signal(&pNotificationEvent->e);
    }
    #else
    {
        return MA_NOT_IMPLEMENTED;  /* Threading is disabled. */
    }
    #endif
}



/************************************************************************************************************************************************************

Job Queue

************************************************************************************************************************************************************/
MA_API ma_slot_allocator_config ma_slot_allocator_config_init(ma_uint32 capacity)
{
    ma_slot_allocator_config config;

    MA_ZERO_OBJECT(&config);
    config.capacity = capacity;

    return config;
}


static MA_INLINE ma_uint32 ma_slot_allocator_calculate_group_capacity(ma_uint32 slotCapacity)
{
    ma_uint32 cap = slotCapacity / 32;
    if ((slotCapacity % 32) != 0) {
        cap += 1;
    }

    return cap;
}

static MA_INLINE ma_uint32 ma_slot_allocator_group_capacity(const ma_slot_allocator* pAllocator)
{
    return ma_slot_allocator_calculate_group_capacity(pAllocator->capacity);
}


typedef struct
{
    size_t sizeInBytes;
    size_t groupsOffset;
    size_t slotsOffset;
} ma_slot_allocator_heap_layout;

static ma_result ma_slot_allocator_get_heap_layout(const ma_slot_allocator_config* pConfig, ma_slot_allocator_heap_layout* pHeapLayout)
{
    MA_ASSERT(pHeapLayout != NULL);

    MA_ZERO_OBJECT(pHeapLayout);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->capacity == 0) {
        return MA_INVALID_ARGS;
    }

    pHeapLayout->sizeInBytes = 0;

    /* Groups. */
    pHeapLayout->groupsOffset = pHeapLayout->sizeInBytes;
    pHeapLayout->sizeInBytes += ma_align_64(ma_slot_allocator_calculate_group_capacity(pConfig->capacity) * sizeof(ma_slot_allocator_group));

    /* Slots. */
    pHeapLayout->slotsOffset  = pHeapLayout->sizeInBytes;
    pHeapLayout->sizeInBytes += ma_align_64(pConfig->capacity * sizeof(ma_uint32));

    return MA_SUCCESS;
}

MA_API ma_result ma_slot_allocator_get_heap_size(const ma_slot_allocator_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_slot_allocator_heap_layout layout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = 0;

    result = ma_slot_allocator_get_heap_layout(pConfig, &layout);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pHeapSizeInBytes = layout.sizeInBytes;

    return result;
}

MA_API ma_result ma_slot_allocator_init_preallocated(const ma_slot_allocator_config* pConfig, void* pHeap, ma_slot_allocator* pAllocator)
{
    ma_result result;
    ma_slot_allocator_heap_layout heapLayout;

    if (pAllocator == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pAllocator);

    if (pHeap == NULL) {
        return MA_INVALID_ARGS;
    }

    result = ma_slot_allocator_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    pAllocator->_pHeap = pHeap;
    MA_ZERO_MEMORY(pHeap, heapLayout.sizeInBytes);

    pAllocator->pGroups  = (ma_slot_allocator_group*)ma_offset_ptr(pHeap, heapLayout.groupsOffset);
    pAllocator->pSlots   = (ma_uint32*)ma_offset_ptr(pHeap, heapLayout.slotsOffset);
    pAllocator->capacity = pConfig->capacity;

    return MA_SUCCESS;
}

MA_API ma_result ma_slot_allocator_init(const ma_slot_allocator_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_slot_allocator* pAllocator)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_slot_allocator_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;  /* Failed to retrieve the size of the heap allocation. */
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_slot_allocator_init_preallocated(pConfig, pHeap, pAllocator);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pAllocator->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_slot_allocator_uninit(ma_slot_allocator* pAllocator, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pAllocator == NULL) {
        return;
    }

    if (pAllocator->_ownsHeap) {
        ma_free(pAllocator->_pHeap, pAllocationCallbacks);
    }
}

MA_API ma_result ma_slot_allocator_alloc(ma_slot_allocator* pAllocator, ma_uint64* pSlot)
{
    ma_uint32 iAttempt;
    const ma_uint32 maxAttempts = 2;    /* The number of iterations to perform until returning MA_OUT_OF_MEMORY if no slots can be found. */

    if (pAllocator == NULL || pSlot == NULL) {
        return MA_INVALID_ARGS;
    }

    for (iAttempt = 0; iAttempt < maxAttempts; iAttempt += 1) {
        /* We need to acquire a suitable bitfield first. This is a bitfield that's got an available slot within it. */
        ma_uint32 iGroup;
        for (iGroup = 0; iGroup < ma_slot_allocator_group_capacity(pAllocator); iGroup += 1) {
            /* CAS */
            for (;;) {
                ma_uint32 oldBitfield;
                ma_uint32 newBitfield;
                ma_uint32 bitOffset;

                oldBitfield = ma_atomic_load_32(&pAllocator->pGroups[iGroup].bitfield);  /* <-- This copy must happen. The compiler must not optimize this away. */

                /* Fast check to see if anything is available. */
                if (oldBitfield == 0xFFFFFFFF) {
                    break;  /* No available bits in this bitfield. */
                }

                bitOffset = ma_ffs_32(~oldBitfield);
                MA_ASSERT(bitOffset < 32);

                newBitfield = oldBitfield | (1 << bitOffset);

                if (ma_atomic_compare_and_swap_32(&pAllocator->pGroups[iGroup].bitfield, oldBitfield, newBitfield) == oldBitfield) {
                    ma_uint32 slotIndex;

                    /* Increment the counter as soon as possible to have other threads report out-of-memory sooner than later. */
                    ma_atomic_fetch_add_32(&pAllocator->count, 1);

                    /* The slot index is required for constructing the output value. */
                    slotIndex = (iGroup << 5) + bitOffset;  /* iGroup << 5 = iGroup * 32 */
                    if (slotIndex >= pAllocator->capacity) {
                        return MA_OUT_OF_MEMORY;
                    }

                    /* Increment the reference count before constructing the output value. */
                    pAllocator->pSlots[slotIndex] += 1;

                    /* Construct the output value. */
                    *pSlot = (((ma_uint64)pAllocator->pSlots[slotIndex] << 32) | slotIndex);

                    return MA_SUCCESS;
                }
            }
        }

        /* We weren't able to find a slot. If it's because we've reached our capacity we need to return MA_OUT_OF_MEMORY. Otherwise we need to do another iteration and try again. */
        if (pAllocator->count < pAllocator->capacity) {
            ma_yield();
        } else {
            return MA_OUT_OF_MEMORY;
        }
    }

    /* We couldn't find a slot within the maximum number of attempts. */
    return MA_OUT_OF_MEMORY;
}

MA_API ma_result ma_slot_allocator_free(ma_slot_allocator* pAllocator, ma_uint64 slot)
{
    ma_uint32 iGroup;
    ma_uint32 iBit;

    if (pAllocator == NULL) {
        return MA_INVALID_ARGS;
    }

    iGroup = (ma_uint32)((slot & 0xFFFFFFFF) >> 5);   /* slot / 32 */
    iBit   = (ma_uint32)((slot & 0xFFFFFFFF) & 31);   /* slot % 32 */

    if (iGroup >= ma_slot_allocator_group_capacity(pAllocator)) {
        return MA_INVALID_ARGS;
    }

    MA_ASSERT(iBit < 32);   /* This must be true due to the logic we used to actually calculate it. */

    while (ma_atomic_load_32(&pAllocator->count) > 0) {
        /* CAS */
        ma_uint32 oldBitfield;
        ma_uint32 newBitfield;

        oldBitfield = ma_atomic_load_32(&pAllocator->pGroups[iGroup].bitfield);  /* <-- This copy must happen. The compiler must not optimize this away. */
        newBitfield = oldBitfield & ~(1 << iBit);

        /* Debugging for checking for double-frees. */
        #if defined(MA_DEBUG_OUTPUT)
        {
            if ((oldBitfield & (1 << iBit)) == 0) {
                MA_ASSERT(MA_FALSE);    /* Double free detected.*/
            }
        }
        #endif

        if (ma_atomic_compare_and_swap_32(&pAllocator->pGroups[iGroup].bitfield, oldBitfield, newBitfield) == oldBitfield) {
            ma_atomic_fetch_sub_32(&pAllocator->count, 1);
            return MA_SUCCESS;
        }
    }

    /* Getting here means there are no allocations available for freeing. */
    return MA_INVALID_OPERATION;
}


#define MA_JOB_ID_NONE      ~((ma_uint64)0)
#define MA_JOB_SLOT_NONE    (ma_uint16)(~0)

static MA_INLINE ma_uint32 ma_job_extract_refcount(ma_uint64 toc)
{
    return (ma_uint32)(toc >> 32);
}

static MA_INLINE ma_uint16 ma_job_extract_slot(ma_uint64 toc)
{
    return (ma_uint16)(toc & 0x0000FFFF);
}

static MA_INLINE ma_uint16 ma_job_extract_code(ma_uint64 toc)
{
    return (ma_uint16)((toc & 0xFFFF0000) >> 16);
}

static MA_INLINE ma_uint64 ma_job_toc_to_allocation(ma_uint64 toc)
{
    return ((ma_uint64)ma_job_extract_refcount(toc) << 32) | (ma_uint64)ma_job_extract_slot(toc);
}

static MA_INLINE ma_uint64 ma_job_set_refcount(ma_uint64 toc, ma_uint32 refcount)
{
    /* Clear the reference count first. */
    toc = toc & ~((ma_uint64)0xFFFFFFFF << 32);
    toc = toc |  ((ma_uint64)refcount   << 32);

    return toc;
}


MA_API ma_job ma_job_init(ma_uint16 code)
{
    ma_job job;

    MA_ZERO_OBJECT(&job);
    job.toc.breakup.code = code;
    job.toc.breakup.slot = MA_JOB_SLOT_NONE;    /* Temp value. Will be allocated when posted to a queue. */
    job.next             = MA_JOB_ID_NONE;

    return job;
}


static ma_result ma_job_process__noop(ma_job* pJob);
static ma_result ma_job_process__quit(ma_job* pJob);
static ma_result ma_job_process__custom(ma_job* pJob);
static ma_result ma_job_process__resource_manager__load_data_buffer_node(ma_job* pJob);
static ma_result ma_job_process__resource_manager__free_data_buffer_node(ma_job* pJob);
static ma_result ma_job_process__resource_manager__page_data_buffer_node(ma_job* pJob);
static ma_result ma_job_process__resource_manager__load_data_buffer(ma_job* pJob);
static ma_result ma_job_process__resource_manager__free_data_buffer(ma_job* pJob);
static ma_result ma_job_process__resource_manager__load_data_stream(ma_job* pJob);
static ma_result ma_job_process__resource_manager__free_data_stream(ma_job* pJob);
static ma_result ma_job_process__resource_manager__page_data_stream(ma_job* pJob);
static ma_result ma_job_process__resource_manager__seek_data_stream(ma_job* pJob);


static ma_job_proc g_jobVTable[MA_JOB_TYPE_COUNT] =
{
    /* Miscellaneous. */
    ma_job_process__quit,                                       /* MA_JOB_TYPE_QUIT */
    ma_job_process__custom,                                     /* MA_JOB_TYPE_CUSTOM */

    /* Resource Manager. */
    ma_job_process__resource_manager__load_data_buffer_node,    /* MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_BUFFER_NODE */
    ma_job_process__resource_manager__free_data_buffer_node,    /* MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_BUFFER_NODE */
    ma_job_process__resource_manager__page_data_buffer_node,    /* MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_BUFFER_NODE */
    ma_job_process__resource_manager__load_data_buffer,         /* MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_BUFFER */
    ma_job_process__resource_manager__free_data_buffer,         /* MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_BUFFER */
    ma_job_process__resource_manager__load_data_stream,         /* MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_STREAM */
    ma_job_process__resource_manager__free_data_stream,         /* MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_STREAM */
    ma_job_process__resource_manager__page_data_stream,         /* MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_STREAM */
    ma_job_process__resource_manager__seek_data_stream,         /* MA_JOB_TYPE_RESOURCE_MANAGER_SEEK_DATA_STREAM */

    /* Device. */
};

MA_API ma_result ma_job_process(ma_job* pJob)
{
    if (pJob == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pJob->toc.breakup.code >= MA_JOB_TYPE_COUNT) {
        return MA_INVALID_OPERATION;
    }

    return g_jobVTable[pJob->toc.breakup.code](pJob);
}

static ma_result ma_job_process__noop(ma_job* pJob)
{
    MA_ASSERT(pJob != NULL);

    /* No-op. */
    (void)pJob;

    return MA_SUCCESS;
}

static ma_result ma_job_process__quit(ma_job* pJob)
{
    return ma_job_process__noop(pJob);
}

static ma_result ma_job_process__custom(ma_job* pJob)
{
    MA_ASSERT(pJob != NULL);

    /* No-op if there's no callback. */
    if (pJob->data.custom.proc == NULL) {
        return MA_SUCCESS;
    }

    return pJob->data.custom.proc(pJob);
}



MA_API ma_job_queue_config ma_job_queue_config_init(ma_uint32 flags, ma_uint32 capacity)
{
    ma_job_queue_config config;

    config.flags    = flags;
    config.capacity = capacity;

    return config;
}


typedef struct
{
    size_t sizeInBytes;
    size_t allocatorOffset;
    size_t jobsOffset;
} ma_job_queue_heap_layout;

static ma_result ma_job_queue_get_heap_layout(const ma_job_queue_config* pConfig, ma_job_queue_heap_layout* pHeapLayout)
{
    ma_result result;

    MA_ASSERT(pHeapLayout != NULL);

    MA_ZERO_OBJECT(pHeapLayout);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->capacity == 0) {
        return MA_INVALID_ARGS;
    }

    pHeapLayout->sizeInBytes = 0;

    /* Allocator. */
    {
        ma_slot_allocator_config allocatorConfig;
        size_t allocatorHeapSizeInBytes;

        allocatorConfig = ma_slot_allocator_config_init(pConfig->capacity);
        result = ma_slot_allocator_get_heap_size(&allocatorConfig, &allocatorHeapSizeInBytes);
        if (result != MA_SUCCESS) {
            return result;
        }

        pHeapLayout->allocatorOffset = pHeapLayout->sizeInBytes;
        pHeapLayout->sizeInBytes    += allocatorHeapSizeInBytes;
    }

    /* Jobs. */
    pHeapLayout->jobsOffset   = pHeapLayout->sizeInBytes;
    pHeapLayout->sizeInBytes += ma_align_64(pConfig->capacity * sizeof(ma_job));

    return MA_SUCCESS;
}

MA_API ma_result ma_job_queue_get_heap_size(const ma_job_queue_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_job_queue_heap_layout layout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = 0;

    result = ma_job_queue_get_heap_layout(pConfig, &layout);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pHeapSizeInBytes = layout.sizeInBytes;

    return MA_SUCCESS;
}

MA_API ma_result ma_job_queue_init_preallocated(const ma_job_queue_config* pConfig, void* pHeap, ma_job_queue* pQueue)
{
    ma_result result;
    ma_job_queue_heap_layout heapLayout;
    ma_slot_allocator_config allocatorConfig;

    if (pQueue == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pQueue);

    result = ma_job_queue_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    pQueue->_pHeap = pHeap;
    MA_ZERO_MEMORY(pHeap, heapLayout.sizeInBytes);

    pQueue->flags    = pConfig->flags;
    pQueue->capacity = pConfig->capacity;
    pQueue->pJobs    = (ma_job*)ma_offset_ptr(pHeap, heapLayout.jobsOffset);

    allocatorConfig = ma_slot_allocator_config_init(pConfig->capacity);
    result = ma_slot_allocator_init_preallocated(&allocatorConfig, ma_offset_ptr(pHeap, heapLayout.allocatorOffset), &pQueue->allocator);
    if (result != MA_SUCCESS) {
        return result;
    }

    /* We need a semaphore if we're running in non-blocking mode. If threading is disabled we need to return an error. */
    if ((pQueue->flags & MA_JOB_QUEUE_FLAG_NON_BLOCKING) == 0) {
        #ifndef MA_NO_THREADING
        {
            ma_semaphore_init(0, &pQueue->sem);
        }
        #else
        {
            /* Threading is disabled and we've requested non-blocking mode. */
            return MA_INVALID_OPERATION;
        }
        #endif
    }

    /*
    Our queue needs to be initialized with a free standing node. This should always be slot 0. Required for the lock free algorithm. The first job in the queue is
    just a dummy item for giving us the first item in the list which is stored in the "next" member.
    */
    ma_slot_allocator_alloc(&pQueue->allocator, &pQueue->head);  /* Will never fail. */
    pQueue->pJobs[ma_job_extract_slot(pQueue->head)].next = MA_JOB_ID_NONE;
    pQueue->tail = pQueue->head;

    return MA_SUCCESS;
}

MA_API ma_result ma_job_queue_init(const ma_job_queue_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_job_queue* pQueue)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_job_queue_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_job_queue_init_preallocated(pConfig, pHeap, pQueue);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pQueue->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_job_queue_uninit(ma_job_queue* pQueue, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pQueue == NULL) {
        return;
    }

    /* All we need to do is uninitialize the semaphore. */
    if ((pQueue->flags & MA_JOB_QUEUE_FLAG_NON_BLOCKING) == 0) {
        #ifndef MA_NO_THREADING
        {
            ma_semaphore_uninit(&pQueue->sem);
        }
        #else
        {
            MA_ASSERT(MA_FALSE);    /* Should never get here. Should have been checked at initialization time. */
        }
        #endif
    }

    ma_slot_allocator_uninit(&pQueue->allocator, pAllocationCallbacks);

    if (pQueue->_ownsHeap) {
        ma_free(pQueue->_pHeap, pAllocationCallbacks);
    }
}

static ma_bool32 ma_job_queue_cas(volatile ma_uint64* dst, ma_uint64 expected, ma_uint64 desired)
{
    /* The new counter is taken from the expected value. */
    return ma_atomic_compare_and_swap_64(dst, expected, ma_job_set_refcount(desired, ma_job_extract_refcount(expected) + 1)) == expected;
}

MA_API ma_result ma_job_queue_post(ma_job_queue* pQueue, const ma_job* pJob)
{
    /*
    Lock free queue implementation based on the paper by Michael and Scott: Nonblocking Algorithms and Preemption-Safe Locking on Multiprogrammed Shared Memory Multiprocessors
    */
    ma_result result;
    ma_uint64 slot;
    ma_uint64 tail;
    ma_uint64 next;

    if (pQueue == NULL || pJob == NULL) {
        return MA_INVALID_ARGS;
    }

    /* We need a new slot. */
    result = ma_slot_allocator_alloc(&pQueue->allocator, &slot);
    if (result != MA_SUCCESS) {
        return result;  /* Probably ran out of slots. If so, MA_OUT_OF_MEMORY will be returned. */
    }

    /* At this point we should have a slot to place the job. */
    MA_ASSERT(ma_job_extract_slot(slot) < pQueue->capacity);

    /* We need to put the job into memory before we do anything. */
    pQueue->pJobs[ma_job_extract_slot(slot)]                  = *pJob;
    pQueue->pJobs[ma_job_extract_slot(slot)].toc.allocation   = slot;                    /* This will overwrite the job code. */
    pQueue->pJobs[ma_job_extract_slot(slot)].toc.breakup.code = pJob->toc.breakup.code;  /* The job code needs to be applied again because the line above overwrote it. */
    pQueue->pJobs[ma_job_extract_slot(slot)].next             = MA_JOB_ID_NONE;          /* Reset for safety. */

    #ifndef MA_USE_EXPERIMENTAL_LOCK_FREE_JOB_QUEUE
    ma_spinlock_lock(&pQueue->lock);
    #endif
    {
        /* The job is stored in memory so now we need to add it to our linked list. We only ever add items to the end of the list. */
        for (;;) {
            tail = ma_atomic_load_64(&pQueue->tail);
            next = ma_atomic_load_64(&pQueue->pJobs[ma_job_extract_slot(tail)].next);

            if (ma_job_toc_to_allocation(tail) == ma_job_toc_to_allocation(ma_atomic_load_64(&pQueue->tail))) {
                if (ma_job_extract_slot(next) == 0xFFFF) {
                    if (ma_job_queue_cas(&pQueue->pJobs[ma_job_extract_slot(tail)].next, next, slot)) {
                        break;
                    }
                } else {
                    ma_job_queue_cas(&pQueue->tail, tail, ma_job_extract_slot(next));
                }
            }
        }
        ma_job_queue_cas(&pQueue->tail, tail, slot);
    }
    #ifndef MA_USE_EXPERIMENTAL_LOCK_FREE_JOB_QUEUE
    ma_spinlock_unlock(&pQueue->lock);
    #endif


    /* Signal the semaphore as the last step if we're using synchronous mode. */
    if ((pQueue->flags & MA_JOB_QUEUE_FLAG_NON_BLOCKING) == 0) {
        #ifndef MA_NO_THREADING
        {
            ma_semaphore_release(&pQueue->sem);
        }
        #else
        {
            MA_ASSERT(MA_FALSE);    /* Should never get here. Should have been checked at initialization time. */
        }
        #endif
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_job_queue_next(ma_job_queue* pQueue, ma_job* pJob)
{
    ma_uint64 head;
    ma_uint64 tail;
    ma_uint64 next;

    if (pQueue == NULL || pJob == NULL) {
        return MA_INVALID_ARGS;
    }

    /* If we're running in synchronous mode we'll need to wait on a semaphore. */
    if ((pQueue->flags & MA_JOB_QUEUE_FLAG_NON_BLOCKING) == 0) {
        #ifndef MA_NO_THREADING
        {
            ma_semaphore_wait(&pQueue->sem);
        }
        #else
        {
            MA_ASSERT(MA_FALSE);    /* Should never get here. Should have been checked at initialization time. */
        }
        #endif
    }

    #ifndef MA_USE_EXPERIMENTAL_LOCK_FREE_JOB_QUEUE
    ma_spinlock_lock(&pQueue->lock);
    #endif
    {
        /*
        BUG: In lock-free mode, multiple threads can be in this section of code. The "head" variable in the loop below
        is stored. One thread can fall through to the freeing of this item while another is still using "head" for the
        retrieval of the "next" variable.

        The slot allocator might need to make use of some reference counting to ensure it's only truly freed when
        there are no more references to the item. This must be fixed before removing these locks.
        */

        /* Now we need to remove the root item from the list. */
        for (;;) {
            head = ma_atomic_load_64(&pQueue->head);
            tail = ma_atomic_load_64(&pQueue->tail);
            next = ma_atomic_load_64(&pQueue->pJobs[ma_job_extract_slot(head)].next);

            if (ma_job_toc_to_allocation(head) == ma_job_toc_to_allocation(ma_atomic_load_64(&pQueue->head))) {
                if (ma_job_extract_slot(head) == ma_job_extract_slot(tail)) {
                    if (ma_job_extract_slot(next) == 0xFFFF) {
                        #ifndef MA_USE_EXPERIMENTAL_LOCK_FREE_JOB_QUEUE
                        ma_spinlock_unlock(&pQueue->lock);
                        #endif
                        return MA_NO_DATA_AVAILABLE;
                    }
                    ma_job_queue_cas(&pQueue->tail, tail, ma_job_extract_slot(next));
                } else {
                    *pJob = pQueue->pJobs[ma_job_extract_slot(next)];
                    if (ma_job_queue_cas(&pQueue->head, head, ma_job_extract_slot(next))) {
                        break;
                    }
                }
            }
        }
    }
    #ifndef MA_USE_EXPERIMENTAL_LOCK_FREE_JOB_QUEUE
    ma_spinlock_unlock(&pQueue->lock);
    #endif

    ma_slot_allocator_free(&pQueue->allocator, head);

    /*
    If it's a quit job make sure it's put back on the queue to ensure other threads have an opportunity to detect it and terminate naturally. We
    could instead just leave it on the queue, but that would involve fiddling with the lock-free code above and I want to keep that as simple as
    possible.
    */
    if (pJob->toc.breakup.code == MA_JOB_TYPE_QUIT) {
        ma_job_queue_post(pQueue, pJob);
        return MA_CANCELLED;    /* Return a cancelled status just in case the thread is checking return codes and not properly checking for a quit job. */
    }

    return MA_SUCCESS;
}



/*******************************************************************************

Dynamic Linking

*******************************************************************************/
#ifdef MA_POSIX
    /* No need for dlfcn.h if we're not using runtime linking. */
    #ifndef MA_NO_RUNTIME_LINKING
        #include <dlfcn.h>
    #endif
#endif

MA_API ma_handle ma_dlopen(ma_log* pLog, const char* filename)
{
#ifndef MA_NO_RUNTIME_LINKING
    ma_handle handle;

    ma_log_postf(pLog, MA_LOG_LEVEL_DEBUG, "Loading library: %s\n", filename);

    #ifdef MA_WIN32
        /* From MSDN: Desktop applications cannot use LoadPackagedLibrary; if a desktop application calls this function it fails with APPMODEL_ERROR_NO_PACKAGE.*/
        #if !defined(MA_WIN32_UWP) || !(defined(WINAPI_FAMILY) && ((defined(WINAPI_FAMILY_PHONE_APP) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP)))
            handle = (ma_handle)LoadLibraryA(filename);
        #else
            /* *sigh* It appears there is no ANSI version of LoadPackagedLibrary()... */
            WCHAR filenameW[4096];
            if (MultiByteToWideChar(CP_UTF8, 0, filename, -1, filenameW, sizeof(filenameW)) == 0) {
                handle = NULL;
            } else {
                handle = (ma_handle)LoadPackagedLibrary(filenameW, 0);
            }
        #endif
    #else
        handle = (ma_handle)dlopen(filename, RTLD_NOW);
    #endif

    /*
    I'm not considering failure to load a library an error nor a warning because seamlessly falling through to a lower-priority
    backend is a deliberate design choice. Instead I'm logging it as an informational message.
    */
    if (handle == NULL) {
        ma_log_postf(pLog, MA_LOG_LEVEL_INFO, "Failed to load library: %s\n", filename);
    }

    return handle;
#else
    /* Runtime linking is disabled. */
    (void)pLog;
    (void)filename;
    return NULL;
#endif
}

MA_API void ma_dlclose(ma_log* pLog, ma_handle handle)
{
#ifndef MA_NO_RUNTIME_LINKING
    #ifdef MA_WIN32
        FreeLibrary((HMODULE)handle);
    #else
        /* Hack for Android bug (see https://github.com/android/ndk/issues/360). Calling dlclose() pre-API 28 may segfault. */
        #if !defined(MA_ANDROID) || (defined(__ANDROID_API__) && __ANDROID_API__ >= 28)
        {
            dlclose((void*)handle);
        }
        #else
        {
            (void)handle;
        }
        #endif
    #endif

    (void)pLog;
#else
    /* Runtime linking is disabled. */
    (void)pLog;
    (void)handle;
#endif
}

MA_API ma_proc ma_dlsym(ma_log* pLog, ma_handle handle, const char* symbol)
{
#ifndef MA_NO_RUNTIME_LINKING
    ma_proc proc;

    ma_log_postf(pLog, MA_LOG_LEVEL_DEBUG, "Loading symbol: %s\n", symbol);

#ifdef _WIN32
    proc = (ma_proc)GetProcAddress((HMODULE)handle, symbol);
#else
#if (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8))) || defined(__clang__)
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpedantic"
#endif
    proc = (ma_proc)dlsym((void*)handle, symbol);
#if (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8))) || defined(__clang__)
    #pragma GCC diagnostic pop
#endif
#endif

    if (proc == NULL) {
        ma_log_postf(pLog, MA_LOG_LEVEL_WARNING, "Failed to load symbol: %s\n", symbol);
    }

    (void)pLog; /* It's possible for pContext to be unused. */
    return proc;
#else
    /* Runtime linking is disabled. */
    (void)pLog;
    (void)handle;
    (void)symbol;
    return NULL;
#endif
}



/************************************************************************************************************************************************************
*************************************************************************************************************************************************************

DEVICE I/O
==========

*************************************************************************************************************************************************************
************************************************************************************************************************************************************/

/* Disable run-time linking on certain backends and platforms. */
#ifndef MA_NO_RUNTIME_LINKING
    #if defined(MA_EMSCRIPTEN) || defined(MA_ORBIS) || defined(MA_PROSPERO)
        #define MA_NO_RUNTIME_LINKING
    #endif
#endif

#ifdef MA_APPLE
    #include <AvailabilityMacros.h>
#endif



MA_API ma_uint32 ma_calculate_buffer_size_in_milliseconds_from_frames(ma_uint32 bufferSizeInFrames, ma_uint32 sampleRate)
{
    /* Prevent a division by zero. */
    if (sampleRate == 0) {
        return 0;
    }

    return (bufferSizeInFrames*1000 + (sampleRate - 1)) / sampleRate;
}

MA_API ma_uint32 ma_calculate_buffer_size_in_frames_from_milliseconds(ma_uint32 bufferSizeInMilliseconds, ma_uint32 sampleRate)
{
    /* Prevent a division by zero. */
    if (sampleRate == 0) {
        return 0;
    }

    return bufferSizeInMilliseconds*sampleRate / 1000;
}

MA_API void ma_copy_pcm_frames(void* dst, const void* src, ma_uint64 frameCount, ma_format format, ma_uint32 channels)
{
    if (dst == src) {
        return; /* No-op. */
    }

    ma_copy_memory_64(dst, src, frameCount * ma_get_bytes_per_frame(format, channels));
}

MA_API void ma_silence_pcm_frames(void* p, ma_uint64 frameCount, ma_format format, ma_uint32 channels)
{
    if (format == ma_format_u8) {
        ma_uint64 sampleCount = frameCount * channels;
        ma_uint64 iSample;
        for (iSample = 0; iSample < sampleCount; iSample += 1) {
            ((ma_uint8*)p)[iSample] = 128;
        }
    } else {
        ma_zero_memory_64(p, frameCount * ma_get_bytes_per_frame(format, channels));
    }
}

MA_API void* ma_offset_pcm_frames_ptr(void* p, ma_uint64 offsetInFrames, ma_format format, ma_uint32 channels)
{
    return ma_offset_ptr(p, offsetInFrames * ma_get_bytes_per_frame(format, channels));
}

MA_API const void* ma_offset_pcm_frames_const_ptr(const void* p, ma_uint64 offsetInFrames, ma_format format, ma_uint32 channels)
{
    return ma_offset_ptr(p, offsetInFrames * ma_get_bytes_per_frame(format, channels));
}


MA_API void ma_clip_samples_u8(ma_uint8* pDst, const ma_int16* pSrc, ma_uint64 count)
{
    ma_uint64 iSample;

    MA_ASSERT(pDst != NULL);
    MA_ASSERT(pSrc != NULL);

    for (iSample = 0; iSample < count; iSample += 1) {
        pDst[iSample] = ma_clip_u8(pSrc[iSample]);
    }
}

MA_API void ma_clip_samples_s16(ma_int16* pDst, const ma_int32* pSrc, ma_uint64 count)
{
    ma_uint64 iSample;

    MA_ASSERT(pDst != NULL);
    MA_ASSERT(pSrc != NULL);

    for (iSample = 0; iSample < count; iSample += 1) {
        pDst[iSample] = ma_clip_s16(pSrc[iSample]);
    }
}

MA_API void ma_clip_samples_s24(ma_uint8* pDst, const ma_int64* pSrc, ma_uint64 count)
{
    ma_uint64 iSample;

    MA_ASSERT(pDst != NULL);
    MA_ASSERT(pSrc != NULL);

    for (iSample = 0; iSample < count; iSample += 1) {
        ma_int64 s = ma_clip_s24(pSrc[iSample]);
        pDst[iSample*3 + 0] = (ma_uint8)((s & 0x000000FF) >>  0);
        pDst[iSample*3 + 1] = (ma_uint8)((s & 0x0000FF00) >>  8);
        pDst[iSample*3 + 2] = (ma_uint8)((s & 0x00FF0000) >> 16);
    }
}

MA_API void ma_clip_samples_s32(ma_int32* pDst, const ma_int64* pSrc, ma_uint64 count)
{
    ma_uint64 iSample;

    MA_ASSERT(pDst != NULL);
    MA_ASSERT(pSrc != NULL);

    for (iSample = 0; iSample < count; iSample += 1) {
        pDst[iSample] = ma_clip_s32(pSrc[iSample]);
    }
}

MA_API void ma_clip_samples_f32(float* pDst, const float* pSrc, ma_uint64 count)
{
    ma_uint64 iSample;

    MA_ASSERT(pDst != NULL);
    MA_ASSERT(pSrc != NULL);

    for (iSample = 0; iSample < count; iSample += 1) {
        pDst[iSample] = ma_clip_f32(pSrc[iSample]);
    }
}

MA_API void ma_clip_pcm_frames(void* pDst, const void* pSrc, ma_uint64 frameCount, ma_format format, ma_uint32 channels)
{
    ma_uint64 sampleCount;

    MA_ASSERT(pDst != NULL);
    MA_ASSERT(pSrc != NULL);

    sampleCount = frameCount * channels;

    switch (format) {
        case ma_format_u8:  ma_clip_samples_u8( (ma_uint8*)pDst, (const ma_int16*)pSrc, sampleCount); break;
        case ma_format_s16: ma_clip_samples_s16((ma_int16*)pDst, (const ma_int32*)pSrc, sampleCount); break;
        case ma_format_s24: ma_clip_samples_s24((ma_uint8*)pDst, (const ma_int64*)pSrc, sampleCount); break;
        case ma_format_s32: ma_clip_samples_s32((ma_int32*)pDst, (const ma_int64*)pSrc, sampleCount); break;
        case ma_format_f32: ma_clip_samples_f32((   float*)pDst, (const    float*)pSrc, sampleCount); break;

        /* Do nothing if we don't know the format. We're including these here to silence a compiler warning about enums not being handled by the switch. */
        case ma_format_unknown:
        case ma_format_count:
            break;
    }
}


MA_API void ma_copy_and_apply_volume_factor_u8(ma_uint8* pSamplesOut, const ma_uint8* pSamplesIn, ma_uint64 sampleCount, float factor)
{
    ma_uint64 iSample;

    if (pSamplesOut == NULL || pSamplesIn == NULL) {
        return;
    }

    for (iSample = 0; iSample < sampleCount; iSample += 1) {
        pSamplesOut[iSample] = (ma_uint8)(pSamplesIn[iSample] * factor);
    }
}

MA_API void ma_copy_and_apply_volume_factor_s16(ma_int16* pSamplesOut, const ma_int16* pSamplesIn, ma_uint64 sampleCount, float factor)
{
    ma_uint64 iSample;

    if (pSamplesOut == NULL || pSamplesIn == NULL) {
        return;
    }

    for (iSample = 0; iSample < sampleCount; iSample += 1) {
        pSamplesOut[iSample] = (ma_int16)(pSamplesIn[iSample] * factor);
    }
}

MA_API void ma_copy_and_apply_volume_factor_s24(void* pSamplesOut, const void* pSamplesIn, ma_uint64 sampleCount, float factor)
{
    ma_uint64 iSample;
    ma_uint8* pSamplesOut8;
    ma_uint8* pSamplesIn8;

    if (pSamplesOut == NULL || pSamplesIn == NULL) {
        return;
    }

    pSamplesOut8 = (ma_uint8*)pSamplesOut;
    pSamplesIn8  = (ma_uint8*)pSamplesIn;

    for (iSample = 0; iSample < sampleCount; iSample += 1) {
        ma_int32 sampleS32;

        sampleS32 = (ma_int32)(((ma_uint32)(pSamplesIn8[iSample*3+0]) << 8) | ((ma_uint32)(pSamplesIn8[iSample*3+1]) << 16) | ((ma_uint32)(pSamplesIn8[iSample*3+2])) << 24);
        sampleS32 = (ma_int32)(sampleS32 * factor);

        pSamplesOut8[iSample*3+0] = (ma_uint8)(((ma_uint32)sampleS32 & 0x0000FF00) >>  8);
        pSamplesOut8[iSample*3+1] = (ma_uint8)(((ma_uint32)sampleS32 & 0x00FF0000) >> 16);
        pSamplesOut8[iSample*3+2] = (ma_uint8)(((ma_uint32)sampleS32 & 0xFF000000) >> 24);
    }
}

MA_API void ma_copy_and_apply_volume_factor_s32(ma_int32* pSamplesOut, const ma_int32* pSamplesIn, ma_uint64 sampleCount, float factor)
{
    ma_uint64 iSample;

    if (pSamplesOut == NULL || pSamplesIn == NULL) {
        return;
    }

    for (iSample = 0; iSample < sampleCount; iSample += 1) {
        pSamplesOut[iSample] = (ma_int32)(pSamplesIn[iSample] * factor);
    }
}

MA_API void ma_copy_and_apply_volume_factor_f32(float* pSamplesOut, const float* pSamplesIn, ma_uint64 sampleCount, float factor)
{
    ma_uint64 iSample;

    if (pSamplesOut == NULL || pSamplesIn == NULL) {
        return;
    }

    if (factor == 1) {
        if (pSamplesOut == pSamplesIn) {
            /* In place. No-op. */
        } else {
            /* Just a copy. */
            for (iSample = 0; iSample < sampleCount; iSample += 1) {
                pSamplesOut[iSample] = pSamplesIn[iSample];
            }
        }
    } else {
        for (iSample = 0; iSample < sampleCount; iSample += 1) {
            pSamplesOut[iSample] = pSamplesIn[iSample] * factor;
        }
    }
}

MA_API void ma_apply_volume_factor_u8(ma_uint8* pSamples, ma_uint64 sampleCount, float factor)
{
    ma_copy_and_apply_volume_factor_u8(pSamples, pSamples, sampleCount, factor);
}

MA_API void ma_apply_volume_factor_s16(ma_int16* pSamples, ma_uint64 sampleCount, float factor)
{
    ma_copy_and_apply_volume_factor_s16(pSamples, pSamples, sampleCount, factor);
}

MA_API void ma_apply_volume_factor_s24(void* pSamples, ma_uint64 sampleCount, float factor)
{
    ma_copy_and_apply_volume_factor_s24(pSamples, pSamples, sampleCount, factor);
}

MA_API void ma_apply_volume_factor_s32(ma_int32* pSamples, ma_uint64 sampleCount, float factor)
{
    ma_copy_and_apply_volume_factor_s32(pSamples, pSamples, sampleCount, factor);
}

MA_API void ma_apply_volume_factor_f32(float* pSamples, ma_uint64 sampleCount, float factor)
{
    ma_copy_and_apply_volume_factor_f32(pSamples, pSamples, sampleCount, factor);
}

MA_API void ma_copy_and_apply_volume_factor_pcm_frames_u8(ma_uint8* pFramesOut, const ma_uint8* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float factor)
{
    ma_copy_and_apply_volume_factor_u8(pFramesOut, pFramesIn, frameCount*channels, factor);
}

MA_API void ma_copy_and_apply_volume_factor_pcm_frames_s16(ma_int16* pFramesOut, const ma_int16* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float factor)
{
    ma_copy_and_apply_volume_factor_s16(pFramesOut, pFramesIn, frameCount*channels, factor);
}

MA_API void ma_copy_and_apply_volume_factor_pcm_frames_s24(void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float factor)
{
    ma_copy_and_apply_volume_factor_s24(pFramesOut, pFramesIn, frameCount*channels, factor);
}

MA_API void ma_copy_and_apply_volume_factor_pcm_frames_s32(ma_int32* pFramesOut, const ma_int32* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float factor)
{
    ma_copy_and_apply_volume_factor_s32(pFramesOut, pFramesIn, frameCount*channels, factor);
}

MA_API void ma_copy_and_apply_volume_factor_pcm_frames_f32(float* pFramesOut, const float* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float factor)
{
    ma_copy_and_apply_volume_factor_f32(pFramesOut, pFramesIn, frameCount*channels, factor);
}

MA_API void ma_copy_and_apply_volume_factor_pcm_frames(void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount, ma_format format, ma_uint32 channels, float factor)
{
    switch (format)
    {
    case ma_format_u8:  ma_copy_and_apply_volume_factor_pcm_frames_u8 ((ma_uint8*)pFramesOut, (const ma_uint8*)pFramesIn, frameCount, channels, factor); return;
    case ma_format_s16: ma_copy_and_apply_volume_factor_pcm_frames_s16((ma_int16*)pFramesOut, (const ma_int16*)pFramesIn, frameCount, channels, factor); return;
    case ma_format_s24: ma_copy_and_apply_volume_factor_pcm_frames_s24(           pFramesOut,                  pFramesIn, frameCount, channels, factor); return;
    case ma_format_s32: ma_copy_and_apply_volume_factor_pcm_frames_s32((ma_int32*)pFramesOut, (const ma_int32*)pFramesIn, frameCount, channels, factor); return;
    case ma_format_f32: ma_copy_and_apply_volume_factor_pcm_frames_f32(   (float*)pFramesOut,    (const float*)pFramesIn, frameCount, channels, factor); return;
    default: return;    /* Do nothing. */
    }
}

MA_API void ma_apply_volume_factor_pcm_frames_u8(ma_uint8* pFrames, ma_uint64 frameCount, ma_uint32 channels, float factor)
{
    ma_copy_and_apply_volume_factor_pcm_frames_u8(pFrames, pFrames, frameCount, channels, factor);
}

MA_API void ma_apply_volume_factor_pcm_frames_s16(ma_int16* pFrames, ma_uint64 frameCount, ma_uint32 channels, float factor)
{
    ma_copy_and_apply_volume_factor_pcm_frames_s16(pFrames, pFrames, frameCount, channels, factor);
}

MA_API void ma_apply_volume_factor_pcm_frames_s24(void* pFrames, ma_uint64 frameCount, ma_uint32 channels, float factor)
{
    ma_copy_and_apply_volume_factor_pcm_frames_s24(pFrames, pFrames, frameCount, channels, factor);
}

MA_API void ma_apply_volume_factor_pcm_frames_s32(ma_int32* pFrames, ma_uint64 frameCount, ma_uint32 channels, float factor)
{
    ma_copy_and_apply_volume_factor_pcm_frames_s32(pFrames, pFrames, frameCount, channels, factor);
}

MA_API void ma_apply_volume_factor_pcm_frames_f32(float* pFrames, ma_uint64 frameCount, ma_uint32 channels, float factor)
{
    ma_copy_and_apply_volume_factor_pcm_frames_f32(pFrames, pFrames, frameCount, channels, factor);
}

MA_API void ma_apply_volume_factor_pcm_frames(void* pFramesOut, ma_uint64 frameCount, ma_format format, ma_uint32 channels, float factor)
{
    ma_copy_and_apply_volume_factor_pcm_frames(pFramesOut, pFramesOut, frameCount, format, channels, factor);
}


MA_API void ma_copy_and_apply_volume_factor_per_channel_f32(float* pFramesOut, const float* pFramesIn, ma_uint64 frameCount, ma_uint32 channels, float* pChannelGains)
{
    ma_uint64 iFrame;

    if (channels == 2) {
        /* TODO: Do an optimized implementation for stereo and mono. Can do a SIMD optimized implementation as well. */
    }

    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        ma_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            pFramesOut[iFrame * channels + iChannel] = pFramesIn[iFrame * channels + iChannel] * pChannelGains[iChannel];
        }
    }
}



static MA_INLINE ma_int16 ma_apply_volume_unclipped_u8(ma_int16 x, ma_int16 volume)
{
    return (ma_int16)(((ma_int32)x * (ma_int32)volume) >> 8);
}

static MA_INLINE ma_int32 ma_apply_volume_unclipped_s16(ma_int32 x, ma_int16 volume)
{
    return (ma_int32)((x * volume) >> 8);
}

static MA_INLINE ma_int64 ma_apply_volume_unclipped_s24(ma_int64 x, ma_int16 volume)
{
    return (ma_int64)((x * volume) >> 8);
}

static MA_INLINE ma_int64 ma_apply_volume_unclipped_s32(ma_int64 x, ma_int16 volume)
{
    return (ma_int64)((x * volume) >> 8);
}

static MA_INLINE float ma_apply_volume_unclipped_f32(float x, float volume)
{
    return x * volume;
}


MA_API void ma_copy_and_apply_volume_and_clip_samples_u8(ma_uint8* pDst, const ma_int16* pSrc, ma_uint64 count, float volume)
{
    ma_uint64 iSample;
    ma_int16  volumeFixed;

    MA_ASSERT(pDst != NULL);
    MA_ASSERT(pSrc != NULL);

    volumeFixed = ma_float_to_fixed_16(volume);

    for (iSample = 0; iSample < count; iSample += 1) {
        pDst[iSample] = ma_clip_u8(ma_apply_volume_unclipped_u8(pSrc[iSample], volumeFixed));
    }
}

MA_API void ma_copy_and_apply_volume_and_clip_samples_s16(ma_int16* pDst, const ma_int32* pSrc, ma_uint64 count, float volume)
{
    ma_uint64 iSample;
    ma_int16  volumeFixed;

    MA_ASSERT(pDst != NULL);
    MA_ASSERT(pSrc != NULL);

    volumeFixed = ma_float_to_fixed_16(volume);

    for (iSample = 0; iSample < count; iSample += 1) {
        pDst[iSample] = ma_clip_s16(ma_apply_volume_unclipped_s16(pSrc[iSample], volumeFixed));
    }
}

MA_API void ma_copy_and_apply_volume_and_clip_samples_s24(ma_uint8* pDst, const ma_int64* pSrc, ma_uint64 count, float volume)
{
    ma_uint64 iSample;
    ma_int16  volumeFixed;

    MA_ASSERT(pDst != NULL);
    MA_ASSERT(pSrc != NULL);

    volumeFixed = ma_float_to_fixed_16(volume);

    for (iSample = 0; iSample < count; iSample += 1) {
        ma_int64 s = ma_clip_s24(ma_apply_volume_unclipped_s24(pSrc[iSample], volumeFixed));
        pDst[iSample*3 + 0] = (ma_uint8)((s & 0x000000FF) >>  0);
        pDst[iSample*3 + 1] = (ma_uint8)((s & 0x0000FF00) >>  8);
        pDst[iSample*3 + 2] = (ma_uint8)((s & 0x00FF0000) >> 16);
    }
}

MA_API void ma_copy_and_apply_volume_and_clip_samples_s32(ma_int32* pDst, const ma_int64* pSrc, ma_uint64 count, float volume)
{
    ma_uint64 iSample;
    ma_int16  volumeFixed;

    MA_ASSERT(pDst != NULL);
    MA_ASSERT(pSrc != NULL);

    volumeFixed = ma_float_to_fixed_16(volume);

    for (iSample = 0; iSample < count; iSample += 1) {
        pDst[iSample] = ma_clip_s32(ma_apply_volume_unclipped_s32(pSrc[iSample], volumeFixed));
    }
}

MA_API void ma_copy_and_apply_volume_and_clip_samples_f32(float* pDst, const float* pSrc, ma_uint64 count, float volume)
{
    ma_uint64 iSample;

    MA_ASSERT(pDst != NULL);
    MA_ASSERT(pSrc != NULL);

    /* For the f32 case we need to make sure this supports in-place processing where the input and output buffers are the same. */

    for (iSample = 0; iSample < count; iSample += 1) {
        pDst[iSample] = ma_clip_f32(ma_apply_volume_unclipped_f32(pSrc[iSample], volume));
    }
}

MA_API void ma_copy_and_apply_volume_and_clip_pcm_frames(void* pDst, const void* pSrc, ma_uint64 frameCount, ma_format format, ma_uint32 channels, float volume)
{
    MA_ASSERT(pDst != NULL);
    MA_ASSERT(pSrc != NULL);

    if (volume == 1) {
        ma_clip_pcm_frames(pDst, pSrc, frameCount, format, channels);   /* Optimized case for volume = 1. */
    } else if (volume == 0) {
        ma_silence_pcm_frames(pDst, frameCount, format, channels);      /* Optimized case for volume = 0. */
    } else {
        ma_uint64 sampleCount = frameCount * channels;

        switch (format) {
            case ma_format_u8:  ma_copy_and_apply_volume_and_clip_samples_u8( (ma_uint8*)pDst, (const ma_int16*)pSrc, sampleCount, volume); break;
            case ma_format_s16: ma_copy_and_apply_volume_and_clip_samples_s16((ma_int16*)pDst, (const ma_int32*)pSrc, sampleCount, volume); break;
            case ma_format_s24: ma_copy_and_apply_volume_and_clip_samples_s24((ma_uint8*)pDst, (const ma_int64*)pSrc, sampleCount, volume); break;
            case ma_format_s32: ma_copy_and_apply_volume_and_clip_samples_s32((ma_int32*)pDst, (const ma_int64*)pSrc, sampleCount, volume); break;
            case ma_format_f32: ma_copy_and_apply_volume_and_clip_samples_f32((   float*)pDst, (const    float*)pSrc, sampleCount, volume); break;

            /* Do nothing if we don't know the format. We're including these here to silence a compiler warning about enums not being handled by the switch. */
            case ma_format_unknown:
            case ma_format_count:
                break;
        }
    }
}



MA_API float ma_volume_linear_to_db(float factor)
{
    return 20*ma_log10f(factor);
}

MA_API float ma_volume_db_to_linear(float gain)
{
    return ma_powf(10, gain/20.0f);
}


MA_API ma_result ma_mix_pcm_frames_f32(float* pDst, const float* pSrc, ma_uint64 frameCount, ma_uint32 channels, float volume)
{
    ma_uint64 iSample;
    ma_uint64 sampleCount;

    if (pDst == NULL || pSrc == NULL || channels == 0) {
        return MA_INVALID_ARGS;
    }

    if (volume == 0) {
        return MA_SUCCESS;  /* No changes if the volume is 0. */
    }

    sampleCount = frameCount * channels;

    if (volume == 1) {
        for (iSample = 0; iSample < sampleCount; iSample += 1) {
            pDst[iSample] += pSrc[iSample];
        }
    } else {
        for (iSample = 0; iSample < sampleCount; iSample += 1) {
            pDst[iSample] += ma_apply_volume_unclipped_f32(pSrc[iSample], volume);
        }
    }

    return MA_SUCCESS;
}



/**************************************************************************************************************************************************************

Format Conversion

**************************************************************************************************************************************************************/

static MA_INLINE ma_int16 ma_pcm_sample_f32_to_s16(float x)
{
    return (ma_int16)(x * 32767.0f);
}

static MA_INLINE ma_int16 ma_pcm_sample_u8_to_s16_no_scale(ma_uint8 x)
{
    return (ma_int16)((ma_int16)x - 128);
}

static MA_INLINE ma_int64 ma_pcm_sample_s24_to_s32_no_scale(const ma_uint8* x)
{
    return (ma_int64)(((ma_uint64)x[0] << 40) | ((ma_uint64)x[1] << 48) | ((ma_uint64)x[2] << 56)) >> 40;  /* Make sure the sign bits are maintained. */
}

static MA_INLINE void ma_pcm_sample_s32_to_s24_no_scale(ma_int64 x, ma_uint8* s24)
{
    s24[0] = (ma_uint8)((x & 0x000000FF) >>  0);
    s24[1] = (ma_uint8)((x & 0x0000FF00) >>  8);
    s24[2] = (ma_uint8)((x & 0x00FF0000) >> 16);
}


/* u8 */
MA_API void ma_pcm_u8_to_u8(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    (void)ditherMode;
    ma_copy_memory_64(dst, src, count * sizeof(ma_uint8));
}


static MA_INLINE void ma_pcm_u8_to_s16__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_int16* dst_s16 = (ma_int16*)dst;
    const ma_uint8* src_u8 = (const ma_uint8*)src;

    ma_uint64 i;
    for (i = 0; i < count; i += 1) {
        ma_int16 x = src_u8[i];
        x = (ma_int16)(x - 128);
        x = (ma_int16)(x << 8);
        dst_s16[i] = x;
    }

    (void)ditherMode;
}

static MA_INLINE void ma_pcm_u8_to_s16__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_u8_to_s16__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_u8_to_s16__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_u8_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_u8_to_s16__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_u8_to_s16__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_u8_to_s16(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_u8_to_s16__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_u8_to_s16__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_u8_to_s16__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_u8_to_s16__optimized(dst, src, count, ditherMode);
        }
#endif
}


static MA_INLINE void ma_pcm_u8_to_s24__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_uint8* dst_s24 = (ma_uint8*)dst;
    const ma_uint8* src_u8 = (const ma_uint8*)src;

    ma_uint64 i;
    for (i = 0; i < count; i += 1) {
        ma_int16 x = src_u8[i];
        x = (ma_int16)(x - 128);

        dst_s24[i*3+0] = 0;
        dst_s24[i*3+1] = 0;
        dst_s24[i*3+2] = (ma_uint8)((ma_int8)x);
    }

    (void)ditherMode;
}

static MA_INLINE void ma_pcm_u8_to_s24__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_u8_to_s24__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_u8_to_s24__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_u8_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_u8_to_s24__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_u8_to_s24__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_u8_to_s24(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_u8_to_s24__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_u8_to_s24__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_u8_to_s24__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_u8_to_s24__optimized(dst, src, count, ditherMode);
        }
#endif
}


static MA_INLINE void ma_pcm_u8_to_s32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_int32* dst_s32 = (ma_int32*)dst;
    const ma_uint8* src_u8 = (const ma_uint8*)src;

    ma_uint64 i;
    for (i = 0; i < count; i += 1) {
        ma_int32 x = src_u8[i];
        x = x - 128;
        x = x << 24;
        dst_s32[i] = x;
    }

    (void)ditherMode;
}

static MA_INLINE void ma_pcm_u8_to_s32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_u8_to_s32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_u8_to_s32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_u8_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_u8_to_s32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_u8_to_s32__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_u8_to_s32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_u8_to_s32__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_u8_to_s32__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_u8_to_s32__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_u8_to_s32__optimized(dst, src, count, ditherMode);
        }
#endif
}


static MA_INLINE void ma_pcm_u8_to_f32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    float* dst_f32 = (float*)dst;
    const ma_uint8* src_u8 = (const ma_uint8*)src;

    ma_uint64 i;
    for (i = 0; i < count; i += 1) {
        float x = (float)src_u8[i];
        x = x * 0.00784313725490196078f;    /* 0..255 to 0..2 */
        x = x - 1;                          /* 0..2 to -1..1 */

        dst_f32[i] = x;
    }

    (void)ditherMode;
}

static MA_INLINE void ma_pcm_u8_to_f32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_u8_to_f32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_u8_to_f32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_u8_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_u8_to_f32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_u8_to_f32__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_u8_to_f32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_u8_to_f32__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_u8_to_f32__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_u8_to_f32__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_u8_to_f32__optimized(dst, src, count, ditherMode);
        }
#endif
}


#ifdef MA_USE_REFERENCE_CONVERSION_APIS
static MA_INLINE void ma_pcm_interleave_u8__reference(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_uint8* dst_u8 = (ma_uint8*)dst;
    const ma_uint8** src_u8 = (const ma_uint8**)src;

    ma_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        ma_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_u8[iFrame*channels + iChannel] = src_u8[iChannel][iFrame];
        }
    }
}
#else
static MA_INLINE void ma_pcm_interleave_u8__optimized(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_uint8* dst_u8 = (ma_uint8*)dst;
    const ma_uint8** src_u8 = (const ma_uint8**)src;

    if (channels == 1) {
        ma_copy_memory_64(dst, src[0], frameCount * sizeof(ma_uint8));
    } else if (channels == 2) {
        ma_uint64 iFrame;
        for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
            dst_u8[iFrame*2 + 0] = src_u8[0][iFrame];
            dst_u8[iFrame*2 + 1] = src_u8[1][iFrame];
        }
    } else {
        ma_uint64 iFrame;
        for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
            ma_uint32 iChannel;
            for (iChannel = 0; iChannel < channels; iChannel += 1) {
                dst_u8[iFrame*channels + iChannel] = src_u8[iChannel][iFrame];
            }
        }
    }
}
#endif

MA_API void ma_pcm_interleave_u8(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_interleave_u8__reference(dst, src, frameCount, channels);
#else
    ma_pcm_interleave_u8__optimized(dst, src, frameCount, channels);
#endif
}


static MA_INLINE void ma_pcm_deinterleave_u8__reference(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_uint8** dst_u8 = (ma_uint8**)dst;
    const ma_uint8* src_u8 = (const ma_uint8*)src;

    ma_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        ma_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_u8[iChannel][iFrame] = src_u8[iFrame*channels + iChannel];
        }
    }
}

static MA_INLINE void ma_pcm_deinterleave_u8__optimized(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_pcm_deinterleave_u8__reference(dst, src, frameCount, channels);
}

MA_API void ma_pcm_deinterleave_u8(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_deinterleave_u8__reference(dst, src, frameCount, channels);
#else
    ma_pcm_deinterleave_u8__optimized(dst, src, frameCount, channels);
#endif
}


/* s16 */
static MA_INLINE void ma_pcm_s16_to_u8__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_uint8* dst_u8 = (ma_uint8*)dst;
    const ma_int16* src_s16 = (const ma_int16*)src;

    if (ditherMode == ma_dither_mode_none) {
        ma_uint64 i;
        for (i = 0; i < count; i += 1) {
            ma_int16 x = src_s16[i];
            x = (ma_int16)(x >> 8);
            x = (ma_int16)(x + 128);
            dst_u8[i] = (ma_uint8)x;
        }
    } else {
        ma_uint64 i;
        for (i = 0; i < count; i += 1) {
            ma_int16 x = src_s16[i];

            /* Dither. Don't overflow. */
            ma_int32 dither = ma_dither_s32(ditherMode, -0x80, 0x7F);
            if ((x + dither) <= 0x7FFF) {
                x = (ma_int16)(x + dither);
            } else {
                x = 0x7FFF;
            }

            x = (ma_int16)(x >> 8);
            x = (ma_int16)(x + 128);
            dst_u8[i] = (ma_uint8)x;
        }
    }
}

static MA_INLINE void ma_pcm_s16_to_u8__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s16_to_u8__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s16_to_u8__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s16_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s16_to_u8__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s16_to_u8__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_s16_to_u8(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_s16_to_u8__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_s16_to_u8__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_s16_to_u8__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_s16_to_u8__optimized(dst, src, count, ditherMode);
        }
#endif
}


MA_API void ma_pcm_s16_to_s16(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    (void)ditherMode;
    ma_copy_memory_64(dst, src, count * sizeof(ma_int16));
}


static MA_INLINE void ma_pcm_s16_to_s24__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_uint8* dst_s24 = (ma_uint8*)dst;
    const ma_int16* src_s16 = (const ma_int16*)src;

    ma_uint64 i;
    for (i = 0; i < count; i += 1) {
        dst_s24[i*3+0] = 0;
        dst_s24[i*3+1] = (ma_uint8)(src_s16[i] & 0xFF);
        dst_s24[i*3+2] = (ma_uint8)(src_s16[i] >> 8);
    }

    (void)ditherMode;
}

static MA_INLINE void ma_pcm_s16_to_s24__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s16_to_s24__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s16_to_s24__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s16_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s16_to_s24__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s16_to_s24__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_s16_to_s24(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_s16_to_s24__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_s16_to_s24__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_s16_to_s24__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_s16_to_s24__optimized(dst, src, count, ditherMode);
        }
#endif
}


static MA_INLINE void ma_pcm_s16_to_s32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_int32* dst_s32 = (ma_int32*)dst;
    const ma_int16* src_s16 = (const ma_int16*)src;

    ma_uint64 i;
    for (i = 0; i < count; i += 1) {
        dst_s32[i] = src_s16[i] << 16;
    }

    (void)ditherMode;
}

static MA_INLINE void ma_pcm_s16_to_s32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s16_to_s32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s16_to_s32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s16_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s16_to_s32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s16_to_s32__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_s16_to_s32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_s16_to_s32__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_s16_to_s32__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_s16_to_s32__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_s16_to_s32__optimized(dst, src, count, ditherMode);
        }
#endif
}


static MA_INLINE void ma_pcm_s16_to_f32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    float* dst_f32 = (float*)dst;
    const ma_int16* src_s16 = (const ma_int16*)src;

    ma_uint64 i;
    for (i = 0; i < count; i += 1) {
        float x = (float)src_s16[i];

#if 0
        /* The accurate way. */
        x = x + 32768.0f;                   /* -32768..32767 to 0..65535 */
        x = x * 0.00003051804379339284f;    /* 0..65535 to 0..2 */
        x = x - 1;                          /* 0..2 to -1..1 */
#else
        /* The fast way. */
        x = x * 0.000030517578125f;         /* -32768..32767 to -1..0.999969482421875 */
#endif

        dst_f32[i] = x;
    }

    (void)ditherMode;
}

static MA_INLINE void ma_pcm_s16_to_f32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s16_to_f32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s16_to_f32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s16_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s16_to_f32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s16_to_f32__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_s16_to_f32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_s16_to_f32__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_s16_to_f32__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_s16_to_f32__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_s16_to_f32__optimized(dst, src, count, ditherMode);
        }
#endif
}


static MA_INLINE void ma_pcm_interleave_s16__reference(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_int16* dst_s16 = (ma_int16*)dst;
    const ma_int16** src_s16 = (const ma_int16**)src;

    ma_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        ma_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_s16[iFrame*channels + iChannel] = src_s16[iChannel][iFrame];
        }
    }
}

static MA_INLINE void ma_pcm_interleave_s16__optimized(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_pcm_interleave_s16__reference(dst, src, frameCount, channels);
}

MA_API void ma_pcm_interleave_s16(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_interleave_s16__reference(dst, src, frameCount, channels);
#else
    ma_pcm_interleave_s16__optimized(dst, src, frameCount, channels);
#endif
}


static MA_INLINE void ma_pcm_deinterleave_s16__reference(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_int16** dst_s16 = (ma_int16**)dst;
    const ma_int16* src_s16 = (const ma_int16*)src;

    ma_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        ma_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_s16[iChannel][iFrame] = src_s16[iFrame*channels + iChannel];
        }
    }
}

static MA_INLINE void ma_pcm_deinterleave_s16__optimized(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_pcm_deinterleave_s16__reference(dst, src, frameCount, channels);
}

MA_API void ma_pcm_deinterleave_s16(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_deinterleave_s16__reference(dst, src, frameCount, channels);
#else
    ma_pcm_deinterleave_s16__optimized(dst, src, frameCount, channels);
#endif
}


/* s24 */
static MA_INLINE void ma_pcm_s24_to_u8__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_uint8* dst_u8 = (ma_uint8*)dst;
    const ma_uint8* src_s24 = (const ma_uint8*)src;

    if (ditherMode == ma_dither_mode_none) {
        ma_uint64 i;
        for (i = 0; i < count; i += 1) {
            dst_u8[i] = (ma_uint8)((ma_int8)src_s24[i*3 + 2] + 128);
        }
    } else {
        ma_uint64 i;
        for (i = 0; i < count; i += 1) {
            ma_int32 x = (ma_int32)(((ma_uint32)(src_s24[i*3+0]) << 8) | ((ma_uint32)(src_s24[i*3+1]) << 16) | ((ma_uint32)(src_s24[i*3+2])) << 24);

            /* Dither. Don't overflow. */
            ma_int32 dither = ma_dither_s32(ditherMode, -0x800000, 0x7FFFFF);
            if ((ma_int64)x + dither <= 0x7FFFFFFF) {
                x = x + dither;
            } else {
                x = 0x7FFFFFFF;
            }

            x = x >> 24;
            x = x + 128;
            dst_u8[i] = (ma_uint8)x;
        }
    }
}

static MA_INLINE void ma_pcm_s24_to_u8__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s24_to_u8__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s24_to_u8__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s24_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s24_to_u8__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s24_to_u8__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_s24_to_u8(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_s24_to_u8__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_s24_to_u8__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_s24_to_u8__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_s24_to_u8__optimized(dst, src, count, ditherMode);
        }
#endif
}


static MA_INLINE void ma_pcm_s24_to_s16__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_int16* dst_s16 = (ma_int16*)dst;
    const ma_uint8* src_s24 = (const ma_uint8*)src;

    if (ditherMode == ma_dither_mode_none) {
        ma_uint64 i;
        for (i = 0; i < count; i += 1) {
            ma_uint16 dst_lo =            ((ma_uint16)src_s24[i*3 + 1]);
            ma_uint16 dst_hi = (ma_uint16)((ma_uint16)src_s24[i*3 + 2] << 8);
            dst_s16[i] = (ma_int16)(dst_lo | dst_hi);
        }
    } else {
        ma_uint64 i;
        for (i = 0; i < count; i += 1) {
            ma_int32 x = (ma_int32)(((ma_uint32)(src_s24[i*3+0]) << 8) | ((ma_uint32)(src_s24[i*3+1]) << 16) | ((ma_uint32)(src_s24[i*3+2])) << 24);

            /* Dither. Don't overflow. */
            ma_int32 dither = ma_dither_s32(ditherMode, -0x8000, 0x7FFF);
            if ((ma_int64)x + dither <= 0x7FFFFFFF) {
                x = x + dither;
            } else {
                x = 0x7FFFFFFF;
            }

            x = x >> 16;
            dst_s16[i] = (ma_int16)x;
        }
    }
}

static MA_INLINE void ma_pcm_s24_to_s16__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s24_to_s16__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s24_to_s16__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s24_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s24_to_s16__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s24_to_s16__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_s24_to_s16(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_s24_to_s16__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_s24_to_s16__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_s24_to_s16__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_s24_to_s16__optimized(dst, src, count, ditherMode);
        }
#endif
}


MA_API void ma_pcm_s24_to_s24(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    (void)ditherMode;

    ma_copy_memory_64(dst, src, count * 3);
}


static MA_INLINE void ma_pcm_s24_to_s32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_int32* dst_s32 = (ma_int32*)dst;
    const ma_uint8* src_s24 = (const ma_uint8*)src;

    ma_uint64 i;
    for (i = 0; i < count; i += 1) {
        dst_s32[i] = (ma_int32)(((ma_uint32)(src_s24[i*3+0]) << 8) | ((ma_uint32)(src_s24[i*3+1]) << 16) | ((ma_uint32)(src_s24[i*3+2])) << 24);
    }

    (void)ditherMode;
}

static MA_INLINE void ma_pcm_s24_to_s32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s24_to_s32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s24_to_s32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s24_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s24_to_s32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s24_to_s32__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_s24_to_s32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_s24_to_s32__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_s24_to_s32__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_s24_to_s32__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_s24_to_s32__optimized(dst, src, count, ditherMode);
        }
#endif
}


static MA_INLINE void ma_pcm_s24_to_f32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    float* dst_f32 = (float*)dst;
    const ma_uint8* src_s24 = (const ma_uint8*)src;

    ma_uint64 i;
    for (i = 0; i < count; i += 1) {
        float x = (float)(((ma_int32)(((ma_uint32)(src_s24[i*3+0]) << 8) | ((ma_uint32)(src_s24[i*3+1]) << 16) | ((ma_uint32)(src_s24[i*3+2])) << 24)) >> 8);

#if 0
        /* The accurate way. */
        x = x + 8388608.0f;                 /* -8388608..8388607 to 0..16777215 */
        x = x * 0.00000011920929665621f;    /* 0..16777215 to 0..2 */
        x = x - 1;                          /* 0..2 to -1..1 */
#else
        /* The fast way. */
        x = x * 0.00000011920928955078125f; /* -8388608..8388607 to -1..0.999969482421875 */
#endif

        dst_f32[i] = x;
    }

    (void)ditherMode;
}

static MA_INLINE void ma_pcm_s24_to_f32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s24_to_f32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s24_to_f32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s24_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s24_to_f32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s24_to_f32__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_s24_to_f32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_s24_to_f32__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_s24_to_f32__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_s24_to_f32__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_s24_to_f32__optimized(dst, src, count, ditherMode);
        }
#endif
}


static MA_INLINE void ma_pcm_interleave_s24__reference(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_uint8* dst8 = (ma_uint8*)dst;
    const ma_uint8** src8 = (const ma_uint8**)src;

    ma_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        ma_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst8[iFrame*3*channels + iChannel*3 + 0] = src8[iChannel][iFrame*3 + 0];
            dst8[iFrame*3*channels + iChannel*3 + 1] = src8[iChannel][iFrame*3 + 1];
            dst8[iFrame*3*channels + iChannel*3 + 2] = src8[iChannel][iFrame*3 + 2];
        }
    }
}

static MA_INLINE void ma_pcm_interleave_s24__optimized(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_pcm_interleave_s24__reference(dst, src, frameCount, channels);
}

MA_API void ma_pcm_interleave_s24(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_interleave_s24__reference(dst, src, frameCount, channels);
#else
    ma_pcm_interleave_s24__optimized(dst, src, frameCount, channels);
#endif
}


static MA_INLINE void ma_pcm_deinterleave_s24__reference(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_uint8** dst8 = (ma_uint8**)dst;
    const ma_uint8* src8 = (const ma_uint8*)src;

    ma_uint32 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        ma_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst8[iChannel][iFrame*3 + 0] = src8[iFrame*3*channels + iChannel*3 + 0];
            dst8[iChannel][iFrame*3 + 1] = src8[iFrame*3*channels + iChannel*3 + 1];
            dst8[iChannel][iFrame*3 + 2] = src8[iFrame*3*channels + iChannel*3 + 2];
        }
    }
}

static MA_INLINE void ma_pcm_deinterleave_s24__optimized(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_pcm_deinterleave_s24__reference(dst, src, frameCount, channels);
}

MA_API void ma_pcm_deinterleave_s24(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_deinterleave_s24__reference(dst, src, frameCount, channels);
#else
    ma_pcm_deinterleave_s24__optimized(dst, src, frameCount, channels);
#endif
}



/* s32 */
static MA_INLINE void ma_pcm_s32_to_u8__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_uint8* dst_u8 = (ma_uint8*)dst;
    const ma_int32* src_s32 = (const ma_int32*)src;

    if (ditherMode == ma_dither_mode_none) {
        ma_uint64 i;
        for (i = 0; i < count; i += 1) {
            ma_int32 x = src_s32[i];
            x = x >> 24;
            x = x + 128;
            dst_u8[i] = (ma_uint8)x;
        }
    } else {
        ma_uint64 i;
        for (i = 0; i < count; i += 1) {
            ma_int32 x = src_s32[i];

            /* Dither. Don't overflow. */
            ma_int32 dither = ma_dither_s32(ditherMode, -0x800000, 0x7FFFFF);
            if ((ma_int64)x + dither <= 0x7FFFFFFF) {
                x = x + dither;
            } else {
                x = 0x7FFFFFFF;
            }

            x = x >> 24;
            x = x + 128;
            dst_u8[i] = (ma_uint8)x;
        }
    }
}

static MA_INLINE void ma_pcm_s32_to_u8__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s32_to_u8__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s32_to_u8__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s32_to_u8__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_s32_to_u8(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_s32_to_u8__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_s32_to_u8__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_s32_to_u8__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_s32_to_u8__optimized(dst, src, count, ditherMode);
        }
#endif
}


static MA_INLINE void ma_pcm_s32_to_s16__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_int16* dst_s16 = (ma_int16*)dst;
    const ma_int32* src_s32 = (const ma_int32*)src;

    if (ditherMode == ma_dither_mode_none) {
        ma_uint64 i;
        for (i = 0; i < count; i += 1) {
            ma_int32 x = src_s32[i];
            x = x >> 16;
            dst_s16[i] = (ma_int16)x;
        }
    } else {
        ma_uint64 i;
        for (i = 0; i < count; i += 1) {
            ma_int32 x = src_s32[i];

            /* Dither. Don't overflow. */
            ma_int32 dither = ma_dither_s32(ditherMode, -0x8000, 0x7FFF);
            if ((ma_int64)x + dither <= 0x7FFFFFFF) {
                x = x + dither;
            } else {
                x = 0x7FFFFFFF;
            }

            x = x >> 16;
            dst_s16[i] = (ma_int16)x;
        }
    }
}

static MA_INLINE void ma_pcm_s32_to_s16__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s32_to_s16__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s32_to_s16__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s32_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s32_to_s16__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s32_to_s16__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_s32_to_s16(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_s32_to_s16__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_s32_to_s16__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_s32_to_s16__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_s32_to_s16__optimized(dst, src, count, ditherMode);
        }
#endif
}


static MA_INLINE void ma_pcm_s32_to_s24__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_uint8* dst_s24 = (ma_uint8*)dst;
    const ma_int32* src_s32 = (const ma_int32*)src;

    ma_uint64 i;
    for (i = 0; i < count; i += 1) {
        ma_uint32 x = (ma_uint32)src_s32[i];
        dst_s24[i*3+0] = (ma_uint8)((x & 0x0000FF00) >>  8);
        dst_s24[i*3+1] = (ma_uint8)((x & 0x00FF0000) >> 16);
        dst_s24[i*3+2] = (ma_uint8)((x & 0xFF000000) >> 24);
    }

    (void)ditherMode;   /* No dithering for s32 -> s24. */
}

static MA_INLINE void ma_pcm_s32_to_s24__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s32_to_s24__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s32_to_s24__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s32_to_s24__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_s32_to_s24(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_s32_to_s24__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_s32_to_s24__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_s32_to_s24__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_s32_to_s24__optimized(dst, src, count, ditherMode);
        }
#endif
}


MA_API void ma_pcm_s32_to_s32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    (void)ditherMode;

    ma_copy_memory_64(dst, src, count * sizeof(ma_int32));
}


static MA_INLINE void ma_pcm_s32_to_f32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    float* dst_f32 = (float*)dst;
    const ma_int32* src_s32 = (const ma_int32*)src;

    ma_uint64 i;
    for (i = 0; i < count; i += 1) {
        double x = src_s32[i];

#if 0
        x = x + 2147483648.0;
        x = x * 0.0000000004656612873077392578125;
        x = x - 1;
#else
        x = x / 2147483648.0;
#endif

        dst_f32[i] = (float)x;
    }

    (void)ditherMode;   /* No dithering for s32 -> f32. */
}

static MA_INLINE void ma_pcm_s32_to_f32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s32_to_f32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s32_to_f32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s32_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s32_to_f32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_s32_to_f32__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_s32_to_f32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_s32_to_f32__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_s32_to_f32__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_s32_to_f32__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_s32_to_f32__optimized(dst, src, count, ditherMode);
        }
#endif
}


static MA_INLINE void ma_pcm_interleave_s32__reference(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_int32* dst_s32 = (ma_int32*)dst;
    const ma_int32** src_s32 = (const ma_int32**)src;

    ma_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        ma_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_s32[iFrame*channels + iChannel] = src_s32[iChannel][iFrame];
        }
    }
}

static MA_INLINE void ma_pcm_interleave_s32__optimized(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_pcm_interleave_s32__reference(dst, src, frameCount, channels);
}

MA_API void ma_pcm_interleave_s32(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_interleave_s32__reference(dst, src, frameCount, channels);
#else
    ma_pcm_interleave_s32__optimized(dst, src, frameCount, channels);
#endif
}


static MA_INLINE void ma_pcm_deinterleave_s32__reference(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_int32** dst_s32 = (ma_int32**)dst;
    const ma_int32* src_s32 = (const ma_int32*)src;

    ma_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        ma_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_s32[iChannel][iFrame] = src_s32[iFrame*channels + iChannel];
        }
    }
}

static MA_INLINE void ma_pcm_deinterleave_s32__optimized(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_pcm_deinterleave_s32__reference(dst, src, frameCount, channels);
}

MA_API void ma_pcm_deinterleave_s32(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_deinterleave_s32__reference(dst, src, frameCount, channels);
#else
    ma_pcm_deinterleave_s32__optimized(dst, src, frameCount, channels);
#endif
}


/* f32 */
static MA_INLINE void ma_pcm_f32_to_u8__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_uint64 i;

    ma_uint8* dst_u8 = (ma_uint8*)dst;
    const float* src_f32 = (const float*)src;

    float ditherMin = 0;
    float ditherMax = 0;
    if (ditherMode != ma_dither_mode_none) {
        ditherMin = 1.0f / -128;
        ditherMax = 1.0f /  127;
    }

    for (i = 0; i < count; i += 1) {
        float x = src_f32[i];
        x = x + ma_dither_f32(ditherMode, ditherMin, ditherMax);
        x = ((x < -1) ? -1 : ((x > 1) ? 1 : x));    /* clip */
        x = x + 1;                                  /* -1..1 to 0..2 */
        x = x * 127.5f;                             /* 0..2 to 0..255 */

        dst_u8[i] = (ma_uint8)x;
    }
}

static MA_INLINE void ma_pcm_f32_to_u8__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_f32_to_u8__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_f32_to_u8__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_f32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_f32_to_u8__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_f32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_f32_to_u8(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_f32_to_u8__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_f32_to_u8__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_f32_to_u8__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_f32_to_u8__optimized(dst, src, count, ditherMode);
        }
#endif
}

#ifdef MA_USE_REFERENCE_CONVERSION_APIS
static MA_INLINE void ma_pcm_f32_to_s16__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_uint64 i;

    ma_int16* dst_s16 = (ma_int16*)dst;
    const float* src_f32 = (const float*)src;

    float ditherMin = 0;
    float ditherMax = 0;
    if (ditherMode != ma_dither_mode_none) {
        ditherMin = 1.0f / -32768;
        ditherMax = 1.0f /  32767;
    }

    for (i = 0; i < count; i += 1) {
        float x = src_f32[i];
        x = x + ma_dither_f32(ditherMode, ditherMin, ditherMax);
        x = ((x < -1) ? -1 : ((x > 1) ? 1 : x));    /* clip */

#if 0
        /* The accurate way. */
        x = x + 1;                                  /* -1..1 to 0..2 */
        x = x * 32767.5f;                           /* 0..2 to 0..65535 */
        x = x - 32768.0f;                           /* 0...65535 to -32768..32767 */
#else
        /* The fast way. */
        x = x * 32767.0f;                           /* -1..1 to -32767..32767 */
#endif

        dst_s16[i] = (ma_int16)x;
    }
}
#else
static MA_INLINE void ma_pcm_f32_to_s16__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_uint64 i;
    ma_uint64 i4;
    ma_uint64 count4;

    ma_int16* dst_s16 = (ma_int16*)dst;
    const float* src_f32 = (const float*)src;

    float ditherMin = 0;
    float ditherMax = 0;
    if (ditherMode != ma_dither_mode_none) {
        ditherMin = 1.0f / -32768;
        ditherMax = 1.0f /  32767;
    }

    /* Unrolled. */
    i = 0;
    count4 = count >> 2;
    for (i4 = 0; i4 < count4; i4 += 1) {
        float d0 = ma_dither_f32(ditherMode, ditherMin, ditherMax);
        float d1 = ma_dither_f32(ditherMode, ditherMin, ditherMax);
        float d2 = ma_dither_f32(ditherMode, ditherMin, ditherMax);
        float d3 = ma_dither_f32(ditherMode, ditherMin, ditherMax);

        float x0 = src_f32[i+0];
        float x1 = src_f32[i+1];
        float x2 = src_f32[i+2];
        float x3 = src_f32[i+3];

        x0 = x0 + d0;
        x1 = x1 + d1;
        x2 = x2 + d2;
        x3 = x3 + d3;

        x0 = ((x0 < -1) ? -1 : ((x0 > 1) ? 1 : x0));
        x1 = ((x1 < -1) ? -1 : ((x1 > 1) ? 1 : x1));
        x2 = ((x2 < -1) ? -1 : ((x2 > 1) ? 1 : x2));
        x3 = ((x3 < -1) ? -1 : ((x3 > 1) ? 1 : x3));

        x0 = x0 * 32767.0f;
        x1 = x1 * 32767.0f;
        x2 = x2 * 32767.0f;
        x3 = x3 * 32767.0f;

        dst_s16[i+0] = (ma_int16)x0;
        dst_s16[i+1] = (ma_int16)x1;
        dst_s16[i+2] = (ma_int16)x2;
        dst_s16[i+3] = (ma_int16)x3;

        i += 4;
    }

    /* Leftover. */
    for (; i < count; i += 1) {
        float x = src_f32[i];
        x = x + ma_dither_f32(ditherMode, ditherMin, ditherMax);
        x = ((x < -1) ? -1 : ((x > 1) ? 1 : x));    /* clip */
        x = x * 32767.0f;                           /* -1..1 to -32767..32767 */

        dst_s16[i] = (ma_int16)x;
    }
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_f32_to_s16__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_uint64 i;
    ma_uint64 i8;
    ma_uint64 count8;
    ma_int16* dst_s16;
    const float* src_f32;
    float ditherMin;
    float ditherMax;

    /* Both the input and output buffers need to be aligned to 16 bytes. */
    if ((((ma_uintptr)dst & 15) != 0) || (((ma_uintptr)src & 15) != 0)) {
        ma_pcm_f32_to_s16__optimized(dst, src, count, ditherMode);
        return;
    }

    dst_s16 = (ma_int16*)dst;
    src_f32 = (const float*)src;

    ditherMin = 0;
    ditherMax = 0;
    if (ditherMode != ma_dither_mode_none) {
        ditherMin = 1.0f / -32768;
        ditherMax = 1.0f /  32767;
    }

    i = 0;

    /* SSE2. SSE allows us to output 8 s16's at a time which means our loop is unrolled 8 times. */
    count8 = count >> 3;
    for (i8 = 0; i8 < count8; i8 += 1) {
        __m128 d0;
        __m128 d1;
        __m128 x0;
        __m128 x1;

        if (ditherMode == ma_dither_mode_none) {
            d0 = _mm_set1_ps(0);
            d1 = _mm_set1_ps(0);
        } else if (ditherMode == ma_dither_mode_rectangle) {
            d0 = _mm_set_ps(
                ma_dither_f32_rectangle(ditherMin, ditherMax),
                ma_dither_f32_rectangle(ditherMin, ditherMax),
                ma_dither_f32_rectangle(ditherMin, ditherMax),
                ma_dither_f32_rectangle(ditherMin, ditherMax)
            );
            d1 = _mm_set_ps(
                ma_dither_f32_rectangle(ditherMin, ditherMax),
                ma_dither_f32_rectangle(ditherMin, ditherMax),
                ma_dither_f32_rectangle(ditherMin, ditherMax),
                ma_dither_f32_rectangle(ditherMin, ditherMax)
            );
        } else {
            d0 = _mm_set_ps(
                ma_dither_f32_triangle(ditherMin, ditherMax),
                ma_dither_f32_triangle(ditherMin, ditherMax),
                ma_dither_f32_triangle(ditherMin, ditherMax),
                ma_dither_f32_triangle(ditherMin, ditherMax)
            );
            d1 = _mm_set_ps(
                ma_dither_f32_triangle(ditherMin, ditherMax),
                ma_dither_f32_triangle(ditherMin, ditherMax),
                ma_dither_f32_triangle(ditherMin, ditherMax),
                ma_dither_f32_triangle(ditherMin, ditherMax)
            );
        }

        x0 = *((__m128*)(src_f32 + i) + 0);
        x1 = *((__m128*)(src_f32 + i) + 1);

        x0 = _mm_add_ps(x0, d0);
        x1 = _mm_add_ps(x1, d1);

        x0 = _mm_mul_ps(x0, _mm_set1_ps(32767.0f));
        x1 = _mm_mul_ps(x1, _mm_set1_ps(32767.0f));

        _mm_stream_si128(((__m128i*)(dst_s16 + i)), _mm_packs_epi32(_mm_cvttps_epi32(x0), _mm_cvttps_epi32(x1)));

        i += 8;
    }


    /* Leftover. */
    for (; i < count; i += 1) {
        float x = src_f32[i];
        x = x + ma_dither_f32(ditherMode, ditherMin, ditherMax);
        x = ((x < -1) ? -1 : ((x > 1) ? 1 : x));    /* clip */
        x = x * 32767.0f;                           /* -1..1 to -32767..32767 */

        dst_s16[i] = (ma_int16)x;
    }
}
#endif  /* SSE2 */

#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_f32_to_s16__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_uint64 i;
    ma_uint64 i8;
    ma_uint64 count8;
    ma_int16* dst_s16;
    const float* src_f32;
    float ditherMin;
    float ditherMax;

    if (!ma_has_neon()) {
        ma_pcm_f32_to_s16__optimized(dst, src, count, ditherMode);
        return;
    }

    /* Both the input and output buffers need to be aligned to 16 bytes. */
    if ((((ma_uintptr)dst & 15) != 0) || (((ma_uintptr)src & 15) != 0)) {
        ma_pcm_f32_to_s16__optimized(dst, src, count, ditherMode);
        return;
    }

    dst_s16 = (ma_int16*)dst;
    src_f32 = (const float*)src;

    ditherMin = 0;
    ditherMax = 0;
    if (ditherMode != ma_dither_mode_none) {
        ditherMin = 1.0f / -32768;
        ditherMax = 1.0f /  32767;
    }

    i = 0;

    /* NEON. NEON allows us to output 8 s16's at a time which means our loop is unrolled 8 times. */
    count8 = count >> 3;
    for (i8 = 0; i8 < count8; i8 += 1) {
        float32x4_t d0;
        float32x4_t d1;
        float32x4_t x0;
        float32x4_t x1;
        int32x4_t i0;
        int32x4_t i1;

        if (ditherMode == ma_dither_mode_none) {
            d0 = vmovq_n_f32(0);
            d1 = vmovq_n_f32(0);
        } else if (ditherMode == ma_dither_mode_rectangle) {
            float d0v[4];
            float d1v[4];

            d0v[0] = ma_dither_f32_rectangle(ditherMin, ditherMax);
            d0v[1] = ma_dither_f32_rectangle(ditherMin, ditherMax);
            d0v[2] = ma_dither_f32_rectangle(ditherMin, ditherMax);
            d0v[3] = ma_dither_f32_rectangle(ditherMin, ditherMax);
            d0 = vld1q_f32(d0v);

            d1v[0] = ma_dither_f32_rectangle(ditherMin, ditherMax);
            d1v[1] = ma_dither_f32_rectangle(ditherMin, ditherMax);
            d1v[2] = ma_dither_f32_rectangle(ditherMin, ditherMax);
            d1v[3] = ma_dither_f32_rectangle(ditherMin, ditherMax);
            d1 = vld1q_f32(d1v);
        } else {
            float d0v[4];
            float d1v[4];

            d0v[0] = ma_dither_f32_triangle(ditherMin, ditherMax);
            d0v[1] = ma_dither_f32_triangle(ditherMin, ditherMax);
            d0v[2] = ma_dither_f32_triangle(ditherMin, ditherMax);
            d0v[3] = ma_dither_f32_triangle(ditherMin, ditherMax);
            d0 = vld1q_f32(d0v);

            d1v[0] = ma_dither_f32_triangle(ditherMin, ditherMax);
            d1v[1] = ma_dither_f32_triangle(ditherMin, ditherMax);
            d1v[2] = ma_dither_f32_triangle(ditherMin, ditherMax);
            d1v[3] = ma_dither_f32_triangle(ditherMin, ditherMax);
            d1 = vld1q_f32(d1v);
        }

        x0 = *((float32x4_t*)(src_f32 + i) + 0);
        x1 = *((float32x4_t*)(src_f32 + i) + 1);

        x0 = vaddq_f32(x0, d0);
        x1 = vaddq_f32(x1, d1);

        x0 = vmulq_n_f32(x0, 32767.0f);
        x1 = vmulq_n_f32(x1, 32767.0f);

        i0 = vcvtq_s32_f32(x0);
        i1 = vcvtq_s32_f32(x1);
        *((int16x8_t*)(dst_s16 + i)) = vcombine_s16(vqmovn_s32(i0), vqmovn_s32(i1));

        i += 8;
    }


    /* Leftover. */
    for (; i < count; i += 1) {
        float x = src_f32[i];
        x = x + ma_dither_f32(ditherMode, ditherMin, ditherMax);
        x = ((x < -1) ? -1 : ((x > 1) ? 1 : x));    /* clip */
        x = x * 32767.0f;                           /* -1..1 to -32767..32767 */

        dst_s16[i] = (ma_int16)x;
    }
}
#endif  /* Neon */
#endif  /* MA_USE_REFERENCE_CONVERSION_APIS */

MA_API void ma_pcm_f32_to_s16(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_f32_to_s16__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_f32_to_s16__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_f32_to_s16__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_f32_to_s16__optimized(dst, src, count, ditherMode);
        }
#endif
}


static MA_INLINE void ma_pcm_f32_to_s24__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_uint8* dst_s24 = (ma_uint8*)dst;
    const float* src_f32 = (const float*)src;

    ma_uint64 i;
    for (i = 0; i < count; i += 1) {
        ma_int32 r;
        float x = src_f32[i];
        x = ((x < -1) ? -1 : ((x > 1) ? 1 : x));    /* clip */

#if 0
        /* The accurate way. */
        x = x + 1;                                  /* -1..1 to 0..2 */
        x = x * 8388607.5f;                         /* 0..2 to 0..16777215 */
        x = x - 8388608.0f;                         /* 0..16777215 to -8388608..8388607 */
#else
        /* The fast way. */
        x = x * 8388607.0f;                         /* -1..1 to -8388607..8388607 */
#endif

        r = (ma_int32)x;
        dst_s24[(i*3)+0] = (ma_uint8)((r & 0x0000FF) >>  0);
        dst_s24[(i*3)+1] = (ma_uint8)((r & 0x00FF00) >>  8);
        dst_s24[(i*3)+2] = (ma_uint8)((r & 0xFF0000) >> 16);
    }

    (void)ditherMode;   /* No dithering for f32 -> s24. */
}

static MA_INLINE void ma_pcm_f32_to_s24__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_f32_to_s24__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_f32_to_s24__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_f32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_f32_to_s24__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_f32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_f32_to_s24(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_f32_to_s24__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_f32_to_s24__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_f32_to_s24__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_f32_to_s24__optimized(dst, src, count, ditherMode);
        }
#endif
}


static MA_INLINE void ma_pcm_f32_to_s32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_int32* dst_s32 = (ma_int32*)dst;
    const float* src_f32 = (const float*)src;

    ma_uint32 i;
    for (i = 0; i < count; i += 1) {
        double x = src_f32[i];
        x = ((x < -1) ? -1 : ((x > 1) ? 1 : x));    /* clip */

#if 0
        /* The accurate way. */
        x = x + 1;                                  /* -1..1 to 0..2 */
        x = x * 2147483647.5;                       /* 0..2 to 0..4294967295 */
        x = x - 2147483648.0;                       /* 0...4294967295 to -2147483648..2147483647 */
#else
        /* The fast way. */
        x = x * 2147483647.0;                       /* -1..1 to -2147483647..2147483647 */
#endif

        dst_s32[i] = (ma_int32)x;
    }

    (void)ditherMode;   /* No dithering for f32 -> s32. */
}

static MA_INLINE void ma_pcm_f32_to_s32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_f32_to_s32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_f32_to_s32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_f32_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_f32_to_s32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    ma_pcm_f32_to_s32__optimized(dst, src, count, ditherMode);
}
#endif

MA_API void ma_pcm_f32_to_s32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_f32_to_s32__reference(dst, src, count, ditherMode);
#else
    #  if defined(MA_SUPPORT_SSE2)
        if (ma_has_sse2()) {
            ma_pcm_f32_to_s32__sse2(dst, src, count, ditherMode);
        } else
    #elif defined(MA_SUPPORT_NEON)
        if (ma_has_neon()) {
            ma_pcm_f32_to_s32__neon(dst, src, count, ditherMode);
        } else
    #endif
        {
            ma_pcm_f32_to_s32__optimized(dst, src, count, ditherMode);
        }
#endif
}


MA_API void ma_pcm_f32_to_f32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
    (void)ditherMode;

    ma_copy_memory_64(dst, src, count * sizeof(float));
}


static void ma_pcm_interleave_f32__reference(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
    float* dst_f32 = (float*)dst;
    const float** src_f32 = (const float**)src;

    ma_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        ma_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_f32[iFrame*channels + iChannel] = src_f32[iChannel][iFrame];
        }
    }
}

static void ma_pcm_interleave_f32__optimized(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_pcm_interleave_f32__reference(dst, src, frameCount, channels);
}

MA_API void ma_pcm_interleave_f32(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_interleave_f32__reference(dst, src, frameCount, channels);
#else
    ma_pcm_interleave_f32__optimized(dst, src, frameCount, channels);
#endif
}


static void ma_pcm_deinterleave_f32__reference(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
    float** dst_f32 = (float**)dst;
    const float* src_f32 = (const float*)src;

    ma_uint64 iFrame;
    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        ma_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; iChannel += 1) {
            dst_f32[iChannel][iFrame] = src_f32[iFrame*channels + iChannel];
        }
    }
}

static void ma_pcm_deinterleave_f32__optimized(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
    ma_pcm_deinterleave_f32__reference(dst, src, frameCount, channels);
}

MA_API void ma_pcm_deinterleave_f32(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
#ifdef MA_USE_REFERENCE_CONVERSION_APIS
    ma_pcm_deinterleave_f32__reference(dst, src, frameCount, channels);
#else
    ma_pcm_deinterleave_f32__optimized(dst, src, frameCount, channels);
#endif
}


MA_API void ma_pcm_convert(void* pOut, ma_format formatOut, const void* pIn, ma_format formatIn, ma_uint64 sampleCount, ma_dither_mode ditherMode)
{
    if (formatOut == formatIn) {
        ma_copy_memory_64(pOut, pIn, sampleCount * ma_get_bytes_per_sample(formatOut));
        return;
    }

    switch (formatIn)
    {
        case ma_format_u8:
        {
            switch (formatOut)
            {
                case ma_format_s16: ma_pcm_u8_to_s16(pOut, pIn, sampleCount, ditherMode); return;
                case ma_format_s24: ma_pcm_u8_to_s24(pOut, pIn, sampleCount, ditherMode); return;
                case ma_format_s32: ma_pcm_u8_to_s32(pOut, pIn, sampleCount, ditherMode); return;
                case ma_format_f32: ma_pcm_u8_to_f32(pOut, pIn, sampleCount, ditherMode); return;
                default: break;
            }
        } break;

        case ma_format_s16:
        {
            switch (formatOut)
            {
                case ma_format_u8:  ma_pcm_s16_to_u8( pOut, pIn, sampleCount, ditherMode); return;
                case ma_format_s24: ma_pcm_s16_to_s24(pOut, pIn, sampleCount, ditherMode); return;
                case ma_format_s32: ma_pcm_s16_to_s32(pOut, pIn, sampleCount, ditherMode); return;
                case ma_format_f32: ma_pcm_s16_to_f32(pOut, pIn, sampleCount, ditherMode); return;
                default: break;
            }
        } break;

        case ma_format_s24:
        {
            switch (formatOut)
            {
                case ma_format_u8:  ma_pcm_s24_to_u8( pOut, pIn, sampleCount, ditherMode); return;
                case ma_format_s16: ma_pcm_s24_to_s16(pOut, pIn, sampleCount, ditherMode); return;
                case ma_format_s32: ma_pcm_s24_to_s32(pOut, pIn, sampleCount, ditherMode); return;
                case ma_format_f32: ma_pcm_s24_to_f32(pOut, pIn, sampleCount, ditherMode); return;
                default: break;
            }
        } break;

        case ma_format_s32:
        {
            switch (formatOut)
            {
                case ma_format_u8:  ma_pcm_s32_to_u8( pOut, pIn, sampleCount, ditherMode); return;
                case ma_format_s16: ma_pcm_s32_to_s16(pOut, pIn, sampleCount, ditherMode); return;
                case ma_format_s24: ma_pcm_s32_to_s24(pOut, pIn, sampleCount, ditherMode); return;
                case ma_format_f32: ma_pcm_s32_to_f32(pOut, pIn, sampleCount, ditherMode); return;
                default: break;
            }
        } break;

        case ma_format_f32:
        {
            switch (formatOut)
            {
                case ma_format_u8:  ma_pcm_f32_to_u8( pOut, pIn, sampleCount, ditherMode); return;
                case ma_format_s16: ma_pcm_f32_to_s16(pOut, pIn, sampleCount, ditherMode); return;
                case ma_format_s24: ma_pcm_f32_to_s24(pOut, pIn, sampleCount, ditherMode); return;
                case ma_format_s32: ma_pcm_f32_to_s32(pOut, pIn, sampleCount, ditherMode); return;
                default: break;
            }
        } break;

        default: break;
    }
}

MA_API void ma_convert_pcm_frames_format(void* pOut, ma_format formatOut, const void* pIn, ma_format formatIn, ma_uint64 frameCount, ma_uint32 channels, ma_dither_mode ditherMode)
{
    ma_pcm_convert(pOut, formatOut, pIn, formatIn, frameCount * channels, ditherMode);
}

MA_API void ma_deinterleave_pcm_frames(ma_format format, ma_uint32 channels, ma_uint64 frameCount, const void* pInterleavedPCMFrames, void** ppDeinterleavedPCMFrames)
{
    if (pInterleavedPCMFrames == NULL || ppDeinterleavedPCMFrames == NULL) {
        return; /* Invalid args. */
    }

    /* For efficiency we do this per format. */
    switch (format) {
        case ma_format_s16:
        {
            const ma_int16* pSrcS16 = (const ma_int16*)pInterleavedPCMFrames;
            ma_uint64 iPCMFrame;
            for (iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
                ma_uint32 iChannel;
                for (iChannel = 0; iChannel < channels; ++iChannel) {
                    ma_int16* pDstS16 = (ma_int16*)ppDeinterleavedPCMFrames[iChannel];
                    pDstS16[iPCMFrame] = pSrcS16[iPCMFrame*channels+iChannel];
                }
            }
        } break;

        case ma_format_f32:
        {
            const float* pSrcF32 = (const float*)pInterleavedPCMFrames;
            ma_uint64 iPCMFrame;
            for (iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
                ma_uint32 iChannel;
                for (iChannel = 0; iChannel < channels; ++iChannel) {
                    float* pDstF32 = (float*)ppDeinterleavedPCMFrames[iChannel];
                    pDstF32[iPCMFrame] = pSrcF32[iPCMFrame*channels+iChannel];
                }
            }
        } break;

        default:
        {
            ma_uint32 sampleSizeInBytes = ma_get_bytes_per_sample(format);
            ma_uint64 iPCMFrame;
            for (iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
                ma_uint32 iChannel;
                for (iChannel = 0; iChannel < channels; ++iChannel) {
                          void* pDst = ma_offset_ptr(ppDeinterleavedPCMFrames[iChannel], iPCMFrame*sampleSizeInBytes);
                    const void* pSrc = ma_offset_ptr(pInterleavedPCMFrames, (iPCMFrame*channels+iChannel)*sampleSizeInBytes);
                    memcpy(pDst, pSrc, sampleSizeInBytes);
                }
            }
        } break;
    }
}

MA_API void ma_interleave_pcm_frames(ma_format format, ma_uint32 channels, ma_uint64 frameCount, const void** ppDeinterleavedPCMFrames, void* pInterleavedPCMFrames)
{
    switch (format)
    {
        case ma_format_s16:
        {
            ma_int16* pDstS16 = (ma_int16*)pInterleavedPCMFrames;
            ma_uint64 iPCMFrame;
            for (iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
                ma_uint32 iChannel;
                for (iChannel = 0; iChannel < channels; ++iChannel) {
                    const ma_int16* pSrcS16 = (const ma_int16*)ppDeinterleavedPCMFrames[iChannel];
                    pDstS16[iPCMFrame*channels+iChannel] = pSrcS16[iPCMFrame];
                }
            }
        } break;

        case ma_format_f32:
        {
            float* pDstF32 = (float*)pInterleavedPCMFrames;
            ma_uint64 iPCMFrame;
            for (iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
                ma_uint32 iChannel;
                for (iChannel = 0; iChannel < channels; ++iChannel) {
                    const float* pSrcF32 = (const float*)ppDeinterleavedPCMFrames[iChannel];
                    pDstF32[iPCMFrame*channels+iChannel] = pSrcF32[iPCMFrame];
                }
            }
        } break;

        default:
        {
            ma_uint32 sampleSizeInBytes = ma_get_bytes_per_sample(format);
            ma_uint64 iPCMFrame;
            for (iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
                ma_uint32 iChannel;
                for (iChannel = 0; iChannel < channels; ++iChannel) {
                          void* pDst = ma_offset_ptr(pInterleavedPCMFrames, (iPCMFrame*channels+iChannel)*sampleSizeInBytes);
                    const void* pSrc = ma_offset_ptr(ppDeinterleavedPCMFrames[iChannel], iPCMFrame*sampleSizeInBytes);
                    memcpy(pDst, pSrc, sampleSizeInBytes);
                }
            }
        } break;
    }
}


/**************************************************************************************************************************************************************

Biquad Filter

**************************************************************************************************************************************************************/
#ifndef MA_BIQUAD_FIXED_POINT_SHIFT
#define MA_BIQUAD_FIXED_POINT_SHIFT 14
#endif

static ma_int32 ma_biquad_float_to_fp(double x)
{
    return (ma_int32)(x * (1 << MA_BIQUAD_FIXED_POINT_SHIFT));
}

MA_API ma_biquad_config ma_biquad_config_init(ma_format format, ma_uint32 channels, double b0, double b1, double b2, double a0, double a1, double a2)
{
    ma_biquad_config config;

    MA_ZERO_OBJECT(&config);
    config.format = format;
    config.channels = channels;
    config.b0 = b0;
    config.b1 = b1;
    config.b2 = b2;
    config.a0 = a0;
    config.a1 = a1;
    config.a2 = a2;

    return config;
}


typedef struct
{
    size_t sizeInBytes;
    size_t r1Offset;
    size_t r2Offset;
} ma_biquad_heap_layout;

static ma_result ma_biquad_get_heap_layout(const ma_biquad_config* pConfig, ma_biquad_heap_layout* pHeapLayout)
{
    MA_ASSERT(pHeapLayout != NULL);

    MA_ZERO_OBJECT(pHeapLayout);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->channels == 0) {
        return MA_INVALID_ARGS;
    }

    pHeapLayout->sizeInBytes = 0;

    /* R0 */
    pHeapLayout->r1Offset = pHeapLayout->sizeInBytes;
    pHeapLayout->sizeInBytes += sizeof(ma_biquad_coefficient) * pConfig->channels;

    /* R1 */
    pHeapLayout->r2Offset = pHeapLayout->sizeInBytes;
    pHeapLayout->sizeInBytes += sizeof(ma_biquad_coefficient) * pConfig->channels;

    /* Make sure allocation size is aligned. */
    pHeapLayout->sizeInBytes = ma_align_64(pHeapLayout->sizeInBytes);

    return MA_SUCCESS;
}

MA_API ma_result ma_biquad_get_heap_size(const ma_biquad_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_biquad_heap_layout heapLayout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = 0;

    result = ma_biquad_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pHeapSizeInBytes = heapLayout.sizeInBytes;

    return MA_SUCCESS;
}

MA_API ma_result ma_biquad_init_preallocated(const ma_biquad_config* pConfig, void* pHeap, ma_biquad* pBQ)
{
    ma_result result;
    ma_biquad_heap_layout heapLayout;

    if (pBQ == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pBQ);

    result = ma_biquad_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    pBQ->_pHeap = pHeap;
    MA_ZERO_MEMORY(pHeap, heapLayout.sizeInBytes);

    pBQ->pR1 = (ma_biquad_coefficient*)ma_offset_ptr(pHeap, heapLayout.r1Offset);
    pBQ->pR2 = (ma_biquad_coefficient*)ma_offset_ptr(pHeap, heapLayout.r2Offset);

    return ma_biquad_reinit(pConfig, pBQ);
}

MA_API ma_result ma_biquad_init(const ma_biquad_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_biquad* pBQ)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_biquad_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_biquad_init_preallocated(pConfig, pHeap, pBQ);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pBQ->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_biquad_uninit(ma_biquad* pBQ, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pBQ == NULL) {
        return;
    }

    if (pBQ->_ownsHeap) {
        ma_free(pBQ->_pHeap, pAllocationCallbacks);
    }
}

MA_API ma_result ma_biquad_reinit(const ma_biquad_config* pConfig, ma_biquad* pBQ)
{
    if (pBQ == NULL || pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->a0 == 0) {
        return MA_INVALID_ARGS; /* Division by zero. */
    }

    /* Only supporting f32 and s16. */
    if (pConfig->format != ma_format_f32 && pConfig->format != ma_format_s16) {
        return MA_INVALID_ARGS;
    }

    /* The format cannot be changed after initialization. */
    if (pBQ->format != ma_format_unknown && pBQ->format != pConfig->format) {
        return MA_INVALID_OPERATION;
    }

    /* The channel count cannot be changed after initialization. */
    if (pBQ->channels != 0 && pBQ->channels != pConfig->channels) {
        return MA_INVALID_OPERATION;
    }


    pBQ->format   = pConfig->format;
    pBQ->channels = pConfig->channels;

    /* Normalize. */
    if (pConfig->format == ma_format_f32) {
        pBQ->b0.f32 = (float)(pConfig->b0 / pConfig->a0);
        pBQ->b1.f32 = (float)(pConfig->b1 / pConfig->a0);
        pBQ->b2.f32 = (float)(pConfig->b2 / pConfig->a0);
        pBQ->a1.f32 = (float)(pConfig->a1 / pConfig->a0);
        pBQ->a2.f32 = (float)(pConfig->a2 / pConfig->a0);
    } else {
        pBQ->b0.s32 = ma_biquad_float_to_fp(pConfig->b0 / pConfig->a0);
        pBQ->b1.s32 = ma_biquad_float_to_fp(pConfig->b1 / pConfig->a0);
        pBQ->b2.s32 = ma_biquad_float_to_fp(pConfig->b2 / pConfig->a0);
        pBQ->a1.s32 = ma_biquad_float_to_fp(pConfig->a1 / pConfig->a0);
        pBQ->a2.s32 = ma_biquad_float_to_fp(pConfig->a2 / pConfig->a0);
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_biquad_clear_cache(ma_biquad* pBQ)
{
    if (pBQ == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pBQ->format == ma_format_f32) {
        pBQ->pR1->f32 = 0;
        pBQ->pR2->f32 = 0;
    } else {
        pBQ->pR1->s32 = 0;
        pBQ->pR2->s32 = 0;
    }

    return MA_SUCCESS;
}

static MA_INLINE void ma_biquad_process_pcm_frame_f32__direct_form_2_transposed(ma_biquad* pBQ, float* pY, const float* pX)
{
    ma_uint32 c;
    const ma_uint32 channels = pBQ->channels;
    const float b0 = pBQ->b0.f32;
    const float b1 = pBQ->b1.f32;
    const float b2 = pBQ->b2.f32;
    const float a1 = pBQ->a1.f32;
    const float a2 = pBQ->a2.f32;

    MA_ASSUME(channels > 0);
    for (c = 0; c < channels; c += 1) {
        float r1 = pBQ->pR1[c].f32;
        float r2 = pBQ->pR2[c].f32;
        float x  = pX[c];
        float y;

        y  = b0*x        + r1;
        r1 = b1*x - a1*y + r2;
        r2 = b2*x - a2*y;

        pY[c]           = y;
        pBQ->pR1[c].f32 = r1;
        pBQ->pR2[c].f32 = r2;
    }
}

static MA_INLINE void ma_biquad_process_pcm_frame_f32(ma_biquad* pBQ, float* pY, const float* pX)
{
    ma_biquad_process_pcm_frame_f32__direct_form_2_transposed(pBQ, pY, pX);
}

static MA_INLINE void ma_biquad_process_pcm_frame_s16__direct_form_2_transposed(ma_biquad* pBQ, ma_int16* pY, const ma_int16* pX)
{
    ma_uint32 c;
    const ma_uint32 channels = pBQ->channels;
    const ma_int32 b0 = pBQ->b0.s32;
    const ma_int32 b1 = pBQ->b1.s32;
    const ma_int32 b2 = pBQ->b2.s32;
    const ma_int32 a1 = pBQ->a1.s32;
    const ma_int32 a2 = pBQ->a2.s32;

    MA_ASSUME(channels > 0);
    for (c = 0; c < channels; c += 1) {
        ma_int32 r1 = pBQ->pR1[c].s32;
        ma_int32 r2 = pBQ->pR2[c].s32;
        ma_int32 x  = pX[c];
        ma_int32 y;

        y  = (b0*x        + r1) >> MA_BIQUAD_FIXED_POINT_SHIFT;
        r1 = (b1*x - a1*y + r2);
        r2 = (b2*x - a2*y);

        pY[c]           = (ma_int16)ma_clamp(y, -32768, 32767);
        pBQ->pR1[c].s32 = r1;
        pBQ->pR2[c].s32 = r2;
    }
}

static MA_INLINE void ma_biquad_process_pcm_frame_s16(ma_biquad* pBQ, ma_int16* pY, const ma_int16* pX)
{
    ma_biquad_process_pcm_frame_s16__direct_form_2_transposed(pBQ, pY, pX);
}

MA_API ma_result ma_biquad_process_pcm_frames(ma_biquad* pBQ, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    ma_uint32 n;

    if (pBQ == NULL || pFramesOut == NULL || pFramesIn == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Note that the logic below needs to support in-place filtering. That is, it must support the case where pFramesOut and pFramesIn are the same. */

    if (pBQ->format == ma_format_f32) {
        /* */ float* pY = (      float*)pFramesOut;
        const float* pX = (const float*)pFramesIn;

        for (n = 0; n < frameCount; n += 1) {
            ma_biquad_process_pcm_frame_f32__direct_form_2_transposed(pBQ, pY, pX);
            pY += pBQ->channels;
            pX += pBQ->channels;
        }
    } else if (pBQ->format == ma_format_s16) {
        /* */ ma_int16* pY = (      ma_int16*)pFramesOut;
        const ma_int16* pX = (const ma_int16*)pFramesIn;

        for (n = 0; n < frameCount; n += 1) {
            ma_biquad_process_pcm_frame_s16__direct_form_2_transposed(pBQ, pY, pX);
            pY += pBQ->channels;
            pX += pBQ->channels;
        }
    } else {
        MA_ASSERT(MA_FALSE);
        return MA_INVALID_ARGS; /* Format not supported. Should never hit this because it's checked in ma_biquad_init() and ma_biquad_reinit(). */
    }

    return MA_SUCCESS;
}

MA_API ma_uint32 ma_biquad_get_latency(const ma_biquad* pBQ)
{
    if (pBQ == NULL) {
        return 0;
    }

    return 2;
}


/**************************************************************************************************************************************************************

Low-Pass Filter

**************************************************************************************************************************************************************/
MA_API ma_lpf1_config ma_lpf1_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency)
{
    ma_lpf1_config config;

    MA_ZERO_OBJECT(&config);
    config.format = format;
    config.channels = channels;
    config.sampleRate = sampleRate;
    config.cutoffFrequency = cutoffFrequency;
    config.q = 0.5;

    return config;
}

MA_API ma_lpf2_config ma_lpf2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, double q)
{
    ma_lpf2_config config;

    MA_ZERO_OBJECT(&config);
    config.format = format;
    config.channels = channels;
    config.sampleRate = sampleRate;
    config.cutoffFrequency = cutoffFrequency;
    config.q = q;

    /* Q cannot be 0 or else it'll result in a division by 0. In this case just default to 0.707107. */
    if (config.q == 0) {
        config.q = 0.707107;
    }

    return config;
}


typedef struct
{
    size_t sizeInBytes;
    size_t r1Offset;
} ma_lpf1_heap_layout;

static ma_result ma_lpf1_get_heap_layout(const ma_lpf1_config* pConfig, ma_lpf1_heap_layout* pHeapLayout)
{
    MA_ASSERT(pHeapLayout != NULL);

    MA_ZERO_OBJECT(pHeapLayout);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->channels == 0) {
        return MA_INVALID_ARGS;
    }

    pHeapLayout->sizeInBytes = 0;

    /* R1 */
    pHeapLayout->r1Offset = pHeapLayout->sizeInBytes;
    pHeapLayout->sizeInBytes += sizeof(ma_biquad_coefficient) * pConfig->channels;

    /* Make sure allocation size is aligned. */
    pHeapLayout->sizeInBytes = ma_align_64(pHeapLayout->sizeInBytes);

    return MA_SUCCESS;
}

MA_API ma_result ma_lpf1_get_heap_size(const ma_lpf1_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_lpf1_heap_layout heapLayout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    result = ma_lpf1_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pHeapSizeInBytes = heapLayout.sizeInBytes;

    return MA_SUCCESS;
}

MA_API ma_result ma_lpf1_init_preallocated(const ma_lpf1_config* pConfig, void* pHeap, ma_lpf1* pLPF)
{
    ma_result result;
    ma_lpf1_heap_layout heapLayout;

    if (pLPF == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pLPF);

    result = ma_lpf1_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    pLPF->_pHeap = pHeap;
    MA_ZERO_MEMORY(pHeap, heapLayout.sizeInBytes);

    pLPF->pR1 = (ma_biquad_coefficient*)ma_offset_ptr(pHeap, heapLayout.r1Offset);

    return ma_lpf1_reinit(pConfig, pLPF);
}

MA_API ma_result ma_lpf1_init(const ma_lpf1_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_lpf1* pLPF)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_lpf1_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_lpf1_init_preallocated(pConfig, pHeap, pLPF);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pLPF->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_lpf1_uninit(ma_lpf1* pLPF, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pLPF == NULL) {
        return;
    }

    if (pLPF->_ownsHeap) {
        ma_free(pLPF->_pHeap, pAllocationCallbacks);
    }
}

MA_API ma_result ma_lpf1_reinit(const ma_lpf1_config* pConfig, ma_lpf1* pLPF)
{
    double a;

    if (pLPF == NULL || pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Only supporting f32 and s16. */
    if (pConfig->format != ma_format_f32 && pConfig->format != ma_format_s16) {
        return MA_INVALID_ARGS;
    }

    /* The format cannot be changed after initialization. */
    if (pLPF->format != ma_format_unknown && pLPF->format != pConfig->format) {
        return MA_INVALID_OPERATION;
    }

    /* The channel count cannot be changed after initialization. */
    if (pLPF->channels != 0 && pLPF->channels != pConfig->channels) {
        return MA_INVALID_OPERATION;
    }

    pLPF->format   = pConfig->format;
    pLPF->channels = pConfig->channels;

    a = ma_expd(-2 * MA_PI_D * pConfig->cutoffFrequency / pConfig->sampleRate);
    if (pConfig->format == ma_format_f32) {
        pLPF->a.f32 = (float)a;
    } else {
        pLPF->a.s32 = ma_biquad_float_to_fp(a);
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_lpf1_clear_cache(ma_lpf1* pLPF)
{
    if (pLPF == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pLPF->format == ma_format_f32) {
        pLPF->a.f32 = 0;
    } else {
        pLPF->a.s32 = 0;
    }

    return MA_SUCCESS;
}

static MA_INLINE void ma_lpf1_process_pcm_frame_f32(ma_lpf1* pLPF, float* pY, const float* pX)
{
    ma_uint32 c;
    const ma_uint32 channels = pLPF->channels;
    const float a = pLPF->a.f32;
    const float b = 1 - a;

    MA_ASSUME(channels > 0);
    for (c = 0; c < channels; c += 1) {
        float r1 = pLPF->pR1[c].f32;
        float x  = pX[c];
        float y;

        y = b*x + a*r1;

        pY[c]           = y;
        pLPF->pR1[c].f32 = y;
    }
}

static MA_INLINE void ma_lpf1_process_pcm_frame_s16(ma_lpf1* pLPF, ma_int16* pY, const ma_int16* pX)
{
    ma_uint32 c;
    const ma_uint32 channels = pLPF->channels;
    const ma_int32 a = pLPF->a.s32;
    const ma_int32 b = ((1 << MA_BIQUAD_FIXED_POINT_SHIFT) - a);

    MA_ASSUME(channels > 0);
    for (c = 0; c < channels; c += 1) {
        ma_int32 r1 = pLPF->pR1[c].s32;
        ma_int32 x  = pX[c];
        ma_int32 y;

        y = (b*x + a*r1) >> MA_BIQUAD_FIXED_POINT_SHIFT;

        pY[c]            = (ma_int16)y;
        pLPF->pR1[c].s32 = (ma_int32)y;
    }
}

MA_API ma_result ma_lpf1_process_pcm_frames(ma_lpf1* pLPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    ma_uint32 n;

    if (pLPF == NULL || pFramesOut == NULL || pFramesIn == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Note that the logic below needs to support in-place filtering. That is, it must support the case where pFramesOut and pFramesIn are the same. */

    if (pLPF->format == ma_format_f32) {
        /* */ float* pY = (      float*)pFramesOut;
        const float* pX = (const float*)pFramesIn;

        for (n = 0; n < frameCount; n += 1) {
            ma_lpf1_process_pcm_frame_f32(pLPF, pY, pX);
            pY += pLPF->channels;
            pX += pLPF->channels;
        }
    } else if (pLPF->format == ma_format_s16) {
        /* */ ma_int16* pY = (      ma_int16*)pFramesOut;
        const ma_int16* pX = (const ma_int16*)pFramesIn;

        for (n = 0; n < frameCount; n += 1) {
            ma_lpf1_process_pcm_frame_s16(pLPF, pY, pX);
            pY += pLPF->channels;
            pX += pLPF->channels;
        }
    } else {
        MA_ASSERT(MA_FALSE);
        return MA_INVALID_ARGS; /* Format not supported. Should never hit this because it's checked in ma_biquad_init() and ma_biquad_reinit(). */
    }

    return MA_SUCCESS;
}

MA_API ma_uint32 ma_lpf1_get_latency(const ma_lpf1* pLPF)
{
    if (pLPF == NULL) {
        return 0;
    }

    return 1;
}


static MA_INLINE ma_biquad_config ma_lpf2__get_biquad_config(const ma_lpf2_config* pConfig)
{
    ma_biquad_config bqConfig;
    double q;
    double w;
    double s;
    double c;
    double a;

    MA_ASSERT(pConfig != NULL);

    q = pConfig->q;
    w = 2 * MA_PI_D * pConfig->cutoffFrequency / pConfig->sampleRate;
    s = ma_sind(w);
    c = ma_cosd(w);
    a = s / (2*q);

    bqConfig.b0 = (1 - c) / 2;
    bqConfig.b1 =  1 - c;
    bqConfig.b2 = (1 - c) / 2;
    bqConfig.a0 =  1 + a;
    bqConfig.a1 = -2 * c;
    bqConfig.a2 =  1 - a;

    bqConfig.format   = pConfig->format;
    bqConfig.channels = pConfig->channels;

    return bqConfig;
}

MA_API ma_result ma_lpf2_get_heap_size(const ma_lpf2_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_biquad_config bqConfig;
    bqConfig = ma_lpf2__get_biquad_config(pConfig);

    return ma_biquad_get_heap_size(&bqConfig, pHeapSizeInBytes);
}

MA_API ma_result ma_lpf2_init_preallocated(const ma_lpf2_config* pConfig, void* pHeap, ma_lpf2* pLPF)
{
    ma_result result;
    ma_biquad_config bqConfig;

    if (pLPF == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pLPF);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    bqConfig = ma_lpf2__get_biquad_config(pConfig);
    result = ma_biquad_init_preallocated(&bqConfig, pHeap, &pLPF->bq);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_lpf2_init(const ma_lpf2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_lpf2* pLPF)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_lpf2_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_lpf2_init_preallocated(pConfig, pHeap, pLPF);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pLPF->bq._ownsHeap = MA_TRUE;    /* <-- This will cause the biquad to take ownership of the heap and free it when it's uninitialized. */
    return MA_SUCCESS;
}

MA_API void ma_lpf2_uninit(ma_lpf2* pLPF, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pLPF == NULL) {
        return;
    }

    ma_biquad_uninit(&pLPF->bq, pAllocationCallbacks);   /* <-- This will free the heap allocation. */
}

MA_API ma_result ma_lpf2_reinit(const ma_lpf2_config* pConfig, ma_lpf2* pLPF)
{
    ma_result result;
    ma_biquad_config bqConfig;

    if (pLPF == NULL || pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    bqConfig = ma_lpf2__get_biquad_config(pConfig);
    result = ma_biquad_reinit(&bqConfig, &pLPF->bq);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_lpf2_clear_cache(ma_lpf2* pLPF)
{
    if (pLPF == NULL) {
        return MA_INVALID_ARGS;
    }

    ma_biquad_clear_cache(&pLPF->bq);

    return MA_SUCCESS;
}

static MA_INLINE void ma_lpf2_process_pcm_frame_s16(ma_lpf2* pLPF, ma_int16* pFrameOut, const ma_int16* pFrameIn)
{
    ma_biquad_process_pcm_frame_s16(&pLPF->bq, pFrameOut, pFrameIn);
}

static MA_INLINE void ma_lpf2_process_pcm_frame_f32(ma_lpf2* pLPF, float* pFrameOut, const float* pFrameIn)
{
    ma_biquad_process_pcm_frame_f32(&pLPF->bq, pFrameOut, pFrameIn);
}

MA_API ma_result ma_lpf2_process_pcm_frames(ma_lpf2* pLPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    if (pLPF == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_biquad_process_pcm_frames(&pLPF->bq, pFramesOut, pFramesIn, frameCount);
}

MA_API ma_uint32 ma_lpf2_get_latency(const ma_lpf2* pLPF)
{
    if (pLPF == NULL) {
        return 0;
    }

    return ma_biquad_get_latency(&pLPF->bq);
}


MA_API ma_lpf_config ma_lpf_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order)
{
    ma_lpf_config config;

    MA_ZERO_OBJECT(&config);
    config.format          = format;
    config.channels        = channels;
    config.sampleRate      = sampleRate;
    config.cutoffFrequency = cutoffFrequency;
    config.order           = ma_min(order, MA_MAX_FILTER_ORDER);

    return config;
}


typedef struct
{
    size_t sizeInBytes;
    size_t lpf1Offset;
    size_t lpf2Offset;  /* Offset of the first second order filter. Subsequent filters will come straight after, and will each have the same heap size. */
} ma_lpf_heap_layout;

static void ma_lpf_calculate_sub_lpf_counts(ma_uint32 order, ma_uint32* pLPF1Count, ma_uint32* pLPF2Count)
{
    MA_ASSERT(pLPF1Count != NULL);
    MA_ASSERT(pLPF2Count != NULL);

    *pLPF1Count = order % 2;
    *pLPF2Count = order / 2;
}

static ma_result ma_lpf_get_heap_layout(const ma_lpf_config* pConfig, ma_lpf_heap_layout* pHeapLayout)
{
    ma_result result;
    ma_uint32 lpf1Count;
    ma_uint32 lpf2Count;
    ma_uint32 ilpf1;
    ma_uint32 ilpf2;

    MA_ASSERT(pHeapLayout != NULL);

    MA_ZERO_OBJECT(pHeapLayout);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->channels == 0) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->order > MA_MAX_FILTER_ORDER) {
        return MA_INVALID_ARGS;
    }

    ma_lpf_calculate_sub_lpf_counts(pConfig->order, &lpf1Count, &lpf2Count);

    pHeapLayout->sizeInBytes = 0;

    /* LPF 1 */
    pHeapLayout->lpf1Offset = pHeapLayout->sizeInBytes;
    for (ilpf1 = 0; ilpf1 < lpf1Count; ilpf1 += 1) {
        size_t lpf1HeapSizeInBytes;
        ma_lpf1_config lpf1Config = ma_lpf1_config_init(pConfig->format, pConfig->channels, pConfig->sampleRate, pConfig->cutoffFrequency);

        result = ma_lpf1_get_heap_size(&lpf1Config, &lpf1HeapSizeInBytes);
        if (result != MA_SUCCESS) {
            return result;
        }

        pHeapLayout->sizeInBytes += sizeof(ma_lpf1) + lpf1HeapSizeInBytes;
    }

    /* LPF 2*/
    pHeapLayout->lpf2Offset = pHeapLayout->sizeInBytes;
    for (ilpf2 = 0; ilpf2 < lpf2Count; ilpf2 += 1) {
        size_t lpf2HeapSizeInBytes;
        ma_lpf2_config lpf2Config = ma_lpf2_config_init(pConfig->format, pConfig->channels, pConfig->sampleRate, pConfig->cutoffFrequency, 0.707107);   /* <-- The "q" parameter does not matter for the purpose of calculating the heap size. */

        result = ma_lpf2_get_heap_size(&lpf2Config, &lpf2HeapSizeInBytes);
        if (result != MA_SUCCESS) {
            return result;
        }

        pHeapLayout->sizeInBytes += sizeof(ma_lpf2) + lpf2HeapSizeInBytes;
    }

    /* Make sure allocation size is aligned. */
    pHeapLayout->sizeInBytes = ma_align_64(pHeapLayout->sizeInBytes);

    return MA_SUCCESS;
}

static ma_result ma_lpf_reinit__internal(const ma_lpf_config* pConfig, void* pHeap, ma_lpf* pLPF, ma_bool32 isNew)
{
    ma_result result;
    ma_uint32 lpf1Count;
    ma_uint32 lpf2Count;
    ma_uint32 ilpf1;
    ma_uint32 ilpf2;
    ma_lpf_heap_layout heapLayout;  /* Only used if isNew is true. */

    if (pLPF == NULL || pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Only supporting f32 and s16. */
    if (pConfig->format != ma_format_f32 && pConfig->format != ma_format_s16) {
        return MA_INVALID_ARGS;
    }

    /* The format cannot be changed after initialization. */
    if (pLPF->format != ma_format_unknown && pLPF->format != pConfig->format) {
        return MA_INVALID_OPERATION;
    }

    /* The channel count cannot be changed after initialization. */
    if (pLPF->channels != 0 && pLPF->channels != pConfig->channels) {
        return MA_INVALID_OPERATION;
    }

    if (pConfig->order > MA_MAX_FILTER_ORDER) {
        return MA_INVALID_ARGS;
    }

    ma_lpf_calculate_sub_lpf_counts(pConfig->order, &lpf1Count, &lpf2Count);

    /* The filter order can't change between reinits. */
    if (!isNew) {
        if (pLPF->lpf1Count != lpf1Count || pLPF->lpf2Count != lpf2Count) {
            return MA_INVALID_OPERATION;
        }
    }

    if (isNew) {
        result = ma_lpf_get_heap_layout(pConfig, &heapLayout);
        if (result != MA_SUCCESS) {
            return result;
        }

        pLPF->_pHeap = pHeap;
        MA_ZERO_MEMORY(pHeap, heapLayout.sizeInBytes);

        pLPF->pLPF1 = (ma_lpf1*)ma_offset_ptr(pHeap, heapLayout.lpf1Offset);
        pLPF->pLPF2 = (ma_lpf2*)ma_offset_ptr(pHeap, heapLayout.lpf2Offset);
    } else {
        MA_ZERO_OBJECT(&heapLayout);    /* To silence a compiler warning. */
    }

    for (ilpf1 = 0; ilpf1 < lpf1Count; ilpf1 += 1) {
        ma_lpf1_config lpf1Config = ma_lpf1_config_init(pConfig->format, pConfig->channels, pConfig->sampleRate, pConfig->cutoffFrequency);

        if (isNew) {
            size_t lpf1HeapSizeInBytes;

            result = ma_lpf1_get_heap_size(&lpf1Config, &lpf1HeapSizeInBytes);
            if (result == MA_SUCCESS) {
                result = ma_lpf1_init_preallocated(&lpf1Config, ma_offset_ptr(pHeap, heapLayout.lpf1Offset + (sizeof(ma_lpf1) * lpf1Count) + (ilpf1 * lpf1HeapSizeInBytes)), &pLPF->pLPF1[ilpf1]);
            }
        } else {
            result = ma_lpf1_reinit(&lpf1Config, &pLPF->pLPF1[ilpf1]);
        }

        if (result != MA_SUCCESS) {
            ma_uint32 jlpf1;

            for (jlpf1 = 0; jlpf1 < ilpf1; jlpf1 += 1) {
                ma_lpf1_uninit(&pLPF->pLPF1[jlpf1], NULL);  /* No need for allocation callbacks here since we used a preallocated heap allocation. */
            }

            return result;
        }
    }

    for (ilpf2 = 0; ilpf2 < lpf2Count; ilpf2 += 1) {
        ma_lpf2_config lpf2Config;
        double q;
        double a;

        /* Tempting to use 0.707107, but won't result in a Butterworth filter if the order is > 2. */
        if (lpf1Count == 1) {
            a = (1 + ilpf2*1) * (MA_PI_D/(pConfig->order*1));   /* Odd order. */
        } else {
            a = (1 + ilpf2*2) * (MA_PI_D/(pConfig->order*2));   /* Even order. */
        }
        q = 1 / (2*ma_cosd(a));

        lpf2Config = ma_lpf2_config_init(pConfig->format, pConfig->channels, pConfig->sampleRate, pConfig->cutoffFrequency, q);

        if (isNew) {
            size_t lpf2HeapSizeInBytes;

            result = ma_lpf2_get_heap_size(&lpf2Config, &lpf2HeapSizeInBytes);
            if (result == MA_SUCCESS) {
                result = ma_lpf2_init_preallocated(&lpf2Config, ma_offset_ptr(pHeap, heapLayout.lpf2Offset + (sizeof(ma_lpf2) * lpf2Count) + (ilpf2 * lpf2HeapSizeInBytes)), &pLPF->pLPF2[ilpf2]);
            }
        } else {
            result = ma_lpf2_reinit(&lpf2Config, &pLPF->pLPF2[ilpf2]);
        }

        if (result != MA_SUCCESS) {
            ma_uint32 jlpf1;
            ma_uint32 jlpf2;

            for (jlpf1 = 0; jlpf1 < lpf1Count; jlpf1 += 1) {
                ma_lpf1_uninit(&pLPF->pLPF1[jlpf1], NULL);  /* No need for allocation callbacks here since we used a preallocated heap allocation. */
            }

            for (jlpf2 = 0; jlpf2 < ilpf2; jlpf2 += 1) {
                ma_lpf2_uninit(&pLPF->pLPF2[jlpf2], NULL);  /* No need for allocation callbacks here since we used a preallocated heap allocation. */
            }

            return result;
        }
    }

    pLPF->lpf1Count  = lpf1Count;
    pLPF->lpf2Count  = lpf2Count;
    pLPF->format     = pConfig->format;
    pLPF->channels   = pConfig->channels;
    pLPF->sampleRate = pConfig->sampleRate;

    return MA_SUCCESS;
}

MA_API ma_result ma_lpf_get_heap_size(const ma_lpf_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_lpf_heap_layout heapLayout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = 0;

    result = ma_lpf_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pHeapSizeInBytes = heapLayout.sizeInBytes;

    return result;
}

MA_API ma_result ma_lpf_init_preallocated(const ma_lpf_config* pConfig, void* pHeap, ma_lpf* pLPF)
{
    if (pLPF == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pLPF);

    return ma_lpf_reinit__internal(pConfig, pHeap, pLPF, /*isNew*/MA_TRUE);
}

MA_API ma_result ma_lpf_init(const ma_lpf_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_lpf* pLPF)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_lpf_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_lpf_init_preallocated(pConfig, pHeap, pLPF);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pLPF->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_lpf_uninit(ma_lpf* pLPF, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_uint32 ilpf1;
    ma_uint32 ilpf2;

    if (pLPF == NULL) {
        return;
    }

    for (ilpf1 = 0; ilpf1 < pLPF->lpf1Count; ilpf1 += 1) {
        ma_lpf1_uninit(&pLPF->pLPF1[ilpf1], pAllocationCallbacks);
    }

    for (ilpf2 = 0; ilpf2 < pLPF->lpf2Count; ilpf2 += 1) {
        ma_lpf2_uninit(&pLPF->pLPF2[ilpf2], pAllocationCallbacks);
    }

    if (pLPF->_ownsHeap) {
        ma_free(pLPF->_pHeap, pAllocationCallbacks);
    }
}

MA_API ma_result ma_lpf_reinit(const ma_lpf_config* pConfig, ma_lpf* pLPF)
{
    return ma_lpf_reinit__internal(pConfig, NULL, pLPF, /*isNew*/MA_FALSE);
}

MA_API ma_result ma_lpf_clear_cache(ma_lpf* pLPF)
{
    ma_uint32 ilpf1;
    ma_uint32 ilpf2;

    if (pLPF == NULL) {
        return MA_INVALID_ARGS;
    }

    for (ilpf1 = 0; ilpf1 < pLPF->lpf1Count; ilpf1 += 1) {
        ma_lpf1_clear_cache(&pLPF->pLPF1[ilpf1]);
    }

    for (ilpf2 = 0; ilpf2 < pLPF->lpf2Count; ilpf2 += 1) {
        ma_lpf2_clear_cache(&pLPF->pLPF2[ilpf2]);
    }

    return MA_SUCCESS;
}

static MA_INLINE void ma_lpf_process_pcm_frame_f32(ma_lpf* pLPF, float* pY, const void* pX)
{
    ma_uint32 ilpf1;
    ma_uint32 ilpf2;

    MA_ASSERT(pLPF->format == ma_format_f32);

    MA_MOVE_MEMORY(pY, pX, ma_get_bytes_per_frame(pLPF->format, pLPF->channels));

    for (ilpf1 = 0; ilpf1 < pLPF->lpf1Count; ilpf1 += 1) {
        ma_lpf1_process_pcm_frame_f32(&pLPF->pLPF1[ilpf1], pY, pY);
    }

    for (ilpf2 = 0; ilpf2 < pLPF->lpf2Count; ilpf2 += 1) {
        ma_lpf2_process_pcm_frame_f32(&pLPF->pLPF2[ilpf2], pY, pY);
    }
}

static MA_INLINE void ma_lpf_process_pcm_frame_s16(ma_lpf* pLPF, ma_int16* pY, const ma_int16* pX)
{
    ma_uint32 ilpf1;
    ma_uint32 ilpf2;

    MA_ASSERT(pLPF->format == ma_format_s16);

    MA_MOVE_MEMORY(pY, pX, ma_get_bytes_per_frame(pLPF->format, pLPF->channels));

    for (ilpf1 = 0; ilpf1 < pLPF->lpf1Count; ilpf1 += 1) {
        ma_lpf1_process_pcm_frame_s16(&pLPF->pLPF1[ilpf1], pY, pY);
    }

    for (ilpf2 = 0; ilpf2 < pLPF->lpf2Count; ilpf2 += 1) {
        ma_lpf2_process_pcm_frame_s16(&pLPF->pLPF2[ilpf2], pY, pY);
    }
}

MA_API ma_result ma_lpf_process_pcm_frames(ma_lpf* pLPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    ma_result result;
    ma_uint32 ilpf1;
    ma_uint32 ilpf2;

    if (pLPF == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Faster path for in-place. */
    if (pFramesOut == pFramesIn) {
        for (ilpf1 = 0; ilpf1 < pLPF->lpf1Count; ilpf1 += 1) {
            result = ma_lpf1_process_pcm_frames(&pLPF->pLPF1[ilpf1], pFramesOut, pFramesOut, frameCount);
            if (result != MA_SUCCESS) {
                return result;
            }
        }

        for (ilpf2 = 0; ilpf2 < pLPF->lpf2Count; ilpf2 += 1) {
            result = ma_lpf2_process_pcm_frames(&pLPF->pLPF2[ilpf2], pFramesOut, pFramesOut, frameCount);
            if (result != MA_SUCCESS) {
                return result;
            }
        }
    }

    /* Slightly slower path for copying. */
    if (pFramesOut != pFramesIn) {
        ma_uint32 iFrame;

        /*  */ if (pLPF->format == ma_format_f32) {
            /* */ float* pFramesOutF32 = (      float*)pFramesOut;
            const float* pFramesInF32  = (const float*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                ma_lpf_process_pcm_frame_f32(pLPF, pFramesOutF32, pFramesInF32);
                pFramesOutF32 += pLPF->channels;
                pFramesInF32  += pLPF->channels;
            }
        } else if (pLPF->format == ma_format_s16) {
            /* */ ma_int16* pFramesOutS16 = (      ma_int16*)pFramesOut;
            const ma_int16* pFramesInS16  = (const ma_int16*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                ma_lpf_process_pcm_frame_s16(pLPF, pFramesOutS16, pFramesInS16);
                pFramesOutS16 += pLPF->channels;
                pFramesInS16  += pLPF->channels;
            }
        } else {
            MA_ASSERT(MA_FALSE);
            return MA_INVALID_OPERATION;    /* Should never hit this. */
        }
    }

    return MA_SUCCESS;
}

MA_API ma_uint32 ma_lpf_get_latency(const ma_lpf* pLPF)
{
    if (pLPF == NULL) {
        return 0;
    }

    return pLPF->lpf2Count*2 + pLPF->lpf1Count;
}


/**************************************************************************************************************************************************************

High-Pass Filtering

**************************************************************************************************************************************************************/
MA_API ma_hpf1_config ma_hpf1_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency)
{
    ma_hpf1_config config;

    MA_ZERO_OBJECT(&config);
    config.format = format;
    config.channels = channels;
    config.sampleRate = sampleRate;
    config.cutoffFrequency = cutoffFrequency;

    return config;
}

MA_API ma_hpf2_config ma_hpf2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, double q)
{
    ma_hpf2_config config;

    MA_ZERO_OBJECT(&config);
    config.format = format;
    config.channels = channels;
    config.sampleRate = sampleRate;
    config.cutoffFrequency = cutoffFrequency;
    config.q = q;

    /* Q cannot be 0 or else it'll result in a division by 0. In this case just default to 0.707107. */
    if (config.q == 0) {
        config.q = 0.707107;
    }

    return config;
}


typedef struct
{
    size_t sizeInBytes;
    size_t r1Offset;
} ma_hpf1_heap_layout;

static ma_result ma_hpf1_get_heap_layout(const ma_hpf1_config* pConfig, ma_hpf1_heap_layout* pHeapLayout)
{
    MA_ASSERT(pHeapLayout != NULL);

    MA_ZERO_OBJECT(pHeapLayout);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->channels == 0) {
        return MA_INVALID_ARGS;
    }

    pHeapLayout->sizeInBytes = 0;

    /* R1 */
    pHeapLayout->r1Offset = pHeapLayout->sizeInBytes;
    pHeapLayout->sizeInBytes += sizeof(ma_biquad_coefficient) * pConfig->channels;

    /* Make sure allocation size is aligned. */
    pHeapLayout->sizeInBytes = ma_align_64(pHeapLayout->sizeInBytes);

    return MA_SUCCESS;
}

MA_API ma_result ma_hpf1_get_heap_size(const ma_hpf1_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_hpf1_heap_layout heapLayout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    result = ma_hpf1_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pHeapSizeInBytes = heapLayout.sizeInBytes;

    return MA_SUCCESS;
}

MA_API ma_result ma_hpf1_init_preallocated(const ma_hpf1_config* pConfig, void* pHeap, ma_hpf1* pLPF)
{
    ma_result result;
    ma_hpf1_heap_layout heapLayout;

    if (pLPF == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pLPF);

    result = ma_hpf1_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    pLPF->_pHeap = pHeap;
    MA_ZERO_MEMORY(pHeap, heapLayout.sizeInBytes);

    pLPF->pR1 = (ma_biquad_coefficient*)ma_offset_ptr(pHeap, heapLayout.r1Offset);

    return ma_hpf1_reinit(pConfig, pLPF);
}

MA_API ma_result ma_hpf1_init(const ma_hpf1_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hpf1* pLPF)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_hpf1_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_hpf1_init_preallocated(pConfig, pHeap, pLPF);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pLPF->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_hpf1_uninit(ma_hpf1* pHPF, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pHPF == NULL) {
        return;
    }

    if (pHPF->_ownsHeap) {
        ma_free(pHPF->_pHeap, pAllocationCallbacks);
    }
}

MA_API ma_result ma_hpf1_reinit(const ma_hpf1_config* pConfig, ma_hpf1* pHPF)
{
    double a;

    if (pHPF == NULL || pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Only supporting f32 and s16. */
    if (pConfig->format != ma_format_f32 && pConfig->format != ma_format_s16) {
        return MA_INVALID_ARGS;
    }

    /* The format cannot be changed after initialization. */
    if (pHPF->format != ma_format_unknown && pHPF->format != pConfig->format) {
        return MA_INVALID_OPERATION;
    }

    /* The channel count cannot be changed after initialization. */
    if (pHPF->channels != 0 && pHPF->channels != pConfig->channels) {
        return MA_INVALID_OPERATION;
    }

    pHPF->format   = pConfig->format;
    pHPF->channels = pConfig->channels;

    a = ma_expd(-2 * MA_PI_D * pConfig->cutoffFrequency / pConfig->sampleRate);
    if (pConfig->format == ma_format_f32) {
        pHPF->a.f32 = (float)a;
    } else {
        pHPF->a.s32 = ma_biquad_float_to_fp(a);
    }

    return MA_SUCCESS;
}

static MA_INLINE void ma_hpf1_process_pcm_frame_f32(ma_hpf1* pHPF, float* pY, const float* pX)
{
    ma_uint32 c;
    const ma_uint32 channels = pHPF->channels;
    const float a = 1 - pHPF->a.f32;
    const float b = 1 - a;

    MA_ASSUME(channels > 0);
    for (c = 0; c < channels; c += 1) {
        float r1 = pHPF->pR1[c].f32;
        float x  = pX[c];
        float y;

        y = b*x - a*r1;

        pY[c]            = y;
        pHPF->pR1[c].f32 = y;
    }
}

static MA_INLINE void ma_hpf1_process_pcm_frame_s16(ma_hpf1* pHPF, ma_int16* pY, const ma_int16* pX)
{
    ma_uint32 c;
    const ma_uint32 channels = pHPF->channels;
    const ma_int32 a = ((1 << MA_BIQUAD_FIXED_POINT_SHIFT) - pHPF->a.s32);
    const ma_int32 b = ((1 << MA_BIQUAD_FIXED_POINT_SHIFT) - a);

    MA_ASSUME(channels > 0);
    for (c = 0; c < channels; c += 1) {
        ma_int32 r1 = pHPF->pR1[c].s32;
        ma_int32 x  = pX[c];
        ma_int32 y;

        y = (b*x - a*r1) >> MA_BIQUAD_FIXED_POINT_SHIFT;

        pY[c]            = (ma_int16)y;
        pHPF->pR1[c].s32 = (ma_int32)y;
    }
}

MA_API ma_result ma_hpf1_process_pcm_frames(ma_hpf1* pHPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    ma_uint32 n;

    if (pHPF == NULL || pFramesOut == NULL || pFramesIn == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Note that the logic below needs to support in-place filtering. That is, it must support the case where pFramesOut and pFramesIn are the same. */

    if (pHPF->format == ma_format_f32) {
        /* */ float* pY = (      float*)pFramesOut;
        const float* pX = (const float*)pFramesIn;

        for (n = 0; n < frameCount; n += 1) {
            ma_hpf1_process_pcm_frame_f32(pHPF, pY, pX);
            pY += pHPF->channels;
            pX += pHPF->channels;
        }
    } else if (pHPF->format == ma_format_s16) {
        /* */ ma_int16* pY = (      ma_int16*)pFramesOut;
        const ma_int16* pX = (const ma_int16*)pFramesIn;

        for (n = 0; n < frameCount; n += 1) {
            ma_hpf1_process_pcm_frame_s16(pHPF, pY, pX);
            pY += pHPF->channels;
            pX += pHPF->channels;
        }
    } else {
        MA_ASSERT(MA_FALSE);
        return MA_INVALID_ARGS; /* Format not supported. Should never hit this because it's checked in ma_biquad_init() and ma_biquad_reinit(). */
    }

    return MA_SUCCESS;
}

MA_API ma_uint32 ma_hpf1_get_latency(const ma_hpf1* pHPF)
{
    if (pHPF == NULL) {
        return 0;
    }

    return 1;
}


static MA_INLINE ma_biquad_config ma_hpf2__get_biquad_config(const ma_hpf2_config* pConfig)
{
    ma_biquad_config bqConfig;
    double q;
    double w;
    double s;
    double c;
    double a;

    MA_ASSERT(pConfig != NULL);

    q = pConfig->q;
    w = 2 * MA_PI_D * pConfig->cutoffFrequency / pConfig->sampleRate;
    s = ma_sind(w);
    c = ma_cosd(w);
    a = s / (2*q);

    bqConfig.b0 =  (1 + c) / 2;
    bqConfig.b1 = -(1 + c);
    bqConfig.b2 =  (1 + c) / 2;
    bqConfig.a0 =   1 + a;
    bqConfig.a1 =  -2 * c;
    bqConfig.a2 =   1 - a;

    bqConfig.format   = pConfig->format;
    bqConfig.channels = pConfig->channels;

    return bqConfig;
}

MA_API ma_result ma_hpf2_get_heap_size(const ma_hpf2_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_biquad_config bqConfig;
    bqConfig = ma_hpf2__get_biquad_config(pConfig);

    return ma_biquad_get_heap_size(&bqConfig, pHeapSizeInBytes);
}

MA_API ma_result ma_hpf2_init_preallocated(const ma_hpf2_config* pConfig, void* pHeap, ma_hpf2* pHPF)
{
    ma_result result;
    ma_biquad_config bqConfig;

    if (pHPF == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pHPF);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    bqConfig = ma_hpf2__get_biquad_config(pConfig);
    result = ma_biquad_init_preallocated(&bqConfig, pHeap, &pHPF->bq);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_hpf2_init(const ma_hpf2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hpf2* pHPF)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_hpf2_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_hpf2_init_preallocated(pConfig, pHeap, pHPF);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pHPF->bq._ownsHeap = MA_TRUE;    /* <-- This will cause the biquad to take ownership of the heap and free it when it's uninitialized. */
    return MA_SUCCESS;
}

MA_API void ma_hpf2_uninit(ma_hpf2* pHPF, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pHPF == NULL) {
        return;
    }

    ma_biquad_uninit(&pHPF->bq, pAllocationCallbacks);   /* <-- This will free the heap allocation. */
}

MA_API ma_result ma_hpf2_reinit(const ma_hpf2_config* pConfig, ma_hpf2* pHPF)
{
    ma_result result;
    ma_biquad_config bqConfig;

    if (pHPF == NULL || pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    bqConfig = ma_hpf2__get_biquad_config(pConfig);
    result = ma_biquad_reinit(&bqConfig, &pHPF->bq);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

static MA_INLINE void ma_hpf2_process_pcm_frame_s16(ma_hpf2* pHPF, ma_int16* pFrameOut, const ma_int16* pFrameIn)
{
    ma_biquad_process_pcm_frame_s16(&pHPF->bq, pFrameOut, pFrameIn);
}

static MA_INLINE void ma_hpf2_process_pcm_frame_f32(ma_hpf2* pHPF, float* pFrameOut, const float* pFrameIn)
{
    ma_biquad_process_pcm_frame_f32(&pHPF->bq, pFrameOut, pFrameIn);
}

MA_API ma_result ma_hpf2_process_pcm_frames(ma_hpf2* pHPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    if (pHPF == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_biquad_process_pcm_frames(&pHPF->bq, pFramesOut, pFramesIn, frameCount);
}

MA_API ma_uint32 ma_hpf2_get_latency(const ma_hpf2* pHPF)
{
    if (pHPF == NULL) {
        return 0;
    }

    return ma_biquad_get_latency(&pHPF->bq);
}


MA_API ma_hpf_config ma_hpf_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order)
{
    ma_hpf_config config;

    MA_ZERO_OBJECT(&config);
    config.format          = format;
    config.channels        = channels;
    config.sampleRate      = sampleRate;
    config.cutoffFrequency = cutoffFrequency;
    config.order           = ma_min(order, MA_MAX_FILTER_ORDER);

    return config;
}


typedef struct
{
    size_t sizeInBytes;
    size_t hpf1Offset;
    size_t hpf2Offset;  /* Offset of the first second order filter. Subsequent filters will come straight after, and will each have the same heap size. */
} ma_hpf_heap_layout;

static void ma_hpf_calculate_sub_hpf_counts(ma_uint32 order, ma_uint32* pHPF1Count, ma_uint32* pHPF2Count)
{
    MA_ASSERT(pHPF1Count != NULL);
    MA_ASSERT(pHPF2Count != NULL);

    *pHPF1Count = order % 2;
    *pHPF2Count = order / 2;
}

static ma_result ma_hpf_get_heap_layout(const ma_hpf_config* pConfig, ma_hpf_heap_layout* pHeapLayout)
{
    ma_result result;
    ma_uint32 hpf1Count;
    ma_uint32 hpf2Count;
    ma_uint32 ihpf1;
    ma_uint32 ihpf2;

    MA_ASSERT(pHeapLayout != NULL);

    MA_ZERO_OBJECT(pHeapLayout);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->channels == 0) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->order > MA_MAX_FILTER_ORDER) {
        return MA_INVALID_ARGS;
    }

    ma_hpf_calculate_sub_hpf_counts(pConfig->order, &hpf1Count, &hpf2Count);

    pHeapLayout->sizeInBytes = 0;

    /* HPF 1 */
    pHeapLayout->hpf1Offset = pHeapLayout->sizeInBytes;
    for (ihpf1 = 0; ihpf1 < hpf1Count; ihpf1 += 1) {
        size_t hpf1HeapSizeInBytes;
        ma_hpf1_config hpf1Config = ma_hpf1_config_init(pConfig->format, pConfig->channels, pConfig->sampleRate, pConfig->cutoffFrequency);

        result = ma_hpf1_get_heap_size(&hpf1Config, &hpf1HeapSizeInBytes);
        if (result != MA_SUCCESS) {
            return result;
        }

        pHeapLayout->sizeInBytes += sizeof(ma_hpf1) + hpf1HeapSizeInBytes;
    }

    /* HPF 2*/
    pHeapLayout->hpf2Offset = pHeapLayout->sizeInBytes;
    for (ihpf2 = 0; ihpf2 < hpf2Count; ihpf2 += 1) {
        size_t hpf2HeapSizeInBytes;
        ma_hpf2_config hpf2Config = ma_hpf2_config_init(pConfig->format, pConfig->channels, pConfig->sampleRate, pConfig->cutoffFrequency, 0.707107);   /* <-- The "q" parameter does not matter for the purpose of calculating the heap size. */

        result = ma_hpf2_get_heap_size(&hpf2Config, &hpf2HeapSizeInBytes);
        if (result != MA_SUCCESS) {
            return result;
        }

        pHeapLayout->sizeInBytes += sizeof(ma_hpf2) + hpf2HeapSizeInBytes;
    }

    /* Make sure allocation size is aligned. */
    pHeapLayout->sizeInBytes = ma_align_64(pHeapLayout->sizeInBytes);

    return MA_SUCCESS;
}

static ma_result ma_hpf_reinit__internal(const ma_hpf_config* pConfig, void* pHeap, ma_hpf* pHPF, ma_bool32 isNew)
{
    ma_result result;
    ma_uint32 hpf1Count;
    ma_uint32 hpf2Count;
    ma_uint32 ihpf1;
    ma_uint32 ihpf2;
    ma_hpf_heap_layout heapLayout;  /* Only used if isNew is true. */

    if (pHPF == NULL || pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Only supporting f32 and s16. */
    if (pConfig->format != ma_format_f32 && pConfig->format != ma_format_s16) {
        return MA_INVALID_ARGS;
    }

    /* The format cannot be changed after initialization. */
    if (pHPF->format != ma_format_unknown && pHPF->format != pConfig->format) {
        return MA_INVALID_OPERATION;
    }

    /* The channel count cannot be changed after initialization. */
    if (pHPF->channels != 0 && pHPF->channels != pConfig->channels) {
        return MA_INVALID_OPERATION;
    }

    if (pConfig->order > MA_MAX_FILTER_ORDER) {
        return MA_INVALID_ARGS;
    }

    ma_hpf_calculate_sub_hpf_counts(pConfig->order, &hpf1Count, &hpf2Count);

    /* The filter order can't change between reinits. */
    if (!isNew) {
        if (pHPF->hpf1Count != hpf1Count || pHPF->hpf2Count != hpf2Count) {
            return MA_INVALID_OPERATION;
        }
    }

    if (isNew) {
        result = ma_hpf_get_heap_layout(pConfig, &heapLayout);
        if (result != MA_SUCCESS) {
            return result;
        }

        pHPF->_pHeap = pHeap;
        MA_ZERO_MEMORY(pHeap, heapLayout.sizeInBytes);

        pHPF->pHPF1 = (ma_hpf1*)ma_offset_ptr(pHeap, heapLayout.hpf1Offset);
        pHPF->pHPF2 = (ma_hpf2*)ma_offset_ptr(pHeap, heapLayout.hpf2Offset);
    } else {
        MA_ZERO_OBJECT(&heapLayout);    /* To silence a compiler warning. */
    }

    for (ihpf1 = 0; ihpf1 < hpf1Count; ihpf1 += 1) {
        ma_hpf1_config hpf1Config = ma_hpf1_config_init(pConfig->format, pConfig->channels, pConfig->sampleRate, pConfig->cutoffFrequency);

        if (isNew) {
            size_t hpf1HeapSizeInBytes;

            result = ma_hpf1_get_heap_size(&hpf1Config, &hpf1HeapSizeInBytes);
            if (result == MA_SUCCESS) {
                result = ma_hpf1_init_preallocated(&hpf1Config, ma_offset_ptr(pHeap, heapLayout.hpf1Offset + (sizeof(ma_hpf1) * hpf1Count) + (ihpf1 * hpf1HeapSizeInBytes)), &pHPF->pHPF1[ihpf1]);
            }
        } else {
            result = ma_hpf1_reinit(&hpf1Config, &pHPF->pHPF1[ihpf1]);
        }

        if (result != MA_SUCCESS) {
            ma_uint32 jhpf1;

            for (jhpf1 = 0; jhpf1 < ihpf1; jhpf1 += 1) {
                ma_hpf1_uninit(&pHPF->pHPF1[jhpf1], NULL);  /* No need for allocation callbacks here since we used a preallocated heap allocation. */
            }

            return result;
        }
    }

    for (ihpf2 = 0; ihpf2 < hpf2Count; ihpf2 += 1) {
        ma_hpf2_config hpf2Config;
        double q;
        double a;

        /* Tempting to use 0.707107, but won't result in a Butterworth filter if the order is > 2. */
        if (hpf1Count == 1) {
            a = (1 + ihpf2*1) * (MA_PI_D/(pConfig->order*1));   /* Odd order. */
        } else {
            a = (1 + ihpf2*2) * (MA_PI_D/(pConfig->order*2));   /* Even order. */
        }
        q = 1 / (2*ma_cosd(a));

        hpf2Config = ma_hpf2_config_init(pConfig->format, pConfig->channels, pConfig->sampleRate, pConfig->cutoffFrequency, q);

        if (isNew) {
            size_t hpf2HeapSizeInBytes;

            result = ma_hpf2_get_heap_size(&hpf2Config, &hpf2HeapSizeInBytes);
            if (result == MA_SUCCESS) {
                result = ma_hpf2_init_preallocated(&hpf2Config, ma_offset_ptr(pHeap, heapLayout.hpf2Offset + (sizeof(ma_hpf2) * hpf2Count) + (ihpf2 * hpf2HeapSizeInBytes)), &pHPF->pHPF2[ihpf2]);
            }
        } else {
            result = ma_hpf2_reinit(&hpf2Config, &pHPF->pHPF2[ihpf2]);
        }

        if (result != MA_SUCCESS) {
            ma_uint32 jhpf1;
            ma_uint32 jhpf2;

            for (jhpf1 = 0; jhpf1 < hpf1Count; jhpf1 += 1) {
                ma_hpf1_uninit(&pHPF->pHPF1[jhpf1], NULL);  /* No need for allocation callbacks here since we used a preallocated heap allocation. */
            }

            for (jhpf2 = 0; jhpf2 < ihpf2; jhpf2 += 1) {
                ma_hpf2_uninit(&pHPF->pHPF2[jhpf2], NULL);  /* No need for allocation callbacks here since we used a preallocated heap allocation. */
            }

            return result;
        }
    }

    pHPF->hpf1Count  = hpf1Count;
    pHPF->hpf2Count  = hpf2Count;
    pHPF->format     = pConfig->format;
    pHPF->channels   = pConfig->channels;
    pHPF->sampleRate = pConfig->sampleRate;

    return MA_SUCCESS;
}

MA_API ma_result ma_hpf_get_heap_size(const ma_hpf_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_hpf_heap_layout heapLayout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = 0;

    result = ma_hpf_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pHeapSizeInBytes = heapLayout.sizeInBytes;

    return result;
}

MA_API ma_result ma_hpf_init_preallocated(const ma_hpf_config* pConfig, void* pHeap, ma_hpf* pLPF)
{
    if (pLPF == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pLPF);

    return ma_hpf_reinit__internal(pConfig, pHeap, pLPF, /*isNew*/MA_TRUE);
}

MA_API ma_result ma_hpf_init(const ma_hpf_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hpf* pHPF)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_hpf_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_hpf_init_preallocated(pConfig, pHeap, pHPF);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pHPF->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_hpf_uninit(ma_hpf* pHPF, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_uint32 ihpf1;
    ma_uint32 ihpf2;

    if (pHPF == NULL) {
        return;
    }

    for (ihpf1 = 0; ihpf1 < pHPF->hpf1Count; ihpf1 += 1) {
        ma_hpf1_uninit(&pHPF->pHPF1[ihpf1], pAllocationCallbacks);
    }

    for (ihpf2 = 0; ihpf2 < pHPF->hpf2Count; ihpf2 += 1) {
        ma_hpf2_uninit(&pHPF->pHPF2[ihpf2], pAllocationCallbacks);
    }

    if (pHPF->_ownsHeap) {
        ma_free(pHPF->_pHeap, pAllocationCallbacks);
    }
}

MA_API ma_result ma_hpf_reinit(const ma_hpf_config* pConfig, ma_hpf* pHPF)
{
    return ma_hpf_reinit__internal(pConfig, NULL, pHPF, /*isNew*/MA_FALSE);
}

MA_API ma_result ma_hpf_process_pcm_frames(ma_hpf* pHPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    ma_result result;
    ma_uint32 ihpf1;
    ma_uint32 ihpf2;

    if (pHPF == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Faster path for in-place. */
    if (pFramesOut == pFramesIn) {
        for (ihpf1 = 0; ihpf1 < pHPF->hpf1Count; ihpf1 += 1) {
            result = ma_hpf1_process_pcm_frames(&pHPF->pHPF1[ihpf1], pFramesOut, pFramesOut, frameCount);
            if (result != MA_SUCCESS) {
                return result;
            }
        }

        for (ihpf2 = 0; ihpf2 < pHPF->hpf2Count; ihpf2 += 1) {
            result = ma_hpf2_process_pcm_frames(&pHPF->pHPF2[ihpf2], pFramesOut, pFramesOut, frameCount);
            if (result != MA_SUCCESS) {
                return result;
            }
        }
    }

    /* Slightly slower path for copying. */
    if (pFramesOut != pFramesIn) {
        ma_uint32 iFrame;

        /*  */ if (pHPF->format == ma_format_f32) {
            /* */ float* pFramesOutF32 = (      float*)pFramesOut;
            const float* pFramesInF32  = (const float*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                MA_COPY_MEMORY(pFramesOutF32, pFramesInF32, ma_get_bytes_per_frame(pHPF->format, pHPF->channels));

                for (ihpf1 = 0; ihpf1 < pHPF->hpf1Count; ihpf1 += 1) {
                    ma_hpf1_process_pcm_frame_f32(&pHPF->pHPF1[ihpf1], pFramesOutF32, pFramesOutF32);
                }

                for (ihpf2 = 0; ihpf2 < pHPF->hpf2Count; ihpf2 += 1) {
                    ma_hpf2_process_pcm_frame_f32(&pHPF->pHPF2[ihpf2], pFramesOutF32, pFramesOutF32);
                }

                pFramesOutF32 += pHPF->channels;
                pFramesInF32  += pHPF->channels;
            }
        } else if (pHPF->format == ma_format_s16) {
            /* */ ma_int16* pFramesOutS16 = (      ma_int16*)pFramesOut;
            const ma_int16* pFramesInS16  = (const ma_int16*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                MA_COPY_MEMORY(pFramesOutS16, pFramesInS16, ma_get_bytes_per_frame(pHPF->format, pHPF->channels));

                for (ihpf1 = 0; ihpf1 < pHPF->hpf1Count; ihpf1 += 1) {
                    ma_hpf1_process_pcm_frame_s16(&pHPF->pHPF1[ihpf1], pFramesOutS16, pFramesOutS16);
                }

                for (ihpf2 = 0; ihpf2 < pHPF->hpf2Count; ihpf2 += 1) {
                    ma_hpf2_process_pcm_frame_s16(&pHPF->pHPF2[ihpf2], pFramesOutS16, pFramesOutS16);
                }

                pFramesOutS16 += pHPF->channels;
                pFramesInS16  += pHPF->channels;
            }
        } else {
            MA_ASSERT(MA_FALSE);
            return MA_INVALID_OPERATION;    /* Should never hit this. */
        }
    }

    return MA_SUCCESS;
}

MA_API ma_uint32 ma_hpf_get_latency(const ma_hpf* pHPF)
{
    if (pHPF == NULL) {
        return 0;
    }

    return pHPF->hpf2Count*2 + pHPF->hpf1Count;
}


/**************************************************************************************************************************************************************

Band-Pass Filtering

**************************************************************************************************************************************************************/
MA_API ma_bpf2_config ma_bpf2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, double q)
{
    ma_bpf2_config config;

    MA_ZERO_OBJECT(&config);
    config.format = format;
    config.channels = channels;
    config.sampleRate = sampleRate;
    config.cutoffFrequency = cutoffFrequency;
    config.q = q;

    /* Q cannot be 0 or else it'll result in a division by 0. In this case just default to 0.707107. */
    if (config.q == 0) {
        config.q = 0.707107;
    }

    return config;
}


static MA_INLINE ma_biquad_config ma_bpf2__get_biquad_config(const ma_bpf2_config* pConfig)
{
    ma_biquad_config bqConfig;
    double q;
    double w;
    double s;
    double c;
    double a;

    MA_ASSERT(pConfig != NULL);

    q = pConfig->q;
    w = 2 * MA_PI_D * pConfig->cutoffFrequency / pConfig->sampleRate;
    s = ma_sind(w);
    c = ma_cosd(w);
    a = s / (2*q);

    bqConfig.b0 =  q * a;
    bqConfig.b1 =  0;
    bqConfig.b2 = -q * a;
    bqConfig.a0 =  1 + a;
    bqConfig.a1 = -2 * c;
    bqConfig.a2 =  1 - a;

    bqConfig.format   = pConfig->format;
    bqConfig.channels = pConfig->channels;

    return bqConfig;
}

MA_API ma_result ma_bpf2_get_heap_size(const ma_bpf2_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_biquad_config bqConfig;
    bqConfig = ma_bpf2__get_biquad_config(pConfig);

    return ma_biquad_get_heap_size(&bqConfig, pHeapSizeInBytes);
}

MA_API ma_result ma_bpf2_init_preallocated(const ma_bpf2_config* pConfig, void* pHeap, ma_bpf2* pBPF)
{
    ma_result result;
    ma_biquad_config bqConfig;

    if (pBPF == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pBPF);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    bqConfig = ma_bpf2__get_biquad_config(pConfig);
    result = ma_biquad_init_preallocated(&bqConfig, pHeap, &pBPF->bq);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_bpf2_init(const ma_bpf2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_bpf2* pBPF)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_bpf2_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_bpf2_init_preallocated(pConfig, pHeap, pBPF);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pBPF->bq._ownsHeap = MA_TRUE;    /* <-- This will cause the biquad to take ownership of the heap and free it when it's uninitialized. */
    return MA_SUCCESS;
}

MA_API void ma_bpf2_uninit(ma_bpf2* pBPF, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pBPF == NULL) {
        return;
    }

    ma_biquad_uninit(&pBPF->bq, pAllocationCallbacks);   /* <-- This will free the heap allocation. */
}

MA_API ma_result ma_bpf2_reinit(const ma_bpf2_config* pConfig, ma_bpf2* pBPF)
{
    ma_result result;
    ma_biquad_config bqConfig;

    if (pBPF == NULL || pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    bqConfig = ma_bpf2__get_biquad_config(pConfig);
    result = ma_biquad_reinit(&bqConfig, &pBPF->bq);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

static MA_INLINE void ma_bpf2_process_pcm_frame_s16(ma_bpf2* pBPF, ma_int16* pFrameOut, const ma_int16* pFrameIn)
{
    ma_biquad_process_pcm_frame_s16(&pBPF->bq, pFrameOut, pFrameIn);
}

static MA_INLINE void ma_bpf2_process_pcm_frame_f32(ma_bpf2* pBPF, float* pFrameOut, const float* pFrameIn)
{
    ma_biquad_process_pcm_frame_f32(&pBPF->bq, pFrameOut, pFrameIn);
}

MA_API ma_result ma_bpf2_process_pcm_frames(ma_bpf2* pBPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    if (pBPF == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_biquad_process_pcm_frames(&pBPF->bq, pFramesOut, pFramesIn, frameCount);
}

MA_API ma_uint32 ma_bpf2_get_latency(const ma_bpf2* pBPF)
{
    if (pBPF == NULL) {
        return 0;
    }

    return ma_biquad_get_latency(&pBPF->bq);
}


MA_API ma_bpf_config ma_bpf_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order)
{
    ma_bpf_config config;

    MA_ZERO_OBJECT(&config);
    config.format          = format;
    config.channels        = channels;
    config.sampleRate      = sampleRate;
    config.cutoffFrequency = cutoffFrequency;
    config.order           = ma_min(order, MA_MAX_FILTER_ORDER);

    return config;
}


typedef struct
{
    size_t sizeInBytes;
    size_t bpf2Offset;
} ma_bpf_heap_layout;

static ma_result ma_bpf_get_heap_layout(const ma_bpf_config* pConfig, ma_bpf_heap_layout* pHeapLayout)
{
    ma_result result;
    ma_uint32 bpf2Count;
    ma_uint32 ibpf2;

    MA_ASSERT(pHeapLayout != NULL);

    MA_ZERO_OBJECT(pHeapLayout);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->order > MA_MAX_FILTER_ORDER) {
        return MA_INVALID_ARGS;
    }

    /* We must have an even number of order. */
    if ((pConfig->order & 0x1) != 0) {
        return MA_INVALID_ARGS;
    }

    bpf2Count = pConfig->order / 2;

    pHeapLayout->sizeInBytes = 0;

    /* BPF 2 */
    pHeapLayout->bpf2Offset = pHeapLayout->sizeInBytes;
    for (ibpf2 = 0; ibpf2 < bpf2Count; ibpf2 += 1) {
        size_t bpf2HeapSizeInBytes;
        ma_bpf2_config bpf2Config = ma_bpf2_config_init(pConfig->format, pConfig->channels, pConfig->sampleRate, pConfig->cutoffFrequency, 0.707107);   /* <-- The "q" parameter does not matter for the purpose of calculating the heap size. */

        result = ma_bpf2_get_heap_size(&bpf2Config, &bpf2HeapSizeInBytes);
        if (result != MA_SUCCESS) {
            return result;
        }

        pHeapLayout->sizeInBytes += sizeof(ma_bpf2) + bpf2HeapSizeInBytes;
    }

    /* Make sure allocation size is aligned. */
    pHeapLayout->sizeInBytes = ma_align_64(pHeapLayout->sizeInBytes);

    return MA_SUCCESS;
}

static ma_result ma_bpf_reinit__internal(const ma_bpf_config* pConfig, void* pHeap, ma_bpf* pBPF, ma_bool32 isNew)
{
    ma_result result;
    ma_uint32 bpf2Count;
    ma_uint32 ibpf2;
    ma_bpf_heap_layout heapLayout;  /* Only used if isNew is true. */

    if (pBPF == NULL || pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Only supporting f32 and s16. */
    if (pConfig->format != ma_format_f32 && pConfig->format != ma_format_s16) {
        return MA_INVALID_ARGS;
    }

    /* The format cannot be changed after initialization. */
    if (pBPF->format != ma_format_unknown && pBPF->format != pConfig->format) {
        return MA_INVALID_OPERATION;
    }

    /* The channel count cannot be changed after initialization. */
    if (pBPF->channels != 0 && pBPF->channels != pConfig->channels) {
        return MA_INVALID_OPERATION;
    }

    if (pConfig->order > MA_MAX_FILTER_ORDER) {
        return MA_INVALID_ARGS;
    }

    /* We must have an even number of order. */
    if ((pConfig->order & 0x1) != 0) {
        return MA_INVALID_ARGS;
    }

    bpf2Count = pConfig->order / 2;

    /* The filter order can't change between reinits. */
    if (!isNew) {
        if (pBPF->bpf2Count != bpf2Count) {
            return MA_INVALID_OPERATION;
        }
    }

    if (isNew) {
        result = ma_bpf_get_heap_layout(pConfig, &heapLayout);
        if (result != MA_SUCCESS) {
            return result;
        }

        pBPF->_pHeap = pHeap;
        MA_ZERO_MEMORY(pHeap, heapLayout.sizeInBytes);

        pBPF->pBPF2 = (ma_bpf2*)ma_offset_ptr(pHeap, heapLayout.bpf2Offset);
    } else {
        MA_ZERO_OBJECT(&heapLayout);
    }

    for (ibpf2 = 0; ibpf2 < bpf2Count; ibpf2 += 1) {
        ma_bpf2_config bpf2Config;
        double q;

        /* TODO: Calculate Q to make this a proper Butterworth filter. */
        q = 0.707107;

        bpf2Config = ma_bpf2_config_init(pConfig->format, pConfig->channels, pConfig->sampleRate, pConfig->cutoffFrequency, q);

        if (isNew) {
            size_t bpf2HeapSizeInBytes;

            result = ma_bpf2_get_heap_size(&bpf2Config, &bpf2HeapSizeInBytes);
            if (result == MA_SUCCESS) {
                result = ma_bpf2_init_preallocated(&bpf2Config, ma_offset_ptr(pHeap, heapLayout.bpf2Offset + (sizeof(ma_bpf2) * bpf2Count) + (ibpf2 * bpf2HeapSizeInBytes)), &pBPF->pBPF2[ibpf2]);
            }
        } else {
            result = ma_bpf2_reinit(&bpf2Config, &pBPF->pBPF2[ibpf2]);
        }

        if (result != MA_SUCCESS) {
            return result;
        }
    }

    pBPF->bpf2Count = bpf2Count;
    pBPF->format    = pConfig->format;
    pBPF->channels  = pConfig->channels;

    return MA_SUCCESS;
}


MA_API ma_result ma_bpf_get_heap_size(const ma_bpf_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_bpf_heap_layout heapLayout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = 0;

    result = ma_bpf_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pHeapSizeInBytes = heapLayout.sizeInBytes;

    return MA_SUCCESS;
}

MA_API ma_result ma_bpf_init_preallocated(const ma_bpf_config* pConfig, void* pHeap, ma_bpf* pBPF)
{
    if (pBPF == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pBPF);

    return ma_bpf_reinit__internal(pConfig, pHeap, pBPF, /*isNew*/MA_TRUE);
}

MA_API ma_result ma_bpf_init(const ma_bpf_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_bpf* pBPF)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_bpf_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_bpf_init_preallocated(pConfig, pHeap, pBPF);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pBPF->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_bpf_uninit(ma_bpf* pBPF, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_uint32 ibpf2;

    if (pBPF == NULL) {
        return;
    }

    for (ibpf2 = 0; ibpf2 < pBPF->bpf2Count; ibpf2 += 1) {
        ma_bpf2_uninit(&pBPF->pBPF2[ibpf2], pAllocationCallbacks);
    }

    if (pBPF->_ownsHeap) {
        ma_free(pBPF->_pHeap, pAllocationCallbacks);
    }
}

MA_API ma_result ma_bpf_reinit(const ma_bpf_config* pConfig, ma_bpf* pBPF)
{
    return ma_bpf_reinit__internal(pConfig, NULL, pBPF, /*isNew*/MA_FALSE);
}

MA_API ma_result ma_bpf_process_pcm_frames(ma_bpf* pBPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    ma_result result;
    ma_uint32 ibpf2;

    if (pBPF == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Faster path for in-place. */
    if (pFramesOut == pFramesIn) {
        for (ibpf2 = 0; ibpf2 < pBPF->bpf2Count; ibpf2 += 1) {
            result = ma_bpf2_process_pcm_frames(&pBPF->pBPF2[ibpf2], pFramesOut, pFramesOut, frameCount);
            if (result != MA_SUCCESS) {
                return result;
            }
        }
    }

    /* Slightly slower path for copying. */
    if (pFramesOut != pFramesIn) {
        ma_uint32 iFrame;

        /*  */ if (pBPF->format == ma_format_f32) {
            /* */ float* pFramesOutF32 = (      float*)pFramesOut;
            const float* pFramesInF32  = (const float*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                MA_COPY_MEMORY(pFramesOutF32, pFramesInF32, ma_get_bytes_per_frame(pBPF->format, pBPF->channels));

                for (ibpf2 = 0; ibpf2 < pBPF->bpf2Count; ibpf2 += 1) {
                    ma_bpf2_process_pcm_frame_f32(&pBPF->pBPF2[ibpf2], pFramesOutF32, pFramesOutF32);
                }

                pFramesOutF32 += pBPF->channels;
                pFramesInF32  += pBPF->channels;
            }
        } else if (pBPF->format == ma_format_s16) {
            /* */ ma_int16* pFramesOutS16 = (      ma_int16*)pFramesOut;
            const ma_int16* pFramesInS16  = (const ma_int16*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                MA_COPY_MEMORY(pFramesOutS16, pFramesInS16, ma_get_bytes_per_frame(pBPF->format, pBPF->channels));

                for (ibpf2 = 0; ibpf2 < pBPF->bpf2Count; ibpf2 += 1) {
                    ma_bpf2_process_pcm_frame_s16(&pBPF->pBPF2[ibpf2], pFramesOutS16, pFramesOutS16);
                }

                pFramesOutS16 += pBPF->channels;
                pFramesInS16  += pBPF->channels;
            }
        } else {
            MA_ASSERT(MA_FALSE);
            return MA_INVALID_OPERATION;    /* Should never hit this. */
        }
    }

    return MA_SUCCESS;
}

MA_API ma_uint32 ma_bpf_get_latency(const ma_bpf* pBPF)
{
    if (pBPF == NULL) {
        return 0;
    }

    return pBPF->bpf2Count*2;
}


/**************************************************************************************************************************************************************

Notching Filter

**************************************************************************************************************************************************************/
MA_API ma_notch2_config ma_notch2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double q, double frequency)
{
    ma_notch2_config config;

    MA_ZERO_OBJECT(&config);
    config.format     = format;
    config.channels   = channels;
    config.sampleRate = sampleRate;
    config.q          = q;
    config.frequency  = frequency;

    if (config.q == 0) {
        config.q = 0.707107;
    }

    return config;
}


static MA_INLINE ma_biquad_config ma_notch2__get_biquad_config(const ma_notch2_config* pConfig)
{
    ma_biquad_config bqConfig;
    double q;
    double w;
    double s;
    double c;
    double a;

    MA_ASSERT(pConfig != NULL);

    q = pConfig->q;
    w = 2 * MA_PI_D * pConfig->frequency / pConfig->sampleRate;
    s = ma_sind(w);
    c = ma_cosd(w);
    a = s / (2*q);

    bqConfig.b0 =  1;
    bqConfig.b1 = -2 * c;
    bqConfig.b2 =  1;
    bqConfig.a0 =  1 + a;
    bqConfig.a1 = -2 * c;
    bqConfig.a2 =  1 - a;

    bqConfig.format   = pConfig->format;
    bqConfig.channels = pConfig->channels;

    return bqConfig;
}

MA_API ma_result ma_notch2_get_heap_size(const ma_notch2_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_biquad_config bqConfig;
    bqConfig = ma_notch2__get_biquad_config(pConfig);

    return ma_biquad_get_heap_size(&bqConfig, pHeapSizeInBytes);
}

MA_API ma_result ma_notch2_init_preallocated(const ma_notch2_config* pConfig, void* pHeap, ma_notch2* pFilter)
{
    ma_result result;
    ma_biquad_config bqConfig;

    if (pFilter == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pFilter);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    bqConfig = ma_notch2__get_biquad_config(pConfig);
    result = ma_biquad_init_preallocated(&bqConfig, pHeap, &pFilter->bq);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_notch2_init(const ma_notch2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_notch2* pFilter)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_notch2_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_notch2_init_preallocated(pConfig, pHeap, pFilter);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pFilter->bq._ownsHeap = MA_TRUE;    /* <-- This will cause the biquad to take ownership of the heap and free it when it's uninitialized. */
    return MA_SUCCESS;
}

MA_API void ma_notch2_uninit(ma_notch2* pFilter, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pFilter == NULL) {
        return;
    }

    ma_biquad_uninit(&pFilter->bq, pAllocationCallbacks);   /* <-- This will free the heap allocation. */
}

MA_API ma_result ma_notch2_reinit(const ma_notch2_config* pConfig, ma_notch2* pFilter)
{
    ma_result result;
    ma_biquad_config bqConfig;

    if (pFilter == NULL || pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    bqConfig = ma_notch2__get_biquad_config(pConfig);
    result = ma_biquad_reinit(&bqConfig, &pFilter->bq);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

static MA_INLINE void ma_notch2_process_pcm_frame_s16(ma_notch2* pFilter, ma_int16* pFrameOut, const ma_int16* pFrameIn)
{
    ma_biquad_process_pcm_frame_s16(&pFilter->bq, pFrameOut, pFrameIn);
}

static MA_INLINE void ma_notch2_process_pcm_frame_f32(ma_notch2* pFilter, float* pFrameOut, const float* pFrameIn)
{
    ma_biquad_process_pcm_frame_f32(&pFilter->bq, pFrameOut, pFrameIn);
}

MA_API ma_result ma_notch2_process_pcm_frames(ma_notch2* pFilter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    if (pFilter == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_biquad_process_pcm_frames(&pFilter->bq, pFramesOut, pFramesIn, frameCount);
}

MA_API ma_uint32 ma_notch2_get_latency(const ma_notch2* pFilter)
{
    if (pFilter == NULL) {
        return 0;
    }

    return ma_biquad_get_latency(&pFilter->bq);
}



/**************************************************************************************************************************************************************

Peaking EQ Filter

**************************************************************************************************************************************************************/
MA_API ma_peak2_config ma_peak2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double q, double frequency)
{
    ma_peak2_config config;

    MA_ZERO_OBJECT(&config);
    config.format     = format;
    config.channels   = channels;
    config.sampleRate = sampleRate;
    config.gainDB     = gainDB;
    config.q          = q;
    config.frequency  = frequency;

    if (config.q == 0) {
        config.q = 0.707107;
    }

    return config;
}


static MA_INLINE ma_biquad_config ma_peak2__get_biquad_config(const ma_peak2_config* pConfig)
{
    ma_biquad_config bqConfig;
    double q;
    double w;
    double s;
    double c;
    double a;
    double A;

    MA_ASSERT(pConfig != NULL);

    q = pConfig->q;
    w = 2 * MA_PI_D * pConfig->frequency / pConfig->sampleRate;
    s = ma_sind(w);
    c = ma_cosd(w);
    a = s / (2*q);
    A = ma_powd(10, (pConfig->gainDB / 40));

    bqConfig.b0 =  1 + (a * A);
    bqConfig.b1 = -2 * c;
    bqConfig.b2 =  1 - (a * A);
    bqConfig.a0 =  1 + (a / A);
    bqConfig.a1 = -2 * c;
    bqConfig.a2 =  1 - (a / A);

    bqConfig.format   = pConfig->format;
    bqConfig.channels = pConfig->channels;

    return bqConfig;
}

MA_API ma_result ma_peak2_get_heap_size(const ma_peak2_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_biquad_config bqConfig;
    bqConfig = ma_peak2__get_biquad_config(pConfig);

    return ma_biquad_get_heap_size(&bqConfig, pHeapSizeInBytes);
}

MA_API ma_result ma_peak2_init_preallocated(const ma_peak2_config* pConfig, void* pHeap, ma_peak2* pFilter)
{
    ma_result result;
    ma_biquad_config bqConfig;

    if (pFilter == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pFilter);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    bqConfig = ma_peak2__get_biquad_config(pConfig);
    result = ma_biquad_init_preallocated(&bqConfig, pHeap, &pFilter->bq);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_peak2_init(const ma_peak2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_peak2* pFilter)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_peak2_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_peak2_init_preallocated(pConfig, pHeap, pFilter);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pFilter->bq._ownsHeap = MA_TRUE;    /* <-- This will cause the biquad to take ownership of the heap and free it when it's uninitialized. */
    return MA_SUCCESS;
}

MA_API void ma_peak2_uninit(ma_peak2* pFilter, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pFilter == NULL) {
        return;
    }

    ma_biquad_uninit(&pFilter->bq, pAllocationCallbacks);   /* <-- This will free the heap allocation. */
}

MA_API ma_result ma_peak2_reinit(const ma_peak2_config* pConfig, ma_peak2* pFilter)
{
    ma_result result;
    ma_biquad_config bqConfig;

    if (pFilter == NULL || pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    bqConfig = ma_peak2__get_biquad_config(pConfig);
    result = ma_biquad_reinit(&bqConfig, &pFilter->bq);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

static MA_INLINE void ma_peak2_process_pcm_frame_s16(ma_peak2* pFilter, ma_int16* pFrameOut, const ma_int16* pFrameIn)
{
    ma_biquad_process_pcm_frame_s16(&pFilter->bq, pFrameOut, pFrameIn);
}

static MA_INLINE void ma_peak2_process_pcm_frame_f32(ma_peak2* pFilter, float* pFrameOut, const float* pFrameIn)
{
    ma_biquad_process_pcm_frame_f32(&pFilter->bq, pFrameOut, pFrameIn);
}

MA_API ma_result ma_peak2_process_pcm_frames(ma_peak2* pFilter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    if (pFilter == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_biquad_process_pcm_frames(&pFilter->bq, pFramesOut, pFramesIn, frameCount);
}

MA_API ma_uint32 ma_peak2_get_latency(const ma_peak2* pFilter)
{
    if (pFilter == NULL) {
        return 0;
    }

    return ma_biquad_get_latency(&pFilter->bq);
}


/**************************************************************************************************************************************************************

Low Shelf Filter

**************************************************************************************************************************************************************/
MA_API ma_loshelf2_config ma_loshelf2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double shelfSlope, double frequency)
{
    ma_loshelf2_config config;

    MA_ZERO_OBJECT(&config);
    config.format     = format;
    config.channels   = channels;
    config.sampleRate = sampleRate;
    config.gainDB     = gainDB;
    config.shelfSlope = shelfSlope;
    config.frequency  = frequency;

    return config;
}


static MA_INLINE ma_biquad_config ma_loshelf2__get_biquad_config(const ma_loshelf2_config* pConfig)
{
    ma_biquad_config bqConfig;
    double w;
    double s;
    double c;
    double A;
    double S;
    double a;
    double sqrtA;

    MA_ASSERT(pConfig != NULL);

    w = 2 * MA_PI_D * pConfig->frequency / pConfig->sampleRate;
    s = ma_sind(w);
    c = ma_cosd(w);
    A = ma_powd(10, (pConfig->gainDB / 40));
    S = pConfig->shelfSlope;
    a = s/2 * ma_sqrtd((A + 1/A) * (1/S - 1) + 2);
    sqrtA = 2*ma_sqrtd(A)*a;

    bqConfig.b0 =  A * ((A + 1) - (A - 1)*c + sqrtA);
    bqConfig.b1 =  2 * A * ((A - 1) - (A + 1)*c);
    bqConfig.b2 =  A * ((A + 1) - (A - 1)*c - sqrtA);
    bqConfig.a0 =  (A + 1) + (A - 1)*c + sqrtA;
    bqConfig.a1 = -2 * ((A - 1) + (A + 1)*c);
    bqConfig.a2 =  (A + 1) + (A - 1)*c - sqrtA;

    bqConfig.format   = pConfig->format;
    bqConfig.channels = pConfig->channels;

    return bqConfig;
}

MA_API ma_result ma_loshelf2_get_heap_size(const ma_loshelf2_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_biquad_config bqConfig;
    bqConfig = ma_loshelf2__get_biquad_config(pConfig);

    return ma_biquad_get_heap_size(&bqConfig, pHeapSizeInBytes);
}

MA_API ma_result ma_loshelf2_init_preallocated(const ma_loshelf2_config* pConfig, void* pHeap, ma_loshelf2* pFilter)
{
    ma_result result;
    ma_biquad_config bqConfig;

    if (pFilter == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pFilter);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    bqConfig = ma_loshelf2__get_biquad_config(pConfig);
    result = ma_biquad_init_preallocated(&bqConfig, pHeap, &pFilter->bq);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_loshelf2_init(const ma_loshelf2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_loshelf2* pFilter)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_loshelf2_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_loshelf2_init_preallocated(pConfig, pHeap, pFilter);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pFilter->bq._ownsHeap = MA_TRUE;    /* <-- This will cause the biquad to take ownership of the heap and free it when it's uninitialized. */
    return MA_SUCCESS;
}

MA_API void ma_loshelf2_uninit(ma_loshelf2* pFilter, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pFilter == NULL) {
        return;
    }

    ma_biquad_uninit(&pFilter->bq, pAllocationCallbacks);   /* <-- This will free the heap allocation. */
}

MA_API ma_result ma_loshelf2_reinit(const ma_loshelf2_config* pConfig, ma_loshelf2* pFilter)
{
    ma_result result;
    ma_biquad_config bqConfig;

    if (pFilter == NULL || pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    bqConfig = ma_loshelf2__get_biquad_config(pConfig);
    result = ma_biquad_reinit(&bqConfig, &pFilter->bq);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

static MA_INLINE void ma_loshelf2_process_pcm_frame_s16(ma_loshelf2* pFilter, ma_int16* pFrameOut, const ma_int16* pFrameIn)
{
    ma_biquad_process_pcm_frame_s16(&pFilter->bq, pFrameOut, pFrameIn);
}

static MA_INLINE void ma_loshelf2_process_pcm_frame_f32(ma_loshelf2* pFilter, float* pFrameOut, const float* pFrameIn)
{
    ma_biquad_process_pcm_frame_f32(&pFilter->bq, pFrameOut, pFrameIn);
}

MA_API ma_result ma_loshelf2_process_pcm_frames(ma_loshelf2* pFilter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    if (pFilter == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_biquad_process_pcm_frames(&pFilter->bq, pFramesOut, pFramesIn, frameCount);
}

MA_API ma_uint32 ma_loshelf2_get_latency(const ma_loshelf2* pFilter)
{
    if (pFilter == NULL) {
        return 0;
    }

    return ma_biquad_get_latency(&pFilter->bq);
}


/**************************************************************************************************************************************************************

High Shelf Filter

**************************************************************************************************************************************************************/
MA_API ma_hishelf2_config ma_hishelf2_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double shelfSlope, double frequency)
{
    ma_hishelf2_config config;

    MA_ZERO_OBJECT(&config);
    config.format     = format;
    config.channels   = channels;
    config.sampleRate = sampleRate;
    config.gainDB     = gainDB;
    config.shelfSlope = shelfSlope;
    config.frequency  = frequency;

    return config;
}


static MA_INLINE ma_biquad_config ma_hishelf2__get_biquad_config(const ma_hishelf2_config* pConfig)
{
    ma_biquad_config bqConfig;
    double w;
    double s;
    double c;
    double A;
    double S;
    double a;
    double sqrtA;

    MA_ASSERT(pConfig != NULL);

    w = 2 * MA_PI_D * pConfig->frequency / pConfig->sampleRate;
    s = ma_sind(w);
    c = ma_cosd(w);
    A = ma_powd(10, (pConfig->gainDB / 40));
    S = pConfig->shelfSlope;
    a = s/2 * ma_sqrtd((A + 1/A) * (1/S - 1) + 2);
    sqrtA = 2*ma_sqrtd(A)*a;

    bqConfig.b0 =  A * ((A + 1) + (A - 1)*c + sqrtA);
    bqConfig.b1 = -2 * A * ((A - 1) + (A + 1)*c);
    bqConfig.b2 =  A * ((A + 1) + (A - 1)*c - sqrtA);
    bqConfig.a0 =  (A + 1) - (A - 1)*c + sqrtA;
    bqConfig.a1 =  2 * ((A - 1) - (A + 1)*c);
    bqConfig.a2 =  (A + 1) - (A - 1)*c - sqrtA;

    bqConfig.format   = pConfig->format;
    bqConfig.channels = pConfig->channels;

    return bqConfig;
}

MA_API ma_result ma_hishelf2_get_heap_size(const ma_hishelf2_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_biquad_config bqConfig;
    bqConfig = ma_hishelf2__get_biquad_config(pConfig);

    return ma_biquad_get_heap_size(&bqConfig, pHeapSizeInBytes);
}

MA_API ma_result ma_hishelf2_init_preallocated(const ma_hishelf2_config* pConfig, void* pHeap, ma_hishelf2* pFilter)
{
    ma_result result;
    ma_biquad_config bqConfig;

    if (pFilter == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pFilter);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    bqConfig = ma_hishelf2__get_biquad_config(pConfig);
    result = ma_biquad_init_preallocated(&bqConfig, pHeap, &pFilter->bq);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_hishelf2_init(const ma_hishelf2_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hishelf2* pFilter)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_hishelf2_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_hishelf2_init_preallocated(pConfig, pHeap, pFilter);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pFilter->bq._ownsHeap = MA_TRUE;    /* <-- This will cause the biquad to take ownership of the heap and free it when it's uninitialized. */
    return MA_SUCCESS;
}

MA_API void ma_hishelf2_uninit(ma_hishelf2* pFilter, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pFilter == NULL) {
        return;
    }

    ma_biquad_uninit(&pFilter->bq, pAllocationCallbacks);   /* <-- This will free the heap allocation. */
}

MA_API ma_result ma_hishelf2_reinit(const ma_hishelf2_config* pConfig, ma_hishelf2* pFilter)
{
    ma_result result;
    ma_biquad_config bqConfig;

    if (pFilter == NULL || pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    bqConfig = ma_hishelf2__get_biquad_config(pConfig);
    result = ma_biquad_reinit(&bqConfig, &pFilter->bq);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

static MA_INLINE void ma_hishelf2_process_pcm_frame_s16(ma_hishelf2* pFilter, ma_int16* pFrameOut, const ma_int16* pFrameIn)
{
    ma_biquad_process_pcm_frame_s16(&pFilter->bq, pFrameOut, pFrameIn);
}

static MA_INLINE void ma_hishelf2_process_pcm_frame_f32(ma_hishelf2* pFilter, float* pFrameOut, const float* pFrameIn)
{
    ma_biquad_process_pcm_frame_f32(&pFilter->bq, pFrameOut, pFrameIn);
}

MA_API ma_result ma_hishelf2_process_pcm_frames(ma_hishelf2* pFilter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    if (pFilter == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_biquad_process_pcm_frames(&pFilter->bq, pFramesOut, pFramesIn, frameCount);
}

MA_API ma_uint32 ma_hishelf2_get_latency(const ma_hishelf2* pFilter)
{
    if (pFilter == NULL) {
        return 0;
    }

    return ma_biquad_get_latency(&pFilter->bq);
}



/*
Delay
*/
MA_API ma_delay_config ma_delay_config_init(ma_uint32 channels, ma_uint32 sampleRate, ma_uint32 delayInFrames, float decay)
{
    ma_delay_config config;

    MA_ZERO_OBJECT(&config);
    config.channels      = channels;
    config.sampleRate    = sampleRate;
    config.delayInFrames = delayInFrames;
    config.delayStart    = (decay == 0) ? MA_TRUE : MA_FALSE;   /* Delay the start if it looks like we're not configuring an echo. */
    config.wet           = 1;
    config.dry           = 1;
    config.decay         = decay;

    return config;
}


MA_API ma_result ma_delay_init(const ma_delay_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_delay* pDelay)
{
    if (pDelay == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pDelay);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->decay < 0 || pConfig->decay > 1) {
        return MA_INVALID_ARGS;
    }

    pDelay->config             = *pConfig;
    pDelay->bufferSizeInFrames = pConfig->delayInFrames;
    pDelay->cursor             = 0;

    pDelay->pBuffer = (float*)ma_malloc((size_t)(pDelay->bufferSizeInFrames * ma_get_bytes_per_frame(ma_format_f32, pConfig->channels)), pAllocationCallbacks);
    if (pDelay->pBuffer == NULL) {
        return MA_OUT_OF_MEMORY;
    }

    ma_silence_pcm_frames(pDelay->pBuffer, pDelay->bufferSizeInFrames, ma_format_f32, pConfig->channels);

    return MA_SUCCESS;
}

MA_API void ma_delay_uninit(ma_delay* pDelay, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pDelay == NULL) {
        return;
    }

    ma_free(pDelay->pBuffer, pAllocationCallbacks);
}

MA_API ma_result ma_delay_process_pcm_frames(ma_delay* pDelay, void* pFramesOut, const void* pFramesIn, ma_uint32 frameCount)
{
    ma_uint32 iFrame;
    ma_uint32 iChannel;
    float* pFramesOutF32 = (float*)pFramesOut;
    const float* pFramesInF32 = (const float*)pFramesIn;

    if (pDelay == NULL || pFramesOut == NULL || pFramesIn == NULL) {
        return MA_INVALID_ARGS;
    }

    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        for (iChannel = 0; iChannel < pDelay->config.channels; iChannel += 1) {
            ma_uint32 iBuffer = (pDelay->cursor * pDelay->config.channels) + iChannel;

            if (pDelay->config.delayStart) {
                /* Delayed start. */

                /* Read */
                pFramesOutF32[iChannel] = pDelay->pBuffer[iBuffer] * pDelay->config.wet;

                /* Feedback */
                pDelay->pBuffer[iBuffer] = (pDelay->pBuffer[iBuffer] * pDelay->config.decay) + (pFramesInF32[iChannel] * pDelay->config.dry);
            } else {
                /* Immediate start */

                /* Feedback */
                pDelay->pBuffer[iBuffer] = (pDelay->pBuffer[iBuffer] * pDelay->config.decay) + (pFramesInF32[iChannel] * pDelay->config.dry);

                /* Read */
                pFramesOutF32[iChannel] = pDelay->pBuffer[iBuffer] * pDelay->config.wet;
            }
        }

        pDelay->cursor = (pDelay->cursor + 1) % pDelay->bufferSizeInFrames;

        pFramesOutF32 += pDelay->config.channels;
        pFramesInF32  += pDelay->config.channels;
    }

    return MA_SUCCESS;
}

MA_API void ma_delay_set_wet(ma_delay* pDelay, float value)
{
    if (pDelay == NULL) {
        return;
    }

    pDelay->config.wet = value;
}

MA_API float ma_delay_get_wet(const ma_delay* pDelay)
{
    if (pDelay == NULL) {
        return 0;
    }

    return pDelay->config.wet;
}

MA_API void ma_delay_set_dry(ma_delay* pDelay, float value)
{
    if (pDelay == NULL) {
        return;
    }

    pDelay->config.dry = value;
}

MA_API float ma_delay_get_dry(const ma_delay* pDelay)
{
    if (pDelay == NULL) {
        return 0;
    }

    return pDelay->config.dry;
}

MA_API void ma_delay_set_decay(ma_delay* pDelay, float value)
{
    if (pDelay == NULL) {
        return;
    }

    pDelay->config.decay = value;
}

MA_API float ma_delay_get_decay(const ma_delay* pDelay)
{
    if (pDelay == NULL) {
        return 0;
    }

    return pDelay->config.decay;
}


MA_API ma_gainer_config ma_gainer_config_init(ma_uint32 channels, ma_uint32 smoothTimeInFrames)
{
    ma_gainer_config config;

    MA_ZERO_OBJECT(&config);
    config.channels           = channels;
    config.smoothTimeInFrames = smoothTimeInFrames;

    return config;
}


typedef struct
{
    size_t sizeInBytes;
    size_t oldGainsOffset;
    size_t newGainsOffset;
} ma_gainer_heap_layout;

static ma_result ma_gainer_get_heap_layout(const ma_gainer_config* pConfig, ma_gainer_heap_layout* pHeapLayout)
{
    MA_ASSERT(pHeapLayout != NULL);

    MA_ZERO_OBJECT(pHeapLayout);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->channels == 0) {
        return MA_INVALID_ARGS;
    }

    pHeapLayout->sizeInBytes = 0;

    /* Old gains. */
    pHeapLayout->oldGainsOffset = pHeapLayout->sizeInBytes;
    pHeapLayout->sizeInBytes += sizeof(float) * pConfig->channels;

    /* New gains. */
    pHeapLayout->newGainsOffset = pHeapLayout->sizeInBytes;
    pHeapLayout->sizeInBytes += sizeof(float) * pConfig->channels;

    /* Alignment. */
    pHeapLayout->sizeInBytes = ma_align_64(pHeapLayout->sizeInBytes);

    return MA_SUCCESS;
}


MA_API ma_result ma_gainer_get_heap_size(const ma_gainer_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_gainer_heap_layout heapLayout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = 0;

    result = ma_gainer_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = heapLayout.sizeInBytes;

    return MA_SUCCESS;
}


MA_API ma_result ma_gainer_init_preallocated(const ma_gainer_config* pConfig, void* pHeap, ma_gainer* pGainer)
{
    ma_result result;
    ma_gainer_heap_layout heapLayout;
    ma_uint32 iChannel;

    if (pGainer == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pGainer);

    if (pConfig == NULL || pHeap == NULL) {
        return MA_INVALID_ARGS;
    }

    result = ma_gainer_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    pGainer->_pHeap = pHeap;
    MA_ZERO_MEMORY(pHeap, heapLayout.sizeInBytes);

    pGainer->pOldGains = (float*)ma_offset_ptr(pHeap, heapLayout.oldGainsOffset);
    pGainer->pNewGains = (float*)ma_offset_ptr(pHeap, heapLayout.newGainsOffset);
    pGainer->masterVolume = 1;

    pGainer->config = *pConfig;
    pGainer->t      = (ma_uint32)-1;  /* No interpolation by default. */

    for (iChannel = 0; iChannel < pConfig->channels; iChannel += 1) {
        pGainer->pOldGains[iChannel] = 1;
        pGainer->pNewGains[iChannel] = 1;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_gainer_init(const ma_gainer_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_gainer* pGainer)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_gainer_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;  /* Failed to retrieve the size of the heap allocation. */
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_gainer_init_preallocated(pConfig, pHeap, pGainer);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pGainer->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_gainer_uninit(ma_gainer* pGainer, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pGainer == NULL) {
        return;
    }

    if (pGainer->_ownsHeap) {
        ma_free(pGainer->_pHeap, pAllocationCallbacks);
    }
}

static float ma_gainer_calculate_current_gain(const ma_gainer* pGainer, ma_uint32 channel)
{
    float a = (float)pGainer->t / pGainer->config.smoothTimeInFrames;
    return ma_mix_f32_fast(pGainer->pOldGains[channel], pGainer->pNewGains[channel], a);
}

static /*__attribute__((noinline))*/ ma_result ma_gainer_process_pcm_frames_internal(ma_gainer * pGainer, void* MA_RESTRICT pFramesOut, const void* MA_RESTRICT pFramesIn, ma_uint64 frameCount)
{
    ma_uint64 iFrame;
    ma_uint32 iChannel;
    ma_uint64 interpolatedFrameCount;

    MA_ASSERT(pGainer != NULL);

    /*
    We don't necessarily need to apply a linear interpolation for the entire frameCount frames. When
    linear interpolation is not needed we can do a simple volume adjustment which will be more
    efficient than a lerp with an alpha value of 1.

    To do this, all we need to do is determine how many frames need to have a lerp applied. Then we
    just process that number of frames with linear interpolation. After that we run on an optimized
    path which just applies the new gains without a lerp.
    */
    if (pGainer->t >= pGainer->config.smoothTimeInFrames) {
        interpolatedFrameCount = 0;
    } else {
        interpolatedFrameCount = pGainer->t - pGainer->config.smoothTimeInFrames;
        if (interpolatedFrameCount > frameCount) {
            interpolatedFrameCount = frameCount;
        }
    }

    /*
    Start off with our interpolated frames. When we do this, we'll adjust frameCount and our pointers
    so that the fast path can work naturally without consideration of the interpolated path.
    */
    if (interpolatedFrameCount > 0) {
        /* We can allow the input and output buffers to be null in which case we'll just update the internal timer. */
        if (pFramesOut != NULL && pFramesIn != NULL) {
            /*
            All we're really doing here is moving the old gains towards the new gains. We don't want to
            be modifying the gains inside the ma_gainer object because that will break things. Instead
            we can make a copy here on the stack. For extreme channel counts we can fall back to a slower
            implementation which just uses a standard lerp.
            */
            float* pFramesOutF32 = (float*)pFramesOut;
            const float* pFramesInF32 = (const float*)pFramesIn;
            float a = (float)pGainer->t / pGainer->config.smoothTimeInFrames;
            float d = 1.0f / pGainer->config.smoothTimeInFrames;

            if (pGainer->config.channels <= 32) {
                float pRunningGain[32];
                float pRunningGainDelta[32];    /* Could this be heap-allocated as part of the ma_gainer object? */

                /* Initialize the running gain. */
                for (iChannel = 0; iChannel < pGainer->config.channels; iChannel += 1) {
                    float t = (pGainer->pNewGains[iChannel] - pGainer->pOldGains[iChannel]) * pGainer->masterVolume;
                    pRunningGainDelta[iChannel] = t * d;
                    pRunningGain[iChannel] = (pGainer->pOldGains[iChannel] * pGainer->masterVolume) + (t * a);
                }

                iFrame = 0;

                /* Optimized paths for common channel counts. This is mostly just experimenting with some SIMD ideas. It's not necessarily final. */
                if (pGainer->config.channels == 2) {
                #if defined(MA_SUPPORT_SSE2)
                    if (ma_has_sse2()) {
                        ma_uint64 unrolledLoopCount = interpolatedFrameCount >> 1;

                        /* Expand some arrays so we can have a clean SIMD loop below. */
                        __m128 runningGainDelta0 = _mm_set_ps(pRunningGainDelta[1], pRunningGainDelta[0], pRunningGainDelta[1], pRunningGainDelta[0]);
                        __m128 runningGain0      = _mm_set_ps(pRunningGain[1] + pRunningGainDelta[1], pRunningGain[0] + pRunningGainDelta[0], pRunningGain[1], pRunningGain[0]);

                        for (; iFrame < unrolledLoopCount; iFrame += 1) {
                            _mm_storeu_ps(&pFramesOutF32[iFrame*4 + 0], _mm_mul_ps(_mm_loadu_ps(&pFramesInF32[iFrame*4 + 0]), runningGain0));
                            runningGain0 = _mm_add_ps(runningGain0, runningGainDelta0);
                        }

                        iFrame = unrolledLoopCount << 1;
                    } else
                #endif
                    {
                        /*
                        Two different scalar implementations here. Clang (and I assume GCC) will vectorize
                        both of these, but the bottom version results in a nicer vectorization with less
                        instructions emitted. The problem, however, is that the bottom version runs slower
                        when compiled with MSVC. The top version will be partially vectorized by MSVC.
                        */
                    #if defined(_MSC_VER) && !defined(__clang__)
                        ma_uint64 unrolledLoopCount = interpolatedFrameCount >> 1;

                        /* Expand some arrays so we can have a clean 4x SIMD operation in the loop. */
                        pRunningGainDelta[2] = pRunningGainDelta[0];
                        pRunningGainDelta[3] = pRunningGainDelta[1];
                        pRunningGain[2] = pRunningGain[0] + pRunningGainDelta[0];
                        pRunningGain[3] = pRunningGain[1] + pRunningGainDelta[1];

                        for (; iFrame < unrolledLoopCount; iFrame += 1) {
                            pFramesOutF32[iFrame*4 + 0] = pFramesInF32[iFrame*4 + 0] * pRunningGain[0];
                            pFramesOutF32[iFrame*4 + 1] = pFramesInF32[iFrame*4 + 1] * pRunningGain[1];
                            pFramesOutF32[iFrame*4 + 2] = pFramesInF32[iFrame*4 + 2] * pRunningGain[2];
                            pFramesOutF32[iFrame*4 + 3] = pFramesInF32[iFrame*4 + 3] * pRunningGain[3];

                            /* Move the running gain forward towards the new gain. */
                            pRunningGain[0] += pRunningGainDelta[0];
                            pRunningGain[1] += pRunningGainDelta[1];
                            pRunningGain[2] += pRunningGainDelta[2];
                            pRunningGain[3] += pRunningGainDelta[3];
                        }

                        iFrame = unrolledLoopCount << 1;
                    #else
                        for (; iFrame < interpolatedFrameCount; iFrame += 1) {
                            for (iChannel = 0; iChannel < 2; iChannel += 1) {
                                pFramesOutF32[iFrame*2 + iChannel] = pFramesInF32[iFrame*2 + iChannel] * pRunningGain[iChannel];
                            }

                            for (iChannel = 0; iChannel < 2; iChannel += 1) {
                                pRunningGain[iChannel] += pRunningGainDelta[iChannel];
                            }
                        }
                    #endif
                    }
                } else if (pGainer->config.channels == 6) {
                #if defined(MA_SUPPORT_SSE2)
                    if (ma_has_sse2()) {
                        /*
                        For 6 channels things are a bit more complicated because 6 isn't cleanly divisible by 4. We need to do 2 frames
                        at a time, meaning we'll be doing 12 samples in a group. Like the stereo case we'll need to expand some arrays
                        so we can do clean 4x SIMD operations.
                        */
                        ma_uint64 unrolledLoopCount = interpolatedFrameCount >> 1;

                        /* Expand some arrays so we can have a clean SIMD loop below. */
                        __m128 runningGainDelta0 = _mm_set_ps(pRunningGainDelta[3], pRunningGainDelta[2], pRunningGainDelta[1], pRunningGainDelta[0]);
                        __m128 runningGainDelta1 = _mm_set_ps(pRunningGainDelta[1], pRunningGainDelta[0], pRunningGainDelta[5], pRunningGainDelta[4]);
                        __m128 runningGainDelta2 = _mm_set_ps(pRunningGainDelta[5], pRunningGainDelta[4], pRunningGainDelta[3], pRunningGainDelta[2]);

                        __m128 runningGain0      = _mm_set_ps(pRunningGain[3],                        pRunningGain[2],                        pRunningGain[1],                        pRunningGain[0]);
                        __m128 runningGain1      = _mm_set_ps(pRunningGain[1] + pRunningGainDelta[1], pRunningGain[0] + pRunningGainDelta[0], pRunningGain[5],                        pRunningGain[4]);
                        __m128 runningGain2      = _mm_set_ps(pRunningGain[5] + pRunningGainDelta[5], pRunningGain[4] + pRunningGainDelta[4], pRunningGain[3] + pRunningGainDelta[3], pRunningGain[2] + pRunningGainDelta[2]);

                        for (; iFrame < unrolledLoopCount; iFrame += 1) {
                            _mm_storeu_ps(&pFramesOutF32[iFrame*12 + 0], _mm_mul_ps(_mm_loadu_ps(&pFramesInF32[iFrame*12 + 0]), runningGain0));
                            _mm_storeu_ps(&pFramesOutF32[iFrame*12 + 4], _mm_mul_ps(_mm_loadu_ps(&pFramesInF32[iFrame*12 + 4]), runningGain1));
                            _mm_storeu_ps(&pFramesOutF32[iFrame*12 + 8], _mm_mul_ps(_mm_loadu_ps(&pFramesInF32[iFrame*12 + 8]), runningGain2));

                            runningGain0 = _mm_add_ps(runningGain0, runningGainDelta0);
                            runningGain1 = _mm_add_ps(runningGain1, runningGainDelta1);
                            runningGain2 = _mm_add_ps(runningGain2, runningGainDelta2);
                        }

                        iFrame = unrolledLoopCount << 1;
                    } else
                #endif
                    {
                        for (; iFrame < interpolatedFrameCount; iFrame += 1) {
                            for (iChannel = 0; iChannel < 6; iChannel += 1) {
                                pFramesOutF32[iFrame*6 + iChannel] = pFramesInF32[iFrame*6 + iChannel] * pRunningGain[iChannel];
                            }

                            /* Move the running gain forward towards the new gain. */
                            for (iChannel = 0; iChannel < 6; iChannel += 1) {
                                pRunningGain[iChannel] += pRunningGainDelta[iChannel];
                            }
                        }
                    }
                } else if (pGainer->config.channels == 8) {
                    /* For 8 channels we can just go over frame by frame and do all eight channels as 2 separate 4x SIMD operations. */
                #if defined(MA_SUPPORT_SSE2)
                    if (ma_has_sse2()) {
                        __m128 runningGainDelta0 = _mm_loadu_ps(&pRunningGainDelta[0]);
                        __m128 runningGainDelta1 = _mm_loadu_ps(&pRunningGainDelta[4]);
                        __m128 runningGain0      = _mm_loadu_ps(&pRunningGain[0]);
                        __m128 runningGain1      = _mm_loadu_ps(&pRunningGain[4]);

                        for (; iFrame < interpolatedFrameCount; iFrame += 1) {
                            _mm_storeu_ps(&pFramesOutF32[iFrame*8 + 0], _mm_mul_ps(_mm_loadu_ps(&pFramesInF32[iFrame*8 + 0]), runningGain0));
                            _mm_storeu_ps(&pFramesOutF32[iFrame*8 + 4], _mm_mul_ps(_mm_loadu_ps(&pFramesInF32[iFrame*8 + 4]), runningGain1));

                            runningGain0 = _mm_add_ps(runningGain0, runningGainDelta0);
                            runningGain1 = _mm_add_ps(runningGain1, runningGainDelta1);
                        }
                    } else
                #endif
                    {
                        /* This is crafted so that it auto-vectorizes when compiled with Clang. */
                        for (; iFrame < interpolatedFrameCount; iFrame += 1) {
                            for (iChannel = 0; iChannel < 8; iChannel += 1) {
                                pFramesOutF32[iFrame*8 + iChannel] = pFramesInF32[iFrame*8 + iChannel] * pRunningGain[iChannel];
                            }

                            /* Move the running gain forward towards the new gain. */
                            for (iChannel = 0; iChannel < 8; iChannel += 1) {
                                pRunningGain[iChannel] += pRunningGainDelta[iChannel];
                            }
                        }
                    }
                }

                for (; iFrame < interpolatedFrameCount; iFrame += 1) {
                    for (iChannel = 0; iChannel < pGainer->config.channels; iChannel += 1) {
                        pFramesOutF32[iFrame*pGainer->config.channels + iChannel] = pFramesInF32[iFrame*pGainer->config.channels + iChannel] * pRunningGain[iChannel];
                        pRunningGain[iChannel] += pRunningGainDelta[iChannel];
                    }
                }
            } else {
                /* Slower path for extreme channel counts where we can't fit enough on the stack. We could also move this to the heap as part of the ma_gainer object which might even be better since it'll only be updated when the gains actually change. */
                for (iFrame = 0; iFrame < interpolatedFrameCount; iFrame += 1) {
                    for (iChannel = 0; iChannel < pGainer->config.channels; iChannel += 1) {
                        pFramesOutF32[iFrame*pGainer->config.channels + iChannel] = pFramesInF32[iFrame*pGainer->config.channels + iChannel] * ma_mix_f32_fast(pGainer->pOldGains[iChannel], pGainer->pNewGains[iChannel], a) * pGainer->masterVolume;
                    }

                    a += d;
                }
            }
        }

        /* Make sure the timer is updated. */
        pGainer->t = (ma_uint32)ma_min(pGainer->t + interpolatedFrameCount, pGainer->config.smoothTimeInFrames);

        /* Adjust our arguments so the next part can work normally. */
        frameCount -= interpolatedFrameCount;
        pFramesOut  = ma_offset_ptr(pFramesOut, interpolatedFrameCount * sizeof(float));
        pFramesIn   = ma_offset_ptr(pFramesIn,  interpolatedFrameCount * sizeof(float));
    }

    /* All we need to do here is apply the new gains using an optimized path. */
    if (pFramesOut != NULL && pFramesIn != NULL) {
        if (pGainer->config.channels <= 32) {
            float gains[32];
            for (iChannel = 0; iChannel < pGainer->config.channels; iChannel += 1) {
                gains[iChannel] = pGainer->pNewGains[iChannel] * pGainer->masterVolume;
            }

            ma_copy_and_apply_volume_factor_per_channel_f32((float*)pFramesOut, (const float*)pFramesIn, frameCount, pGainer->config.channels, gains);
        } else {
            /* Slow path. Too many channels to fit on the stack. Need to apply a master volume as a separate path. */
            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                for (iChannel = 0; iChannel < pGainer->config.channels; iChannel += 1) {
                    ((float*)pFramesOut)[iFrame*pGainer->config.channels + iChannel] = ((const float*)pFramesIn)[iFrame*pGainer->config.channels + iChannel] * pGainer->pNewGains[iChannel] * pGainer->masterVolume;
                }
            }
        }
    }

    /* Now that some frames have been processed we need to make sure future changes to the gain are interpolated. */
    if (pGainer->t == (ma_uint32)-1) {
        pGainer->t  = (ma_uint32)ma_min(pGainer->config.smoothTimeInFrames, frameCount);
    }

#if 0
    if (pGainer->t >= pGainer->config.smoothTimeInFrames) {
        /* Fast path. No gain calculation required. */
        ma_copy_and_apply_volume_factor_per_channel_f32(pFramesOutF32, pFramesInF32, frameCount, pGainer->config.channels, pGainer->pNewGains);
        ma_apply_volume_factor_f32(pFramesOutF32, frameCount * pGainer->config.channels, pGainer->masterVolume);

        /* Now that some frames have been processed we need to make sure future changes to the gain are interpolated. */
        if (pGainer->t == (ma_uint32)-1) {
            pGainer->t = pGainer->config.smoothTimeInFrames;
        }
    } else {
        /* Slow path. Need to interpolate the gain for each channel individually. */

        /* We can allow the input and output buffers to be null in which case we'll just update the internal timer. */
        if (pFramesOut != NULL && pFramesIn != NULL) {
            float a = (float)pGainer->t / pGainer->config.smoothTimeInFrames;
            float d = 1.0f / pGainer->config.smoothTimeInFrames;
            ma_uint32 channelCount = pGainer->config.channels;

            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                for (iChannel = 0; iChannel < channelCount; iChannel += 1) {
                    pFramesOutF32[iChannel] = pFramesInF32[iChannel] * ma_mix_f32_fast(pGainer->pOldGains[iChannel], pGainer->pNewGains[iChannel], a) * pGainer->masterVolume;
                }

                pFramesOutF32 += channelCount;
                pFramesInF32  += channelCount;

                a += d;
                if (a > 1) {
                    a = 1;
                }
            }
        }

        pGainer->t = (ma_uint32)ma_min(pGainer->t + frameCount, pGainer->config.smoothTimeInFrames);

    #if 0   /* Reference implementation. */
        for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
            /* We can allow the input and output buffers to be null in which case we'll just update the internal timer. */
            if (pFramesOut != NULL && pFramesIn != NULL) {
                for (iChannel = 0; iChannel < pGainer->config.channels; iChannel += 1) {
                    pFramesOutF32[iFrame * pGainer->config.channels + iChannel] = pFramesInF32[iFrame * pGainer->config.channels + iChannel] * ma_gainer_calculate_current_gain(pGainer, iChannel) * pGainer->masterVolume;
                }
            }

            /* Move interpolation time forward, but don't go beyond our smoothing time. */
            pGainer->t = ma_min(pGainer->t + 1, pGainer->config.smoothTimeInFrames);
        }
    #endif
    }
#endif

    return MA_SUCCESS;
}

MA_API ma_result ma_gainer_process_pcm_frames(ma_gainer* pGainer, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    if (pGainer == NULL) {
        return MA_INVALID_ARGS;
    }

    /*
    ma_gainer_process_pcm_frames_internal() marks pFramesOut and pFramesIn with MA_RESTRICT which
    helps with auto-vectorization.
    */
    return ma_gainer_process_pcm_frames_internal(pGainer, pFramesOut, pFramesIn, frameCount);
}

static void ma_gainer_set_gain_by_index(ma_gainer* pGainer, float newGain, ma_uint32 iChannel)
{
    pGainer->pOldGains[iChannel] = ma_gainer_calculate_current_gain(pGainer, iChannel);
    pGainer->pNewGains[iChannel] = newGain;
}

static void ma_gainer_reset_smoothing_time(ma_gainer* pGainer)
{
    if (pGainer->t == (ma_uint32)-1) {
        pGainer->t = pGainer->config.smoothTimeInFrames;    /* No smoothing required for initial gains setting. */
    } else {
        pGainer->t = 0;
    }
}

MA_API ma_result ma_gainer_set_gain(ma_gainer* pGainer, float newGain)
{
    ma_uint32 iChannel;

    if (pGainer == NULL) {
        return MA_INVALID_ARGS;
    }

    for (iChannel = 0; iChannel < pGainer->config.channels; iChannel += 1) {
        ma_gainer_set_gain_by_index(pGainer, newGain, iChannel);
    }

    /* The smoothing time needs to be reset to ensure we always interpolate by the configured smoothing time, but only if it's not the first setting. */
    ma_gainer_reset_smoothing_time(pGainer);

    return MA_SUCCESS;
}

MA_API ma_result ma_gainer_set_gains(ma_gainer* pGainer, float* pNewGains)
{
    ma_uint32 iChannel;

    if (pGainer == NULL || pNewGains == NULL) {
        return MA_INVALID_ARGS;
    }

    for (iChannel = 0; iChannel < pGainer->config.channels; iChannel += 1) {
        ma_gainer_set_gain_by_index(pGainer, pNewGains[iChannel], iChannel);
    }

    /* The smoothing time needs to be reset to ensure we always interpolate by the configured smoothing time, but only if it's not the first setting. */
    ma_gainer_reset_smoothing_time(pGainer);

    return MA_SUCCESS;
}

MA_API ma_result ma_gainer_set_master_volume(ma_gainer* pGainer, float volume)
{
    if (pGainer == NULL) {
        return MA_INVALID_ARGS;
    }

    pGainer->masterVolume = volume;

    return MA_SUCCESS;
}

MA_API ma_result ma_gainer_get_master_volume(const ma_gainer* pGainer, float* pVolume)
{
    if (pGainer == NULL || pVolume == NULL) {
        return MA_INVALID_ARGS;
    }

    *pVolume = pGainer->masterVolume;

    return MA_SUCCESS;
}


MA_API ma_panner_config ma_panner_config_init(ma_format format, ma_uint32 channels)
{
    ma_panner_config config;

    MA_ZERO_OBJECT(&config);
    config.format   = format;
    config.channels = channels;
    config.mode     = ma_pan_mode_balance;  /* Set to balancing mode by default because it's consistent with other audio engines and most likely what the caller is expecting. */
    config.pan      = 0;

    return config;
}


MA_API ma_result ma_panner_init(const ma_panner_config* pConfig, ma_panner* pPanner)
{
    if (pPanner == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pPanner);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    pPanner->format   = pConfig->format;
    pPanner->channels = pConfig->channels;
    pPanner->mode     = pConfig->mode;
    pPanner->pan      = pConfig->pan;

    return MA_SUCCESS;
}

static void ma_stereo_balance_pcm_frames_f32(float* pFramesOut, const float* pFramesIn, ma_uint64 frameCount, float pan)
{
    ma_uint64 iFrame;

    if (pan > 0) {
        float factor = 1.0f - pan;
        if (pFramesOut == pFramesIn) {
            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                pFramesOut[iFrame*2 + 0] = pFramesIn[iFrame*2 + 0] * factor;
            }
        } else {
            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                pFramesOut[iFrame*2 + 0] = pFramesIn[iFrame*2 + 0] * factor;
                pFramesOut[iFrame*2 + 1] = pFramesIn[iFrame*2 + 1];
            }
        }
    } else {
        float factor = 1.0f + pan;
        if (pFramesOut == pFramesIn) {
            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                pFramesOut[iFrame*2 + 1] = pFramesIn[iFrame*2 + 1] * factor;
            }
        } else {
            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                pFramesOut[iFrame*2 + 0] = pFramesIn[iFrame*2 + 0];
                pFramesOut[iFrame*2 + 1] = pFramesIn[iFrame*2 + 1] * factor;
            }
        }
    }
}

static void ma_stereo_balance_pcm_frames(void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount, ma_format format, float pan)
{
    if (pan == 0) {
        /* Fast path. No panning required. */
        if (pFramesOut == pFramesIn) {
            /* No-op */
        } else {
            ma_copy_pcm_frames(pFramesOut, pFramesIn, frameCount, format, 2);
        }

        return;
    }

    switch (format) {
        case ma_format_f32: ma_stereo_balance_pcm_frames_f32((float*)pFramesOut, (float*)pFramesIn, frameCount, pan); break;

        /* Unknown format. Just copy. */
        default:
        {
            ma_copy_pcm_frames(pFramesOut, pFramesIn, frameCount, format, 2);
        } break;
    }
}


static void ma_stereo_pan_pcm_frames_f32(float* pFramesOut, const float* pFramesIn, ma_uint64 frameCount, float pan)
{
    ma_uint64 iFrame;

    if (pan > 0) {
        float factorL0 = 1.0f - pan;
        float factorL1 = 0.0f + pan;

        for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
            float sample0 = (pFramesIn[iFrame*2 + 0] * factorL0);
            float sample1 = (pFramesIn[iFrame*2 + 0] * factorL1) + pFramesIn[iFrame*2 + 1];

            pFramesOut[iFrame*2 + 0] = sample0;
            pFramesOut[iFrame*2 + 1] = sample1;
        }
    } else {
        float factorR0 = 0.0f - pan;
        float factorR1 = 1.0f + pan;

        for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
            float sample0 = pFramesIn[iFrame*2 + 0] + (pFramesIn[iFrame*2 + 1] * factorR0);
            float sample1 =                           (pFramesIn[iFrame*2 + 1] * factorR1);

            pFramesOut[iFrame*2 + 0] = sample0;
            pFramesOut[iFrame*2 + 1] = sample1;
        }
    }
}

static void ma_stereo_pan_pcm_frames(void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount, ma_format format, float pan)
{
    if (pan == 0) {
        /* Fast path. No panning required. */
        if (pFramesOut == pFramesIn) {
            /* No-op */
        } else {
            ma_copy_pcm_frames(pFramesOut, pFramesIn, frameCount, format, 2);
        }

        return;
    }

    switch (format) {
        case ma_format_f32: ma_stereo_pan_pcm_frames_f32((float*)pFramesOut, (float*)pFramesIn, frameCount, pan); break;

        /* Unknown format. Just copy. */
        default:
        {
            ma_copy_pcm_frames(pFramesOut, pFramesIn, frameCount, format, 2);
        } break;
    }
}

MA_API ma_result ma_panner_process_pcm_frames(ma_panner* pPanner, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    if (pPanner == NULL || pFramesOut == NULL || pFramesIn == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pPanner->channels == 2) {
        /* Stereo case. For now assume channel 0 is left and channel right is 1, but should probably add support for a channel map. */
        if (pPanner->mode == ma_pan_mode_balance) {
            ma_stereo_balance_pcm_frames(pFramesOut, pFramesIn, frameCount, pPanner->format, pPanner->pan);
        } else {
            ma_stereo_pan_pcm_frames(pFramesOut, pFramesIn, frameCount, pPanner->format, pPanner->pan);
        }
    } else {
        if (pPanner->channels == 1) {
            /* Panning has no effect on mono streams. */
            ma_copy_pcm_frames(pFramesOut, pFramesIn, frameCount, pPanner->format, pPanner->channels);
        } else {
            /* For now we're not going to support non-stereo set ups. Not sure how I want to handle this case just yet. */
            ma_copy_pcm_frames(pFramesOut, pFramesIn, frameCount, pPanner->format, pPanner->channels);
        }
    }

    return MA_SUCCESS;
}

MA_API void ma_panner_set_mode(ma_panner* pPanner, ma_pan_mode mode)
{
    if (pPanner == NULL) {
        return;
    }

    pPanner->mode = mode;
}

MA_API ma_pan_mode ma_panner_get_mode(const ma_panner* pPanner)
{
    if (pPanner == NULL) {
        return ma_pan_mode_balance;
    }

    return pPanner->mode;
}

MA_API void ma_panner_set_pan(ma_panner* pPanner, float pan)
{
    if (pPanner == NULL) {
        return;
    }

    pPanner->pan = ma_clamp(pan, -1.0f, 1.0f);
}

MA_API float ma_panner_get_pan(const ma_panner* pPanner)
{
    if (pPanner == NULL) {
        return 0;
    }

    return pPanner->pan;
}




MA_API ma_fader_config ma_fader_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate)
{
    ma_fader_config config;

    MA_ZERO_OBJECT(&config);
    config.format     = format;
    config.channels   = channels;
    config.sampleRate = sampleRate;

    return config;
}


MA_API ma_result ma_fader_init(const ma_fader_config* pConfig, ma_fader* pFader)
{
    if (pFader == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pFader);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Only f32 is supported for now. */
    if (pConfig->format != ma_format_f32) {
        return MA_INVALID_ARGS;
    }

    pFader->config         = *pConfig;
    pFader->volumeBeg      = 1;
    pFader->volumeEnd      = 1;
    pFader->lengthInFrames = 0;
    pFader->cursorInFrames = 0;

    return MA_SUCCESS;
}

MA_API ma_result ma_fader_process_pcm_frames(ma_fader* pFader, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    if (pFader == NULL) {
        return MA_INVALID_ARGS;
    }

    /* If the cursor is still negative we need to just copy the absolute number of those frames, but no more than frameCount. */
    if (pFader->cursorInFrames < 0) {
        ma_uint64 absCursorInFrames = (ma_uint64)0 - pFader->cursorInFrames;
        if (absCursorInFrames > frameCount) {
            absCursorInFrames = frameCount;
        }

        ma_copy_pcm_frames(pFramesOut, pFramesIn, absCursorInFrames, pFader->config.format, pFader->config.channels);

        pFader->cursorInFrames += absCursorInFrames;
        frameCount -= absCursorInFrames;
        pFramesOut  = ma_offset_ptr(pFramesOut, ma_get_bytes_per_frame(pFader->config.format, pFader->config.channels)*absCursorInFrames);
        pFramesIn   = ma_offset_ptr(pFramesIn,  ma_get_bytes_per_frame(pFader->config.format, pFader->config.channels)*absCursorInFrames);
    }

    if (pFader->cursorInFrames >= 0) {
        /*
        For now we need to clamp frameCount so that the cursor never overflows 32-bits. This is required for
        the conversion to a float which we use for the linear interpolation. This might be changed later.
        */
        if (frameCount + pFader->cursorInFrames > UINT_MAX) {
            frameCount = UINT_MAX - pFader->cursorInFrames;
        }

        /* Optimized path if volumeBeg and volumeEnd are equal. */
        if (pFader->volumeBeg == pFader->volumeEnd) {
            if (pFader->volumeBeg == 1) {
                /* Straight copy. */
                ma_copy_pcm_frames(pFramesOut, pFramesIn, frameCount, pFader->config.format, pFader->config.channels);
            } else {
                /* Copy with volume. */
                ma_copy_and_apply_volume_and_clip_pcm_frames(pFramesOut, pFramesIn, frameCount, pFader->config.format, pFader->config.channels, pFader->volumeBeg);
            }
        } else {
            /* Slower path. Volumes are different, so may need to do an interpolation. */
            if ((ma_uint64)pFader->cursorInFrames >= pFader->lengthInFrames) {
                /* Fast path. We've gone past the end of the fade period so just apply the end volume to all samples. */
                ma_copy_and_apply_volume_and_clip_pcm_frames(pFramesOut, pFramesIn, frameCount, pFader->config.format, pFader->config.channels, pFader->volumeEnd);
            } else {
                /* Slow path. This is where we do the actual fading. */
                ma_uint64 iFrame;
                ma_uint32 iChannel;

                /* For now we only support f32. Support for other formats might be added later. */
                if (pFader->config.format == ma_format_f32) {
                    const float* pFramesInF32  = (const float*)pFramesIn;
                    /* */ float* pFramesOutF32 = (      float*)pFramesOut;

                    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                        float a = (ma_uint32)ma_min(pFader->cursorInFrames + iFrame, pFader->lengthInFrames) / (float)((ma_uint32)pFader->lengthInFrames);   /* Safe cast due to the frameCount clamp at the top of this function. */
                        float volume = ma_mix_f32_fast(pFader->volumeBeg, pFader->volumeEnd, a);

                        for (iChannel = 0; iChannel < pFader->config.channels; iChannel += 1) {
                            pFramesOutF32[iFrame*pFader->config.channels + iChannel] = pFramesInF32[iFrame*pFader->config.channels + iChannel] * volume;
                        }
                    }
                } else {
                    return MA_NOT_IMPLEMENTED;
                }
            }
        }
    }

    pFader->cursorInFrames += frameCount;

    return MA_SUCCESS;
}

MA_API void ma_fader_get_data_format(const ma_fader* pFader, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate)
{
    if (pFader == NULL) {
        return;
    }

    if (pFormat != NULL) {
        *pFormat = pFader->config.format;
    }

    if (pChannels != NULL) {
        *pChannels = pFader->config.channels;
    }

    if (pSampleRate != NULL) {
        *pSampleRate = pFader->config.sampleRate;
    }
}

MA_API void ma_fader_set_fade(ma_fader* pFader, float volumeBeg, float volumeEnd, ma_uint64 lengthInFrames)
{
    ma_fader_set_fade_ex(pFader, volumeBeg, volumeEnd, lengthInFrames, 0);
}

MA_API void ma_fader_set_fade_ex(ma_fader* pFader, float volumeBeg, float volumeEnd, ma_uint64 lengthInFrames, ma_int64 startOffsetInFrames)
{
    if (pFader == NULL) {
        return;
    }

    /* If the volume is negative, use current volume. */
    if (volumeBeg < 0) {
        volumeBeg = ma_fader_get_current_volume(pFader);
    }

    /*
    The length needs to be clamped to 32-bits due to how we convert it to a float for linear
    interpolation reasons. I might change this requirement later, but for now it's not important.
    */
    if (lengthInFrames > UINT_MAX) {
        lengthInFrames = UINT_MAX;
    }

    /* The start offset needs to be clamped to ensure it doesn't overflow a signed number. */
    if (startOffsetInFrames > INT_MAX) {
        startOffsetInFrames = INT_MAX;
    }

    pFader->volumeBeg      = volumeBeg;
    pFader->volumeEnd      = volumeEnd;
    pFader->lengthInFrames = lengthInFrames;
    pFader->cursorInFrames = -startOffsetInFrames;
}

MA_API float ma_fader_get_current_volume(const ma_fader* pFader)
{
    if (pFader == NULL) {
        return 0.0f;
    }

    /* Any frames prior to the start of the fade period will be at unfaded volume. */
    if (pFader->cursorInFrames < 0) {
        return 1.0f;
    }

    /* The current volume depends on the position of the cursor. */
    if (pFader->cursorInFrames == 0) {
        return pFader->volumeBeg;
    } else if ((ma_uint64)pFader->cursorInFrames >= pFader->lengthInFrames) {   /* Safe case because the < 0 case was checked above. */
        return pFader->volumeEnd;
    } else {
        /* The cursor is somewhere inside the fading period. We can figure this out with a simple linear interpolation between volumeBeg and volumeEnd based on our cursor position. */
        return ma_mix_f32_fast(pFader->volumeBeg, pFader->volumeEnd, (ma_uint32)pFader->cursorInFrames / (float)((ma_uint32)pFader->lengthInFrames));    /* Safe cast to uint32 because we clamp it in ma_fader_process_pcm_frames(). */
    }
}





MA_API ma_vec3f ma_vec3f_init_3f(float x, float y, float z)
{
    ma_vec3f v;

    v.x = x;
    v.y = y;
    v.z = z;

    return v;
}

MA_API ma_vec3f ma_vec3f_sub(ma_vec3f a, ma_vec3f b)
{
    return ma_vec3f_init_3f(
        a.x - b.x,
        a.y - b.y,
        a.z - b.z
    );
}

MA_API ma_vec3f ma_vec3f_neg(ma_vec3f a)
{
    return ma_vec3f_init_3f(
        -a.x,
        -a.y,
        -a.z
    );
}

MA_API float ma_vec3f_dot(ma_vec3f a, ma_vec3f b)
{
    return a.x*b.x + a.y*b.y + a.z*b.z;
}

MA_API float ma_vec3f_len2(ma_vec3f v)
{
    return ma_vec3f_dot(v, v);
}

MA_API float ma_vec3f_len(ma_vec3f v)
{
    return (float)ma_sqrtd(ma_vec3f_len2(v));
}



MA_API float ma_vec3f_dist(ma_vec3f a, ma_vec3f b)
{
    return ma_vec3f_len(ma_vec3f_sub(a, b));
}

MA_API ma_vec3f ma_vec3f_normalize(ma_vec3f v)
{
    float invLen;
    float len2 = ma_vec3f_len2(v);
    if (len2 == 0) {
        return ma_vec3f_init_3f(0, 0, 0);
    }

    invLen = ma_rsqrtf(len2);
    v.x *= invLen;
    v.y *= invLen;
    v.z *= invLen;

    return v;
}

MA_API ma_vec3f ma_vec3f_cross(ma_vec3f a, ma_vec3f b)
{
    return ma_vec3f_init_3f(
        a.y*b.z - a.z*b.y,
        a.z*b.x - a.x*b.z,
        a.x*b.y - a.y*b.x
    );
}


MA_API void ma_atomic_vec3f_init(ma_atomic_vec3f* v, ma_vec3f value)
{
    v->v = value;
    v->lock = 0;    /* Important this is initialized to 0. */
}

MA_API void ma_atomic_vec3f_set(ma_atomic_vec3f* v, ma_vec3f value)
{
    ma_spinlock_lock(&v->lock);
    {
        v->v = value;
    }
    ma_spinlock_unlock(&v->lock);
}

MA_API ma_vec3f ma_atomic_vec3f_get(ma_atomic_vec3f* v)
{
    ma_vec3f r;

    ma_spinlock_lock(&v->lock);
    {
        r = v->v;
    }
    ma_spinlock_unlock(&v->lock);

    return r;
}



static void ma_channel_map_apply_f32(float* pFramesOut, const ma_channel* pChannelMapOut, ma_uint32 channelsOut, const float* pFramesIn, const ma_channel* pChannelMapIn, ma_uint32 channelsIn, ma_uint64 frameCount, ma_channel_mix_mode mode, ma_mono_expansion_mode monoExpansionMode);
static ma_bool32 ma_is_spatial_channel_position(ma_channel channelPosition);


#ifndef MA_DEFAULT_SPEED_OF_SOUND
#define MA_DEFAULT_SPEED_OF_SOUND   343.3f
#endif

/*
These vectors represent the direction that speakers are facing from the center point. They're used
for panning in the spatializer. Must be normalized.
*/
static ma_vec3f g_maChannelDirections[MA_CHANNEL_POSITION_COUNT] = {
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_NONE */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_MONO */
    {-0.7071f,  0.0f,    -0.7071f },  /* MA_CHANNEL_FRONT_LEFT */
    {+0.7071f,  0.0f,    -0.7071f },  /* MA_CHANNEL_FRONT_RIGHT */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_FRONT_CENTER */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_LFE */
    {-0.7071f,  0.0f,    +0.7071f },  /* MA_CHANNEL_BACK_LEFT */
    {+0.7071f,  0.0f,    +0.7071f },  /* MA_CHANNEL_BACK_RIGHT */
    {-0.3162f,  0.0f,    -0.9487f },  /* MA_CHANNEL_FRONT_LEFT_CENTER */
    {+0.3162f,  0.0f,    -0.9487f },  /* MA_CHANNEL_FRONT_RIGHT_CENTER */
    { 0.0f,     0.0f,    +1.0f    },  /* MA_CHANNEL_BACK_CENTER */
    {-1.0f,     0.0f,     0.0f    },  /* MA_CHANNEL_SIDE_LEFT */
    {+1.0f,     0.0f,     0.0f    },  /* MA_CHANNEL_SIDE_RIGHT */
    { 0.0f,    +1.0f,     0.0f    },  /* MA_CHANNEL_TOP_CENTER */
    {-0.5774f, +0.5774f, -0.5774f },  /* MA_CHANNEL_TOP_FRONT_LEFT */
    { 0.0f,    +0.7071f, -0.7071f },  /* MA_CHANNEL_TOP_FRONT_CENTER */
    {+0.5774f, +0.5774f, -0.5774f },  /* MA_CHANNEL_TOP_FRONT_RIGHT */
    {-0.5774f, +0.5774f, +0.5774f },  /* MA_CHANNEL_TOP_BACK_LEFT */
    { 0.0f,    +0.7071f, +0.7071f },  /* MA_CHANNEL_TOP_BACK_CENTER */
    {+0.5774f, +0.5774f, +0.5774f },  /* MA_CHANNEL_TOP_BACK_RIGHT */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_0 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_1 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_2 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_3 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_4 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_5 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_6 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_7 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_8 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_9 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_10 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_11 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_12 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_13 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_14 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_15 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_16 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_17 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_18 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_19 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_20 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_21 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_22 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_23 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_24 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_25 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_26 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_27 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_28 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_29 */
    { 0.0f,     0.0f,    -1.0f    },  /* MA_CHANNEL_AUX_30 */
    { 0.0f,     0.0f,    -1.0f    }   /* MA_CHANNEL_AUX_31 */
};

static ma_vec3f ma_get_channel_direction(ma_channel channel)
{
    if (channel >= MA_CHANNEL_POSITION_COUNT) {
        return ma_vec3f_init_3f(0, 0, -1);
    } else {
        return g_maChannelDirections[channel];
    }
}



static float ma_attenuation_inverse(float distance, float minDistance, float maxDistance, float rolloff)
{
    if (minDistance >= maxDistance) {
        return 1;   /* To avoid division by zero. Do not attenuate. */
    }

    return minDistance / (minDistance + rolloff * (ma_clamp(distance, minDistance, maxDistance) - minDistance));
}

static float ma_attenuation_linear(float distance, float minDistance, float maxDistance, float rolloff)
{
    if (minDistance >= maxDistance) {
        return 1;   /* To avoid division by zero. Do not attenuate. */
    }

    return 1 - rolloff * (ma_clamp(distance, minDistance, maxDistance) - minDistance) / (maxDistance - minDistance);
}

static float ma_attenuation_exponential(float distance, float minDistance, float maxDistance, float rolloff)
{
    if (minDistance >= maxDistance) {
        return 1;   /* To avoid division by zero. Do not attenuate. */
    }

    return (float)ma_powd(ma_clamp(distance, minDistance, maxDistance) / minDistance, -rolloff);
}


/*
Doppler Effect calculation taken from the OpenAL spec, with two main differences:

  1) The source to listener vector will have already been calculated at an earlier step so we can
     just use that directly. We need only the position of the source relative to the origin.

  2) We don't scale by a frequency because we actually just want the ratio which we'll plug straight
     into the resampler directly.
*/
static float ma_doppler_pitch(ma_vec3f relativePosition, ma_vec3f sourceVelocity, ma_vec3f listenVelocity, float speedOfSound, float dopplerFactor)
{
    float len;
    float vls;
    float vss;

    len = ma_vec3f_len(relativePosition);

    /*
    There's a case where the position of the source will be right on top of the listener in which
    case the length will be 0 and we'll end up with a division by zero. We can just return a ratio
    of 1.0 in this case. This is not considered in the OpenAL spec, but is necessary.
    */
    if (len == 0) {
        return 1.0;
    }

    vls = ma_vec3f_dot(relativePosition, listenVelocity) / len;
    vss = ma_vec3f_dot(relativePosition, sourceVelocity) / len;

    vls = ma_min(vls, speedOfSound / dopplerFactor);
    vss = ma_min(vss, speedOfSound / dopplerFactor);

    return (speedOfSound - dopplerFactor*vls) / (speedOfSound - dopplerFactor*vss);
}


static void ma_get_default_channel_map_for_spatializer(ma_channel* pChannelMap, size_t channelMapCap, ma_uint32 channelCount)
{
    /*
    Special case for stereo. Want to default the left and right speakers to side left and side
    right so that they're facing directly down the X axis rather than slightly forward. Not
    doing this will result in sounds being quieter when behind the listener. This might
    actually be good for some scenarios, but I don't think it's an appropriate default because
    it can be a bit unexpected.
    */
    if (channelCount == 2) {
        pChannelMap[0] = MA_CHANNEL_SIDE_LEFT;
        pChannelMap[1] = MA_CHANNEL_SIDE_RIGHT;
    } else {
        ma_channel_map_init_standard(ma_standard_channel_map_default, pChannelMap, channelMapCap, channelCount);
    }
}


MA_API ma_spatializer_listener_config ma_spatializer_listener_config_init(ma_uint32 channelsOut)
{
    ma_spatializer_listener_config config;

    MA_ZERO_OBJECT(&config);
    config.channelsOut             = channelsOut;
    config.pChannelMapOut          = NULL;
    config.handedness              = ma_handedness_right;
    config.worldUp                 = ma_vec3f_init_3f(0, 1,  0);
    config.coneInnerAngleInRadians = 6.283185f; /* 360 degrees. */
    config.coneOuterAngleInRadians = 6.283185f; /* 360 degrees. */
    config.coneOuterGain           = 0;
    config.speedOfSound            = 343.3f;    /* Same as OpenAL. Used for doppler effect. */

    return config;
}


typedef struct
{
    size_t sizeInBytes;
    size_t channelMapOutOffset;
} ma_spatializer_listener_heap_layout;

static ma_result ma_spatializer_listener_get_heap_layout(const ma_spatializer_listener_config* pConfig, ma_spatializer_listener_heap_layout* pHeapLayout)
{
    MA_ASSERT(pHeapLayout != NULL);

    MA_ZERO_OBJECT(pHeapLayout);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->channelsOut == 0) {
        return MA_INVALID_ARGS;
    }

    pHeapLayout->sizeInBytes = 0;

    /* Channel map. We always need this, even for passthroughs. */
    pHeapLayout->channelMapOutOffset = pHeapLayout->sizeInBytes;
    pHeapLayout->sizeInBytes += ma_align_64(sizeof(*pConfig->pChannelMapOut) * pConfig->channelsOut);

    return MA_SUCCESS;
}


MA_API ma_result ma_spatializer_listener_get_heap_size(const ma_spatializer_listener_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_spatializer_listener_heap_layout heapLayout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = 0;

    result = ma_spatializer_listener_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pHeapSizeInBytes = heapLayout.sizeInBytes;

    return MA_SUCCESS;
}

MA_API ma_result ma_spatializer_listener_init_preallocated(const ma_spatializer_listener_config* pConfig, void* pHeap, ma_spatializer_listener* pListener)
{
    ma_result result;
    ma_spatializer_listener_heap_layout heapLayout;

    if (pListener == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pListener);

    result = ma_spatializer_listener_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    pListener->_pHeap = pHeap;
    MA_ZERO_MEMORY(pHeap, heapLayout.sizeInBytes);

    pListener->config    = *pConfig;
    ma_atomic_vec3f_init(&pListener->position,  ma_vec3f_init_3f(0, 0, 0));
    ma_atomic_vec3f_init(&pListener->direction, ma_vec3f_init_3f(0, 0, -1));
    ma_atomic_vec3f_init(&pListener->velocity,  ma_vec3f_init_3f(0, 0,  0));
    pListener->isEnabled = MA_TRUE;

    /* Swap the forward direction if we're left handed (it was initialized based on right handed). */
    if (pListener->config.handedness == ma_handedness_left) {
        ma_vec3f negDir = ma_vec3f_neg(ma_spatializer_listener_get_direction(pListener));
        ma_spatializer_listener_set_direction(pListener, negDir.x, negDir.y, negDir.z);
    }


    /* We must always have a valid channel map. */
    pListener->config.pChannelMapOut = (ma_channel*)ma_offset_ptr(pHeap, heapLayout.channelMapOutOffset);

    /* Use a slightly different default channel map for stereo. */
    if (pConfig->pChannelMapOut == NULL) {
        ma_get_default_channel_map_for_spatializer(pListener->config.pChannelMapOut, pConfig->channelsOut, pConfig->channelsOut);
    } else {
        ma_channel_map_copy_or_default(pListener->config.pChannelMapOut, pConfig->channelsOut, pConfig->pChannelMapOut, pConfig->channelsOut);
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_spatializer_listener_init(const ma_spatializer_listener_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_spatializer_listener* pListener)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_spatializer_listener_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_spatializer_listener_init_preallocated(pConfig, pHeap, pListener);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pListener->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_spatializer_listener_uninit(ma_spatializer_listener* pListener, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pListener == NULL) {
        return;
    }

    if (pListener->_ownsHeap) {
        ma_free(pListener->_pHeap, pAllocationCallbacks);
    }
}

MA_API ma_channel* ma_spatializer_listener_get_channel_map(ma_spatializer_listener* pListener)
{
    if (pListener == NULL) {
        return NULL;
    }

    return pListener->config.pChannelMapOut;
}

MA_API void ma_spatializer_listener_set_cone(ma_spatializer_listener* pListener, float innerAngleInRadians, float outerAngleInRadians, float outerGain)
{
    if (pListener == NULL) {
        return;
    }

    pListener->config.coneInnerAngleInRadians = innerAngleInRadians;
    pListener->config.coneOuterAngleInRadians = outerAngleInRadians;
    pListener->config.coneOuterGain           = outerGain;
}

MA_API void ma_spatializer_listener_get_cone(const ma_spatializer_listener* pListener, float* pInnerAngleInRadians, float* pOuterAngleInRadians, float* pOuterGain)
{
    if (pListener == NULL) {
        return;
    }

    if (pInnerAngleInRadians != NULL) {
        *pInnerAngleInRadians = pListener->config.coneInnerAngleInRadians;
    }

    if (pOuterAngleInRadians != NULL) {
        *pOuterAngleInRadians = pListener->config.coneOuterAngleInRadians;
    }

    if (pOuterGain != NULL) {
        *pOuterGain = pListener->config.coneOuterGain;
    }
}

MA_API void ma_spatializer_listener_set_position(ma_spatializer_listener* pListener, float x, float y, float z)
{
    if (pListener == NULL) {
        return;
    }

    ma_atomic_vec3f_set(&pListener->position, ma_vec3f_init_3f(x, y, z));
}

MA_API ma_vec3f ma_spatializer_listener_get_position(const ma_spatializer_listener* pListener)
{
    if (pListener == NULL) {
        return ma_vec3f_init_3f(0, 0, 0);
    }

    return ma_atomic_vec3f_get((ma_atomic_vec3f*)&pListener->position); /* Naughty const-cast. It's just for atomically loading the vec3 which should be safe. */
}

MA_API void ma_spatializer_listener_set_direction(ma_spatializer_listener* pListener, float x, float y, float z)
{
    if (pListener == NULL) {
        return;
    }

    ma_atomic_vec3f_set(&pListener->direction, ma_vec3f_init_3f(x, y, z));
}

MA_API ma_vec3f ma_spatializer_listener_get_direction(const ma_spatializer_listener* pListener)
{
    if (pListener == NULL) {
        return ma_vec3f_init_3f(0, 0, -1);
    }

    return ma_atomic_vec3f_get((ma_atomic_vec3f*)&pListener->direction);    /* Naughty const-cast. It's just for atomically loading the vec3 which should be safe. */
}

MA_API void ma_spatializer_listener_set_velocity(ma_spatializer_listener* pListener, float x, float y, float z)
{
    if (pListener == NULL) {
        return;
    }

    ma_atomic_vec3f_set(&pListener->velocity, ma_vec3f_init_3f(x, y, z));
}

MA_API ma_vec3f ma_spatializer_listener_get_velocity(const ma_spatializer_listener* pListener)
{
    if (pListener == NULL) {
        return ma_vec3f_init_3f(0, 0, 0);
    }

    return ma_atomic_vec3f_get((ma_atomic_vec3f*)&pListener->velocity); /* Naughty const-cast. It's just for atomically loading the vec3 which should be safe. */
}

MA_API void ma_spatializer_listener_set_speed_of_sound(ma_spatializer_listener* pListener, float speedOfSound)
{
    if (pListener == NULL) {
        return;
    }

    pListener->config.speedOfSound = speedOfSound;
}

MA_API float ma_spatializer_listener_get_speed_of_sound(const ma_spatializer_listener* pListener)
{
    if (pListener == NULL) {
        return 0;
    }

    return pListener->config.speedOfSound;
}

MA_API void ma_spatializer_listener_set_world_up(ma_spatializer_listener* pListener, float x, float y, float z)
{
    if (pListener == NULL) {
        return;
    }

    pListener->config.worldUp = ma_vec3f_init_3f(x, y, z);
}

MA_API ma_vec3f ma_spatializer_listener_get_world_up(const ma_spatializer_listener* pListener)
{
    if (pListener == NULL) {
        return ma_vec3f_init_3f(0, 1, 0);
    }

    return pListener->config.worldUp;
}

MA_API void ma_spatializer_listener_set_enabled(ma_spatializer_listener* pListener, ma_bool32 isEnabled)
{
    if (pListener == NULL) {
        return;
    }

    pListener->isEnabled = isEnabled;
}

MA_API ma_bool32 ma_spatializer_listener_is_enabled(const ma_spatializer_listener* pListener)
{
    if (pListener == NULL) {
        return MA_FALSE;
    }

    return pListener->isEnabled;
}




MA_API ma_spatializer_config ma_spatializer_config_init(ma_uint32 channelsIn, ma_uint32 channelsOut)
{
    ma_spatializer_config config;

    MA_ZERO_OBJECT(&config);
    config.channelsIn                   = channelsIn;
    config.channelsOut                  = channelsOut;
    config.pChannelMapIn                = NULL;
    config.attenuationModel             = ma_attenuation_model_inverse;
    config.positioning                  = ma_positioning_absolute;
    config.handedness                   = ma_handedness_right;
    config.minGain                      = 0;
    config.maxGain                      = 1;
    config.minDistance                  = 1;
    config.maxDistance                  = MA_FLT_MAX;
    config.rolloff                      = 1;
    config.coneInnerAngleInRadians      = 6.283185f; /* 360 degrees. */
    config.coneOuterAngleInRadians      = 6.283185f; /* 360 degrees. */
    config.coneOuterGain                = 0.0f;
    config.dopplerFactor                = 1;
    config.directionalAttenuationFactor = 1;
    config.minSpatializationChannelGain = 0.2f;
    config.gainSmoothTimeInFrames       = 360;       /* 7.5ms @ 48K. */

    return config;
}


static ma_gainer_config ma_spatializer_gainer_config_init(const ma_spatializer_config* pConfig)
{
    MA_ASSERT(pConfig != NULL);
    return ma_gainer_config_init(pConfig->channelsOut, pConfig->gainSmoothTimeInFrames);
}

static ma_result ma_spatializer_validate_config(const ma_spatializer_config* pConfig)
{
    MA_ASSERT(pConfig != NULL);

    if (pConfig->channelsIn == 0 || pConfig->channelsOut == 0) {
        return MA_INVALID_ARGS;
    }

    return MA_SUCCESS;
}

typedef struct
{
    size_t sizeInBytes;
    size_t channelMapInOffset;
    size_t newChannelGainsOffset;
    size_t gainerOffset;
} ma_spatializer_heap_layout;

static ma_result ma_spatializer_get_heap_layout(const ma_spatializer_config* pConfig, ma_spatializer_heap_layout* pHeapLayout)
{
    ma_result result;

    MA_ASSERT(pHeapLayout != NULL);

    MA_ZERO_OBJECT(pHeapLayout);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    result = ma_spatializer_validate_config(pConfig);
    if (result != MA_SUCCESS) {
        return result;
    }

    pHeapLayout->sizeInBytes = 0;

    /* Channel map. */
    pHeapLayout->channelMapInOffset = MA_SIZE_MAX;  /* <-- MA_SIZE_MAX indicates no allocation necessary. */
    if (pConfig->pChannelMapIn != NULL) {
        pHeapLayout->channelMapInOffset = pHeapLayout->sizeInBytes;
        pHeapLayout->sizeInBytes += ma_align_64(sizeof(*pConfig->pChannelMapIn) * pConfig->channelsIn);
    }

    /* New channel gains for output. */
    pHeapLayout->newChannelGainsOffset = pHeapLayout->sizeInBytes;
    pHeapLayout->sizeInBytes += ma_align_64(sizeof(float) * pConfig->channelsOut);

    /* Gainer. */
    {
        size_t gainerHeapSizeInBytes;
        ma_gainer_config gainerConfig;

        gainerConfig = ma_spatializer_gainer_config_init(pConfig);

        result = ma_gainer_get_heap_size(&gainerConfig, &gainerHeapSizeInBytes);
        if (result != MA_SUCCESS) {
            return result;
        }

        pHeapLayout->gainerOffset = pHeapLayout->sizeInBytes;
        pHeapLayout->sizeInBytes += ma_align_64(gainerHeapSizeInBytes);
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_spatializer_get_heap_size(const ma_spatializer_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_spatializer_heap_layout heapLayout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = 0;  /* Safety. */

    result = ma_spatializer_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pHeapSizeInBytes = heapLayout.sizeInBytes;

    return MA_SUCCESS;
}


MA_API ma_result ma_spatializer_init_preallocated(const ma_spatializer_config* pConfig, void* pHeap, ma_spatializer* pSpatializer)
{
    ma_result result;
    ma_spatializer_heap_layout heapLayout;
    ma_gainer_config gainerConfig;

    if (pSpatializer == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pSpatializer);

    if (pConfig == NULL || pHeap == NULL) {
        return MA_INVALID_ARGS;
    }

    result = ma_spatializer_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    pSpatializer->_pHeap = pHeap;
    MA_ZERO_MEMORY(pHeap, heapLayout.sizeInBytes);

    pSpatializer->channelsIn                   = pConfig->channelsIn;
    pSpatializer->channelsOut                  = pConfig->channelsOut;
    pSpatializer->attenuationModel             = pConfig->attenuationModel;
    pSpatializer->positioning                  = pConfig->positioning;
    pSpatializer->handedness                   = pConfig->handedness;
    pSpatializer->minGain                      = pConfig->minGain;
    pSpatializer->maxGain                      = pConfig->maxGain;
    pSpatializer->minDistance                  = pConfig->minDistance;
    pSpatializer->maxDistance                  = pConfig->maxDistance;
    pSpatializer->rolloff                      = pConfig->rolloff;
    pSpatializer->coneInnerAngleInRadians      = pConfig->coneInnerAngleInRadians;
    pSpatializer->coneOuterAngleInRadians      = pConfig->coneOuterAngleInRadians;
    pSpatializer->coneOuterGain                = pConfig->coneOuterGain;
    pSpatializer->dopplerFactor                = pConfig->dopplerFactor;
    pSpatializer->minSpatializationChannelGain = pConfig->minSpatializationChannelGain;
    pSpatializer->directionalAttenuationFactor = pConfig->directionalAttenuationFactor;
    pSpatializer->gainSmoothTimeInFrames       = pConfig->gainSmoothTimeInFrames;
    ma_atomic_vec3f_init(&pSpatializer->position,  ma_vec3f_init_3f(0, 0,  0));
    ma_atomic_vec3f_init(&pSpatializer->direction, ma_vec3f_init_3f(0, 0, -1));
    ma_atomic_vec3f_init(&pSpatializer->velocity,  ma_vec3f_init_3f(0, 0,  0));
    pSpatializer->dopplerPitch                 = 1;

    /* Swap the forward direction if we're left handed (it was initialized based on right handed). */
    if (pSpatializer->handedness == ma_handedness_left) {
        ma_vec3f negDir = ma_vec3f_neg(ma_spatializer_get_direction(pSpatializer));
        ma_spatializer_set_direction(pSpatializer, negDir.x, negDir.y, negDir.z);
    }

    /* Channel map. This will be on the heap. */
    if (pConfig->pChannelMapIn != NULL) {
        pSpatializer->pChannelMapIn = (ma_channel*)ma_offset_ptr(pHeap, heapLayout.channelMapInOffset);
        ma_channel_map_copy_or_default(pSpatializer->pChannelMapIn, pSpatializer->channelsIn, pConfig->pChannelMapIn, pSpatializer->channelsIn);
    }

    /* New channel gains for output channels. */
    pSpatializer->pNewChannelGainsOut = (float*)ma_offset_ptr(pHeap, heapLayout.newChannelGainsOffset);

    /* Gainer. */
    gainerConfig = ma_spatializer_gainer_config_init(pConfig);

    result = ma_gainer_init_preallocated(&gainerConfig, ma_offset_ptr(pHeap, heapLayout.gainerOffset), &pSpatializer->gainer);
    if (result != MA_SUCCESS) {
        return result;  /* Failed to initialize the gainer. */
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_spatializer_init(const ma_spatializer_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_spatializer* pSpatializer)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    /* We'll need a heap allocation to retrieve the size. */
    result = ma_spatializer_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_spatializer_init_preallocated(pConfig, pHeap, pSpatializer);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pSpatializer->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_spatializer_uninit(ma_spatializer* pSpatializer, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pSpatializer == NULL) {
        return;
    }

    ma_gainer_uninit(&pSpatializer->gainer, pAllocationCallbacks);

    if (pSpatializer->_ownsHeap) {
        ma_free(pSpatializer->_pHeap, pAllocationCallbacks);
    }
}

static float ma_calculate_angular_gain(ma_vec3f dirA, ma_vec3f dirB, float coneInnerAngleInRadians, float coneOuterAngleInRadians, float coneOuterGain)
{
    /*
    Angular attenuation.

    Unlike distance gain, the math for this is not specified by the OpenAL spec so we'll just go ahead and figure
    this out for ourselves at the expense of possibly being inconsistent with other implementations.

    To do cone attenuation, I'm just using the same math that we'd use to implement a basic spotlight in OpenGL. We
    just need to get the direction from the source to the listener and then do a dot product against that and the
    direction of the spotlight. Then we just compare that dot product against the cosine of the inner and outer
    angles. If the dot product is greater than the outer angle, we just use coneOuterGain. If it's less than
    the inner angle, we just use a gain of 1. Otherwise we linearly interpolate between 1 and coneOuterGain.
    */
    if (coneInnerAngleInRadians < 6.283185f) {
        float angularGain = 1;
        float cutoffInner = (float)ma_cosd(coneInnerAngleInRadians*0.5f);
        float cutoffOuter = (float)ma_cosd(coneOuterAngleInRadians*0.5f);
        float d;

        d = ma_vec3f_dot(dirA, dirB);

        if (d > cutoffInner) {
            /* It's inside the inner angle. */
            angularGain = 1;
        } else {
            /* It's outside the inner angle. */
            if (d > cutoffOuter) {
                /* It's between the inner and outer angle. We need to linearly interpolate between 1 and coneOuterGain. */
                angularGain = ma_mix_f32(coneOuterGain, 1, (d - cutoffOuter) / (cutoffInner - cutoffOuter));
            } else {
                /* It's outside the outer angle. */
                angularGain = coneOuterGain;
            }
        }

        /*printf("d = %f; cutoffInner = %f; cutoffOuter = %f; angularGain = %f\n", d, cutoffInner, cutoffOuter, angularGain);*/
        return angularGain;
    } else {
        /* Inner angle is 360 degrees so no need to do any attenuation. */
        return 1;
    }
}

MA_API ma_result ma_spatializer_process_pcm_frames(ma_spatializer* pSpatializer, ma_spatializer_listener* pListener, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    ma_channel* pChannelMapIn  = pSpatializer->pChannelMapIn;
    ma_channel* pChannelMapOut = pListener->config.pChannelMapOut;

    if (pSpatializer == NULL) {
        return MA_INVALID_ARGS;
    }

    /* If we're not spatializing we need to run an optimized path. */
    if (ma_atomic_load_i32(&pSpatializer->attenuationModel) == ma_attenuation_model_none) {
        if (ma_spatializer_listener_is_enabled(pListener)) {
            /* No attenuation is required, but we'll need to do some channel conversion. */
            if (pSpatializer->channelsIn == pSpatializer->channelsOut) {
                ma_copy_pcm_frames(pFramesOut, pFramesIn, frameCount, ma_format_f32, pSpatializer->channelsIn);
            } else {
                ma_channel_map_apply_f32((float*)pFramesOut, pChannelMapOut, pSpatializer->channelsOut, (const float*)pFramesIn, pChannelMapIn, pSpatializer->channelsIn, frameCount, ma_channel_mix_mode_rectangular, ma_mono_expansion_mode_default);   /* Safe casts to float* because f32 is the only supported format. */
            }
        } else {
            /* The listener is disabled. Output silence. */
            ma_silence_pcm_frames(pFramesOut, frameCount, ma_format_f32, pSpatializer->channelsOut);
        }

        /*
        We're not doing attenuation so don't bother with doppler for now. I'm not sure if this is
        the correct thinking so might need to review this later.
        */
        pSpatializer->dopplerPitch = 1;
    } else {
        /*
        Let's first determine which listener the sound is closest to. Need to keep in mind that we
        might not have a world or any listeners, in which case we just spatializer based on the
        listener being positioned at the origin (0, 0, 0).
        */
        ma_vec3f relativePosNormalized;
        ma_vec3f relativePos;   /* The position relative to the listener. */
        ma_vec3f relativeDir;   /* The direction of the sound, relative to the listener. */
        ma_vec3f listenerVel;   /* The velocity of the listener. For doppler pitch calculation. */
        float speedOfSound;
        float distance = 0;
        float gain = 1;
        ma_uint32 iChannel;
        const ma_uint32 channelsOut = pSpatializer->channelsOut;
        const ma_uint32 channelsIn  = pSpatializer->channelsIn;
        float minDistance = ma_spatializer_get_min_distance(pSpatializer);
        float maxDistance = ma_spatializer_get_max_distance(pSpatializer);
        float rolloff = ma_spatializer_get_rolloff(pSpatializer);
        float dopplerFactor = ma_spatializer_get_doppler_factor(pSpatializer);

        /*
        We'll need the listener velocity for doppler pitch calculations. The speed of sound is
        defined by the listener, so we'll grab that here too.
        */
        if (pListener != NULL) {
            listenerVel  = ma_spatializer_listener_get_velocity(pListener);
            speedOfSound = pListener->config.speedOfSound;
        } else {
            listenerVel  = ma_vec3f_init_3f(0, 0, 0);
            speedOfSound = MA_DEFAULT_SPEED_OF_SOUND;
        }

        if (pListener == NULL || ma_spatializer_get_positioning(pSpatializer) == ma_positioning_relative) {
            /* There's no listener or we're using relative positioning. */
            relativePos = ma_spatializer_get_position(pSpatializer);
            relativeDir = ma_spatializer_get_direction(pSpatializer);
        } else {
            /*
            We've found a listener and we're using absolute positioning. We need to transform the
            sound's position and direction so that it's relative to listener. Later on we'll use
            this for determining the factors to apply to each channel to apply the panning effect.
            */
            ma_spatializer_get_relative_position_and_direction(pSpatializer, pListener, &relativePos, &relativeDir);
        }

        distance = ma_vec3f_len(relativePos);

        /* We've gathered the data, so now we can apply some spatialization. */
        switch (ma_spatializer_get_attenuation_model(pSpatializer)) {
            case ma_attenuation_model_inverse:
            {
                gain = ma_attenuation_inverse(distance, minDistance, maxDistance, rolloff);
            } break;
            case ma_attenuation_model_linear:
            {
                gain = ma_attenuation_linear(distance, minDistance, maxDistance, rolloff);
            } break;
            case ma_attenuation_model_exponential:
            {
                gain = ma_attenuation_exponential(distance, minDistance, maxDistance, rolloff);
            } break;
            case ma_attenuation_model_none:
            default:
            {
                gain = 1;
            } break;
        }

        /* Normalize the position. */
        if (distance > 0.001f) {
            float distanceInv = 1/distance;
            relativePosNormalized    = relativePos;
            relativePosNormalized.x *= distanceInv;
            relativePosNormalized.y *= distanceInv;
            relativePosNormalized.z *= distanceInv;
        } else {
            distance = 0;
            relativePosNormalized = ma_vec3f_init_3f(0, 0, 0);
        }

        /*
        Angular attenuation.

        Unlike distance gain, the math for this is not specified by the OpenAL spec so we'll just go ahead and figure
        this out for ourselves at the expense of possibly being inconsistent with other implementations.

        To do cone attenuation, I'm just using the same math that we'd use to implement a basic spotlight in OpenGL. We
        just need to get the direction from the source to the listener and then do a dot product against that and the
        direction of the spotlight. Then we just compare that dot product against the cosine of the inner and outer
        angles. If the dot product is greater than the outer angle, we just use coneOuterGain. If it's less than
        the inner angle, we just use a gain of 1. Otherwise we linearly interpolate between 1 and coneOuterGain.
        */
        if (distance > 0) {
            /* Source angular gain. */
            float spatializerConeInnerAngle;
            float spatializerConeOuterAngle;
            float spatializerConeOuterGain;
            ma_spatializer_get_cone(pSpatializer, &spatializerConeInnerAngle, &spatializerConeOuterAngle, &spatializerConeOuterGain);

            gain *= ma_calculate_angular_gain(relativeDir, ma_vec3f_neg(relativePosNormalized), spatializerConeInnerAngle, spatializerConeOuterAngle, spatializerConeOuterGain);

            /*
            We're supporting angular gain on the listener as well for those who want to reduce the volume of sounds that
            are positioned behind the listener. On default settings, this will have no effect.
            */
            if (pListener != NULL && pListener->config.coneInnerAngleInRadians < 6.283185f) {
                ma_vec3f listenerDirection;
                float listenerInnerAngle;
                float listenerOuterAngle;
                float listenerOuterGain;

                if (pListener->config.handedness == ma_handedness_right) {
                    listenerDirection = ma_vec3f_init_3f(0, 0, -1);
                } else {
                    listenerDirection = ma_vec3f_init_3f(0, 0, +1);
                }

                listenerInnerAngle = pListener->config.coneInnerAngleInRadians;
                listenerOuterAngle = pListener->config.coneOuterAngleInRadians;
                listenerOuterGain  = pListener->config.coneOuterGain;

                gain *= ma_calculate_angular_gain(listenerDirection, relativePosNormalized, listenerInnerAngle, listenerOuterAngle, listenerOuterGain);
            }
        } else {
            /* The sound is right on top of the listener. Don't do any angular attenuation. */
        }


        /* Clamp the gain. */
        gain = ma_clamp(gain, ma_spatializer_get_min_gain(pSpatializer), ma_spatializer_get_max_gain(pSpatializer));

        /*
        The gain needs to be applied per-channel here. The spatialization code below will be changing the per-channel
        gains which will then eventually be passed into the gainer which will deal with smoothing the gain transitions
        to avoid harsh changes in gain.
        */
        for (iChannel = 0; iChannel < channelsOut; iChannel += 1) {
            pSpatializer->pNewChannelGainsOut[iChannel] = gain;
        }

        /*
        Convert to our output channel count. If the listener is disabled we just output silence here. We cannot ignore
        the whole section of code here because we need to update some internal spatialization state.
        */
        if (ma_spatializer_listener_is_enabled(pListener)) {
            ma_channel_map_apply_f32((float*)pFramesOut, pChannelMapOut, channelsOut, (const float*)pFramesIn, pChannelMapIn, channelsIn, frameCount, ma_channel_mix_mode_rectangular, ma_mono_expansion_mode_default);
        } else {
            ma_silence_pcm_frames(pFramesOut, frameCount, ma_format_f32, pSpatializer->channelsOut);
        }


        /*
        Panning. This is where we'll apply the gain and convert to the output channel count. We have an optimized path for
        when we're converting to a mono stream. In that case we don't really need to do any panning - we just apply the
        gain to the final output.
        */
        /*printf("distance=%f; gain=%f\n", distance, gain);*/

        /* We must have a valid channel map here to ensure we spatialize properly. */
        MA_ASSERT(pChannelMapOut != NULL);

        /*
        We're not converting to mono so we'll want to apply some panning. This is where the feeling of something being
        to the left, right, infront or behind the listener is calculated. I'm just using a basic model here. Note that
        the code below is not based on any specific algorithm. I'm just implementing this off the top of my head and
        seeing how it goes. There might be better ways to do this.

        To determine the direction of the sound relative to a speaker I'm using dot products. Each speaker is given a
        direction. For example, the left channel in a stereo system will be -1 on the X axis and the right channel will
        be +1 on the X axis. A dot product is performed against the direction vector of the channel and the normalized
        position of the sound.
        */

        /*
        Calculate our per-channel gains. We do this based on the normalized relative position of the sound and it's
        relation to the direction of the channel.
        */
        if (distance > 0) {
            ma_vec3f unitPos = relativePos;
            float distanceInv = 1/distance;
            unitPos.x *= distanceInv;
            unitPos.y *= distanceInv;
            unitPos.z *= distanceInv;

            for (iChannel = 0; iChannel < channelsOut; iChannel += 1) {
                ma_channel channelOut;
                float d;
                float dMin;

                channelOut = ma_channel_map_get_channel(pChannelMapOut, channelsOut, iChannel);
                if (ma_is_spatial_channel_position(channelOut)) {
                    d = ma_mix_f32_fast(1, ma_vec3f_dot(unitPos, ma_get_channel_direction(channelOut)), ma_spatializer_get_directional_attenuation_factor(pSpatializer));
                } else {
                    d = 1;  /* It's not a spatial channel so there's no real notion of direction. */
                }

                /*
                In my testing, if the panning effect is too aggressive it makes spatialization feel uncomfortable.
                The "dMin" variable below is used to control the aggressiveness of the panning effect. When set to
                0, panning will be most extreme and any sounds that are positioned on the opposite side of the
                speaker will be completely silent from that speaker. Not only does this feel uncomfortable, it
                doesn't even remotely represent the real world at all because sounds that come from your right side
                are still clearly audible from your left side. Setting "dMin" to 1 will result in no panning at
                all, which is also not ideal. By setting it to something greater than 0, the spatialization effect
                becomes much less dramatic and a lot more bearable.

                Summary: 0 = more extreme panning; 1 = no panning.
                */
                dMin = pSpatializer->minSpatializationChannelGain;

                /*
                At this point, "d" will be positive if the sound is on the same side as the channel and negative if
                it's on the opposite side. It will be in the range of -1..1. There's two ways I can think of to
                calculate a panning value. The first is to simply convert it to 0..1, however this has a problem
                which I'm not entirely happy with. Considering a stereo system, when a sound is positioned right
                in front of the listener it'll result in each speaker getting a gain of 0.5. I don't know if I like
                the idea of having a scaling factor of 0.5 being applied to a sound when it's sitting right in front
                of the listener. I would intuitively expect that to be played at full volume, or close to it.

                The second idea I think of is to only apply a reduction in gain when the sound is on the opposite
                side of the speaker. That is, reduce the gain only when the dot product is negative. The problem
                with this is that there will not be any attenuation as the sound sweeps around the 180 degrees
                where the dot product is positive. The idea with this option is that you leave the gain at 1 when
                the sound is being played on the same side as the speaker and then you just reduce the volume when
                the sound is on the other side.

                The summarize, I think the first option should give a better sense of spatialization, but the second
                option is better for preserving the sound's power.

                UPDATE: In my testing, I find the first option to sound better. You can feel the sense of space a
                bit better, but you can also hear the reduction in volume when it's right in front.
                */
                #if 1
                {
                    /*
                    Scale the dot product from -1..1 to 0..1. Will result in a sound directly in front losing power
                    by being played at 0.5 gain.
                    */
                    d = (d + 1) * 0.5f;  /* -1..1 to 0..1 */
                    d = ma_max(d, dMin);
                    pSpatializer->pNewChannelGainsOut[iChannel] *= d;
                }
                #else
                {
                    /*
                    Only reduce the volume of the sound if it's on the opposite side. This path keeps the volume more
                    consistent, but comes at the expense of a worse sense of space and positioning.
                    */
                    if (d < 0) {
                        d += 1; /* Move into the positive range. */
                        d = ma_max(d, dMin);
                        channelGainsOut[iChannel] *= d;
                    }
                }
                #endif
            }
        } else {
            /* Assume the sound is right on top of us. Don't do any panning. */
        }

        /* Now we need to apply the volume to each channel. This needs to run through the gainer to ensure we get a smooth volume transition. */
        ma_gainer_set_gains(&pSpatializer->gainer, pSpatializer->pNewChannelGainsOut);
        ma_gainer_process_pcm_frames(&pSpatializer->gainer, pFramesOut, pFramesOut, frameCount);

        /*
        Before leaving we'll want to update our doppler pitch so that the caller can apply some
        pitch shifting if they desire. Note that we need to negate the relative position here
        because the doppler calculation needs to be source-to-listener, but ours is listener-to-
        source.
        */
        if (dopplerFactor > 0) {
            pSpatializer->dopplerPitch = ma_doppler_pitch(ma_vec3f_sub(ma_spatializer_listener_get_position(pListener), ma_spatializer_get_position(pSpatializer)), ma_spatializer_get_velocity(pSpatializer), listenerVel, speedOfSound, dopplerFactor);
        } else {
            pSpatializer->dopplerPitch = 1;
        }
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_spatializer_set_master_volume(ma_spatializer* pSpatializer, float volume)
{
    if (pSpatializer == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_gainer_set_master_volume(&pSpatializer->gainer, volume);
}

MA_API ma_result ma_spatializer_get_master_volume(const ma_spatializer* pSpatializer, float* pVolume)
{
    if (pSpatializer == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_gainer_get_master_volume(&pSpatializer->gainer, pVolume);
}

MA_API ma_uint32 ma_spatializer_get_input_channels(const ma_spatializer* pSpatializer)
{
    if (pSpatializer == NULL) {
        return 0;
    }

    return pSpatializer->channelsIn;
}

MA_API ma_uint32 ma_spatializer_get_output_channels(const ma_spatializer* pSpatializer)
{
    if (pSpatializer == NULL) {
        return 0;
    }

    return pSpatializer->channelsOut;
}

MA_API void ma_spatializer_set_attenuation_model(ma_spatializer* pSpatializer, ma_attenuation_model attenuationModel)
{
    if (pSpatializer == NULL) {
        return;
    }

    ma_atomic_exchange_i32(&pSpatializer->attenuationModel, attenuationModel);
}

MA_API ma_attenuation_model ma_spatializer_get_attenuation_model(const ma_spatializer* pSpatializer)
{
    if (pSpatializer == NULL) {
        return ma_attenuation_model_none;
    }

    return (ma_attenuation_model)ma_atomic_load_i32(&pSpatializer->attenuationModel);
}

MA_API void ma_spatializer_set_positioning(ma_spatializer* pSpatializer, ma_positioning positioning)
{
    if (pSpatializer == NULL) {
        return;
    }

    ma_atomic_exchange_i32(&pSpatializer->positioning, positioning);
}

MA_API ma_positioning ma_spatializer_get_positioning(const ma_spatializer* pSpatializer)
{
    if (pSpatializer == NULL) {
        return ma_positioning_absolute;
    }

    return (ma_positioning)ma_atomic_load_i32(&pSpatializer->positioning);
}

MA_API void ma_spatializer_set_rolloff(ma_spatializer* pSpatializer, float rolloff)
{
    if (pSpatializer == NULL) {
        return;
    }

    ma_atomic_exchange_f32(&pSpatializer->rolloff, rolloff);
}

MA_API float ma_spatializer_get_rolloff(const ma_spatializer* pSpatializer)
{
    if (pSpatializer == NULL) {
        return 0;
    }

    return ma_atomic_load_f32(&pSpatializer->rolloff);
}

MA_API void ma_spatializer_set_min_gain(ma_spatializer* pSpatializer, float minGain)
{
    if (pSpatializer == NULL) {
        return;
    }

    ma_atomic_exchange_f32(&pSpatializer->minGain, minGain);
}

MA_API float ma_spatializer_get_min_gain(const ma_spatializer* pSpatializer)
{
    if (pSpatializer == NULL) {
        return 0;
    }

    return ma_atomic_load_f32(&pSpatializer->minGain);
}

MA_API void ma_spatializer_set_max_gain(ma_spatializer* pSpatializer, float maxGain)
{
    if (pSpatializer == NULL) {
        return;
    }

    ma_atomic_exchange_f32(&pSpatializer->maxGain, maxGain);
}

MA_API float ma_spatializer_get_max_gain(const ma_spatializer* pSpatializer)
{
    if (pSpatializer == NULL) {
        return 0;
    }

    return ma_atomic_load_f32(&pSpatializer->maxGain);
}

MA_API void ma_spatializer_set_min_distance(ma_spatializer* pSpatializer, float minDistance)
{
    if (pSpatializer == NULL) {
        return;
    }

    ma_atomic_exchange_f32(&pSpatializer->minDistance, minDistance);
}

MA_API float ma_spatializer_get_min_distance(const ma_spatializer* pSpatializer)
{
    if (pSpatializer == NULL) {
        return 0;
    }

    return ma_atomic_load_f32(&pSpatializer->minDistance);
}

MA_API void ma_spatializer_set_max_distance(ma_spatializer* pSpatializer, float maxDistance)
{
    if (pSpatializer == NULL) {
        return;
    }

    ma_atomic_exchange_f32(&pSpatializer->maxDistance, maxDistance);
}

MA_API float ma_spatializer_get_max_distance(const ma_spatializer* pSpatializer)
{
    if (pSpatializer == NULL) {
        return 0;
    }

    return ma_atomic_load_f32(&pSpatializer->maxDistance);
}

MA_API void ma_spatializer_set_cone(ma_spatializer* pSpatializer, float innerAngleInRadians, float outerAngleInRadians, float outerGain)
{
    if (pSpatializer == NULL) {
        return;
    }

    ma_atomic_exchange_f32(&pSpatializer->coneInnerAngleInRadians, innerAngleInRadians);
    ma_atomic_exchange_f32(&pSpatializer->coneOuterAngleInRadians, outerAngleInRadians);
    ma_atomic_exchange_f32(&pSpatializer->coneOuterGain,           outerGain);
}

MA_API void ma_spatializer_get_cone(const ma_spatializer* pSpatializer, float* pInnerAngleInRadians, float* pOuterAngleInRadians, float* pOuterGain)
{
    if (pSpatializer == NULL) {
        return;
    }

    if (pInnerAngleInRadians != NULL) {
        *pInnerAngleInRadians = ma_atomic_load_f32(&pSpatializer->coneInnerAngleInRadians);
    }

    if (pOuterAngleInRadians != NULL) {
        *pOuterAngleInRadians = ma_atomic_load_f32(&pSpatializer->coneOuterAngleInRadians);
    }

    if (pOuterGain != NULL) {
        *pOuterGain = ma_atomic_load_f32(&pSpatializer->coneOuterGain);
    }
}

MA_API void ma_spatializer_set_doppler_factor(ma_spatializer* pSpatializer, float dopplerFactor)
{
    if (pSpatializer == NULL) {
        return;
    }

    ma_atomic_exchange_f32(&pSpatializer->dopplerFactor, dopplerFactor);
}

MA_API float ma_spatializer_get_doppler_factor(const ma_spatializer* pSpatializer)
{
    if (pSpatializer == NULL) {
        return 1;
    }

    return ma_atomic_load_f32(&pSpatializer->dopplerFactor);
}

MA_API void ma_spatializer_set_directional_attenuation_factor(ma_spatializer* pSpatializer, float directionalAttenuationFactor)
{
    if (pSpatializer == NULL) {
        return;
    }

    ma_atomic_exchange_f32(&pSpatializer->directionalAttenuationFactor, directionalAttenuationFactor);
}

MA_API float ma_spatializer_get_directional_attenuation_factor(const ma_spatializer* pSpatializer)
{
    if (pSpatializer == NULL) {
        return 1;
    }

    return ma_atomic_load_f32(&pSpatializer->directionalAttenuationFactor);
}

MA_API void ma_spatializer_set_position(ma_spatializer* pSpatializer, float x, float y, float z)
{
    if (pSpatializer == NULL) {
        return;
    }

    ma_atomic_vec3f_set(&pSpatializer->position, ma_vec3f_init_3f(x, y, z));
}

MA_API ma_vec3f ma_spatializer_get_position(const ma_spatializer* pSpatializer)
{
    if (pSpatializer == NULL) {
        return ma_vec3f_init_3f(0, 0, 0);
    }

    return ma_atomic_vec3f_get((ma_atomic_vec3f*)&pSpatializer->position);  /* Naughty const-cast. It's just for atomically loading the vec3 which should be safe. */
}

MA_API void ma_spatializer_set_direction(ma_spatializer* pSpatializer, float x, float y, float z)
{
    if (pSpatializer == NULL) {
        return;
    }

    ma_atomic_vec3f_set(&pSpatializer->direction, ma_vec3f_init_3f(x, y, z));
}

MA_API ma_vec3f ma_spatializer_get_direction(const ma_spatializer* pSpatializer)
{
    if (pSpatializer == NULL) {
        return ma_vec3f_init_3f(0, 0, -1);
    }

    return ma_atomic_vec3f_get((ma_atomic_vec3f*)&pSpatializer->direction); /* Naughty const-cast. It's just for atomically loading the vec3 which should be safe. */
}

MA_API void ma_spatializer_set_velocity(ma_spatializer* pSpatializer, float x, float y, float z)
{
    if (pSpatializer == NULL) {
        return;
    }

    ma_atomic_vec3f_set(&pSpatializer->velocity, ma_vec3f_init_3f(x, y, z));
}

MA_API ma_vec3f ma_spatializer_get_velocity(const ma_spatializer* pSpatializer)
{
    if (pSpatializer == NULL) {
        return ma_vec3f_init_3f(0, 0, 0);
    }

    return ma_atomic_vec3f_get((ma_atomic_vec3f*)&pSpatializer->velocity);  /* Naughty const-cast. It's just for atomically loading the vec3 which should be safe. */
}

MA_API void ma_spatializer_get_relative_position_and_direction(const ma_spatializer* pSpatializer, const ma_spatializer_listener* pListener, ma_vec3f* pRelativePos, ma_vec3f* pRelativeDir)
{
    if (pRelativePos != NULL) {
        pRelativePos->x = 0;
        pRelativePos->y = 0;
        pRelativePos->z = 0;
    }

    if (pRelativeDir != NULL) {
        pRelativeDir->x = 0;
        pRelativeDir->y = 0;
        pRelativeDir->z = -1;
    }

    if (pSpatializer == NULL) {
        return;
    }

    if (pListener == NULL || ma_spatializer_get_positioning(pSpatializer) == ma_positioning_relative) {
        /* There's no listener or we're using relative positioning. */
        if (pRelativePos != NULL) {
            *pRelativePos = ma_spatializer_get_position(pSpatializer);
        }
        if (pRelativeDir != NULL) {
            *pRelativeDir = ma_spatializer_get_direction(pSpatializer);
        }
    } else {
        ma_vec3f spatializerPosition;
        ma_vec3f spatializerDirection;
        ma_vec3f listenerPosition;
        ma_vec3f listenerDirection;
        ma_vec3f v;
        ma_vec3f axisX;
        ma_vec3f axisY;
        ma_vec3f axisZ;
        float m[4][4];

        spatializerPosition  = ma_spatializer_get_position(pSpatializer);
        spatializerDirection = ma_spatializer_get_direction(pSpatializer);
        listenerPosition     = ma_spatializer_listener_get_position(pListener);
        listenerDirection    = ma_spatializer_listener_get_direction(pListener);

        /*
        We need to calculate the right vector from our forward and up vectors. This is done with
        a cross product.
        */
        axisZ = ma_vec3f_normalize(listenerDirection);                                  /* Normalization required here because we can't trust the caller. */
        axisX = ma_vec3f_normalize(ma_vec3f_cross(axisZ, pListener->config.worldUp));   /* Normalization required here because the world up vector may not be perpendicular with the forward vector. */

        /*
        The calculation of axisX above can result in a zero-length vector if the listener is
        looking straight up on the Y axis. We'll need to fall back to a +X in this case so that
        the calculations below don't fall apart. This is where a quaternion based listener and
        sound orientation would come in handy.
        */
        if (ma_vec3f_len2(axisX) == 0) {
            axisX = ma_vec3f_init_3f(1, 0, 0);
        }

        axisY = ma_vec3f_cross(axisX, axisZ);                                           /* No normalization is required here because axisX and axisZ are unit length and perpendicular. */

        /*
        We need to swap the X axis if we're left handed because otherwise the cross product above
        will have resulted in it pointing in the wrong direction (right handed was assumed in the
        cross products above).
        */
        if (pListener->config.handedness == ma_handedness_left) {
            axisX = ma_vec3f_neg(axisX);
        }

        /* Lookat. */
        m[0][0] =  axisX.x; m[1][0] =  axisX.y; m[2][0] =  axisX.z; m[3][0] = -ma_vec3f_dot(axisX,               listenerPosition);
        m[0][1] =  axisY.x; m[1][1] =  axisY.y; m[2][1] =  axisY.z; m[3][1] = -ma_vec3f_dot(axisY,               listenerPosition);
        m[0][2] = -axisZ.x; m[1][2] = -axisZ.y; m[2][2] = -axisZ.z; m[3][2] = -ma_vec3f_dot(ma_vec3f_neg(axisZ), listenerPosition);
        m[0][3] = 0;        m[1][3] = 0;        m[2][3] = 0;        m[3][3] = 1;

        /*
        Multiply the lookat matrix by the spatializer position to transform it to listener
        space. This allows calculations to work based on the sound being relative to the
        origin which makes things simpler.
        */
        if (pRelativePos != NULL) {
            v = spatializerPosition;
            pRelativePos->x = m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * 1;
            pRelativePos->y = m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * 1;
            pRelativePos->z = m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * 1;
        }

        /*
        The direction of the sound needs to also be transformed so that it's relative to the
        rotation of the listener.
        */
        if (pRelativeDir != NULL) {
            v = spatializerDirection;
            pRelativeDir->x = m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z;
            pRelativeDir->y = m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z;
            pRelativeDir->z = m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z;
        }
    }
}




/**************************************************************************************************************************************************************

Resampling

**************************************************************************************************************************************************************/
MA_API ma_linear_resampler_config ma_linear_resampler_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)
{
    ma_linear_resampler_config config;
    MA_ZERO_OBJECT(&config);
    config.format           = format;
    config.channels         = channels;
    config.sampleRateIn     = sampleRateIn;
    config.sampleRateOut    = sampleRateOut;
    config.lpfOrder         = ma_min(MA_DEFAULT_RESAMPLER_LPF_ORDER, MA_MAX_FILTER_ORDER);
    config.lpfNyquistFactor = 1;

    return config;
}


typedef struct
{
    size_t sizeInBytes;
    size_t x0Offset;
    size_t x1Offset;
    size_t lpfOffset;
} ma_linear_resampler_heap_layout;


static void ma_linear_resampler_adjust_timer_for_new_rate(ma_linear_resampler* pResampler, ma_uint32 oldSampleRateOut, ma_uint32 newSampleRateOut)
{
    /*
    So what's happening here? Basically we need to adjust the fractional component of the time advance based on the new rate. The old time advance will
    be based on the old sample rate, but we are needing to adjust it to that it's based on the new sample rate.
    */
    ma_uint32 oldRateTimeWhole = pResampler->inTimeFrac / oldSampleRateOut;  /* <-- This should almost never be anything other than 0, but leaving it here to make this more general and robust just in case. */
    ma_uint32 oldRateTimeFract = pResampler->inTimeFrac % oldSampleRateOut;

    pResampler->inTimeFrac =
         (oldRateTimeWhole * newSampleRateOut) +
        ((oldRateTimeFract * newSampleRateOut) / oldSampleRateOut);

    /* Make sure the fractional part is less than the output sample rate. */
    pResampler->inTimeInt += pResampler->inTimeFrac / pResampler->config.sampleRateOut;
    pResampler->inTimeFrac = pResampler->inTimeFrac % pResampler->config.sampleRateOut;
}

static ma_result ma_linear_resampler_set_rate_internal(ma_linear_resampler* pResampler, void* pHeap, ma_linear_resampler_heap_layout* pHeapLayout, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut, ma_bool32 isResamplerAlreadyInitialized)
{
    ma_result result;
    ma_uint32 gcf;
    ma_uint32 lpfSampleRate;
    double lpfCutoffFrequency;
    ma_lpf_config lpfConfig;
    ma_uint32 oldSampleRateOut; /* Required for adjusting time advance down the bottom. */

    if (pResampler == NULL) {
        return MA_INVALID_ARGS;
    }

    if (sampleRateIn == 0 || sampleRateOut == 0) {
        return MA_INVALID_ARGS;
    }

    oldSampleRateOut = pResampler->config.sampleRateOut;

    pResampler->config.sampleRateIn  = sampleRateIn;
    pResampler->config.sampleRateOut = sampleRateOut;

    /* Simplify the sample rate. */
    gcf = ma_gcf_u32(pResampler->config.sampleRateIn, pResampler->config.sampleRateOut);
    pResampler->config.sampleRateIn  /= gcf;
    pResampler->config.sampleRateOut /= gcf;

    /* Always initialize the low-pass filter, even when the order is 0. */
    if (pResampler->config.lpfOrder > MA_MAX_FILTER_ORDER) {
        return MA_INVALID_ARGS;
    }

    lpfSampleRate      = (ma_uint32)(ma_max(pResampler->config.sampleRateIn, pResampler->config.sampleRateOut));
    lpfCutoffFrequency = (   double)(ma_min(pResampler->config.sampleRateIn, pResampler->config.sampleRateOut) * 0.5 * pResampler->config.lpfNyquistFactor);

    lpfConfig = ma_lpf_config_init(pResampler->config.format, pResampler->config.channels, lpfSampleRate, lpfCutoffFrequency, pResampler->config.lpfOrder);

    /*
    If the resampler is already initialized we don't want to do a fresh initialization of the low-pass filter because it will result in the cached frames
    getting cleared. Instead we re-initialize the filter which will maintain any cached frames.
    */
    if (isResamplerAlreadyInitialized) {
        result = ma_lpf_reinit(&lpfConfig, &pResampler->lpf);
    } else {
        result = ma_lpf_init_preallocated(&lpfConfig, ma_offset_ptr(pHeap, pHeapLayout->lpfOffset), &pResampler->lpf);
    }

    if (result != MA_SUCCESS) {
        return result;
    }


    pResampler->inAdvanceInt  = pResampler->config.sampleRateIn / pResampler->config.sampleRateOut;
    pResampler->inAdvanceFrac = pResampler->config.sampleRateIn % pResampler->config.sampleRateOut;

    /* Our timer was based on the old rate. We need to adjust it so that it's based on the new rate. */
    ma_linear_resampler_adjust_timer_for_new_rate(pResampler, oldSampleRateOut, pResampler->config.sampleRateOut);

    return MA_SUCCESS;
}

static ma_result ma_linear_resampler_get_heap_layout(const ma_linear_resampler_config* pConfig, ma_linear_resampler_heap_layout* pHeapLayout)
{
    MA_ASSERT(pHeapLayout != NULL);

    MA_ZERO_OBJECT(pHeapLayout);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->format != ma_format_f32 && pConfig->format != ma_format_s16) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->channels == 0) {
        return MA_INVALID_ARGS;
    }

    pHeapLayout->sizeInBytes = 0;

    /* x0 */
    pHeapLayout->x0Offset = pHeapLayout->sizeInBytes;
    if (pConfig->format == ma_format_f32) {
        pHeapLayout->sizeInBytes += sizeof(float) * pConfig->channels;
    } else {
        pHeapLayout->sizeInBytes += sizeof(ma_int16) * pConfig->channels;
    }

    /* x1 */
    pHeapLayout->x1Offset = pHeapLayout->sizeInBytes;
    if (pConfig->format == ma_format_f32) {
        pHeapLayout->sizeInBytes += sizeof(float) * pConfig->channels;
    } else {
        pHeapLayout->sizeInBytes += sizeof(ma_int16) * pConfig->channels;
    }

    /* LPF */
    pHeapLayout->lpfOffset = ma_align_64(pHeapLayout->sizeInBytes);
    {
        ma_result result;
        size_t lpfHeapSizeInBytes;
        ma_lpf_config lpfConfig = ma_lpf_config_init(pConfig->format, pConfig->channels, 1, 1, pConfig->lpfOrder);  /* Sample rate and cutoff frequency do not matter. */

        result = ma_lpf_get_heap_size(&lpfConfig, &lpfHeapSizeInBytes);
        if (result != MA_SUCCESS) {
            return result;
        }

        pHeapLayout->sizeInBytes += lpfHeapSizeInBytes;
    }

    /* Make sure allocation size is aligned. */
    pHeapLayout->sizeInBytes = ma_align_64(pHeapLayout->sizeInBytes);

    return MA_SUCCESS;
}

MA_API ma_result ma_linear_resampler_get_heap_size(const ma_linear_resampler_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_linear_resampler_heap_layout heapLayout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = 0;

    result = ma_linear_resampler_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pHeapSizeInBytes = heapLayout.sizeInBytes;

    return MA_SUCCESS;
}

MA_API ma_result ma_linear_resampler_init_preallocated(const ma_linear_resampler_config* pConfig, void* pHeap, ma_linear_resampler* pResampler)
{
    ma_result result;
    ma_linear_resampler_heap_layout heapLayout;

    if (pResampler == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pResampler);

    result = ma_linear_resampler_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    pResampler->config = *pConfig;

    pResampler->_pHeap = pHeap;
    MA_ZERO_MEMORY(pHeap, heapLayout.sizeInBytes);

    if (pConfig->format == ma_format_f32) {
        pResampler->x0.f32 = (float*)ma_offset_ptr(pHeap, heapLayout.x0Offset);
        pResampler->x1.f32 = (float*)ma_offset_ptr(pHeap, heapLayout.x1Offset);
    } else {
        pResampler->x0.s16 = (ma_int16*)ma_offset_ptr(pHeap, heapLayout.x0Offset);
        pResampler->x1.s16 = (ma_int16*)ma_offset_ptr(pHeap, heapLayout.x1Offset);
    }

    /* Setting the rate will set up the filter and time advances for us. */
    result = ma_linear_resampler_set_rate_internal(pResampler, pHeap, &heapLayout, pConfig->sampleRateIn, pConfig->sampleRateOut, /* isResamplerAlreadyInitialized = */ MA_FALSE);
    if (result != MA_SUCCESS) {
        return result;
    }

    pResampler->inTimeInt  = 1;  /* Set this to one to force an input sample to always be loaded for the first output frame. */
    pResampler->inTimeFrac = 0;

    return MA_SUCCESS;
}

MA_API ma_result ma_linear_resampler_init(const ma_linear_resampler_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_linear_resampler* pResampler)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_linear_resampler_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_linear_resampler_init_preallocated(pConfig, pHeap, pResampler);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pResampler->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_linear_resampler_uninit(ma_linear_resampler* pResampler, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pResampler == NULL) {
        return;
    }

    ma_lpf_uninit(&pResampler->lpf, pAllocationCallbacks);

    if (pResampler->_ownsHeap) {
        ma_free(pResampler->_pHeap, pAllocationCallbacks);
    }
}

static MA_INLINE ma_int16 ma_linear_resampler_mix_s16(ma_int16 x, ma_int16 y, ma_int32 a, const ma_int32 shift)
{
    ma_int32 b;
    ma_int32 c;
    ma_int32 r;

    MA_ASSERT(a <= (1<<shift));

    b = x * ((1<<shift) - a);
    c = y * a;
    r = b + c;

    return (ma_int16)(r >> shift);
}

static void ma_linear_resampler_interpolate_frame_s16(ma_linear_resampler* pResampler, ma_int16* MA_RESTRICT pFrameOut)
{
    ma_uint32 c;
    ma_uint32 a;
    const ma_uint32 channels = pResampler->config.channels;
    const ma_uint32 shift = 12;

    MA_ASSERT(pResampler != NULL);
    MA_ASSERT(pFrameOut  != NULL);

    a = (pResampler->inTimeFrac << shift) / pResampler->config.sampleRateOut;

    MA_ASSUME(channels > 0);
    for (c = 0; c < channels; c += 1) {
        ma_int16 s = ma_linear_resampler_mix_s16(pResampler->x0.s16[c], pResampler->x1.s16[c], a, shift);
        pFrameOut[c] = s;
    }
}


static void ma_linear_resampler_interpolate_frame_f32(ma_linear_resampler* pResampler, float* MA_RESTRICT pFrameOut)
{
    ma_uint32 c;
    float a;
    const ma_uint32 channels = pResampler->config.channels;

    MA_ASSERT(pResampler != NULL);
    MA_ASSERT(pFrameOut  != NULL);

    a = (float)pResampler->inTimeFrac / pResampler->config.sampleRateOut;

    MA_ASSUME(channels > 0);
    for (c = 0; c < channels; c += 1) {
        float s = ma_mix_f32_fast(pResampler->x0.f32[c], pResampler->x1.f32[c], a);
        pFrameOut[c] = s;
    }
}

static ma_result ma_linear_resampler_process_pcm_frames_s16_downsample(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    const ma_int16* pFramesInS16;
    /* */ ma_int16* pFramesOutS16;
    ma_uint64 frameCountIn;
    ma_uint64 frameCountOut;
    ma_uint64 framesProcessedIn;
    ma_uint64 framesProcessedOut;

    MA_ASSERT(pResampler     != NULL);
    MA_ASSERT(pFrameCountIn  != NULL);
    MA_ASSERT(pFrameCountOut != NULL);

    pFramesInS16       = (const ma_int16*)pFramesIn;
    pFramesOutS16      = (      ma_int16*)pFramesOut;
    frameCountIn       = *pFrameCountIn;
    frameCountOut      = *pFrameCountOut;
    framesProcessedIn  = 0;
    framesProcessedOut = 0;

    while (framesProcessedOut < frameCountOut) {
        /* Before interpolating we need to load the buffers. When doing this we need to ensure we run every input sample through the filter. */
        while (pResampler->inTimeInt > 0 && frameCountIn > framesProcessedIn) {
            ma_uint32 iChannel;

            if (pFramesInS16 != NULL) {
                for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
                    pResampler->x0.s16[iChannel] = pResampler->x1.s16[iChannel];
                    pResampler->x1.s16[iChannel] = pFramesInS16[iChannel];
                }
                pFramesInS16 += pResampler->config.channels;
            } else {
                for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
                    pResampler->x0.s16[iChannel] = pResampler->x1.s16[iChannel];
                    pResampler->x1.s16[iChannel] = 0;
                }
            }

            /* Filter. Do not apply filtering if sample rates are the same or else you'll get dangerous glitching. */
            if (pResampler->config.sampleRateIn != pResampler->config.sampleRateOut) {
                ma_lpf_process_pcm_frame_s16(&pResampler->lpf, pResampler->x1.s16, pResampler->x1.s16);
            }

            framesProcessedIn     += 1;
            pResampler->inTimeInt -= 1;
        }

        if (pResampler->inTimeInt > 0) {
            break;  /* Ran out of input data. */
        }

        /* Getting here means the frames have been loaded and filtered and we can generate the next output frame. */
        if (pFramesOutS16 != NULL) {
            MA_ASSERT(pResampler->inTimeInt == 0);
            ma_linear_resampler_interpolate_frame_s16(pResampler, pFramesOutS16);

            pFramesOutS16 += pResampler->config.channels;
        }

        framesProcessedOut += 1;

        /* Advance time forward. */
        pResampler->inTimeInt  += pResampler->inAdvanceInt;
        pResampler->inTimeFrac += pResampler->inAdvanceFrac;
        if (pResampler->inTimeFrac >= pResampler->config.sampleRateOut) {
            pResampler->inTimeFrac -= pResampler->config.sampleRateOut;
            pResampler->inTimeInt  += 1;
        }
    }

    *pFrameCountIn  = framesProcessedIn;
    *pFrameCountOut = framesProcessedOut;

    return MA_SUCCESS;
}

static ma_result ma_linear_resampler_process_pcm_frames_s16_upsample(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    const ma_int16* pFramesInS16;
    /* */ ma_int16* pFramesOutS16;
    ma_uint64 frameCountIn;
    ma_uint64 frameCountOut;
    ma_uint64 framesProcessedIn;
    ma_uint64 framesProcessedOut;

    MA_ASSERT(pResampler     != NULL);
    MA_ASSERT(pFrameCountIn  != NULL);
    MA_ASSERT(pFrameCountOut != NULL);

    pFramesInS16       = (const ma_int16*)pFramesIn;
    pFramesOutS16      = (      ma_int16*)pFramesOut;
    frameCountIn       = *pFrameCountIn;
    frameCountOut      = *pFrameCountOut;
    framesProcessedIn  = 0;
    framesProcessedOut = 0;

    while (framesProcessedOut < frameCountOut) {
        /* Before interpolating we need to load the buffers. */
        while (pResampler->inTimeInt > 0 && frameCountIn > framesProcessedIn) {
            ma_uint32 iChannel;

            if (pFramesInS16 != NULL) {
                for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
                    pResampler->x0.s16[iChannel] = pResampler->x1.s16[iChannel];
                    pResampler->x1.s16[iChannel] = pFramesInS16[iChannel];
                }
                pFramesInS16 += pResampler->config.channels;
            } else {
                for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
                    pResampler->x0.s16[iChannel] = pResampler->x1.s16[iChannel];
                    pResampler->x1.s16[iChannel] = 0;
                }
            }

            framesProcessedIn     += 1;
            pResampler->inTimeInt -= 1;
        }

        if (pResampler->inTimeInt > 0) {
            break;  /* Ran out of input data. */
        }

        /* Getting here means the frames have been loaded and we can generate the next output frame. */
        if (pFramesOutS16 != NULL) {
            MA_ASSERT(pResampler->inTimeInt == 0);
            ma_linear_resampler_interpolate_frame_s16(pResampler, pFramesOutS16);

            /* Filter. Do not apply filtering if sample rates are the same or else you'll get dangerous glitching. */
            if (pResampler->config.sampleRateIn != pResampler->config.sampleRateOut) {
                ma_lpf_process_pcm_frame_s16(&pResampler->lpf, pFramesOutS16, pFramesOutS16);
            }

            pFramesOutS16 += pResampler->config.channels;
        }

        framesProcessedOut += 1;

        /* Advance time forward. */
        pResampler->inTimeInt  += pResampler->inAdvanceInt;
        pResampler->inTimeFrac += pResampler->inAdvanceFrac;
        if (pResampler->inTimeFrac >= pResampler->config.sampleRateOut) {
            pResampler->inTimeFrac -= pResampler->config.sampleRateOut;
            pResampler->inTimeInt  += 1;
        }
    }

    *pFrameCountIn  = framesProcessedIn;
    *pFrameCountOut = framesProcessedOut;

    return MA_SUCCESS;
}

static ma_result ma_linear_resampler_process_pcm_frames_s16(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    MA_ASSERT(pResampler != NULL);

    if (pResampler->config.sampleRateIn > pResampler->config.sampleRateOut) {
        return ma_linear_resampler_process_pcm_frames_s16_downsample(pResampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
    } else {
        return ma_linear_resampler_process_pcm_frames_s16_upsample(pResampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
    }
}


static ma_result ma_linear_resampler_process_pcm_frames_f32_downsample(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    const float* pFramesInF32;
    /* */ float* pFramesOutF32;
    ma_uint64 frameCountIn;
    ma_uint64 frameCountOut;
    ma_uint64 framesProcessedIn;
    ma_uint64 framesProcessedOut;

    MA_ASSERT(pResampler     != NULL);
    MA_ASSERT(pFrameCountIn  != NULL);
    MA_ASSERT(pFrameCountOut != NULL);

    pFramesInF32       = (const float*)pFramesIn;
    pFramesOutF32      = (      float*)pFramesOut;
    frameCountIn       = *pFrameCountIn;
    frameCountOut      = *pFrameCountOut;
    framesProcessedIn  = 0;
    framesProcessedOut = 0;

    while (framesProcessedOut < frameCountOut) {
        /* Before interpolating we need to load the buffers. When doing this we need to ensure we run every input sample through the filter. */
        while (pResampler->inTimeInt > 0 && frameCountIn > framesProcessedIn) {
            ma_uint32 iChannel;

            if (pFramesInF32 != NULL) {
                for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
                    pResampler->x0.f32[iChannel] = pResampler->x1.f32[iChannel];
                    pResampler->x1.f32[iChannel] = pFramesInF32[iChannel];
                }
                pFramesInF32 += pResampler->config.channels;
            } else {
                for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
                    pResampler->x0.f32[iChannel] = pResampler->x1.f32[iChannel];
                    pResampler->x1.f32[iChannel] = 0;
                }
            }

            /* Filter. Do not apply filtering if sample rates are the same or else you'll get dangerous glitching. */
            if (pResampler->config.sampleRateIn != pResampler->config.sampleRateOut) {
                ma_lpf_process_pcm_frame_f32(&pResampler->lpf, pResampler->x1.f32, pResampler->x1.f32);
            }

            framesProcessedIn     += 1;
            pResampler->inTimeInt -= 1;
        }

        if (pResampler->inTimeInt > 0) {
            break;  /* Ran out of input data. */
        }

        /* Getting here means the frames have been loaded and filtered and we can generate the next output frame. */
        if (pFramesOutF32 != NULL) {
            MA_ASSERT(pResampler->inTimeInt == 0);
            ma_linear_resampler_interpolate_frame_f32(pResampler, pFramesOutF32);

            pFramesOutF32 += pResampler->config.channels;
        }

        framesProcessedOut += 1;

        /* Advance time forward. */
        pResampler->inTimeInt  += pResampler->inAdvanceInt;
        pResampler->inTimeFrac += pResampler->inAdvanceFrac;
        if (pResampler->inTimeFrac >= pResampler->config.sampleRateOut) {
            pResampler->inTimeFrac -= pResampler->config.sampleRateOut;
            pResampler->inTimeInt  += 1;
        }
    }

    *pFrameCountIn  = framesProcessedIn;
    *pFrameCountOut = framesProcessedOut;

    return MA_SUCCESS;
}

static ma_result ma_linear_resampler_process_pcm_frames_f32_upsample(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    const float* pFramesInF32;
    /* */ float* pFramesOutF32;
    ma_uint64 frameCountIn;
    ma_uint64 frameCountOut;
    ma_uint64 framesProcessedIn;
    ma_uint64 framesProcessedOut;

    MA_ASSERT(pResampler     != NULL);
    MA_ASSERT(pFrameCountIn  != NULL);
    MA_ASSERT(pFrameCountOut != NULL);

    pFramesInF32       = (const float*)pFramesIn;
    pFramesOutF32      = (      float*)pFramesOut;
    frameCountIn       = *pFrameCountIn;
    frameCountOut      = *pFrameCountOut;
    framesProcessedIn  = 0;
    framesProcessedOut = 0;

    while (framesProcessedOut < frameCountOut) {
        /* Before interpolating we need to load the buffers. */
        while (pResampler->inTimeInt > 0 && frameCountIn > framesProcessedIn) {
            ma_uint32 iChannel;

            if (pFramesInF32 != NULL) {
                for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
                    pResampler->x0.f32[iChannel] = pResampler->x1.f32[iChannel];
                    pResampler->x1.f32[iChannel] = pFramesInF32[iChannel];
                }
                pFramesInF32 += pResampler->config.channels;
            } else {
                for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
                    pResampler->x0.f32[iChannel] = pResampler->x1.f32[iChannel];
                    pResampler->x1.f32[iChannel] = 0;
                }
            }

            framesProcessedIn     += 1;
            pResampler->inTimeInt -= 1;
        }

        if (pResampler->inTimeInt > 0) {
            break;  /* Ran out of input data. */
        }

        /* Getting here means the frames have been loaded and we can generate the next output frame. */
        if (pFramesOutF32 != NULL) {
            MA_ASSERT(pResampler->inTimeInt == 0);
            ma_linear_resampler_interpolate_frame_f32(pResampler, pFramesOutF32);

            /* Filter. Do not apply filtering if sample rates are the same or else you'll get dangerous glitching. */
            if (pResampler->config.sampleRateIn != pResampler->config.sampleRateOut) {
                ma_lpf_process_pcm_frame_f32(&pResampler->lpf, pFramesOutF32, pFramesOutF32);
            }

            pFramesOutF32 += pResampler->config.channels;
        }

        framesProcessedOut += 1;

        /* Advance time forward. */
        pResampler->inTimeInt  += pResampler->inAdvanceInt;
        pResampler->inTimeFrac += pResampler->inAdvanceFrac;
        if (pResampler->inTimeFrac >= pResampler->config.sampleRateOut) {
            pResampler->inTimeFrac -= pResampler->config.sampleRateOut;
            pResampler->inTimeInt  += 1;
        }
    }

    *pFrameCountIn  = framesProcessedIn;
    *pFrameCountOut = framesProcessedOut;

    return MA_SUCCESS;
}

static ma_result ma_linear_resampler_process_pcm_frames_f32(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    MA_ASSERT(pResampler != NULL);

    if (pResampler->config.sampleRateIn > pResampler->config.sampleRateOut) {
        return ma_linear_resampler_process_pcm_frames_f32_downsample(pResampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
    } else {
        return ma_linear_resampler_process_pcm_frames_f32_upsample(pResampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
    }
}


MA_API ma_result ma_linear_resampler_process_pcm_frames(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    if (pResampler == NULL) {
        return MA_INVALID_ARGS;
    }

    /*  */ if (pResampler->config.format == ma_format_s16) {
        return ma_linear_resampler_process_pcm_frames_s16(pResampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
    } else if (pResampler->config.format == ma_format_f32) {
        return ma_linear_resampler_process_pcm_frames_f32(pResampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
    } else {
        /* Should never get here. Getting here means the format is not supported and you didn't check the return value of ma_linear_resampler_init(). */
        MA_ASSERT(MA_FALSE);
        return MA_INVALID_ARGS;
    }
}


MA_API ma_result ma_linear_resampler_set_rate(ma_linear_resampler* pResampler, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)
{
    return ma_linear_resampler_set_rate_internal(pResampler, NULL, NULL, sampleRateIn, sampleRateOut, /* isResamplerAlreadyInitialized = */ MA_TRUE);
}

MA_API ma_result ma_linear_resampler_set_rate_ratio(ma_linear_resampler* pResampler, float ratioInOut)
{
    ma_uint32 n;
    ma_uint32 d;

    if (pResampler == NULL) {
        return MA_INVALID_ARGS;
    }

    if (ratioInOut <= 0) {
        return MA_INVALID_ARGS;
    }

    d = 1000000;
    n = (ma_uint32)(ratioInOut * d);

    if (n == 0) {
        return MA_INVALID_ARGS; /* Ratio too small. */
    }

    MA_ASSERT(n != 0);

    return ma_linear_resampler_set_rate(pResampler, n, d);
}

MA_API ma_uint64 ma_linear_resampler_get_input_latency(const ma_linear_resampler* pResampler)
{
    if (pResampler == NULL) {
        return 0;
    }

    return 1 + ma_lpf_get_latency(&pResampler->lpf);
}

MA_API ma_uint64 ma_linear_resampler_get_output_latency(const ma_linear_resampler* pResampler)
{
    if (pResampler == NULL) {
        return 0;
    }

    return ma_linear_resampler_get_input_latency(pResampler) * pResampler->config.sampleRateOut / pResampler->config.sampleRateIn;
}

MA_API ma_result ma_linear_resampler_get_required_input_frame_count(const ma_linear_resampler* pResampler, ma_uint64 outputFrameCount, ma_uint64* pInputFrameCount)
{
    ma_uint64 inputFrameCount;

    if (pInputFrameCount == NULL) {
        return MA_INVALID_ARGS;
    }

    *pInputFrameCount = 0;

    if (pResampler == NULL) {
        return MA_INVALID_ARGS;
    }

    if (outputFrameCount == 0) {
        return MA_SUCCESS;
    }

    /* Any whole input frames are consumed before the first output frame is generated. */
    inputFrameCount = pResampler->inTimeInt;
    outputFrameCount -= 1;

    /* The rest of the output frames can be calculated in constant time. */
    inputFrameCount += outputFrameCount * pResampler->inAdvanceInt;
    inputFrameCount += (pResampler->inTimeFrac + (outputFrameCount * pResampler->inAdvanceFrac)) / pResampler->config.sampleRateOut;

    *pInputFrameCount = inputFrameCount;

    return MA_SUCCESS;
}

MA_API ma_result ma_linear_resampler_get_expected_output_frame_count(const ma_linear_resampler* pResampler, ma_uint64 inputFrameCount, ma_uint64* pOutputFrameCount)
{
    ma_uint64 outputFrameCount;
    ma_uint64 preliminaryInputFrameCountFromFrac;
    ma_uint64 preliminaryInputFrameCount;

    if (pOutputFrameCount == NULL) {
        return MA_INVALID_ARGS;
    }

    *pOutputFrameCount = 0;

    if (pResampler == NULL) {
        return MA_INVALID_ARGS;
    }

    /*
    The first step is to get a preliminary output frame count. This will either be exactly equal to what we need, or less by 1. We need to
    determine how many input frames will be consumed by this value. If it's greater than our original input frame count it means we won't
    be able to generate an extra frame because we will have run out of input data. Otherwise we will have enough input for the generation
    of an extra output frame. This add-by-one logic is necessary due to how the data loading logic works when processing frames.
    */
    outputFrameCount = (inputFrameCount * pResampler->config.sampleRateOut) / pResampler->config.sampleRateIn;

    /*
    We need to determine how many *whole* input frames will have been processed to generate our preliminary output frame count. This is
    used in the logic below to determine whether or not we need to add an extra output frame.
    */
    preliminaryInputFrameCountFromFrac = (pResampler->inTimeFrac + outputFrameCount*pResampler->inAdvanceFrac) / pResampler->config.sampleRateOut;
    preliminaryInputFrameCount         = (pResampler->inTimeInt  + outputFrameCount*pResampler->inAdvanceInt ) + preliminaryInputFrameCountFromFrac;

    /*
    If the total number of *whole* input frames that would be required to generate our preliminary output frame count is greater than
    the amount of whole input frames we have available as input we need to *not* add an extra output frame as there won't be enough data
    to actually process. Otherwise we need to add the extra output frame.
    */
    if (preliminaryInputFrameCount <= inputFrameCount) {
        outputFrameCount += 1;
    }

    *pOutputFrameCount = outputFrameCount;

    return MA_SUCCESS;
}

MA_API ma_result ma_linear_resampler_reset(ma_linear_resampler* pResampler)
{
    ma_uint32 iChannel;

    if (pResampler == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Timers need to be cleared back to zero. */
    pResampler->inTimeInt  = 1;  /* Set this to one to force an input sample to always be loaded for the first output frame. */
    pResampler->inTimeFrac = 0;

    /* Cached samples need to be cleared. */
    if (pResampler->config.format == ma_format_f32) {
        for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
            pResampler->x0.f32[iChannel] = 0;
            pResampler->x1.f32[iChannel] = 0;
        }
    } else {
        for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
            pResampler->x0.s16[iChannel] = 0;
            pResampler->x1.s16[iChannel] = 0;
        }
    }

    /* The low pass filter needs to have its cache reset. */
    ma_lpf_clear_cache(&pResampler->lpf);

    return MA_SUCCESS;
}



/* Linear resampler backend vtable. */
static ma_linear_resampler_config ma_resampling_backend_get_config__linear(const ma_resampler_config* pConfig)
{
    ma_linear_resampler_config linearConfig;

    linearConfig = ma_linear_resampler_config_init(pConfig->format, pConfig->channels, pConfig->sampleRateIn, pConfig->sampleRateOut);
    linearConfig.lpfOrder = pConfig->linear.lpfOrder;

    return linearConfig;
}

static ma_result ma_resampling_backend_get_heap_size__linear(void* pUserData, const ma_resampler_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_linear_resampler_config linearConfig;

    (void)pUserData;

    linearConfig = ma_resampling_backend_get_config__linear(pConfig);

    return ma_linear_resampler_get_heap_size(&linearConfig, pHeapSizeInBytes);
}

static ma_result ma_resampling_backend_init__linear(void* pUserData, const ma_resampler_config* pConfig, void* pHeap, ma_resampling_backend** ppBackend)
{
    ma_resampler* pResampler = (ma_resampler*)pUserData;
    ma_result result;
    ma_linear_resampler_config linearConfig;

    (void)pUserData;

    linearConfig = ma_resampling_backend_get_config__linear(pConfig);

    result = ma_linear_resampler_init_preallocated(&linearConfig, pHeap, &pResampler->state.linear);
    if (result != MA_SUCCESS) {
        return result;
    }

    *ppBackend = &pResampler->state.linear;

    return MA_SUCCESS;
}

static void ma_resampling_backend_uninit__linear(void* pUserData, ma_resampling_backend* pBackend, const ma_allocation_callbacks* pAllocationCallbacks)
{
    (void)pUserData;

    ma_linear_resampler_uninit((ma_linear_resampler*)pBackend, pAllocationCallbacks);
}

static ma_result ma_resampling_backend_process__linear(void* pUserData, ma_resampling_backend* pBackend, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    (void)pUserData;

    return ma_linear_resampler_process_pcm_frames((ma_linear_resampler*)pBackend, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
}

static ma_result ma_resampling_backend_set_rate__linear(void* pUserData, ma_resampling_backend* pBackend, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)
{
    (void)pUserData;

    return ma_linear_resampler_set_rate((ma_linear_resampler*)pBackend, sampleRateIn, sampleRateOut);
}

static ma_uint64 ma_resampling_backend_get_input_latency__linear(void* pUserData, const ma_resampling_backend* pBackend)
{
    (void)pUserData;

    return ma_linear_resampler_get_input_latency((const ma_linear_resampler*)pBackend);
}

static ma_uint64 ma_resampling_backend_get_output_latency__linear(void* pUserData, const ma_resampling_backend* pBackend)
{
    (void)pUserData;

    return ma_linear_resampler_get_output_latency((const ma_linear_resampler*)pBackend);
}

static ma_result ma_resampling_backend_get_required_input_frame_count__linear(void* pUserData, const ma_resampling_backend* pBackend, ma_uint64 outputFrameCount, ma_uint64* pInputFrameCount)
{
    (void)pUserData;

    return ma_linear_resampler_get_required_input_frame_count((const ma_linear_resampler*)pBackend, outputFrameCount, pInputFrameCount);
}

static ma_result ma_resampling_backend_get_expected_output_frame_count__linear(void* pUserData, const ma_resampling_backend* pBackend, ma_uint64 inputFrameCount, ma_uint64* pOutputFrameCount)
{
    (void)pUserData;

    return ma_linear_resampler_get_expected_output_frame_count((const ma_linear_resampler*)pBackend, inputFrameCount, pOutputFrameCount);
}

static ma_result ma_resampling_backend_reset__linear(void* pUserData, ma_resampling_backend* pBackend)
{
    (void)pUserData;

    return ma_linear_resampler_reset((ma_linear_resampler*)pBackend);
}

static ma_resampling_backend_vtable g_ma_linear_resampler_vtable =
{
    ma_resampling_backend_get_heap_size__linear,
    ma_resampling_backend_init__linear,
    ma_resampling_backend_uninit__linear,
    ma_resampling_backend_process__linear,
    ma_resampling_backend_set_rate__linear,
    ma_resampling_backend_get_input_latency__linear,
    ma_resampling_backend_get_output_latency__linear,
    ma_resampling_backend_get_required_input_frame_count__linear,
    ma_resampling_backend_get_expected_output_frame_count__linear,
    ma_resampling_backend_reset__linear
};



MA_API ma_resampler_config ma_resampler_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut, ma_resample_algorithm algorithm)
{
    ma_resampler_config config;

    MA_ZERO_OBJECT(&config);
    config.format = format;
    config.channels = channels;
    config.sampleRateIn = sampleRateIn;
    config.sampleRateOut = sampleRateOut;
    config.algorithm = algorithm;

    /* Linear. */
    config.linear.lpfOrder = ma_min(MA_DEFAULT_RESAMPLER_LPF_ORDER, MA_MAX_FILTER_ORDER);

    return config;
}

static ma_result ma_resampler_get_vtable(const ma_resampler_config* pConfig, ma_resampler* pResampler, ma_resampling_backend_vtable** ppVTable, void** ppUserData)
{
    MA_ASSERT(pConfig    != NULL);
    MA_ASSERT(ppVTable   != NULL);
    MA_ASSERT(ppUserData != NULL);

    /* Safety. */
    *ppVTable   = NULL;
    *ppUserData = NULL;

    switch (pConfig->algorithm)
    {
        case ma_resample_algorithm_linear:
        {
            *ppVTable   = &g_ma_linear_resampler_vtable;
            *ppUserData = pResampler;
        } break;

        case ma_resample_algorithm_custom:
        {
            *ppVTable   = pConfig->pBackendVTable;
            *ppUserData = pConfig->pBackendUserData;
        } break;

        default: return MA_INVALID_ARGS;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_resampler_get_heap_size(const ma_resampler_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_resampling_backend_vtable* pVTable;
    void* pVTableUserData;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = 0;

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    result = ma_resampler_get_vtable(pConfig, NULL, &pVTable, &pVTableUserData);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (pVTable == NULL || pVTable->onGetHeapSize == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    result = pVTable->onGetHeapSize(pVTableUserData, pConfig, pHeapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_resampler_init_preallocated(const ma_resampler_config* pConfig, void* pHeap, ma_resampler* pResampler)
{
    ma_result result;

    if (pResampler == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pResampler);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    pResampler->_pHeap        = pHeap;
    pResampler->format        = pConfig->format;
    pResampler->channels      = pConfig->channels;
    pResampler->sampleRateIn  = pConfig->sampleRateIn;
    pResampler->sampleRateOut = pConfig->sampleRateOut;

    result = ma_resampler_get_vtable(pConfig, pResampler, &pResampler->pBackendVTable, &pResampler->pBackendUserData);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (pResampler->pBackendVTable == NULL || pResampler->pBackendVTable->onInit == NULL) {
        return MA_NOT_IMPLEMENTED;  /* onInit not implemented. */
    }

    result = pResampler->pBackendVTable->onInit(pResampler->pBackendUserData, pConfig, pHeap, &pResampler->pBackend);
    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_resampler_init(const ma_resampler_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_resampler* pResampler)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_resampler_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_resampler_init_preallocated(pConfig, pHeap, pResampler);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pResampler->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_resampler_uninit(ma_resampler* pResampler, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pResampler == NULL) {
        return;
    }

    if (pResampler->pBackendVTable == NULL || pResampler->pBackendVTable->onUninit == NULL) {
        return;
    }

    pResampler->pBackendVTable->onUninit(pResampler->pBackendUserData, pResampler->pBackend, pAllocationCallbacks);

    if (pResampler->_ownsHeap) {
        ma_free(pResampler->_pHeap, pAllocationCallbacks);
    }
}

MA_API ma_result ma_resampler_process_pcm_frames(ma_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    if (pResampler == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pFrameCountOut == NULL && pFrameCountIn == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pResampler->pBackendVTable == NULL || pResampler->pBackendVTable->onProcess == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    return pResampler->pBackendVTable->onProcess(pResampler->pBackendUserData, pResampler->pBackend, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
}

MA_API ma_result ma_resampler_set_rate(ma_resampler* pResampler, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)
{
    ma_result result;

    if (pResampler == NULL) {
        return MA_INVALID_ARGS;
    }

    if (sampleRateIn == 0 || sampleRateOut == 0) {
        return MA_INVALID_ARGS;
    }

    if (pResampler->pBackendVTable == NULL || pResampler->pBackendVTable->onSetRate == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    result = pResampler->pBackendVTable->onSetRate(pResampler->pBackendUserData, pResampler->pBackend, sampleRateIn, sampleRateOut);
    if (result != MA_SUCCESS) {
        return result;
    }

    pResampler->sampleRateIn  = sampleRateIn;
    pResampler->sampleRateOut = sampleRateOut;

    return MA_SUCCESS;
}

MA_API ma_result ma_resampler_set_rate_ratio(ma_resampler* pResampler, float ratio)
{
    ma_uint32 n;
    ma_uint32 d;

    if (pResampler == NULL) {
        return MA_INVALID_ARGS;
    }

    if (ratio <= 0) {
        return MA_INVALID_ARGS;
    }

    d = 1000;
    n = (ma_uint32)(ratio * d);

    if (n == 0) {
        return MA_INVALID_ARGS; /* Ratio too small. */
    }

    MA_ASSERT(n != 0);

    return ma_resampler_set_rate(pResampler, n, d);
}

MA_API ma_uint64 ma_resampler_get_input_latency(const ma_resampler* pResampler)
{
    if (pResampler == NULL) {
        return 0;
    }

    if (pResampler->pBackendVTable == NULL || pResampler->pBackendVTable->onGetInputLatency == NULL) {
        return 0;
    }

    return pResampler->pBackendVTable->onGetInputLatency(pResampler->pBackendUserData, pResampler->pBackend);
}

MA_API ma_uint64 ma_resampler_get_output_latency(const ma_resampler* pResampler)
{
    if (pResampler == NULL) {
        return 0;
    }

    if (pResampler->pBackendVTable == NULL || pResampler->pBackendVTable->onGetOutputLatency == NULL) {
        return 0;
    }

    return pResampler->pBackendVTable->onGetOutputLatency(pResampler->pBackendUserData, pResampler->pBackend);
}

MA_API ma_result ma_resampler_get_required_input_frame_count(const ma_resampler* pResampler, ma_uint64 outputFrameCount, ma_uint64* pInputFrameCount)
{
    if (pInputFrameCount == NULL) {
        return MA_INVALID_ARGS;
    }

    *pInputFrameCount = 0;

    if (pResampler == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pResampler->pBackendVTable == NULL || pResampler->pBackendVTable->onGetRequiredInputFrameCount == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    return pResampler->pBackendVTable->onGetRequiredInputFrameCount(pResampler->pBackendUserData, pResampler->pBackend, outputFrameCount, pInputFrameCount);
}

MA_API ma_result ma_resampler_get_expected_output_frame_count(const ma_resampler* pResampler, ma_uint64 inputFrameCount, ma_uint64* pOutputFrameCount)
{
    if (pOutputFrameCount == NULL) {
        return MA_INVALID_ARGS;
    }

    *pOutputFrameCount = 0;

    if (pResampler == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pResampler->pBackendVTable == NULL || pResampler->pBackendVTable->onGetExpectedOutputFrameCount == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    return pResampler->pBackendVTable->onGetExpectedOutputFrameCount(pResampler->pBackendUserData, pResampler->pBackend, inputFrameCount, pOutputFrameCount);
}

MA_API ma_result ma_resampler_reset(ma_resampler* pResampler)
{
    if (pResampler == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pResampler->pBackendVTable == NULL || pResampler->pBackendVTable->onReset == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    return pResampler->pBackendVTable->onReset(pResampler->pBackendUserData, pResampler->pBackend);
}

/**************************************************************************************************************************************************************

Channel Conversion

**************************************************************************************************************************************************************/
#ifndef MA_CHANNEL_CONVERTER_FIXED_POINT_SHIFT
#define MA_CHANNEL_CONVERTER_FIXED_POINT_SHIFT  12
#endif

#define MA_PLANE_LEFT      0
#define MA_PLANE_RIGHT     1
#define MA_PLANE_FRONT     2
#define MA_PLANE_BACK      3
#define MA_PLANE_BOTTOM    4
#define MA_PLANE_TOP       5

static float g_maChannelPlaneRatios[MA_CHANNEL_POSITION_COUNT][6] = {
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_NONE */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_MONO */
    { 0.5f,  0.0f,  0.5f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_FRONT_LEFT */
    { 0.0f,  0.5f,  0.5f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_FRONT_RIGHT */
    { 0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_FRONT_CENTER */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_LFE */
    { 0.5f,  0.0f,  0.0f,  0.5f,  0.0f,  0.0f},  /* MA_CHANNEL_BACK_LEFT */
    { 0.0f,  0.5f,  0.0f,  0.5f,  0.0f,  0.0f},  /* MA_CHANNEL_BACK_RIGHT */
    { 0.25f, 0.0f,  0.75f, 0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_FRONT_LEFT_CENTER */
    { 0.0f,  0.25f, 0.75f, 0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_FRONT_RIGHT_CENTER */
    { 0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f},  /* MA_CHANNEL_BACK_CENTER */
    { 1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_SIDE_LEFT */
    { 0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_SIDE_RIGHT */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f},  /* MA_CHANNEL_TOP_CENTER */
    { 0.33f, 0.0f,  0.33f, 0.0f,  0.0f,  0.34f}, /* MA_CHANNEL_TOP_FRONT_LEFT */
    { 0.0f,  0.0f,  0.5f,  0.0f,  0.0f,  0.5f},  /* MA_CHANNEL_TOP_FRONT_CENTER */
    { 0.0f,  0.33f, 0.33f, 0.0f,  0.0f,  0.34f}, /* MA_CHANNEL_TOP_FRONT_RIGHT */
    { 0.33f, 0.0f,  0.0f,  0.33f, 0.0f,  0.34f}, /* MA_CHANNEL_TOP_BACK_LEFT */
    { 0.0f,  0.0f,  0.0f,  0.5f,  0.0f,  0.5f},  /* MA_CHANNEL_TOP_BACK_CENTER */
    { 0.0f,  0.33f, 0.0f,  0.33f, 0.0f,  0.34f}, /* MA_CHANNEL_TOP_BACK_RIGHT */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_0 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_1 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_2 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_3 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_4 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_5 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_6 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_7 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_8 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_9 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_10 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_11 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_12 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_13 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_14 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_15 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_16 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_17 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_18 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_19 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_20 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_21 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_22 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_23 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_24 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_25 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_26 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_27 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_28 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_29 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_30 */
    { 0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f},  /* MA_CHANNEL_AUX_31 */
};

static float ma_calculate_channel_position_rectangular_weight(ma_channel channelPositionA, ma_channel channelPositionB)
{
    /*
    Imagine the following simplified example: You have a single input speaker which is the front/left speaker which you want to convert to
    the following output configuration:

     - front/left
     - side/left
     - back/left

    The front/left output is easy - it the same speaker position so it receives the full contribution of the front/left input. The amount
    of contribution to apply to the side/left and back/left speakers, however, is a bit more complicated.

    Imagine the front/left speaker as emitting audio from two planes - the front plane and the left plane. You can think of the front/left
    speaker emitting half of its total volume from the front, and the other half from the left. Since part of its volume is being emitted
    from the left side, and the side/left and back/left channels also emit audio from the left plane, one would expect that they would
    receive some amount of contribution from front/left speaker. The amount of contribution depends on how many planes are shared between
    the two speakers. Note that in the examples below I've added a top/front/left speaker as an example just to show how the math works
    across 3 spatial dimensions.

    The first thing to do is figure out how each speaker's volume is spread over each of plane:
     - front/left:     2 planes (front and left)      = 1/2 = half its total volume on each plane
     - side/left:      1 plane (left only)            = 1/1 = entire volume from left plane
     - back/left:      2 planes (back and left)       = 1/2 = half its total volume on each plane
     - top/front/left: 3 planes (top, front and left) = 1/3 = one third its total volume on each plane

    The amount of volume each channel contributes to each of its planes is what controls how much it is willing to given and take to other
    channels on the same plane. The volume that is willing to the given by one channel is multiplied by the volume that is willing to be
    taken by the other to produce the final contribution.
    */

    /* Contribution = Sum(Volume to Give * Volume to Take) */
    float contribution =
        g_maChannelPlaneRatios[channelPositionA][0] * g_maChannelPlaneRatios[channelPositionB][0] +
        g_maChannelPlaneRatios[channelPositionA][1] * g_maChannelPlaneRatios[channelPositionB][1] +
        g_maChannelPlaneRatios[channelPositionA][2] * g_maChannelPlaneRatios[channelPositionB][2] +
        g_maChannelPlaneRatios[channelPositionA][3] * g_maChannelPlaneRatios[channelPositionB][3] +
        g_maChannelPlaneRatios[channelPositionA][4] * g_maChannelPlaneRatios[channelPositionB][4] +
        g_maChannelPlaneRatios[channelPositionA][5] * g_maChannelPlaneRatios[channelPositionB][5];

    return contribution;
}

MA_API ma_channel_converter_config ma_channel_converter_config_init(ma_format format, ma_uint32 channelsIn, const ma_channel* pChannelMapIn, ma_uint32 channelsOut, const ma_channel* pChannelMapOut, ma_channel_mix_mode mixingMode)
{
    ma_channel_converter_config config;

    MA_ZERO_OBJECT(&config);
    config.format         = format;
    config.channelsIn     = channelsIn;
    config.channelsOut    = channelsOut;
    config.pChannelMapIn  = pChannelMapIn;
    config.pChannelMapOut = pChannelMapOut;
    config.mixingMode     = mixingMode;

    return config;
}

static ma_int32 ma_channel_converter_float_to_fixed(float x)
{
    return (ma_int32)(x * (1<<MA_CHANNEL_CONVERTER_FIXED_POINT_SHIFT));
}

static ma_uint32 ma_channel_map_get_spatial_channel_count(const ma_channel* pChannelMap, ma_uint32 channels)
{
    ma_uint32 spatialChannelCount = 0;
    ma_uint32 iChannel;

    MA_ASSERT(pChannelMap != NULL);
    MA_ASSERT(channels > 0);

    for (iChannel = 0; iChannel < channels; ++iChannel) {
        if (ma_is_spatial_channel_position(ma_channel_map_get_channel(pChannelMap, channels, iChannel))) {
            spatialChannelCount++;
        }
    }

    return spatialChannelCount;
}

static ma_bool32 ma_is_spatial_channel_position(ma_channel channelPosition)
{
    int i;

    if (channelPosition == MA_CHANNEL_NONE || channelPosition == MA_CHANNEL_MONO || channelPosition == MA_CHANNEL_LFE) {
        return MA_FALSE;
    }

    if (channelPosition >= MA_CHANNEL_AUX_0 && channelPosition <= MA_CHANNEL_AUX_31) {
        return MA_FALSE;
    }

    for (i = 0; i < 6; ++i) {   /* Each side of a cube. */
        if (g_maChannelPlaneRatios[channelPosition][i] != 0) {
            return MA_TRUE;
        }
    }

    return MA_FALSE;
}


static ma_bool32 ma_channel_map_is_passthrough(const ma_channel* pChannelMapIn, ma_uint32 channelsIn, const ma_channel* pChannelMapOut, ma_uint32 channelsOut)
{
    if (channelsOut == channelsIn) {
        return ma_channel_map_is_equal(pChannelMapOut, pChannelMapIn, channelsOut);
    } else {
        return MA_FALSE;    /* Channel counts differ, so cannot be a passthrough. */
    }
}

static ma_channel_conversion_path ma_channel_map_get_conversion_path(const ma_channel* pChannelMapIn, ma_uint32 channelsIn, const ma_channel* pChannelMapOut, ma_uint32 channelsOut, ma_channel_mix_mode mode)
{
    if (ma_channel_map_is_passthrough(pChannelMapIn, channelsIn, pChannelMapOut, channelsOut)) {
        return ma_channel_conversion_path_passthrough;
    }

    if (channelsOut == 1 && (pChannelMapOut == NULL || pChannelMapOut[0] == MA_CHANNEL_MONO)) {
        return ma_channel_conversion_path_mono_out;
    }

    if (channelsIn == 1 && (pChannelMapIn == NULL || pChannelMapIn[0] == MA_CHANNEL_MONO)) {
        return ma_channel_conversion_path_mono_in;
    }

    if (mode == ma_channel_mix_mode_custom_weights) {
        return ma_channel_conversion_path_weights;
    }

    /*
    We can use a simple shuffle if both channel maps have the same channel count and all channel
    positions are present in both.
    */
    if (channelsIn == channelsOut) {
        ma_uint32 iChannelIn;
        ma_bool32 areAllChannelPositionsPresent = MA_TRUE;
        for (iChannelIn = 0; iChannelIn < channelsIn; ++iChannelIn) {
            ma_bool32 isInputChannelPositionInOutput = ma_channel_map_contains_channel_position(channelsOut, pChannelMapOut, ma_channel_map_get_channel(pChannelMapIn, channelsIn, iChannelIn));
            if (!isInputChannelPositionInOutput) {
                areAllChannelPositionsPresent = MA_FALSE;
                break;
            }
        }

        if (areAllChannelPositionsPresent) {
            return ma_channel_conversion_path_shuffle;
        }
    }

    /* Getting here means we'll need to use weights. */
    return ma_channel_conversion_path_weights;
}


static ma_result ma_channel_map_build_shuffle_table(const ma_channel* pChannelMapIn, ma_uint32 channelCountIn, const ma_channel* pChannelMapOut, ma_uint32 channelCountOut, ma_uint8* pShuffleTable)
{
    ma_uint32 iChannelIn;
    ma_uint32 iChannelOut;

    if (pShuffleTable == NULL || channelCountIn == 0 || channelCountOut == 0) {
        return MA_INVALID_ARGS;
    }

    /*
    When building the shuffle table we just do a 1:1 mapping based on the first occurrence of a channel. If the
    input channel has more than one occurrence of a channel position, the second one will be ignored.
    */
    for (iChannelOut = 0; iChannelOut < channelCountOut; iChannelOut += 1) {
        ma_channel channelOut;

        /* Default to MA_CHANNEL_INDEX_NULL so that if a mapping is not found it'll be set appropriately. */
        pShuffleTable[iChannelOut] = MA_CHANNEL_INDEX_NULL;

        channelOut = ma_channel_map_get_channel(pChannelMapOut, channelCountOut, iChannelOut);
        for (iChannelIn = 0; iChannelIn < channelCountIn; iChannelIn += 1) {
            ma_channel channelIn;

            channelIn = ma_channel_map_get_channel(pChannelMapIn, channelCountIn, iChannelIn);
            if (channelOut == channelIn) {
                pShuffleTable[iChannelOut] = (ma_uint8)iChannelIn;
                break;
            }

            /*
            Getting here means the channels don't exactly match, but we are going to support some
            relaxed matching for practicality. If, for example, there are two stereo channel maps,
            but one uses front left/right and the other uses side left/right, it makes logical
            sense to just map these. The way we'll do it is we'll check if there is a logical
            corresponding mapping, and if so, apply it, but we will *not* break from the loop,
            thereby giving the loop a chance to find an exact match later which will take priority.
            */
            switch (channelOut)
            {
                /* Left channels. */
                case MA_CHANNEL_FRONT_LEFT:
                case MA_CHANNEL_SIDE_LEFT:
                {
                    switch (channelIn) {
                        case MA_CHANNEL_FRONT_LEFT:
                        case MA_CHANNEL_SIDE_LEFT:
                        {
                            pShuffleTable[iChannelOut] = (ma_uint8)iChannelIn;
                        } break;
                    }
                } break;

                /* Right channels. */
                case MA_CHANNEL_FRONT_RIGHT:
                case MA_CHANNEL_SIDE_RIGHT:
                {
                    switch (channelIn) {
                        case MA_CHANNEL_FRONT_RIGHT:
                        case MA_CHANNEL_SIDE_RIGHT:
                        {
                            pShuffleTable[iChannelOut] = (ma_uint8)iChannelIn;
                        } break;
                    }
                } break;

                default: break;
            }
        }
    }

    return MA_SUCCESS;
}


static void ma_channel_map_apply_shuffle_table_u8(ma_uint8* pFramesOut, ma_uint32 channelsOut, const ma_uint8* pFramesIn, ma_uint32 channelsIn, ma_uint64 frameCount, const ma_uint8* pShuffleTable)
{
    ma_uint64 iFrame;
    ma_uint32 iChannelOut;

    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
            ma_uint8 iChannelIn = pShuffleTable[iChannelOut];
            if (iChannelIn < channelsIn) {  /* For safety, and to deal with MA_CHANNEL_INDEX_NULL. */
                pFramesOut[iChannelOut] = pFramesIn[iChannelIn];
            } else {
                pFramesOut[iChannelOut] = 0;
            }
        }

        pFramesOut += channelsOut;
        pFramesIn  += channelsIn;
    }
}

static void ma_channel_map_apply_shuffle_table_s16(ma_int16* pFramesOut, ma_uint32 channelsOut, const ma_int16* pFramesIn, ma_uint32 channelsIn, ma_uint64 frameCount, const ma_uint8* pShuffleTable)
{
    ma_uint64 iFrame;
    ma_uint32 iChannelOut;

    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
            ma_uint8 iChannelIn = pShuffleTable[iChannelOut];
            if (iChannelIn < channelsIn) {  /* For safety, and to deal with MA_CHANNEL_INDEX_NULL. */
                pFramesOut[iChannelOut] = pFramesIn[iChannelIn];
            } else {
                pFramesOut[iChannelOut] = 0;
            }
        }

        pFramesOut += channelsOut;
        pFramesIn  += channelsIn;
    }
}

static void ma_channel_map_apply_shuffle_table_s24(ma_uint8* pFramesOut, ma_uint32 channelsOut, const ma_uint8* pFramesIn, ma_uint32 channelsIn, ma_uint64 frameCount, const ma_uint8* pShuffleTable)
{
    ma_uint64 iFrame;
    ma_uint32 iChannelOut;

    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
            ma_uint8 iChannelIn = pShuffleTable[iChannelOut];
            if (iChannelIn < channelsIn) {  /* For safety, and to deal with MA_CHANNEL_INDEX_NULL. */
                pFramesOut[iChannelOut*3 + 0] = pFramesIn[iChannelIn*3 + 0];
                pFramesOut[iChannelOut*3 + 1] = pFramesIn[iChannelIn*3 + 1];
                pFramesOut[iChannelOut*3 + 2] = pFramesIn[iChannelIn*3 + 2];
            } else {
                pFramesOut[iChannelOut*3 + 0] = 0;
            }   pFramesOut[iChannelOut*3 + 1] = 0;
        }       pFramesOut[iChannelOut*3 + 2] = 0;

        pFramesOut += channelsOut*3;
        pFramesIn  += channelsIn*3;
    }
}

static void ma_channel_map_apply_shuffle_table_s32(ma_int32* pFramesOut, ma_uint32 channelsOut, const ma_int32* pFramesIn, ma_uint32 channelsIn, ma_uint64 frameCount, const ma_uint8* pShuffleTable)
{
    ma_uint64 iFrame;
    ma_uint32 iChannelOut;

    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
            ma_uint8 iChannelIn = pShuffleTable[iChannelOut];
            if (iChannelIn < channelsIn) {  /* For safety, and to deal with MA_CHANNEL_INDEX_NULL. */
                pFramesOut[iChannelOut] = pFramesIn[iChannelIn];
            } else {
                pFramesOut[iChannelOut] = 0;
            }
        }

        pFramesOut += channelsOut;
        pFramesIn  += channelsIn;
    }
}

static void ma_channel_map_apply_shuffle_table_f32(float* pFramesOut, ma_uint32 channelsOut, const float* pFramesIn, ma_uint32 channelsIn, ma_uint64 frameCount, const ma_uint8* pShuffleTable)
{
    ma_uint64 iFrame;
    ma_uint32 iChannelOut;

    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
        for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
            ma_uint8 iChannelIn = pShuffleTable[iChannelOut];
            if (iChannelIn < channelsIn) {  /* For safety, and to deal with MA_CHANNEL_INDEX_NULL. */
                pFramesOut[iChannelOut] = pFramesIn[iChannelIn];
            } else {
                pFramesOut[iChannelOut] = 0;
            }
        }

        pFramesOut += channelsOut;
        pFramesIn  += channelsIn;
    }
}

static ma_result ma_channel_map_apply_shuffle_table(void* pFramesOut, ma_uint32 channelsOut, const void* pFramesIn, ma_uint32 channelsIn, ma_uint64 frameCount, const ma_uint8* pShuffleTable, ma_format format)
{
    if (pFramesOut == NULL || pFramesIn == NULL || channelsOut == 0 || pShuffleTable == NULL) {
        return MA_INVALID_ARGS;
    }

    switch (format)
    {
        case ma_format_u8:
        {
            ma_channel_map_apply_shuffle_table_u8((ma_uint8*)pFramesOut, channelsOut, (const ma_uint8*)pFramesIn, channelsIn, frameCount, pShuffleTable);
        } break;

        case ma_format_s16:
        {
            ma_channel_map_apply_shuffle_table_s16((ma_int16*)pFramesOut, channelsOut, (const ma_int16*)pFramesIn, channelsIn, frameCount, pShuffleTable);
        } break;

        case ma_format_s24:
        {
            ma_channel_map_apply_shuffle_table_s24((ma_uint8*)pFramesOut, channelsOut, (const ma_uint8*)pFramesIn, channelsIn, frameCount, pShuffleTable);
        } break;

        case ma_format_s32:
        {
            ma_channel_map_apply_shuffle_table_s32((ma_int32*)pFramesOut, channelsOut, (const ma_int32*)pFramesIn, channelsIn, frameCount, pShuffleTable);
        } break;

        case ma_format_f32:
        {
            ma_channel_map_apply_shuffle_table_f32((float*)pFramesOut, channelsOut, (const float*)pFramesIn, channelsIn, frameCount, pShuffleTable);
        } break;

        default: return MA_INVALID_ARGS;    /* Unknown format. */
    }

    return MA_SUCCESS;
}

static ma_result ma_channel_map_apply_mono_out_f32(float* pFramesOut, const float* pFramesIn, const ma_channel* pChannelMapIn, ma_uint32 channelsIn, ma_uint64 frameCount)
{
    ma_uint64 iFrame;
    ma_uint32 iChannelIn;
    ma_uint32 accumulationCount;

    if (pFramesOut == NULL || pFramesIn == NULL || channelsIn == 0) {
        return MA_INVALID_ARGS;
    }

    /* In this case the output stream needs to be the average of all channels, ignoring NONE. */

    /* A quick pre-processing step to get the accumulation counter since we're ignoring NONE channels. */
    accumulationCount = 0;
    for (iChannelIn = 0; iChannelIn < channelsIn; iChannelIn += 1) {
        if (ma_channel_map_get_channel(pChannelMapIn, channelsIn, iChannelIn) != MA_CHANNEL_NONE) {
            accumulationCount += 1;
        }
    }

    if (accumulationCount > 0) {    /* <-- Prevent a division by zero. */
        for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
            float accumulation = 0;

            for (iChannelIn = 0; iChannelIn < channelsIn; iChannelIn += 1) {
                ma_channel channelIn = ma_channel_map_get_channel(pChannelMapIn, channelsIn, iChannelIn);
                if (channelIn != MA_CHANNEL_NONE) {
                    accumulation += pFramesIn[iChannelIn];
                }
            }

            pFramesOut[0] = accumulation / accumulationCount;
            pFramesOut += 1;
            pFramesIn  += channelsIn;
        }
    } else {
        ma_silence_pcm_frames(pFramesOut, frameCount, ma_format_f32, 1);
    }

    return MA_SUCCESS;
}

static ma_result ma_channel_map_apply_mono_in_f32(float* MA_RESTRICT pFramesOut, const ma_channel* pChannelMapOut, ma_uint32 channelsOut, const float* MA_RESTRICT pFramesIn, ma_uint64 frameCount, ma_mono_expansion_mode monoExpansionMode)
{
    ma_uint64 iFrame;
    ma_uint32 iChannelOut;

    if (pFramesOut == NULL || channelsOut == 0 || pFramesIn == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Note that the MA_CHANNEL_NONE channel must be ignored in all cases. */
    switch (monoExpansionMode)
    {
        case ma_mono_expansion_mode_average:
        {
            float weight;
            ma_uint32 validChannelCount = 0;

            for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
                ma_channel channelOut = ma_channel_map_get_channel(pChannelMapOut, channelsOut, iChannelOut);
                if (channelOut != MA_CHANNEL_NONE) {
                    validChannelCount += 1;
                }
            }

            weight = 1.0f / validChannelCount;

            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
                    ma_channel channelOut = ma_channel_map_get_channel(pChannelMapOut, channelsOut, iChannelOut);
                    if (channelOut != MA_CHANNEL_NONE) {
                        pFramesOut[iChannelOut] = pFramesIn[0] * weight;
                    }
                }

                pFramesOut += channelsOut;
                pFramesIn  += 1;
            }
        } break;

        case ma_mono_expansion_mode_stereo_only:
        {
            if (channelsOut >= 2) {
                ma_uint32 iChannelLeft  = (ma_uint32)-1;
                ma_uint32 iChannelRight = (ma_uint32)-1;

                /*
                We first need to find our stereo channels. We prefer front-left and front-right, but
                if they're not available, we'll also try side-left and side-right. If neither are
                available we'll fall through to the default case below.
                */
                for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
                    ma_channel channelOut = ma_channel_map_get_channel(pChannelMapOut, channelsOut, iChannelOut);
                    if (channelOut == MA_CHANNEL_SIDE_LEFT) {
                        iChannelLeft  = iChannelOut;
                    }
                    if (channelOut == MA_CHANNEL_SIDE_RIGHT) {
                        iChannelRight = iChannelOut;
                    }
                }

                for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
                    ma_channel channelOut = ma_channel_map_get_channel(pChannelMapOut, channelsOut, iChannelOut);
                    if (channelOut == MA_CHANNEL_FRONT_LEFT) {
                        iChannelLeft  = iChannelOut;
                    }
                    if (channelOut == MA_CHANNEL_FRONT_RIGHT) {
                        iChannelRight = iChannelOut;
                    }
                }


                if (iChannelLeft != (ma_uint32)-1 && iChannelRight != (ma_uint32)-1) {
                    /* We found our stereo channels so we can duplicate the signal across those channels. */
                    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                        for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
                            ma_channel channelOut = ma_channel_map_get_channel(pChannelMapOut, channelsOut, iChannelOut);
                            if (channelOut != MA_CHANNEL_NONE) {
                                if (iChannelOut == iChannelLeft || iChannelOut == iChannelRight) {
                                    pFramesOut[iChannelOut] = pFramesIn[0];
                                } else {
                                    pFramesOut[iChannelOut] = 0.0f;
                                }
                            }
                        }

                        pFramesOut += channelsOut;
                        pFramesIn  += 1;
                    }

                    break;  /* Get out of the switch. */
                } else {
                    /* Fallthrough. Does not have left and right channels. */
                    goto default_handler;
                }
            } else {
                /* Fallthrough. Does not have stereo channels. */
                goto default_handler;
            }
        };  /* Fallthrough. See comments above. */

        case ma_mono_expansion_mode_duplicate:
        default:
        {
            default_handler:
            {
                if (channelsOut <= MA_MAX_CHANNELS) {
                    ma_bool32 hasEmptyChannel = MA_FALSE;
                    ma_channel channelPositions[MA_MAX_CHANNELS];
                    for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
                        channelPositions[iChannelOut] = ma_channel_map_get_channel(pChannelMapOut, channelsOut, iChannelOut);
                        if (channelPositions[iChannelOut] == MA_CHANNEL_NONE) {
                            hasEmptyChannel = MA_TRUE;
                        }
                    }

                    if (hasEmptyChannel == MA_FALSE) {
                        /*
                        Faster path when there's no MA_CHANNEL_NONE channel positions. This should hopefully
                        help the compiler with auto-vectorization.m
                        */
                        if (channelsOut == 2) {
                        #if defined(MA_SUPPORT_SSE2)
                            if (ma_has_sse2()) {
                                /* We want to do two frames in each iteration. */
                                ma_uint64 unrolledFrameCount = frameCount >> 1;

                                for (iFrame = 0; iFrame < unrolledFrameCount; iFrame += 1) {
                                    __m128 in0 = _mm_set1_ps(pFramesIn[iFrame*2 + 0]);
                                    __m128 in1 = _mm_set1_ps(pFramesIn[iFrame*2 + 1]);
                                    _mm_storeu_ps(&pFramesOut[iFrame*4 + 0], _mm_shuffle_ps(in0, in1, _MM_SHUFFLE(0, 0, 0, 0)));
                                }

                                /* Tail. */
                                iFrame = unrolledFrameCount << 1;
                                goto generic_on_fastpath;
                            } else
                        #endif
                            {
                                for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                                    for (iChannelOut = 0; iChannelOut < 2; iChannelOut += 1) {
                                        pFramesOut[iFrame*2 + iChannelOut] = pFramesIn[iFrame];
                                    }
                                }
                            }
                        } else if (channelsOut == 6) {
                        #if defined(MA_SUPPORT_SSE2)
                            if (ma_has_sse2()) {
                                /* We want to do two frames in each iteration so we can have a multiple of 4 samples. */
                                ma_uint64 unrolledFrameCount = frameCount >> 1;

                                for (iFrame = 0; iFrame < unrolledFrameCount; iFrame += 1) {
                                    __m128 in0 = _mm_set1_ps(pFramesIn[iFrame*2 + 0]);
                                    __m128 in1 = _mm_set1_ps(pFramesIn[iFrame*2 + 1]);

                                    _mm_storeu_ps(&pFramesOut[iFrame*12 + 0], in0);
                                    _mm_storeu_ps(&pFramesOut[iFrame*12 + 4], _mm_shuffle_ps(in0, in1, _MM_SHUFFLE(0, 0, 0, 0)));
                                    _mm_storeu_ps(&pFramesOut[iFrame*12 + 8], in1);
                                }

                                /* Tail. */
                                iFrame = unrolledFrameCount << 1;
                                goto generic_on_fastpath;
                            } else
                        #endif
                            {
                                for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                                    for (iChannelOut = 0; iChannelOut < 6; iChannelOut += 1) {
                                        pFramesOut[iFrame*6 + iChannelOut] = pFramesIn[iFrame];
                                    }
                                }
                            }
                        } else if (channelsOut == 8) {
                        #if defined(MA_SUPPORT_SSE2)
                            if (ma_has_sse2()) {
                                for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                                    __m128 in = _mm_set1_ps(pFramesIn[iFrame]);
                                    _mm_storeu_ps(&pFramesOut[iFrame*8 + 0], in);
                                    _mm_storeu_ps(&pFramesOut[iFrame*8 + 4], in);
                                }
                            } else
                        #endif
                            {
                                for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                                    for (iChannelOut = 0; iChannelOut < 8; iChannelOut += 1) {
                                        pFramesOut[iFrame*8 + iChannelOut] = pFramesIn[iFrame];
                                    }
                                }
                            }
                        } else {
                            iFrame = 0;

                            #if defined(MA_SUPPORT_SSE2)    /* For silencing a warning with non-x86 builds. */
                            generic_on_fastpath:
                            #endif
                            {
                                for (; iFrame < frameCount; iFrame += 1) {
                                    for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
                                        pFramesOut[iFrame*channelsOut + iChannelOut] = pFramesIn[iFrame];
                                    }
                                }
                            }
                        }
                    } else {
                        /* Slow path. Need to handle MA_CHANNEL_NONE. */
                        for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                            for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
                                if (channelPositions[iChannelOut] != MA_CHANNEL_NONE) {
                                    pFramesOut[iFrame*channelsOut + iChannelOut] = pFramesIn[iFrame];
                                }
                            }
                        }
                    }
                } else {
                    /* Slow path. Too many channels to store on the stack. */
                    for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                        for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
                            ma_channel channelOut = ma_channel_map_get_channel(pChannelMapOut, channelsOut, iChannelOut);
                            if (channelOut != MA_CHANNEL_NONE) {
                                pFramesOut[iFrame*channelsOut + iChannelOut] = pFramesIn[iFrame];
                            }
                        }
                    }
                }
            }
        } break;
    }

    return MA_SUCCESS;
}

static void ma_channel_map_apply_f32(float* pFramesOut, const ma_channel* pChannelMapOut, ma_uint32 channelsOut, const float* pFramesIn, const ma_channel* pChannelMapIn, ma_uint32 channelsIn, ma_uint64 frameCount, ma_channel_mix_mode mode, ma_mono_expansion_mode monoExpansionMode)
{
    ma_channel_conversion_path conversionPath = ma_channel_map_get_conversion_path(pChannelMapIn, channelsIn, pChannelMapOut, channelsOut, mode);

    /* Optimized Path: Passthrough */
    if (conversionPath == ma_channel_conversion_path_passthrough) {
        ma_copy_pcm_frames(pFramesOut, pFramesIn, frameCount, ma_format_f32, channelsOut);
        return;
    }

    /* Special Path: Mono Output. */
    if (conversionPath == ma_channel_conversion_path_mono_out) {
        ma_channel_map_apply_mono_out_f32(pFramesOut, pFramesIn, pChannelMapIn, channelsIn, frameCount);
        return;
    }

    /* Special Path: Mono Input. */
    if (conversionPath == ma_channel_conversion_path_mono_in) {
        ma_channel_map_apply_mono_in_f32(pFramesOut, pChannelMapOut, channelsOut, pFramesIn, frameCount, monoExpansionMode);
        return;
    }

    /* Getting here means we aren't running on an optimized conversion path. */
    if (channelsOut <= MA_MAX_CHANNELS) {
        ma_result result;

        if (mode == ma_channel_mix_mode_simple) {
            ma_channel shuffleTable[MA_MAX_CHANNELS];

            result = ma_channel_map_build_shuffle_table(pChannelMapIn, channelsIn, pChannelMapOut, channelsOut, shuffleTable);
            if (result != MA_SUCCESS) {
                return;
            }

            result = ma_channel_map_apply_shuffle_table(pFramesOut, channelsOut, pFramesIn, channelsIn, frameCount, shuffleTable, ma_format_f32);
            if (result != MA_SUCCESS) {
                return;
            }
        } else {
            ma_uint32 iFrame;
            ma_uint32 iChannelOut;
            ma_uint32 iChannelIn;
            float weights[32][32];  /* Do not use MA_MAX_CHANNELS here! */

            /*
            If we have a small enough number of channels, pre-compute the weights. Otherwise we'll just need to
            fall back to a slower path because otherwise we'll run out of stack space.
            */
            if (channelsIn <= ma_countof(weights) && channelsOut <= ma_countof(weights)) {
                /* Pre-compute weights. */
                for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
                    ma_channel channelOut = ma_channel_map_get_channel(pChannelMapOut, channelsOut, iChannelOut);
                    for (iChannelIn = 0; iChannelIn < channelsIn; iChannelIn += 1) {
                        ma_channel channelIn = ma_channel_map_get_channel(pChannelMapIn, channelsIn, iChannelIn);
                        weights[iChannelOut][iChannelIn] = ma_calculate_channel_position_rectangular_weight(channelOut, channelIn);
                    }
                }

                iFrame = 0;

                /* Experiment: Try an optimized unroll for some specific cases to see how it improves performance. RESULT: Good gains. */
                if (channelsOut == 8) {
                    /* Experiment 2: Expand the inner loop to see what kind of different it makes. RESULT: Small, but worthwhile gain. */
                    if (channelsIn == 2) {
                        for (; iFrame < frameCount; iFrame += 1) {
                            float accumulation[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };

                            accumulation[0] += pFramesIn[iFrame*2 + 0] * weights[0][0];
                            accumulation[1] += pFramesIn[iFrame*2 + 0] * weights[1][0];
                            accumulation[2] += pFramesIn[iFrame*2 + 0] * weights[2][0];
                            accumulation[3] += pFramesIn[iFrame*2 + 0] * weights[3][0];
                            accumulation[4] += pFramesIn[iFrame*2 + 0] * weights[4][0];
                            accumulation[5] += pFramesIn[iFrame*2 + 0] * weights[5][0];
                            accumulation[6] += pFramesIn[iFrame*2 + 0] * weights[6][0];
                            accumulation[7] += pFramesIn[iFrame*2 + 0] * weights[7][0];

                            accumulation[0] += pFramesIn[iFrame*2 + 1] * weights[0][1];
                            accumulation[1] += pFramesIn[iFrame*2 + 1] * weights[1][1];
                            accumulation[2] += pFramesIn[iFrame*2 + 1] * weights[2][1];
                            accumulation[3] += pFramesIn[iFrame*2 + 1] * weights[3][1];
                            accumulation[4] += pFramesIn[iFrame*2 + 1] * weights[4][1];
                            accumulation[5] += pFramesIn[iFrame*2 + 1] * weights[5][1];
                            accumulation[6] += pFramesIn[iFrame*2 + 1] * weights[6][1];
                            accumulation[7] += pFramesIn[iFrame*2 + 1] * weights[7][1];

                            pFramesOut[iFrame*8 + 0] = accumulation[0];
                            pFramesOut[iFrame*8 + 1] = accumulation[1];
                            pFramesOut[iFrame*8 + 2] = accumulation[2];
                            pFramesOut[iFrame*8 + 3] = accumulation[3];
                            pFramesOut[iFrame*8 + 4] = accumulation[4];
                            pFramesOut[iFrame*8 + 5] = accumulation[5];
                            pFramesOut[iFrame*8 + 6] = accumulation[6];
                            pFramesOut[iFrame*8 + 7] = accumulation[7];
                        }
                    } else {
                        /* When outputting to 8 channels, we can do everything in groups of two 4x SIMD operations. */
                        for (; iFrame < frameCount; iFrame += 1) {
                            float accumulation[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };

                            for (iChannelIn = 0; iChannelIn < channelsIn; iChannelIn += 1) {
                                accumulation[0] += pFramesIn[iFrame*channelsIn + iChannelIn] * weights[0][iChannelIn];
                                accumulation[1] += pFramesIn[iFrame*channelsIn + iChannelIn] * weights[1][iChannelIn];
                                accumulation[2] += pFramesIn[iFrame*channelsIn + iChannelIn] * weights[2][iChannelIn];
                                accumulation[3] += pFramesIn[iFrame*channelsIn + iChannelIn] * weights[3][iChannelIn];
                                accumulation[4] += pFramesIn[iFrame*channelsIn + iChannelIn] * weights[4][iChannelIn];
                                accumulation[5] += pFramesIn[iFrame*channelsIn + iChannelIn] * weights[5][iChannelIn];
                                accumulation[6] += pFramesIn[iFrame*channelsIn + iChannelIn] * weights[6][iChannelIn];
                                accumulation[7] += pFramesIn[iFrame*channelsIn + iChannelIn] * weights[7][iChannelIn];
                            }

                            pFramesOut[iFrame*8 + 0] = accumulation[0];
                            pFramesOut[iFrame*8 + 1] = accumulation[1];
                            pFramesOut[iFrame*8 + 2] = accumulation[2];
                            pFramesOut[iFrame*8 + 3] = accumulation[3];
                            pFramesOut[iFrame*8 + 4] = accumulation[4];
                            pFramesOut[iFrame*8 + 5] = accumulation[5];
                            pFramesOut[iFrame*8 + 6] = accumulation[6];
                            pFramesOut[iFrame*8 + 7] = accumulation[7];
                        }
                    }
                } else if (channelsOut == 6) {
                    /*
                    When outputting to 6 channels we unfortunately don't have a nice multiple of 4 to do 4x SIMD operations. Instead we'll
                    expand our weights and do two frames at a time.
                    */
                    for (; iFrame < frameCount; iFrame += 1) {
                        float accumulation[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

                        for (iChannelIn = 0; iChannelIn < channelsIn; iChannelIn += 1) {
                            accumulation[0] += pFramesIn[iFrame*channelsIn + iChannelIn] * weights[0][iChannelIn];
                            accumulation[1] += pFramesIn[iFrame*channelsIn + iChannelIn] * weights[1][iChannelIn];
                            accumulation[2] += pFramesIn[iFrame*channelsIn + iChannelIn] * weights[2][iChannelIn];
                            accumulation[3] += pFramesIn[iFrame*channelsIn + iChannelIn] * weights[3][iChannelIn];
                            accumulation[4] += pFramesIn[iFrame*channelsIn + iChannelIn] * weights[4][iChannelIn];
                            accumulation[5] += pFramesIn[iFrame*channelsIn + iChannelIn] * weights[5][iChannelIn];
                        }

                        pFramesOut[iFrame*6 + 0] = accumulation[0];
                        pFramesOut[iFrame*6 + 1] = accumulation[1];
                        pFramesOut[iFrame*6 + 2] = accumulation[2];
                        pFramesOut[iFrame*6 + 3] = accumulation[3];
                        pFramesOut[iFrame*6 + 4] = accumulation[4];
                        pFramesOut[iFrame*6 + 5] = accumulation[5];
                    }
                }

                /* Leftover frames. */
                for (; iFrame < frameCount; iFrame += 1) {
                    for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
                        float accumulation = 0;

                        for (iChannelIn = 0; iChannelIn < channelsIn; iChannelIn += 1) {
                            accumulation += pFramesIn[iFrame*channelsIn + iChannelIn] * weights[iChannelOut][iChannelIn];
                        }

                        pFramesOut[iFrame*channelsOut + iChannelOut] = accumulation;
                    }
                }
            } else {
                /* Cannot pre-compute weights because not enough room in stack-allocated buffer. */
                for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                    for (iChannelOut = 0; iChannelOut < channelsOut; iChannelOut += 1) {
                        float accumulation = 0;
                        ma_channel channelOut = ma_channel_map_get_channel(pChannelMapOut, channelsOut, iChannelOut);

                        for (iChannelIn = 0; iChannelIn < channelsIn; iChannelIn += 1) {
                            ma_channel channelIn = ma_channel_map_get_channel(pChannelMapIn, channelsIn, iChannelIn);
                            accumulation += pFramesIn[iFrame*channelsIn + iChannelIn] * ma_calculate_channel_position_rectangular_weight(channelOut, channelIn);
                        }

                        pFramesOut[iFrame*channelsOut + iChannelOut] = accumulation;
                    }
                }
            }
        }
    } else {
        /* Fall back to silence. If you hit this, what are you doing with so many channels?! */
        ma_silence_pcm_frames(pFramesOut, frameCount, ma_format_f32, channelsOut);
    }
}


typedef struct
{
    size_t sizeInBytes;
    size_t channelMapInOffset;
    size_t channelMapOutOffset;
    size_t shuffleTableOffset;
    size_t weightsOffset;
} ma_channel_converter_heap_layout;

static ma_channel_conversion_path ma_channel_converter_config_get_conversion_path(const ma_channel_converter_config* pConfig)
{
    return ma_channel_map_get_conversion_path(pConfig->pChannelMapIn, pConfig->channelsIn, pConfig->pChannelMapOut, pConfig->channelsOut, pConfig->mixingMode);
}

static ma_result ma_channel_converter_get_heap_layout(const ma_channel_converter_config* pConfig, ma_channel_converter_heap_layout* pHeapLayout)
{
    ma_channel_conversion_path conversionPath;

    MA_ASSERT(pHeapLayout != NULL);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->channelsIn == 0 || pConfig->channelsOut == 0) {
        return MA_INVALID_ARGS;
    }

    if (!ma_channel_map_is_valid(pConfig->pChannelMapIn, pConfig->channelsIn)) {
        return MA_INVALID_ARGS;
    }

    if (!ma_channel_map_is_valid(pConfig->pChannelMapOut, pConfig->channelsOut)) {
        return MA_INVALID_ARGS;
    }

    pHeapLayout->sizeInBytes = 0;

    /* Input channel map. Only need to allocate this if we have an input channel map (otherwise default channel map is assumed). */
    pHeapLayout->channelMapInOffset = pHeapLayout->sizeInBytes;
    if (pConfig->pChannelMapIn != NULL) {
        pHeapLayout->sizeInBytes += sizeof(ma_channel) * pConfig->channelsIn;
    }

    /* Output channel map. Only need to allocate this if we have an output channel map (otherwise default channel map is assumed). */
    pHeapLayout->channelMapOutOffset = pHeapLayout->sizeInBytes;
    if (pConfig->pChannelMapOut != NULL) {
        pHeapLayout->sizeInBytes += sizeof(ma_channel) * pConfig->channelsOut;
    }

    /* Alignment for the next section. */
    pHeapLayout->sizeInBytes = ma_align_64(pHeapLayout->sizeInBytes);

    /* Whether or not we use weights of a shuffle table depends on the channel map themselves and the algorithm we've chosen. */
    conversionPath = ma_channel_converter_config_get_conversion_path(pConfig);

    /* Shuffle table */
    pHeapLayout->shuffleTableOffset = pHeapLayout->sizeInBytes;
    if (conversionPath == ma_channel_conversion_path_shuffle) {
        pHeapLayout->sizeInBytes += sizeof(ma_uint8) * pConfig->channelsOut;
    }

    /* Weights */
    pHeapLayout->weightsOffset = pHeapLayout->sizeInBytes;
    if (conversionPath == ma_channel_conversion_path_weights) {
        pHeapLayout->sizeInBytes += sizeof(float*) * pConfig->channelsIn;
        pHeapLayout->sizeInBytes += sizeof(float ) * pConfig->channelsIn * pConfig->channelsOut;
    }

    /* Make sure allocation size is aligned. */
    pHeapLayout->sizeInBytes = ma_align_64(pHeapLayout->sizeInBytes);

    return MA_SUCCESS;
}

MA_API ma_result ma_channel_converter_get_heap_size(const ma_channel_converter_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_channel_converter_heap_layout heapLayout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = 0;

    result = ma_channel_converter_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pHeapSizeInBytes = heapLayout.sizeInBytes;

    return MA_SUCCESS;
}

MA_API ma_result ma_channel_converter_init_preallocated(const ma_channel_converter_config* pConfig, void* pHeap, ma_channel_converter* pConverter)
{
    ma_result result;
    ma_channel_converter_heap_layout heapLayout;

    if (pConverter == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pConverter);

    result = ma_channel_converter_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    pConverter->_pHeap = pHeap;
    MA_ZERO_MEMORY(pConverter->_pHeap, heapLayout.sizeInBytes);

    pConverter->format      = pConfig->format;
    pConverter->channelsIn  = pConfig->channelsIn;
    pConverter->channelsOut = pConfig->channelsOut;
    pConverter->mixingMode  = pConfig->mixingMode;

    if (pConfig->pChannelMapIn != NULL) {
        pConverter->pChannelMapIn = (ma_channel*)ma_offset_ptr(pHeap, heapLayout.channelMapInOffset);
        ma_channel_map_copy_or_default(pConverter->pChannelMapIn, pConfig->channelsIn, pConfig->pChannelMapIn, pConfig->channelsIn);
    } else {
        pConverter->pChannelMapIn = NULL;   /* Use default channel map. */
    }

    if (pConfig->pChannelMapOut != NULL) {
        pConverter->pChannelMapOut = (ma_channel*)ma_offset_ptr(pHeap, heapLayout.channelMapOutOffset);
        ma_channel_map_copy_or_default(pConverter->pChannelMapOut, pConfig->channelsOut, pConfig->pChannelMapOut, pConfig->channelsOut);
    } else {
        pConverter->pChannelMapOut = NULL;  /* Use default channel map. */
    }

    pConverter->conversionPath = ma_channel_converter_config_get_conversion_path(pConfig);

    if (pConverter->conversionPath == ma_channel_conversion_path_shuffle) {
        pConverter->pShuffleTable = (ma_uint8*)ma_offset_ptr(pHeap, heapLayout.shuffleTableOffset);
        ma_channel_map_build_shuffle_table(pConverter->pChannelMapIn, pConverter->channelsIn, pConverter->pChannelMapOut, pConverter->channelsOut, pConverter->pShuffleTable);
    }

    if (pConverter->conversionPath == ma_channel_conversion_path_weights) {
        ma_uint32 iChannelIn;
        ma_uint32 iChannelOut;

        if (pConverter->format == ma_format_f32) {
            pConverter->weights.f32 = (float**   )ma_offset_ptr(pHeap, heapLayout.weightsOffset);
            for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; iChannelIn += 1) {
                pConverter->weights.f32[iChannelIn] = (float*)ma_offset_ptr(pHeap, heapLayout.weightsOffset + ((sizeof(float*) * pConverter->channelsIn) + (sizeof(float) * pConverter->channelsOut * iChannelIn)));
            }
        } else {
            pConverter->weights.s16 = (ma_int32**)ma_offset_ptr(pHeap, heapLayout.weightsOffset);
            for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; iChannelIn += 1) {
                pConverter->weights.s16[iChannelIn] = (ma_int32*)ma_offset_ptr(pHeap, heapLayout.weightsOffset + ((sizeof(ma_int32*) * pConverter->channelsIn) + (sizeof(ma_int32) * pConverter->channelsOut * iChannelIn)));
            }
        }

        /* Silence our weights by default. */
        for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; iChannelIn += 1) {
            for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; iChannelOut += 1) {
                if (pConverter->format == ma_format_f32) {
                    pConverter->weights.f32[iChannelIn][iChannelOut] = 0.0f;
                } else {
                    pConverter->weights.s16[iChannelIn][iChannelOut] = 0;
                }
            }
        }

        /*
        We now need to fill out our weights table. This is determined by the mixing mode.
        */

        /* In all cases we need to make sure all channels that are present in both channel maps have a 1:1 mapping. */
        for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
            ma_channel channelPosIn = ma_channel_map_get_channel(pConverter->pChannelMapIn, pConverter->channelsIn, iChannelIn);

            for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
                ma_channel channelPosOut = ma_channel_map_get_channel(pConverter->pChannelMapOut, pConverter->channelsOut, iChannelOut);

                if (channelPosIn == channelPosOut) {
                    float weight = 1;

                    if (pConverter->format == ma_format_f32) {
                        pConverter->weights.f32[iChannelIn][iChannelOut] = weight;
                    } else {
                        pConverter->weights.s16[iChannelIn][iChannelOut] = ma_channel_converter_float_to_fixed(weight);
                    }
                }
            }
        }

        switch (pConverter->mixingMode)
        {
            case ma_channel_mix_mode_custom_weights:
            {
                if (pConfig->ppWeights == NULL) {
                    return MA_INVALID_ARGS; /* Config specified a custom weights mixing mode, but no custom weights have been specified. */
                }

                for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; iChannelIn += 1) {
                    for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; iChannelOut += 1) {
                        float weight = pConfig->ppWeights[iChannelIn][iChannelOut];

                        if (pConverter->format == ma_format_f32) {
                            pConverter->weights.f32[iChannelIn][iChannelOut] = weight;
                        } else {
                            pConverter->weights.s16[iChannelIn][iChannelOut] = ma_channel_converter_float_to_fixed(weight);
                        }
                    }
                }
            } break;

            case ma_channel_mix_mode_simple:
            {
                /*
                In simple mode, only set weights for channels that have exactly matching types, leave the rest at
                zero. The 1:1 mappings have already been covered before this switch statement.
                */
            } break;

            case ma_channel_mix_mode_rectangular:
            default:
            {
                /* Unmapped input channels. */
                for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
                    ma_channel channelPosIn = ma_channel_map_get_channel(pConverter->pChannelMapIn, pConverter->channelsIn, iChannelIn);

                    if (ma_is_spatial_channel_position(channelPosIn)) {
                        if (!ma_channel_map_contains_channel_position(pConverter->channelsOut, pConverter->pChannelMapOut, channelPosIn)) {
                            for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
                                ma_channel channelPosOut = ma_channel_map_get_channel(pConverter->pChannelMapOut, pConverter->channelsOut, iChannelOut);

                                if (ma_is_spatial_channel_position(channelPosOut)) {
                                    float weight = 0;
                                    if (pConverter->mixingMode == ma_channel_mix_mode_rectangular) {
                                        weight = ma_calculate_channel_position_rectangular_weight(channelPosIn, channelPosOut);
                                    }

                                    /* Only apply the weight if we haven't already got some contribution from the respective channels. */
                                    if (pConverter->format == ma_format_f32) {
                                        if (pConverter->weights.f32[iChannelIn][iChannelOut] == 0) {
                                            pConverter->weights.f32[iChannelIn][iChannelOut] = weight;
                                        }
                                    } else {
                                        if (pConverter->weights.s16[iChannelIn][iChannelOut] == 0) {
                                            pConverter->weights.s16[iChannelIn][iChannelOut] = ma_channel_converter_float_to_fixed(weight);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                /* Unmapped output channels. */
                for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
                    ma_channel channelPosOut = ma_channel_map_get_channel(pConverter->pChannelMapOut, pConverter->channelsOut, iChannelOut);

                    if (ma_is_spatial_channel_position(channelPosOut)) {
                        if (!ma_channel_map_contains_channel_position(pConverter->channelsIn, pConverter->pChannelMapIn, channelPosOut)) {
                            for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
                                ma_channel channelPosIn = ma_channel_map_get_channel(pConverter->pChannelMapIn, pConverter->channelsIn, iChannelIn);

                                if (ma_is_spatial_channel_position(channelPosIn)) {
                                    float weight = 0;
                                    if (pConverter->mixingMode == ma_channel_mix_mode_rectangular) {
                                        weight = ma_calculate_channel_position_rectangular_weight(channelPosIn, channelPosOut);
                                    }

                                    /* Only apply the weight if we haven't already got some contribution from the respective channels. */
                                    if (pConverter->format == ma_format_f32) {
                                        if (pConverter->weights.f32[iChannelIn][iChannelOut] == 0) {
                                            pConverter->weights.f32[iChannelIn][iChannelOut] = weight;
                                        }
                                    } else {
                                        if (pConverter->weights.s16[iChannelIn][iChannelOut] == 0) {
                                            pConverter->weights.s16[iChannelIn][iChannelOut] = ma_channel_converter_float_to_fixed(weight);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                /* If LFE is in the output channel map but was not present in the input channel map, configure its weight now */
                if (pConfig->calculateLFEFromSpatialChannels) {
                    if (!ma_channel_map_contains_channel_position(pConverter->channelsIn, pConverter->pChannelMapIn, MA_CHANNEL_LFE)) {
                        ma_uint32 spatialChannelCount = ma_channel_map_get_spatial_channel_count(pConverter->pChannelMapIn, pConverter->channelsIn);
                        ma_uint32 iChannelOutLFE;

                        if (spatialChannelCount > 0 && ma_channel_map_find_channel_position(pConverter->channelsOut, pConverter->pChannelMapOut, MA_CHANNEL_LFE, &iChannelOutLFE)) {
                            const float weightForLFE = 1.0f / spatialChannelCount;
                            for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
                                const ma_channel channelPosIn = ma_channel_map_get_channel(pConverter->pChannelMapIn, pConverter->channelsIn, iChannelIn);
                                if (ma_is_spatial_channel_position(channelPosIn)) {
                                    if (pConverter->format == ma_format_f32) {
                                        if (pConverter->weights.f32[iChannelIn][iChannelOutLFE] == 0) {
                                            pConverter->weights.f32[iChannelIn][iChannelOutLFE] = weightForLFE;
                                        }
                                    } else {
                                        if (pConverter->weights.s16[iChannelIn][iChannelOutLFE] == 0) {
                                            pConverter->weights.s16[iChannelIn][iChannelOutLFE] = ma_channel_converter_float_to_fixed(weightForLFE);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } break;
        }
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_channel_converter_init(const ma_channel_converter_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_channel_converter* pConverter)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_channel_converter_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_channel_converter_init_preallocated(pConfig, pHeap, pConverter);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pConverter->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_channel_converter_uninit(ma_channel_converter* pConverter, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pConverter == NULL) {
        return;
    }

    if (pConverter->_ownsHeap) {
        ma_free(pConverter->_pHeap, pAllocationCallbacks);
    }
}

static ma_result ma_channel_converter_process_pcm_frames__passthrough(ma_channel_converter* pConverter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    MA_ASSERT(pConverter != NULL);
    MA_ASSERT(pFramesOut != NULL);
    MA_ASSERT(pFramesIn  != NULL);

    ma_copy_memory_64(pFramesOut, pFramesIn, frameCount * ma_get_bytes_per_frame(pConverter->format, pConverter->channelsOut));
    return MA_SUCCESS;
}

static ma_result ma_channel_converter_process_pcm_frames__shuffle(ma_channel_converter* pConverter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    MA_ASSERT(pConverter != NULL);
    MA_ASSERT(pFramesOut != NULL);
    MA_ASSERT(pFramesIn  != NULL);
    MA_ASSERT(pConverter->channelsIn == pConverter->channelsOut);

    return ma_channel_map_apply_shuffle_table(pFramesOut, pConverter->channelsOut, pFramesIn, pConverter->channelsIn, frameCount, pConverter->pShuffleTable, pConverter->format);
}

static ma_result ma_channel_converter_process_pcm_frames__mono_in(ma_channel_converter* pConverter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    ma_uint64 iFrame;

    MA_ASSERT(pConverter != NULL);
    MA_ASSERT(pFramesOut != NULL);
    MA_ASSERT(pFramesIn  != NULL);
    MA_ASSERT(pConverter->channelsIn == 1);

    switch (pConverter->format)
    {
        case ma_format_u8:
        {
            /* */ ma_uint8* pFramesOutU8 = (      ma_uint8*)pFramesOut;
            const ma_uint8* pFramesInU8  = (const ma_uint8*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; ++iFrame) {
                ma_uint32 iChannel;
                for (iChannel = 0; iChannel < pConverter->channelsOut; iChannel += 1) {
                    pFramesOutU8[iFrame*pConverter->channelsOut + iChannel] = pFramesInU8[iFrame];
                }
            }
        } break;

        case ma_format_s16:
        {
            /* */ ma_int16* pFramesOutS16 = (      ma_int16*)pFramesOut;
            const ma_int16* pFramesInS16  = (const ma_int16*)pFramesIn;

            if (pConverter->channelsOut == 2) {
                for (iFrame = 0; iFrame < frameCount; ++iFrame) {
                    pFramesOutS16[iFrame*2 + 0] = pFramesInS16[iFrame];
                    pFramesOutS16[iFrame*2 + 1] = pFramesInS16[iFrame];
                }
            } else {
                for (iFrame = 0; iFrame < frameCount; ++iFrame) {
                    ma_uint32 iChannel;
                    for (iChannel = 0; iChannel < pConverter->channelsOut; iChannel += 1) {
                        pFramesOutS16[iFrame*pConverter->channelsOut + iChannel] = pFramesInS16[iFrame];
                    }
                }
            }
        } break;

        case ma_format_s24:
        {
            /* */ ma_uint8* pFramesOutS24 = (      ma_uint8*)pFramesOut;
            const ma_uint8* pFramesInS24  = (const ma_uint8*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; ++iFrame) {
                ma_uint32 iChannel;
                for (iChannel = 0; iChannel < pConverter->channelsOut; iChannel += 1) {
                    ma_uint64 iSampleOut = iFrame*pConverter->channelsOut + iChannel;
                    ma_uint64 iSampleIn  = iFrame;
                    pFramesOutS24[iSampleOut*3 + 0] = pFramesInS24[iSampleIn*3 + 0];
                    pFramesOutS24[iSampleOut*3 + 1] = pFramesInS24[iSampleIn*3 + 1];
                    pFramesOutS24[iSampleOut*3 + 2] = pFramesInS24[iSampleIn*3 + 2];
                }
            }
        } break;

        case ma_format_s32:
        {
            /* */ ma_int32* pFramesOutS32 = (      ma_int32*)pFramesOut;
            const ma_int32* pFramesInS32  = (const ma_int32*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; ++iFrame) {
                ma_uint32 iChannel;
                for (iChannel = 0; iChannel < pConverter->channelsOut; iChannel += 1) {
                    pFramesOutS32[iFrame*pConverter->channelsOut + iChannel] = pFramesInS32[iFrame];
                }
            }
        } break;

        case ma_format_f32:
        {
            /* */ float* pFramesOutF32 = (      float*)pFramesOut;
            const float* pFramesInF32  = (const float*)pFramesIn;

            if (pConverter->channelsOut == 2) {
                for (iFrame = 0; iFrame < frameCount; ++iFrame) {
                    pFramesOutF32[iFrame*2 + 0] = pFramesInF32[iFrame];
                    pFramesOutF32[iFrame*2 + 1] = pFramesInF32[iFrame];
                }
            } else {
                for (iFrame = 0; iFrame < frameCount; ++iFrame) {
                    ma_uint32 iChannel;
                    for (iChannel = 0; iChannel < pConverter->channelsOut; iChannel += 1) {
                        pFramesOutF32[iFrame*pConverter->channelsOut + iChannel] = pFramesInF32[iFrame];
                    }
                }
            }
        } break;

        default: return MA_INVALID_OPERATION;   /* Unknown format. */
    }

    return MA_SUCCESS;
}

static ma_result ma_channel_converter_process_pcm_frames__mono_out(ma_channel_converter* pConverter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    ma_uint64 iFrame;
    ma_uint32 iChannel;

    MA_ASSERT(pConverter != NULL);
    MA_ASSERT(pFramesOut != NULL);
    MA_ASSERT(pFramesIn  != NULL);
    MA_ASSERT(pConverter->channelsOut == 1);

    switch (pConverter->format)
    {
        case ma_format_u8:
        {
            /* */ ma_uint8* pFramesOutU8 = (      ma_uint8*)pFramesOut;
            const ma_uint8* pFramesInU8  = (const ma_uint8*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; ++iFrame) {
                ma_int32 t = 0;
                for (iChannel = 0; iChannel < pConverter->channelsIn; iChannel += 1) {
                    t += ma_pcm_sample_u8_to_s16_no_scale(pFramesInU8[iFrame*pConverter->channelsIn + iChannel]);
                }

                pFramesOutU8[iFrame] = ma_clip_u8(t / pConverter->channelsOut);
            }
        } break;

        case ma_format_s16:
        {
            /* */ ma_int16* pFramesOutS16 = (      ma_int16*)pFramesOut;
            const ma_int16* pFramesInS16  = (const ma_int16*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; ++iFrame) {
                ma_int32 t = 0;
                for (iChannel = 0; iChannel < pConverter->channelsIn; iChannel += 1) {
                    t += pFramesInS16[iFrame*pConverter->channelsIn + iChannel];
                }

                pFramesOutS16[iFrame] = (ma_int16)(t / pConverter->channelsIn);
            }
        } break;

        case ma_format_s24:
        {
            /* */ ma_uint8* pFramesOutS24 = (      ma_uint8*)pFramesOut;
            const ma_uint8* pFramesInS24  = (const ma_uint8*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; ++iFrame) {
                ma_int64 t = 0;
                for (iChannel = 0; iChannel < pConverter->channelsIn; iChannel += 1) {
                    t += ma_pcm_sample_s24_to_s32_no_scale(&pFramesInS24[(iFrame*pConverter->channelsIn + iChannel)*3]);
                }

                ma_pcm_sample_s32_to_s24_no_scale(t / pConverter->channelsIn, &pFramesOutS24[iFrame*3]);
            }
        } break;

        case ma_format_s32:
        {
            /* */ ma_int32* pFramesOutS32 = (      ma_int32*)pFramesOut;
            const ma_int32* pFramesInS32  = (const ma_int32*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; ++iFrame) {
                ma_int64 t = 0;
                for (iChannel = 0; iChannel < pConverter->channelsIn; iChannel += 1) {
                    t += pFramesInS32[iFrame*pConverter->channelsIn + iChannel];
                }

                pFramesOutS32[iFrame] = (ma_int32)(t / pConverter->channelsIn);
            }
        } break;

        case ma_format_f32:
        {
            /* */ float* pFramesOutF32 = (      float*)pFramesOut;
            const float* pFramesInF32  = (const float*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; ++iFrame) {
                float t = 0;
                for (iChannel = 0; iChannel < pConverter->channelsIn; iChannel += 1) {
                    t += pFramesInF32[iFrame*pConverter->channelsIn + iChannel];
                }

                pFramesOutF32[iFrame] = t / pConverter->channelsIn;
            }
        } break;

        default: return MA_INVALID_OPERATION;   /* Unknown format. */
    }

    return MA_SUCCESS;
}

static ma_result ma_channel_converter_process_pcm_frames__weights(ma_channel_converter* pConverter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    ma_uint32 iFrame;
    ma_uint32 iChannelIn;
    ma_uint32 iChannelOut;

    MA_ASSERT(pConverter != NULL);
    MA_ASSERT(pFramesOut != NULL);
    MA_ASSERT(pFramesIn  != NULL);

    /* This is the more complicated case. Each of the output channels is accumulated with 0 or more input channels. */

    /* Clear. */
    ma_zero_memory_64(pFramesOut, frameCount * ma_get_bytes_per_frame(pConverter->format, pConverter->channelsOut));

    /* Accumulate. */
    switch (pConverter->format)
    {
        case ma_format_u8:
        {
            /* */ ma_uint8* pFramesOutU8 = (      ma_uint8*)pFramesOut;
            const ma_uint8* pFramesInU8  = (const ma_uint8*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
                    for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
                        ma_int16 u8_O = ma_pcm_sample_u8_to_s16_no_scale(pFramesOutU8[iFrame*pConverter->channelsOut + iChannelOut]);
                        ma_int16 u8_I = ma_pcm_sample_u8_to_s16_no_scale(pFramesInU8 [iFrame*pConverter->channelsIn  + iChannelIn ]);
                        ma_int32 s    = (ma_int32)ma_clamp(u8_O + ((u8_I * pConverter->weights.s16[iChannelIn][iChannelOut]) >> MA_CHANNEL_CONVERTER_FIXED_POINT_SHIFT), -128, 127);
                        pFramesOutU8[iFrame*pConverter->channelsOut + iChannelOut] = ma_clip_u8((ma_int16)s);
                    }
                }
            }
        } break;

        case ma_format_s16:
        {
            /* */ ma_int16* pFramesOutS16 = (      ma_int16*)pFramesOut;
            const ma_int16* pFramesInS16  = (const ma_int16*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
                    for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
                        ma_int32 s = pFramesOutS16[iFrame*pConverter->channelsOut + iChannelOut];
                        s += (pFramesInS16[iFrame*pConverter->channelsIn + iChannelIn] * pConverter->weights.s16[iChannelIn][iChannelOut]) >> MA_CHANNEL_CONVERTER_FIXED_POINT_SHIFT;

                        pFramesOutS16[iFrame*pConverter->channelsOut + iChannelOut] = (ma_int16)ma_clamp(s, -32768, 32767);
                    }
                }
            }
        } break;

        case ma_format_s24:
        {
            /* */ ma_uint8* pFramesOutS24 = (      ma_uint8*)pFramesOut;
            const ma_uint8* pFramesInS24  = (const ma_uint8*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
                    for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
                        ma_int64 s24_O = ma_pcm_sample_s24_to_s32_no_scale(&pFramesOutS24[(iFrame*pConverter->channelsOut + iChannelOut)*3]);
                        ma_int64 s24_I = ma_pcm_sample_s24_to_s32_no_scale(&pFramesInS24 [(iFrame*pConverter->channelsIn  + iChannelIn )*3]);
                        ma_int64 s24   = (ma_int32)ma_clamp(s24_O + ((s24_I * pConverter->weights.s16[iChannelIn][iChannelOut]) >> MA_CHANNEL_CONVERTER_FIXED_POINT_SHIFT), -8388608, 8388607);
                        ma_pcm_sample_s32_to_s24_no_scale(s24, &pFramesOutS24[(iFrame*pConverter->channelsOut + iChannelOut)*3]);
                    }
                }
            }
        } break;

        case ma_format_s32:
        {
            /* */ ma_int32* pFramesOutS32 = (      ma_int32*)pFramesOut;
            const ma_int32* pFramesInS32  = (const ma_int32*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
                    for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
                        ma_int64 s = pFramesOutS32[iFrame*pConverter->channelsOut + iChannelOut];
                        s += ((ma_int64)pFramesInS32[iFrame*pConverter->channelsIn + iChannelIn] * pConverter->weights.s16[iChannelIn][iChannelOut]) >> MA_CHANNEL_CONVERTER_FIXED_POINT_SHIFT;

                        pFramesOutS32[iFrame*pConverter->channelsOut + iChannelOut] = ma_clip_s32(s);
                    }
                }
            }
        } break;

        case ma_format_f32:
        {
            /* */ float* pFramesOutF32 = (      float*)pFramesOut;
            const float* pFramesInF32  = (const float*)pFramesIn;

            for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
                for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
                    for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
                        pFramesOutF32[iFrame*pConverter->channelsOut + iChannelOut] += pFramesInF32[iFrame*pConverter->channelsIn + iChannelIn] * pConverter->weights.f32[iChannelIn][iChannelOut];
                    }
                }
            }
        } break;

        default: return MA_INVALID_OPERATION;   /* Unknown format. */
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_channel_converter_process_pcm_frames(ma_channel_converter* pConverter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
    if (pConverter == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pFramesOut == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pFramesIn == NULL) {
        ma_zero_memory_64(pFramesOut, frameCount * ma_get_bytes_per_frame(pConverter->format, pConverter->channelsOut));
        return MA_SUCCESS;
    }

    switch (pConverter->conversionPath)
    {
        case ma_channel_conversion_path_passthrough: return ma_channel_converter_process_pcm_frames__passthrough(pConverter, pFramesOut, pFramesIn, frameCount);
        case ma_channel_conversion_path_mono_out:    return ma_channel_converter_process_pcm_frames__mono_out(pConverter, pFramesOut, pFramesIn, frameCount);
        case ma_channel_conversion_path_mono_in:     return ma_channel_converter_process_pcm_frames__mono_in(pConverter, pFramesOut, pFramesIn, frameCount);
        case ma_channel_conversion_path_shuffle:     return ma_channel_converter_process_pcm_frames__shuffle(pConverter, pFramesOut, pFramesIn, frameCount);
        case ma_channel_conversion_path_weights:
        default:
        {
            return ma_channel_converter_process_pcm_frames__weights(pConverter, pFramesOut, pFramesIn, frameCount);
        }
    }
}

MA_API ma_result ma_channel_converter_get_input_channel_map(const ma_channel_converter* pConverter, ma_channel* pChannelMap, size_t channelMapCap)
{
    if (pConverter == NULL || pChannelMap == NULL) {
        return MA_INVALID_ARGS;
    }

    ma_channel_map_copy_or_default(pChannelMap, channelMapCap, pConverter->pChannelMapIn, pConverter->channelsIn);

    return MA_SUCCESS;
}

MA_API ma_result ma_channel_converter_get_output_channel_map(const ma_channel_converter* pConverter, ma_channel* pChannelMap, size_t channelMapCap)
{
    if (pConverter == NULL || pChannelMap == NULL) {
        return MA_INVALID_ARGS;
    }

    ma_channel_map_copy_or_default(pChannelMap, channelMapCap, pConverter->pChannelMapOut, pConverter->channelsOut);

    return MA_SUCCESS;
}


/**************************************************************************************************************************************************************

Data Conversion

**************************************************************************************************************************************************************/
MA_API ma_data_converter_config ma_data_converter_config_init_default(void)
{
    ma_data_converter_config config;
    MA_ZERO_OBJECT(&config);

    config.ditherMode = ma_dither_mode_none;
    config.resampling.algorithm = ma_resample_algorithm_linear;
    config.allowDynamicSampleRate = MA_FALSE; /* Disable dynamic sample rates by default because dynamic rate adjustments should be quite rare and it allows an optimization for cases when the in and out sample rates are the same. */

    /* Linear resampling defaults. */
    config.resampling.linear.lpfOrder = 1;

    return config;
}

MA_API ma_data_converter_config ma_data_converter_config_init(ma_format formatIn, ma_format formatOut, ma_uint32 channelsIn, ma_uint32 channelsOut, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)
{
    ma_data_converter_config config = ma_data_converter_config_init_default();
    config.formatIn      = formatIn;
    config.formatOut     = formatOut;
    config.channelsIn    = channelsIn;
    config.channelsOut   = channelsOut;
    config.sampleRateIn  = sampleRateIn;
    config.sampleRateOut = sampleRateOut;

    return config;
}


typedef struct
{
    size_t sizeInBytes;
    size_t channelConverterOffset;
    size_t resamplerOffset;
} ma_data_converter_heap_layout;

static ma_bool32 ma_data_converter_config_is_resampler_required(const ma_data_converter_config* pConfig)
{
    MA_ASSERT(pConfig != NULL);

    return pConfig->allowDynamicSampleRate || pConfig->sampleRateIn != pConfig->sampleRateOut;
}

static ma_format ma_data_converter_config_get_mid_format(const ma_data_converter_config* pConfig)
{
    MA_ASSERT(pConfig != NULL);

    /*
    We want to avoid as much data conversion as possible. The channel converter and linear
    resampler both support s16 and f32 natively. We need to decide on the format to use for this
    stage. We call this the mid format because it's used in the middle stage of the conversion
    pipeline. If the output format is either s16 or f32 we use that one. If that is not the case it
    will do the same thing for the input format. If it's neither we just use f32. If we are using a
    custom resampling backend, we can only guarantee that f32 will be supported so we'll be forced
    to use that if resampling is required.
    */
    if (ma_data_converter_config_is_resampler_required(pConfig) && pConfig->resampling.algorithm != ma_resample_algorithm_linear) {
        return ma_format_f32;  /* <-- Force f32 since that is the only one we can guarantee will be supported by the resampler. */
    } else {
        /*  */ if (pConfig->formatOut == ma_format_s16 || pConfig->formatOut == ma_format_f32) {
            return pConfig->formatOut;
        } else if (pConfig->formatIn  == ma_format_s16 || pConfig->formatIn  == ma_format_f32) {
            return pConfig->formatIn;
        } else {
            return ma_format_f32;
        }
    }
}

static ma_channel_converter_config ma_channel_converter_config_init_from_data_converter_config(const ma_data_converter_config* pConfig)
{
    ma_channel_converter_config channelConverterConfig;

    MA_ASSERT(pConfig != NULL);

    channelConverterConfig = ma_channel_converter_config_init(ma_data_converter_config_get_mid_format(pConfig), pConfig->channelsIn, pConfig->pChannelMapIn, pConfig->channelsOut, pConfig->pChannelMapOut, pConfig->channelMixMode);
    channelConverterConfig.ppWeights = pConfig->ppChannelWeights;
    channelConverterConfig.calculateLFEFromSpatialChannels = pConfig->calculateLFEFromSpatialChannels;

    return channelConverterConfig;
}

static ma_resampler_config ma_resampler_config_init_from_data_converter_config(const ma_data_converter_config* pConfig)
{
    ma_resampler_config resamplerConfig;
    ma_uint32 resamplerChannels;

    MA_ASSERT(pConfig != NULL);

    /* The resampler is the most expensive part of the conversion process, so we need to do it at the stage where the channel count is at it's lowest. */
    if (pConfig->channelsIn < pConfig->channelsOut) {
        resamplerChannels = pConfig->channelsIn;
    } else {
        resamplerChannels = pConfig->channelsOut;
    }

    resamplerConfig = ma_resampler_config_init(ma_data_converter_config_get_mid_format(pConfig), resamplerChannels, pConfig->sampleRateIn, pConfig->sampleRateOut, pConfig->resampling.algorithm);
    resamplerConfig.linear           = pConfig->resampling.linear;
    resamplerConfig.pBackendVTable   = pConfig->resampling.pBackendVTable;
    resamplerConfig.pBackendUserData = pConfig->resampling.pBackendUserData;

    return resamplerConfig;
}

static ma_result ma_data_converter_get_heap_layout(const ma_data_converter_config* pConfig, ma_data_converter_heap_layout* pHeapLayout)
{
    ma_result result;

    MA_ASSERT(pHeapLayout != NULL);

    MA_ZERO_OBJECT(pHeapLayout);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->channelsIn == 0 || pConfig->channelsOut == 0) {
        return MA_INVALID_ARGS;
    }

    pHeapLayout->sizeInBytes = 0;

    /* Channel converter. */
    pHeapLayout->channelConverterOffset = pHeapLayout->sizeInBytes;
    {
        size_t heapSizeInBytes;
        ma_channel_converter_config channelConverterConfig = ma_channel_converter_config_init_from_data_converter_config(pConfig);

        result = ma_channel_converter_get_heap_size(&channelConverterConfig, &heapSizeInBytes);
        if (result != MA_SUCCESS) {
            return result;
        }

        pHeapLayout->sizeInBytes += heapSizeInBytes;
    }

    /* Resampler. */
    pHeapLayout->resamplerOffset = pHeapLayout->sizeInBytes;
    if (ma_data_converter_config_is_resampler_required(pConfig)) {
        size_t heapSizeInBytes;
        ma_resampler_config resamplerConfig = ma_resampler_config_init_from_data_converter_config(pConfig);

        result = ma_resampler_get_heap_size(&resamplerConfig, &heapSizeInBytes);
        if (result != MA_SUCCESS) {
            return result;
        }

        pHeapLayout->sizeInBytes += heapSizeInBytes;
    }

    /* Make sure allocation size is aligned. */
    pHeapLayout->sizeInBytes = ma_align_64(pHeapLayout->sizeInBytes);

    return MA_SUCCESS;
}

MA_API ma_result ma_data_converter_get_heap_size(const ma_data_converter_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_data_converter_heap_layout heapLayout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = 0;

    result = ma_data_converter_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pHeapSizeInBytes = heapLayout.sizeInBytes;

    return MA_SUCCESS;
}

MA_API ma_result ma_data_converter_init_preallocated(const ma_data_converter_config* pConfig, void* pHeap, ma_data_converter* pConverter)
{
    ma_result result;
    ma_data_converter_heap_layout heapLayout;
    ma_format midFormat;
    ma_bool32 isResamplingRequired;

    if (pConverter == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pConverter);

    result = ma_data_converter_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    pConverter->_pHeap = pHeap;
    MA_ZERO_MEMORY(pHeap, heapLayout.sizeInBytes);

    pConverter->formatIn      = pConfig->formatIn;
    pConverter->formatOut     = pConfig->formatOut;
    pConverter->channelsIn    = pConfig->channelsIn;
    pConverter->channelsOut   = pConfig->channelsOut;
    pConverter->sampleRateIn  = pConfig->sampleRateIn;
    pConverter->sampleRateOut = pConfig->sampleRateOut;
    pConverter->ditherMode    = pConfig->ditherMode;

    /*
    Determine if resampling is required. We need to do this so we can determine an appropriate
    mid format to use. If resampling is required, the mid format must be ma_format_f32 since
    that is the only one that is guaranteed to supported by custom resampling backends.
    */
    isResamplingRequired = ma_data_converter_config_is_resampler_required(pConfig);
    midFormat = ma_data_converter_config_get_mid_format(pConfig);


    /* Channel converter. We always initialize this, but we check if it configures itself as a passthrough to determine whether or not it's needed. */
    {
        ma_channel_converter_config channelConverterConfig = ma_channel_converter_config_init_from_data_converter_config(pConfig);

        result = ma_channel_converter_init_preallocated(&channelConverterConfig, ma_offset_ptr(pHeap, heapLayout.channelConverterOffset), &pConverter->channelConverter);
        if (result != MA_SUCCESS) {
            return result;
        }

        /* If the channel converter is not a passthrough we need to enable it. Otherwise we can skip it. */
        if (pConverter->channelConverter.conversionPath != ma_channel_conversion_path_passthrough) {
            pConverter->hasChannelConverter = MA_TRUE;
        }
    }


    /* Resampler. */
    if (isResamplingRequired) {
        ma_resampler_config resamplerConfig = ma_resampler_config_init_from_data_converter_config(pConfig);

        result = ma_resampler_init_preallocated(&resamplerConfig, ma_offset_ptr(pHeap, heapLayout.resamplerOffset), &pConverter->resampler);
        if (result != MA_SUCCESS) {
            return result;
        }

        pConverter->hasResampler = MA_TRUE;
    }


    /* We can simplify pre- and post-format conversion if we have neither channel conversion nor resampling. */
    if (pConverter->hasChannelConverter == MA_FALSE && pConverter->hasResampler == MA_FALSE) {
        /* We have neither channel conversion nor resampling so we'll only need one of pre- or post-format conversion, or none if the input and output formats are the same. */
        if (pConverter->formatIn == pConverter->formatOut) {
            /* The formats are the same so we can just pass through. */
            pConverter->hasPreFormatConversion  = MA_FALSE;
            pConverter->hasPostFormatConversion = MA_FALSE;
        } else {
            /* The formats are different so we need to do either pre- or post-format conversion. It doesn't matter which. */
            pConverter->hasPreFormatConversion  = MA_FALSE;
            pConverter->hasPostFormatConversion = MA_TRUE;
        }
    } else {
        /* We have a channel converter and/or resampler so we'll need channel conversion based on the mid format. */
        if (pConverter->formatIn != midFormat) {
            pConverter->hasPreFormatConversion  = MA_TRUE;
        }
        if (pConverter->formatOut != midFormat) {
            pConverter->hasPostFormatConversion = MA_TRUE;
        }
    }

    /* We can enable passthrough optimizations if applicable. Note that we'll only be able to do this if the sample rate is static. */
    if (pConverter->hasPreFormatConversion  == MA_FALSE &&
        pConverter->hasPostFormatConversion == MA_FALSE &&
        pConverter->hasChannelConverter     == MA_FALSE &&
        pConverter->hasResampler            == MA_FALSE) {
        pConverter->isPassthrough = MA_TRUE;
    }


    /* We now need to determine our execution path. */
    if (pConverter->isPassthrough) {
        pConverter->executionPath = ma_data_converter_execution_path_passthrough;
    } else {
        if (pConverter->channelsIn < pConverter->channelsOut) {
            /* Do resampling first, if necessary. */
            MA_ASSERT(pConverter->hasChannelConverter == MA_TRUE);

            if (pConverter->hasResampler) {
                pConverter->executionPath = ma_data_converter_execution_path_resample_first;
            } else {
                pConverter->executionPath = ma_data_converter_execution_path_channels_only;
            }
        } else {
            /* Do channel conversion first, if necessary. */
            if (pConverter->hasChannelConverter) {
                if (pConverter->hasResampler) {
                    pConverter->executionPath = ma_data_converter_execution_path_channels_first;
                } else {
                    pConverter->executionPath = ma_data_converter_execution_path_channels_only;
                }
            } else {
                /* Channel routing not required. */
                if (pConverter->hasResampler) {
                    pConverter->executionPath = ma_data_converter_execution_path_resample_only;
                } else {
                    pConverter->executionPath = ma_data_converter_execution_path_format_only;
                }
            }
        }
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_data_converter_init(const ma_data_converter_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_data_converter* pConverter)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_data_converter_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_data_converter_init_preallocated(pConfig, pHeap, pConverter);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pConverter->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_data_converter_uninit(ma_data_converter* pConverter, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pConverter == NULL) {
        return;
    }

    if (pConverter->hasResampler) {
        ma_resampler_uninit(&pConverter->resampler, pAllocationCallbacks);
    }

    ma_channel_converter_uninit(&pConverter->channelConverter, pAllocationCallbacks);

    if (pConverter->_ownsHeap) {
        ma_free(pConverter->_pHeap, pAllocationCallbacks);
    }
}

static ma_result ma_data_converter_process_pcm_frames__passthrough(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    ma_uint64 frameCountIn;
    ma_uint64 frameCountOut;
    ma_uint64 frameCount;

    MA_ASSERT(pConverter != NULL);

    frameCountIn = 0;
    if (pFrameCountIn != NULL) {
        frameCountIn = *pFrameCountIn;
    }

    frameCountOut = 0;
    if (pFrameCountOut != NULL) {
        frameCountOut = *pFrameCountOut;
    }

    frameCount = ma_min(frameCountIn, frameCountOut);

    if (pFramesOut != NULL) {
        if (pFramesIn != NULL) {
            ma_copy_memory_64(pFramesOut, pFramesIn, frameCount * ma_get_bytes_per_frame(pConverter->formatOut, pConverter->channelsOut));
        } else {
            ma_zero_memory_64(pFramesOut,            frameCount * ma_get_bytes_per_frame(pConverter->formatOut, pConverter->channelsOut));
        }
    }

    if (pFrameCountIn != NULL) {
        *pFrameCountIn = frameCount;
    }
    if (pFrameCountOut != NULL) {
        *pFrameCountOut = frameCount;
    }

    return MA_SUCCESS;
}

static ma_result ma_data_converter_process_pcm_frames__format_only(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    ma_uint64 frameCountIn;
    ma_uint64 frameCountOut;
    ma_uint64 frameCount;

    MA_ASSERT(pConverter != NULL);

    frameCountIn = 0;
    if (pFrameCountIn != NULL) {
        frameCountIn = *pFrameCountIn;
    }

    frameCountOut = 0;
    if (pFrameCountOut != NULL) {
        frameCountOut = *pFrameCountOut;
    }

    frameCount = ma_min(frameCountIn, frameCountOut);

    if (pFramesOut != NULL) {
        if (pFramesIn != NULL) {
            ma_convert_pcm_frames_format(pFramesOut, pConverter->formatOut, pFramesIn, pConverter->formatIn, frameCount, pConverter->channelsIn, pConverter->ditherMode);
        } else {
            ma_zero_memory_64(pFramesOut, frameCount * ma_get_bytes_per_frame(pConverter->formatOut, pConverter->channelsOut));
        }
    }

    if (pFrameCountIn != NULL) {
        *pFrameCountIn = frameCount;
    }
    if (pFrameCountOut != NULL) {
        *pFrameCountOut = frameCount;
    }

    return MA_SUCCESS;
}


static ma_result ma_data_converter_process_pcm_frames__resample_with_format_conversion(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    ma_result result = MA_SUCCESS;
    ma_uint64 frameCountIn;
    ma_uint64 frameCountOut;
    ma_uint64 framesProcessedIn;
    ma_uint64 framesProcessedOut;

    MA_ASSERT(pConverter != NULL);

    frameCountIn = 0;
    if (pFrameCountIn != NULL) {
        frameCountIn = *pFrameCountIn;
    }

    frameCountOut = 0;
    if (pFrameCountOut != NULL) {
        frameCountOut = *pFrameCountOut;
    }

    framesProcessedIn  = 0;
    framesProcessedOut = 0;

    while (framesProcessedOut < frameCountOut) {
        ma_uint8 pTempBufferOut[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
        const ma_uint32 tempBufferOutCap = sizeof(pTempBufferOut) / ma_get_bytes_per_frame(pConverter->resampler.format, pConverter->resampler.channels);
        const void* pFramesInThisIteration;
        /* */ void* pFramesOutThisIteration;
        ma_uint64 frameCountInThisIteration;
        ma_uint64 frameCountOutThisIteration;

        if (pFramesIn != NULL) {
            pFramesInThisIteration = ma_offset_ptr(pFramesIn, framesProcessedIn * ma_get_bytes_per_frame(pConverter->formatIn, pConverter->channelsIn));
        } else {
            pFramesInThisIteration = NULL;
        }

        if (pFramesOut != NULL) {
            pFramesOutThisIteration = ma_offset_ptr(pFramesOut, framesProcessedOut * ma_get_bytes_per_frame(pConverter->formatOut, pConverter->channelsOut));
        } else {
            pFramesOutThisIteration = NULL;
        }

        /* Do a pre format conversion if necessary. */
        if (pConverter->hasPreFormatConversion) {
            ma_uint8 pTempBufferIn[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
            const ma_uint32 tempBufferInCap = sizeof(pTempBufferIn) / ma_get_bytes_per_frame(pConverter->resampler.format, pConverter->resampler.channels);

            frameCountInThisIteration  = (frameCountIn - framesProcessedIn);
            if (frameCountInThisIteration > tempBufferInCap) {
                frameCountInThisIteration = tempBufferInCap;
            }

            if (pConverter->hasPostFormatConversion) {
               if (frameCountInThisIteration > tempBufferOutCap) {
                   frameCountInThisIteration = tempBufferOutCap;
               }
            }

            if (pFramesInThisIteration != NULL) {
                ma_convert_pcm_frames_format(pTempBufferIn, pConverter->resampler.format, pFramesInThisIteration, pConverter->formatIn, frameCountInThisIteration, pConverter->channelsIn, pConverter->ditherMode);
            } else {
                MA_ZERO_MEMORY(pTempBufferIn, sizeof(pTempBufferIn));
            }

            frameCountOutThisIteration = (frameCountOut - framesProcessedOut);

            if (pConverter->hasPostFormatConversion) {
                /* Both input and output conversion required. Output to the temp buffer. */
                if (frameCountOutThisIteration > tempBufferOutCap) {
                    frameCountOutThisIteration = tempBufferOutCap;
                }

                result = ma_resampler_process_pcm_frames(&pConverter->resampler, pTempBufferIn, &frameCountInThisIteration, pTempBufferOut, &frameCountOutThisIteration);
            } else {
                /* Only pre-format required. Output straight to the output buffer. */
                result = ma_resampler_process_pcm_frames(&pConverter->resampler, pTempBufferIn, &frameCountInThisIteration, pFramesOutThisIteration, &frameCountOutThisIteration);
            }

            if (result != MA_SUCCESS) {
                break;
            }
        } else {
            /* No pre-format required. Just read straight from the input buffer. */
            MA_ASSERT(pConverter->hasPostFormatConversion == MA_TRUE);

            frameCountInThisIteration  = (frameCountIn  - framesProcessedIn);
            frameCountOutThisIteration = (frameCountOut - framesProcessedOut);
            if (frameCountOutThisIteration > tempBufferOutCap) {
                frameCountOutThisIteration = tempBufferOutCap;
            }

            result = ma_resampler_process_pcm_frames(&pConverter->resampler, pFramesInThisIteration, &frameCountInThisIteration, pTempBufferOut, &frameCountOutThisIteration);
            if (result != MA_SUCCESS) {
                break;
            }
        }

        /* If we are doing a post format conversion we need to do that now. */
        if (pConverter->hasPostFormatConversion) {
            if (pFramesOutThisIteration != NULL) {
                ma_convert_pcm_frames_format(pFramesOutThisIteration, pConverter->formatOut, pTempBufferOut, pConverter->resampler.format, frameCountOutThisIteration, pConverter->resampler.channels, pConverter->ditherMode);
            }
        }

        framesProcessedIn  += frameCountInThisIteration;
        framesProcessedOut += frameCountOutThisIteration;

        MA_ASSERT(framesProcessedIn  <= frameCountIn);
        MA_ASSERT(framesProcessedOut <= frameCountOut);

        if (frameCountOutThisIteration == 0) {
            break;  /* Consumed all of our input data. */
        }
    }

    if (pFrameCountIn != NULL) {
        *pFrameCountIn = framesProcessedIn;
    }
    if (pFrameCountOut != NULL) {
        *pFrameCountOut = framesProcessedOut;
    }

    return result;
}

static ma_result ma_data_converter_process_pcm_frames__resample_only(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    MA_ASSERT(pConverter != NULL);

    if (pConverter->hasPreFormatConversion == MA_FALSE && pConverter->hasPostFormatConversion == MA_FALSE) {
        /* Neither pre- nor post-format required. This is simple case where only resampling is required. */
        return ma_resampler_process_pcm_frames(&pConverter->resampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
    } else {
        /* Format conversion required. */
        return ma_data_converter_process_pcm_frames__resample_with_format_conversion(pConverter, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
    }
}

static ma_result ma_data_converter_process_pcm_frames__channels_only(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    ma_result result;
    ma_uint64 frameCountIn;
    ma_uint64 frameCountOut;
    ma_uint64 frameCount;

    MA_ASSERT(pConverter != NULL);

    frameCountIn = 0;
    if (pFrameCountIn != NULL) {
        frameCountIn = *pFrameCountIn;
    }

    frameCountOut = 0;
    if (pFrameCountOut != NULL) {
        frameCountOut = *pFrameCountOut;
    }

    frameCount = ma_min(frameCountIn, frameCountOut);

    if (pConverter->hasPreFormatConversion == MA_FALSE && pConverter->hasPostFormatConversion == MA_FALSE) {
        /* No format conversion required. */
        result = ma_channel_converter_process_pcm_frames(&pConverter->channelConverter, pFramesOut, pFramesIn, frameCount);
        if (result != MA_SUCCESS) {
            return result;
        }
    } else {
        /* Format conversion required. */
        ma_uint64 framesProcessed = 0;

        while (framesProcessed < frameCount) {
            ma_uint8 pTempBufferOut[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
            const ma_uint32 tempBufferOutCap = sizeof(pTempBufferOut) / ma_get_bytes_per_frame(pConverter->channelConverter.format, pConverter->channelConverter.channelsOut);
            const void* pFramesInThisIteration;
            /* */ void* pFramesOutThisIteration;
            ma_uint64 frameCountThisIteration;

            if (pFramesIn != NULL) {
                pFramesInThisIteration = ma_offset_ptr(pFramesIn, framesProcessed * ma_get_bytes_per_frame(pConverter->formatIn, pConverter->channelsIn));
            } else {
                pFramesInThisIteration = NULL;
            }

            if (pFramesOut != NULL) {
                pFramesOutThisIteration = ma_offset_ptr(pFramesOut, framesProcessed * ma_get_bytes_per_frame(pConverter->formatOut, pConverter->channelsOut));
            } else {
                pFramesOutThisIteration = NULL;
            }

            /* Do a pre format conversion if necessary. */
            if (pConverter->hasPreFormatConversion) {
                ma_uint8 pTempBufferIn[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
                const ma_uint32 tempBufferInCap = sizeof(pTempBufferIn) / ma_get_bytes_per_frame(pConverter->channelConverter.format, pConverter->channelConverter.channelsIn);

                frameCountThisIteration = (frameCount - framesProcessed);
                if (frameCountThisIteration > tempBufferInCap) {
                    frameCountThisIteration = tempBufferInCap;
                }

                if (pConverter->hasPostFormatConversion) {
                    if (frameCountThisIteration > tempBufferOutCap) {
                        frameCountThisIteration = tempBufferOutCap;
                    }
                }

                if (pFramesInThisIteration != NULL) {
                    ma_convert_pcm_frames_format(pTempBufferIn, pConverter->channelConverter.format, pFramesInThisIteration, pConverter->formatIn, frameCountThisIteration, pConverter->channelsIn, pConverter->ditherMode);
                } else {
                    MA_ZERO_MEMORY(pTempBufferIn, sizeof(pTempBufferIn));
                }

                if (pConverter->hasPostFormatConversion) {
                    /* Both input and output conversion required. Output to the temp buffer. */
                    result = ma_channel_converter_process_pcm_frames(&pConverter->channelConverter, pTempBufferOut, pTempBufferIn, frameCountThisIteration);
                } else {
                    /* Only pre-format required. Output straight to the output buffer. */
                    result = ma_channel_converter_process_pcm_frames(&pConverter->channelConverter, pFramesOutThisIteration, pTempBufferIn, frameCountThisIteration);
                }

                if (result != MA_SUCCESS) {
                    break;
                }
            } else {
                /* No pre-format required. Just read straight from the input buffer. */
                MA_ASSERT(pConverter->hasPostFormatConversion == MA_TRUE);

                frameCountThisIteration = (frameCount - framesProcessed);
                if (frameCountThisIteration > tempBufferOutCap) {
                    frameCountThisIteration = tempBufferOutCap;
                }

                result = ma_channel_converter_process_pcm_frames(&pConverter->channelConverter, pTempBufferOut, pFramesInThisIteration, frameCountThisIteration);
                if (result != MA_SUCCESS) {
                    break;
                }
            }

            /* If we are doing a post format conversion we need to do that now. */
            if (pConverter->hasPostFormatConversion) {
                if (pFramesOutThisIteration != NULL) {
                    ma_convert_pcm_frames_format(pFramesOutThisIteration, pConverter->formatOut, pTempBufferOut, pConverter->channelConverter.format, frameCountThisIteration, pConverter->channelConverter.channelsOut, pConverter->ditherMode);
                }
            }

            framesProcessed += frameCountThisIteration;
        }
    }

    if (pFrameCountIn != NULL) {
        *pFrameCountIn = frameCount;
    }
    if (pFrameCountOut != NULL) {
        *pFrameCountOut = frameCount;
    }

    return MA_SUCCESS;
}

static ma_result ma_data_converter_process_pcm_frames__resample_first(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    ma_result result;
    ma_uint64 frameCountIn;
    ma_uint64 frameCountOut;
    ma_uint64 framesProcessedIn;
    ma_uint64 framesProcessedOut;
    ma_uint8  pTempBufferIn[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];   /* In resampler format. */
    ma_uint64 tempBufferInCap;
    ma_uint8  pTempBufferMid[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];  /* In resampler format, channel converter input format. */
    ma_uint64 tempBufferMidCap;
    ma_uint8  pTempBufferOut[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];  /* In channel converter output format. */
    ma_uint64 tempBufferOutCap;

    MA_ASSERT(pConverter != NULL);
    MA_ASSERT(pConverter->resampler.format   == pConverter->channelConverter.format);
    MA_ASSERT(pConverter->resampler.channels == pConverter->channelConverter.channelsIn);
    MA_ASSERT(pConverter->resampler.channels <  pConverter->channelConverter.channelsOut);

    frameCountIn = 0;
    if (pFrameCountIn != NULL) {
        frameCountIn = *pFrameCountIn;
    }

    frameCountOut = 0;
    if (pFrameCountOut != NULL) {
        frameCountOut = *pFrameCountOut;
    }

    framesProcessedIn  = 0;
    framesProcessedOut = 0;

    tempBufferInCap  = sizeof(pTempBufferIn)  / ma_get_bytes_per_frame(pConverter->resampler.format, pConverter->resampler.channels);
    tempBufferMidCap = sizeof(pTempBufferIn)  / ma_get_bytes_per_frame(pConverter->resampler.format, pConverter->resampler.channels);
    tempBufferOutCap = sizeof(pTempBufferOut) / ma_get_bytes_per_frame(pConverter->channelConverter.format, pConverter->channelConverter.channelsOut);

    while (framesProcessedOut < frameCountOut) {
        ma_uint64 frameCountInThisIteration;
        ma_uint64 frameCountOutThisIteration;
        const void* pRunningFramesIn = NULL;
        void* pRunningFramesOut = NULL;
        const void* pResampleBufferIn;
        void* pChannelsBufferOut;

        if (pFramesIn != NULL) {
            pRunningFramesIn  = ma_offset_ptr(pFramesIn,  framesProcessedIn  * ma_get_bytes_per_frame(pConverter->formatIn, pConverter->channelsIn));
        }
        if (pFramesOut != NULL) {
            pRunningFramesOut = ma_offset_ptr(pFramesOut, framesProcessedOut * ma_get_bytes_per_frame(pConverter->formatOut, pConverter->channelsOut));
        }

        /* Run input data through the resampler and output it to the temporary buffer. */
        frameCountInThisIteration = (frameCountIn - framesProcessedIn);

        if (pConverter->hasPreFormatConversion) {
            if (frameCountInThisIteration > tempBufferInCap) {
                frameCountInThisIteration = tempBufferInCap;
            }
        }

        frameCountOutThisIteration = (frameCountOut - framesProcessedOut);
        if (frameCountOutThisIteration > tempBufferMidCap) {
            frameCountOutThisIteration = tempBufferMidCap;
        }

        /* We can't read more frames than can fit in the output buffer. */
        if (pConverter->hasPostFormatConversion) {
            if (frameCountOutThisIteration > tempBufferOutCap) {
                frameCountOutThisIteration = tempBufferOutCap;
            }
        }

        /* We need to ensure we don't try to process too many input frames that we run out of room in the output buffer. If this happens we'll end up glitching. */

        /*
        We need to try to predict how many input frames will be required for the resampler. If the
        resampler can tell us, we'll use that. Otherwise we'll need to make a best guess. The further
        off we are from this, the more wasted format conversions we'll end up doing.
        */
        #if 1
        {
            ma_uint64 requiredInputFrameCount;

            result = ma_resampler_get_required_input_frame_count(&pConverter->resampler, frameCountOutThisIteration, &requiredInputFrameCount);
            if (result != MA_SUCCESS) {
                /* Fall back to a best guess. */
                requiredInputFrameCount = (frameCountOutThisIteration * pConverter->resampler.sampleRateIn) / pConverter->resampler.sampleRateOut;
            }

            if (frameCountInThisIteration > requiredInputFrameCount) {
                frameCountInThisIteration = requiredInputFrameCount;
            }
        }
        #endif

        if (pConverter->hasPreFormatConversion) {
            if (pFramesIn != NULL) {
                ma_convert_pcm_frames_format(pTempBufferIn, pConverter->resampler.format, pRunningFramesIn, pConverter->formatIn, frameCountInThisIteration, pConverter->channelsIn, pConverter->ditherMode);
                pResampleBufferIn = pTempBufferIn;
            } else {
                pResampleBufferIn = NULL;
            }
        } else {
            pResampleBufferIn = pRunningFramesIn;
        }

        result = ma_resampler_process_pcm_frames(&pConverter->resampler, pResampleBufferIn, &frameCountInThisIteration, pTempBufferMid, &frameCountOutThisIteration);
        if (result != MA_SUCCESS) {
            return result;
        }


        /*
        The input data has been resampled so now we need to run it through the channel converter. The input data is always contained in pTempBufferMid. We only need to do
        this part if we have an output buffer.
        */
        if (pFramesOut != NULL) {
            if (pConverter->hasPostFormatConversion) {
                pChannelsBufferOut = pTempBufferOut;
            } else {
                pChannelsBufferOut = pRunningFramesOut;
            }

            result = ma_channel_converter_process_pcm_frames(&pConverter->channelConverter, pChannelsBufferOut, pTempBufferMid, frameCountOutThisIteration);
            if (result != MA_SUCCESS) {
                return result;
            }

            /* Finally we do post format conversion. */
            if (pConverter->hasPostFormatConversion) {
                ma_convert_pcm_frames_format(pRunningFramesOut, pConverter->formatOut, pChannelsBufferOut, pConverter->channelConverter.format, frameCountOutThisIteration, pConverter->channelConverter.channelsOut, pConverter->ditherMode);
            }
        }


        framesProcessedIn  += frameCountInThisIteration;
        framesProcessedOut += frameCountOutThisIteration;

        MA_ASSERT(framesProcessedIn  <= frameCountIn);
        MA_ASSERT(framesProcessedOut <= frameCountOut);

        if (frameCountOutThisIteration == 0) {
            break;  /* Consumed all of our input data. */
        }
    }

    if (pFrameCountIn != NULL) {
        *pFrameCountIn = framesProcessedIn;
    }
    if (pFrameCountOut != NULL) {
        *pFrameCountOut = framesProcessedOut;
    }

    return MA_SUCCESS;
}

static ma_result ma_data_converter_process_pcm_frames__channels_first(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    ma_result result;
    ma_uint64 frameCountIn;
    ma_uint64 frameCountOut;
    ma_uint64 framesProcessedIn;
    ma_uint64 framesProcessedOut;
    ma_uint8  pTempBufferIn[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];   /* In resampler format. */
    ma_uint64 tempBufferInCap;
    ma_uint8  pTempBufferMid[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];  /* In resampler format, channel converter input format. */
    ma_uint64 tempBufferMidCap;
    ma_uint8  pTempBufferOut[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];  /* In channel converter output format. */
    ma_uint64 tempBufferOutCap;

    MA_ASSERT(pConverter != NULL);
    MA_ASSERT(pConverter->resampler.format   == pConverter->channelConverter.format);
    MA_ASSERT(pConverter->resampler.channels == pConverter->channelConverter.channelsOut);
    MA_ASSERT(pConverter->resampler.channels <= pConverter->channelConverter.channelsIn);

    frameCountIn = 0;
    if (pFrameCountIn != NULL) {
        frameCountIn = *pFrameCountIn;
    }

    frameCountOut = 0;
    if (pFrameCountOut != NULL) {
        frameCountOut = *pFrameCountOut;
    }

    framesProcessedIn  = 0;
    framesProcessedOut = 0;

    tempBufferInCap  = sizeof(pTempBufferIn)  / ma_get_bytes_per_frame(pConverter->channelConverter.format, pConverter->channelConverter.channelsIn);
    tempBufferMidCap = sizeof(pTempBufferIn)  / ma_get_bytes_per_frame(pConverter->channelConverter.format, pConverter->channelConverter.channelsOut);
    tempBufferOutCap = sizeof(pTempBufferOut) / ma_get_bytes_per_frame(pConverter->resampler.format, pConverter->resampler.channels);

    while (framesProcessedOut < frameCountOut) {
        ma_uint64 frameCountInThisIteration;
        ma_uint64 frameCountOutThisIteration;
        const void* pRunningFramesIn = NULL;
        void* pRunningFramesOut = NULL;
        const void* pChannelsBufferIn;
        void* pResampleBufferOut;

        if (pFramesIn != NULL) {
            pRunningFramesIn  = ma_offset_ptr(pFramesIn,  framesProcessedIn  * ma_get_bytes_per_frame(pConverter->formatIn, pConverter->channelsIn));
        }
        if (pFramesOut != NULL) {
            pRunningFramesOut = ma_offset_ptr(pFramesOut, framesProcessedOut * ma_get_bytes_per_frame(pConverter->formatOut, pConverter->channelsOut));
        }

        /*
        Before doing any processing we need to determine how many frames we should try processing
        this iteration, for both input and output. The resampler requires us to perform format and
        channel conversion before passing any data into it. If we get our input count wrong, we'll
        end up performing redundant pre-processing. This isn't the end of the world, but it does
        result in some inefficiencies proportionate to how far our estimates are off.

        If the resampler has a means to calculate exactly how much we'll need, we'll use that.
        Otherwise we'll make a best guess. In order to do this, we'll need to calculate the output
        frame count first.
        */
        frameCountOutThisIteration = (frameCountOut - framesProcessedOut);
        if (frameCountOutThisIteration > tempBufferMidCap) {
            frameCountOutThisIteration = tempBufferMidCap;
        }

        if (pConverter->hasPostFormatConversion) {
            if (frameCountOutThisIteration > tempBufferOutCap) {
                frameCountOutThisIteration = tempBufferOutCap;
            }
        }

        /* Now that we have the output frame count we can determine the input frame count. */
        frameCountInThisIteration = (frameCountIn - framesProcessedIn);
        if (pConverter->hasPreFormatConversion) {
            if (frameCountInThisIteration > tempBufferInCap) {
                frameCountInThisIteration = tempBufferInCap;
            }
        }

        if (frameCountInThisIteration > tempBufferMidCap) {
            frameCountInThisIteration = tempBufferMidCap;
        }

        #if 1
        {
            ma_uint64 requiredInputFrameCount;

            result = ma_resampler_get_required_input_frame_count(&pConverter->resampler, frameCountOutThisIteration, &requiredInputFrameCount);
            if (result != MA_SUCCESS) {
                /* Fall back to a best guess. */
                requiredInputFrameCount = (frameCountOutThisIteration * pConverter->resampler.sampleRateIn) / pConverter->resampler.sampleRateOut;
            }

            if (frameCountInThisIteration > requiredInputFrameCount) {
                frameCountInThisIteration = requiredInputFrameCount;
            }
        }
        #endif


        /* Pre format conversion. */
        if (pConverter->hasPreFormatConversion) {
            if (pRunningFramesIn != NULL) {
                ma_convert_pcm_frames_format(pTempBufferIn, pConverter->channelConverter.format, pRunningFramesIn, pConverter->formatIn, frameCountInThisIteration, pConverter->channelsIn, pConverter->ditherMode);
                pChannelsBufferIn = pTempBufferIn;
            } else {
                pChannelsBufferIn = NULL;
            }
        } else {
            pChannelsBufferIn = pRunningFramesIn;
        }


        /* Channel conversion. */
        result = ma_channel_converter_process_pcm_frames(&pConverter->channelConverter, pTempBufferMid, pChannelsBufferIn, frameCountInThisIteration);
        if (result != MA_SUCCESS) {
            return result;
        }


        /* Resampling. */
        if (pConverter->hasPostFormatConversion) {
            pResampleBufferOut = pTempBufferOut;
        } else {
            pResampleBufferOut = pRunningFramesOut;
        }

        result = ma_resampler_process_pcm_frames(&pConverter->resampler, pTempBufferMid, &frameCountInThisIteration, pResampleBufferOut, &frameCountOutThisIteration);
        if (result != MA_SUCCESS) {
            return result;
        }


        /* Post format conversion. */
        if (pConverter->hasPostFormatConversion) {
            if (pRunningFramesOut != NULL) {
                ma_convert_pcm_frames_format(pRunningFramesOut, pConverter->formatOut, pResampleBufferOut, pConverter->resampler.format, frameCountOutThisIteration, pConverter->channelsOut, pConverter->ditherMode);
            }
        }


        framesProcessedIn  += frameCountInThisIteration;
        framesProcessedOut += frameCountOutThisIteration;

        MA_ASSERT(framesProcessedIn  <= frameCountIn);
        MA_ASSERT(framesProcessedOut <= frameCountOut);

        if (frameCountOutThisIteration == 0) {
            break;  /* Consumed all of our input data. */
        }
    }

    if (pFrameCountIn != NULL) {
        *pFrameCountIn = framesProcessedIn;
    }
    if (pFrameCountOut != NULL) {
        *pFrameCountOut = framesProcessedOut;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_data_converter_process_pcm_frames(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
    if (pConverter == NULL) {
        return MA_INVALID_ARGS;
    }

    switch (pConverter->executionPath)
    {
        case ma_data_converter_execution_path_passthrough:    return ma_data_converter_process_pcm_frames__passthrough(pConverter, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
        case ma_data_converter_execution_path_format_only:    return ma_data_converter_process_pcm_frames__format_only(pConverter, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
        case ma_data_converter_execution_path_channels_only:  return ma_data_converter_process_pcm_frames__channels_only(pConverter, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
        case ma_data_converter_execution_path_resample_only:  return ma_data_converter_process_pcm_frames__resample_only(pConverter, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
        case ma_data_converter_execution_path_resample_first: return ma_data_converter_process_pcm_frames__resample_first(pConverter, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
        case ma_data_converter_execution_path_channels_first: return ma_data_converter_process_pcm_frames__channels_first(pConverter, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
        default: return MA_INVALID_OPERATION;   /* Should never hit this. */
    }
}

MA_API ma_result ma_data_converter_set_rate(ma_data_converter* pConverter, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)
{
    if (pConverter == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConverter->hasResampler == MA_FALSE) {
        return MA_INVALID_OPERATION;    /* Dynamic resampling not enabled. */
    }

    return ma_resampler_set_rate(&pConverter->resampler, sampleRateIn, sampleRateOut);
}

MA_API ma_result ma_data_converter_set_rate_ratio(ma_data_converter* pConverter, float ratioInOut)
{
    if (pConverter == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConverter->hasResampler == MA_FALSE) {
        return MA_INVALID_OPERATION;    /* Dynamic resampling not enabled. */
    }

    return ma_resampler_set_rate_ratio(&pConverter->resampler, ratioInOut);
}

MA_API ma_uint64 ma_data_converter_get_input_latency(const ma_data_converter* pConverter)
{
    if (pConverter == NULL) {
        return 0;
    }

    if (pConverter->hasResampler) {
        return ma_resampler_get_input_latency(&pConverter->resampler);
    }

    return 0;   /* No latency without a resampler. */
}

MA_API ma_uint64 ma_data_converter_get_output_latency(const ma_data_converter* pConverter)
{
    if (pConverter == NULL) {
        return 0;
    }

    if (pConverter->hasResampler) {
        return ma_resampler_get_output_latency(&pConverter->resampler);
    }

    return 0;   /* No latency without a resampler. */
}

MA_API ma_result ma_data_converter_get_required_input_frame_count(const ma_data_converter* pConverter, ma_uint64 outputFrameCount, ma_uint64* pInputFrameCount)
{
    if (pInputFrameCount == NULL) {
        return MA_INVALID_ARGS;
    }

    *pInputFrameCount = 0;

    if (pConverter == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConverter->hasResampler) {
        return ma_resampler_get_required_input_frame_count(&pConverter->resampler, outputFrameCount, pInputFrameCount);
    } else {
        *pInputFrameCount = outputFrameCount;   /* 1:1 */
        return MA_SUCCESS;
    }
}

MA_API ma_result ma_data_converter_get_expected_output_frame_count(const ma_data_converter* pConverter, ma_uint64 inputFrameCount, ma_uint64* pOutputFrameCount)
{
    if (pOutputFrameCount == NULL) {
        return MA_INVALID_ARGS;
    }

    *pOutputFrameCount = 0;

    if (pConverter == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConverter->hasResampler) {
        return ma_resampler_get_expected_output_frame_count(&pConverter->resampler, inputFrameCount, pOutputFrameCount);
    } else {
        *pOutputFrameCount = inputFrameCount;   /* 1:1 */
        return MA_SUCCESS;
    }
}

MA_API ma_result ma_data_converter_get_input_channel_map(const ma_data_converter* pConverter, ma_channel* pChannelMap, size_t channelMapCap)
{
    if (pConverter == NULL || pChannelMap == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConverter->hasChannelConverter) {
        ma_channel_converter_get_output_channel_map(&pConverter->channelConverter, pChannelMap, channelMapCap);
    } else {
        ma_channel_map_init_standard(ma_standard_channel_map_default, pChannelMap, channelMapCap, pConverter->channelsOut);
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_data_converter_get_output_channel_map(const ma_data_converter* pConverter, ma_channel* pChannelMap, size_t channelMapCap)
{
    if (pConverter == NULL || pChannelMap == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConverter->hasChannelConverter) {
        ma_channel_converter_get_input_channel_map(&pConverter->channelConverter, pChannelMap, channelMapCap);
    } else {
        ma_channel_map_init_standard(ma_standard_channel_map_default, pChannelMap, channelMapCap, pConverter->channelsIn);
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_data_converter_reset(ma_data_converter* pConverter)
{
    if (pConverter == NULL) {
        return MA_INVALID_ARGS;
    }

    /* There's nothing to do if we're not resampling. */
    if (pConverter->hasResampler == MA_FALSE) {
        return MA_SUCCESS;
    }

    return ma_resampler_reset(&pConverter->resampler);
}



/**************************************************************************************************************************************************************

Channel Maps

**************************************************************************************************************************************************************/
static ma_channel ma_channel_map_init_standard_channel(ma_standard_channel_map standardChannelMap, ma_uint32 channelCount, ma_uint32 channelIndex);

MA_API ma_channel ma_channel_map_get_channel(const ma_channel* pChannelMap, ma_uint32 channelCount, ma_uint32 channelIndex)
{
    if (pChannelMap == NULL) {
        return ma_channel_map_init_standard_channel(ma_standard_channel_map_default, channelCount, channelIndex);
    } else {
        if (channelIndex >= channelCount) {
            return MA_CHANNEL_NONE;
        }

        return pChannelMap[channelIndex];
    }
}

MA_API void ma_channel_map_init_blank(ma_channel* pChannelMap, ma_uint32 channels)
{
    if (pChannelMap == NULL) {
        return;
    }

    MA_ZERO_MEMORY(pChannelMap, sizeof(*pChannelMap) * channels);
}


static ma_channel ma_channel_map_init_standard_channel_microsoft(ma_uint32 channelCount, ma_uint32 channelIndex)
{
    if (channelCount == 0 || channelIndex >= channelCount) {
        return MA_CHANNEL_NONE;
    }

    /* This is the Microsoft channel map. Based off the speaker configurations mentioned here: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ksmedia/ns-ksmedia-ksaudio_channel_config */
    switch (channelCount)
    {
        case 0: return MA_CHANNEL_NONE;

        case 1:
        {
            return MA_CHANNEL_MONO;
        } break;

        case 2:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
            }
        } break;

        case 3: /* No defined, but best guess. */
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
            }
        } break;

        case 4:
        {
            switch (channelIndex) {
            #ifndef MA_USE_QUAD_MICROSOFT_CHANNEL_MAP
                /* Surround. Using the Surround profile has the advantage of the 3rd channel (MA_CHANNEL_FRONT_CENTER) mapping nicely with higher channel counts. */
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
                case 3: return MA_CHANNEL_BACK_CENTER;
            #else
                /* Quad. */
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_BACK_LEFT;
                case 3: return MA_CHANNEL_BACK_RIGHT;
            #endif
            }
        } break;

        case 5: /* Not defined, but best guess. */
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
                case 3: return MA_CHANNEL_BACK_LEFT;
                case 4: return MA_CHANNEL_BACK_RIGHT;
            }
        } break;

        case 6:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
                case 3: return MA_CHANNEL_LFE;
                case 4: return MA_CHANNEL_SIDE_LEFT;
                case 5: return MA_CHANNEL_SIDE_RIGHT;
            }
        } break;

        case 7: /* Not defined, but best guess. */
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
                case 3: return MA_CHANNEL_LFE;
                case 4: return MA_CHANNEL_BACK_CENTER;
                case 5: return MA_CHANNEL_SIDE_LEFT;
                case 6: return MA_CHANNEL_SIDE_RIGHT;
            }
        } break;

        case 8:
        default:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
                case 3: return MA_CHANNEL_LFE;
                case 4: return MA_CHANNEL_BACK_LEFT;
                case 5: return MA_CHANNEL_BACK_RIGHT;
                case 6: return MA_CHANNEL_SIDE_LEFT;
                case 7: return MA_CHANNEL_SIDE_RIGHT;
            }
        } break;
    }

    if (channelCount > 8) {
        if (channelIndex < 32) {    /* We have 32 AUX channels. */
            return (ma_channel)(MA_CHANNEL_AUX_0 + (channelIndex - 8));
        }
    }

    /* Getting here means we don't know how to map the channel position so just return MA_CHANNEL_NONE. */
    return MA_CHANNEL_NONE;
}

static ma_channel ma_channel_map_init_standard_channel_alsa(ma_uint32 channelCount, ma_uint32 channelIndex)
{
    switch (channelCount)
    {
        case 0: return MA_CHANNEL_NONE;

        case 1:
        {
            return MA_CHANNEL_MONO;
        } break;

        case 2:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
            }
        } break;

        case 3:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
            }
        } break;

        case 4:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_BACK_LEFT;
                case 3: return MA_CHANNEL_BACK_RIGHT;
            }
        } break;

        case 5:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_BACK_LEFT;
                case 3: return MA_CHANNEL_BACK_RIGHT;
                case 4: return MA_CHANNEL_FRONT_CENTER;
            }
        } break;

        case 6:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_BACK_LEFT;
                case 3: return MA_CHANNEL_BACK_RIGHT;
                case 4: return MA_CHANNEL_FRONT_CENTER;
                case 5: return MA_CHANNEL_LFE;
            }
        } break;

        case 7:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_BACK_LEFT;
                case 3: return MA_CHANNEL_BACK_RIGHT;
                case 4: return MA_CHANNEL_FRONT_CENTER;
                case 5: return MA_CHANNEL_LFE;
                case 6: return MA_CHANNEL_BACK_CENTER;
            }
        } break;

        case 8:
        default:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_BACK_LEFT;
                case 3: return MA_CHANNEL_BACK_RIGHT;
                case 4: return MA_CHANNEL_FRONT_CENTER;
                case 5: return MA_CHANNEL_LFE;
                case 6: return MA_CHANNEL_SIDE_LEFT;
                case 7: return MA_CHANNEL_SIDE_RIGHT;
            }
        } break;
    }

    if (channelCount > 8) {
        if (channelIndex < 32) {    /* We have 32 AUX channels. */
            return (ma_channel)(MA_CHANNEL_AUX_0 + (channelIndex - 8));
        }
    }

    /* Getting here means we don't know how to map the channel position so just return MA_CHANNEL_NONE. */
    return MA_CHANNEL_NONE;
}

static ma_channel ma_channel_map_init_standard_channel_rfc3551(ma_uint32 channelCount, ma_uint32 channelIndex)
{
    switch (channelCount)
    {
        case 0: return MA_CHANNEL_NONE;

        case 1:
        {
            return MA_CHANNEL_MONO;
        } break;

        case 2:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
            }
        } break;

        case 3:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
            }
        } break;

        case 4:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 3: return MA_CHANNEL_BACK_CENTER;
            }
        } break;

        case 5:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
                case 3: return MA_CHANNEL_BACK_LEFT;
                case 4: return MA_CHANNEL_BACK_RIGHT;
            }
        } break;

        case 6:
        default:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_SIDE_LEFT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
                case 3: return MA_CHANNEL_FRONT_RIGHT;
                case 4: return MA_CHANNEL_SIDE_RIGHT;
                case 5: return MA_CHANNEL_BACK_CENTER;
            }
        } break;
    }

    if (channelCount > 6) {
        if (channelIndex < 32) {    /* We have 32 AUX channels. */
            return (ma_channel)(MA_CHANNEL_AUX_0 + (channelIndex - 6));
        }
    }

    /* Getting here means we don't know how to map the channel position so just return MA_CHANNEL_NONE. */
    return MA_CHANNEL_NONE;
}

static ma_channel ma_channel_map_init_standard_channel_flac(ma_uint32 channelCount, ma_uint32 channelIndex)
{
    switch (channelCount)
    {
        case 0: return MA_CHANNEL_NONE;

        case 1:
        {
            return MA_CHANNEL_MONO;
        } break;

        case 2:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
            }
        } break;

        case 3:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
            }
        } break;

        case 4:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_BACK_LEFT;
                case 3: return MA_CHANNEL_BACK_RIGHT;
            }
        } break;

        case 5:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
                case 3: return MA_CHANNEL_BACK_LEFT;
                case 4: return MA_CHANNEL_BACK_RIGHT;
            }
        } break;

        case 6:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
                case 3: return MA_CHANNEL_LFE;
                case 4: return MA_CHANNEL_BACK_LEFT;
                case 5: return MA_CHANNEL_BACK_RIGHT;
            }
        } break;

        case 7:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
                case 3: return MA_CHANNEL_LFE;
                case 4: return MA_CHANNEL_BACK_CENTER;
                case 5: return MA_CHANNEL_SIDE_LEFT;
                case 6: return MA_CHANNEL_SIDE_RIGHT;
            }
        } break;

        case 8:
        default:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
                case 3: return MA_CHANNEL_LFE;
                case 4: return MA_CHANNEL_BACK_LEFT;
                case 5: return MA_CHANNEL_BACK_RIGHT;
                case 6: return MA_CHANNEL_SIDE_LEFT;
                case 7: return MA_CHANNEL_SIDE_RIGHT;
            }
        } break;
    }

    if (channelCount > 8) {
        if (channelIndex < 32) {    /* We have 32 AUX channels. */
            return (ma_channel)(MA_CHANNEL_AUX_0 + (channelIndex - 8));
        }
    }

    /* Getting here means we don't know how to map the channel position so just return MA_CHANNEL_NONE. */
    return MA_CHANNEL_NONE;
}

static ma_channel ma_channel_map_init_standard_channel_vorbis(ma_uint32 channelCount, ma_uint32 channelIndex)
{
    switch (channelCount)
    {
        case 0: return MA_CHANNEL_NONE;

        case 1:
        {
            return MA_CHANNEL_MONO;
        } break;

        case 2:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
            }
        } break;

        case 3:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_CENTER;
                case 2: return MA_CHANNEL_FRONT_RIGHT;
            }
        } break;

        case 4:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_BACK_LEFT;
                case 3: return MA_CHANNEL_BACK_RIGHT;
            }
        } break;

        case 5:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_CENTER;
                case 2: return MA_CHANNEL_FRONT_RIGHT;
                case 3: return MA_CHANNEL_BACK_LEFT;
                case 4: return MA_CHANNEL_BACK_RIGHT;
            }
        } break;

        case 6:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_CENTER;
                case 2: return MA_CHANNEL_FRONT_RIGHT;
                case 3: return MA_CHANNEL_BACK_LEFT;
                case 4: return MA_CHANNEL_BACK_RIGHT;
                case 5: return MA_CHANNEL_LFE;
            }
        } break;

        case 7:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_CENTER;
                case 2: return MA_CHANNEL_FRONT_RIGHT;
                case 3: return MA_CHANNEL_SIDE_LEFT;
                case 4: return MA_CHANNEL_SIDE_RIGHT;
                case 5: return MA_CHANNEL_BACK_CENTER;
                case 6: return MA_CHANNEL_LFE;
            }
        } break;

        case 8:
        default:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_CENTER;
                case 2: return MA_CHANNEL_FRONT_RIGHT;
                case 3: return MA_CHANNEL_SIDE_LEFT;
                case 4: return MA_CHANNEL_SIDE_RIGHT;
                case 5: return MA_CHANNEL_BACK_LEFT;
                case 6: return MA_CHANNEL_BACK_RIGHT;
                case 7: return MA_CHANNEL_LFE;
            }
        } break;
    }

    if (channelCount > 8) {
        if (channelIndex < 32) {    /* We have 32 AUX channels. */
            return (ma_channel)(MA_CHANNEL_AUX_0 + (channelIndex - 8));
        }
    }

    /* Getting here means we don't know how to map the channel position so just return MA_CHANNEL_NONE. */
    return MA_CHANNEL_NONE;
}

static ma_channel ma_channel_map_init_standard_channel_sound4(ma_uint32 channelCount, ma_uint32 channelIndex)
{
    switch (channelCount)
    {
        case 0: return MA_CHANNEL_NONE;

        case 1:
        {
            return MA_CHANNEL_MONO;
        } break;

        case 2:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
            }
        } break;

        case 3:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
            }
        } break;

        case 4:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_BACK_LEFT;
                case 3: return MA_CHANNEL_BACK_RIGHT;
            }
        } break;

        case 5:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
                case 3: return MA_CHANNEL_BACK_LEFT;
                case 4: return MA_CHANNEL_BACK_RIGHT;
            }
        } break;

        case 6:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_CENTER;
                case 2: return MA_CHANNEL_FRONT_RIGHT;
                case 3: return MA_CHANNEL_BACK_LEFT;
                case 4: return MA_CHANNEL_BACK_RIGHT;
                case 5: return MA_CHANNEL_LFE;
            }
        } break;

        case 7:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_CENTER;
                case 2: return MA_CHANNEL_FRONT_RIGHT;
                case 3: return MA_CHANNEL_SIDE_LEFT;
                case 4: return MA_CHANNEL_SIDE_RIGHT;
                case 5: return MA_CHANNEL_BACK_CENTER;
                case 6: return MA_CHANNEL_LFE;
            }
        } break;

        case 8:
        default:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_CENTER;
                case 2: return MA_CHANNEL_FRONT_RIGHT;
                case 3: return MA_CHANNEL_SIDE_LEFT;
                case 4: return MA_CHANNEL_SIDE_RIGHT;
                case 5: return MA_CHANNEL_BACK_LEFT;
                case 6: return MA_CHANNEL_BACK_RIGHT;
                case 7: return MA_CHANNEL_LFE;
            }
        } break;
    }

    if (channelCount > 8) {
        if (channelIndex < 32) {    /* We have 32 AUX channels. */
            return (ma_channel)(MA_CHANNEL_AUX_0 + (channelIndex - 8));
        }
    }

    /* Getting here means we don't know how to map the channel position so just return MA_CHANNEL_NONE. */
    return MA_CHANNEL_NONE;
}

static ma_channel ma_channel_map_init_standard_channel_sndio(ma_uint32 channelCount, ma_uint32 channelIndex)
{
    switch (channelCount)
    {
        case 0: return MA_CHANNEL_NONE;

        case 1:
        {
            return MA_CHANNEL_MONO;
        } break;

        case 2:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
            }
        } break;

        case 3: /* No defined, but best guess. */
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_FRONT_CENTER;
            }
        } break;

        case 4:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_BACK_LEFT;
                case 3: return MA_CHANNEL_BACK_RIGHT;
            }
        } break;

        case 5: /* Not defined, but best guess. */
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_BACK_LEFT;
                case 3: return MA_CHANNEL_BACK_RIGHT;
                case 4: return MA_CHANNEL_FRONT_CENTER;
            }
        } break;

        case 6:
        default:
        {
            switch (channelIndex) {
                case 0: return MA_CHANNEL_FRONT_LEFT;
                case 1: return MA_CHANNEL_FRONT_RIGHT;
                case 2: return MA_CHANNEL_BACK_LEFT;
                case 3: return MA_CHANNEL_BACK_RIGHT;
                case 4: return MA_CHANNEL_FRONT_CENTER;
                case 5: return MA_CHANNEL_LFE;
            }
        } break;
    }

    if (channelCount > 6) {
        if (channelIndex < 32) {    /* We have 32 AUX channels. */
            return (ma_channel)(MA_CHANNEL_AUX_0 + (channelIndex - 6));
        }
    }

    /* Getting here means we don't know how to map the channel position so just return MA_CHANNEL_NONE. */
    return MA_CHANNEL_NONE;
}


static ma_channel ma_channel_map_init_standard_channel(ma_standard_channel_map standardChannelMap, ma_uint32 channelCount, ma_uint32 channelIndex)
{
    if (channelCount == 0 || channelIndex >= channelCount) {
        return MA_CHANNEL_NONE;
    }

    switch (standardChannelMap)
    {
        case ma_standard_channel_map_alsa:
        {
            return ma_channel_map_init_standard_channel_alsa(channelCount, channelIndex);
        } break;

        case ma_standard_channel_map_rfc3551:
        {
            return ma_channel_map_init_standard_channel_rfc3551(channelCount, channelIndex);
        } break;

        case ma_standard_channel_map_flac:
        {
            return ma_channel_map_init_standard_channel_flac(channelCount, channelIndex);
        } break;

        case ma_standard_channel_map_vorbis:
        {
            return ma_channel_map_init_standard_channel_vorbis(channelCount, channelIndex);
        } break;

        case ma_standard_channel_map_sound4:
        {
            return ma_channel_map_init_standard_channel_sound4(channelCount, channelIndex);
        } break;

        case ma_standard_channel_map_sndio:
        {
            return ma_channel_map_init_standard_channel_sndio(channelCount, channelIndex);
        } break;

        case ma_standard_channel_map_microsoft: /* Also default. */
        /*case ma_standard_channel_map_default;*/
        default:
        {
            return ma_channel_map_init_standard_channel_microsoft(channelCount, channelIndex);
        } break;
    }
}

MA_API void ma_channel_map_init_standard(ma_standard_channel_map standardChannelMap, ma_channel* pChannelMap, size_t channelMapCap, ma_uint32 channels)
{
    ma_uint32 iChannel;

    if (pChannelMap == NULL || channelMapCap == 0 || channels == 0) {
        return;
    }

    for (iChannel = 0; iChannel < channels; iChannel += 1) {
        if (channelMapCap == 0) {
            break;  /* Ran out of room. */
        }

        pChannelMap[0] = ma_channel_map_init_standard_channel(standardChannelMap, channels, iChannel);
        pChannelMap   += 1;
        channelMapCap -= 1;
    }
}

MA_API void ma_channel_map_copy(ma_channel* pOut, const ma_channel* pIn, ma_uint32 channels)
{
    if (pOut != NULL && pIn != NULL && channels > 0) {
        MA_COPY_MEMORY(pOut, pIn, sizeof(*pOut) * channels);
    }
}

MA_API void ma_channel_map_copy_or_default(ma_channel* pOut, size_t channelMapCapOut, const ma_channel* pIn, ma_uint32 channels)
{
    if (pOut == NULL || channels == 0) {
        return;
    }

    if (pIn != NULL) {
        ma_channel_map_copy(pOut, pIn, channels);
    } else {
        ma_channel_map_init_standard(ma_standard_channel_map_default, pOut, channelMapCapOut, channels);
    }
}

MA_API ma_bool32 ma_channel_map_is_valid(const ma_channel* pChannelMap, ma_uint32 channels)
{
    /* A channel count of 0 is invalid. */
    if (channels == 0) {
        return MA_FALSE;
    }

    /* It does not make sense to have a mono channel when there is more than 1 channel. */
    if (channels > 1) {
        ma_uint32 iChannel;
        for (iChannel = 0; iChannel < channels; ++iChannel) {
            if (ma_channel_map_get_channel(pChannelMap, channels, iChannel) == MA_CHANNEL_MONO) {
                return MA_FALSE;
            }
        }
    }

    return MA_TRUE;
}

MA_API ma_bool32 ma_channel_map_is_equal(const ma_channel* pChannelMapA, const ma_channel* pChannelMapB, ma_uint32 channels)
{
    ma_uint32 iChannel;

    if (pChannelMapA == pChannelMapB) {
        return MA_TRUE;
    }

    for (iChannel = 0; iChannel < channels; ++iChannel) {
        if (ma_channel_map_get_channel(pChannelMapA, channels, iChannel) != ma_channel_map_get_channel(pChannelMapB, channels, iChannel)) {
            return MA_FALSE;
        }
    }

    return MA_TRUE;
}

MA_API ma_bool32 ma_channel_map_is_blank(const ma_channel* pChannelMap, ma_uint32 channels)
{
    ma_uint32 iChannel;

    /* A null channel map is equivalent to the default channel map. */
    if (pChannelMap == NULL) {
        return MA_FALSE;
    }

    for (iChannel = 0; iChannel < channels; ++iChannel) {
        if (pChannelMap[iChannel] != MA_CHANNEL_NONE) {
            return MA_FALSE;
        }
    }

    return MA_TRUE;
}

MA_API ma_bool32 ma_channel_map_contains_channel_position(ma_uint32 channels, const ma_channel* pChannelMap, ma_channel channelPosition)
{
    return ma_channel_map_find_channel_position(channels, pChannelMap, channelPosition, NULL);
}

MA_API ma_bool32 ma_channel_map_find_channel_position(ma_uint32 channels, const ma_channel* pChannelMap, ma_channel channelPosition, ma_uint32* pChannelIndex)
{
    ma_uint32 iChannel;

    if (pChannelIndex != NULL) {
        *pChannelIndex = (ma_uint32)-1;
    }

    for (iChannel = 0; iChannel < channels; ++iChannel) {
        if (ma_channel_map_get_channel(pChannelMap, channels, iChannel) == channelPosition) {
            if (pChannelIndex != NULL) {
                *pChannelIndex = iChannel;
            }

            return MA_TRUE;
        }
    }

    /* Getting here means the channel position was not found. */
    return MA_FALSE;
}

MA_API size_t ma_channel_map_to_string(const ma_channel* pChannelMap, ma_uint32 channels, char* pBufferOut, size_t bufferCap)
{
    size_t len;
    ma_uint32 iChannel;

    len = 0;

    for (iChannel = 0; iChannel < channels; iChannel += 1) {
        const char* pChannelStr = ma_channel_position_to_string(ma_channel_map_get_channel(pChannelMap, channels, iChannel));
        size_t channelStrLen = strlen(pChannelStr);

        /* Append the string if necessary. */
        if (pBufferOut != NULL && bufferCap > len + channelStrLen) {
            MA_COPY_MEMORY(pBufferOut + len, pChannelStr, channelStrLen);
        }
        len += channelStrLen;

        /* Append a space if it's not the last item. */
        if (iChannel+1 < channels) {
            if (pBufferOut != NULL && bufferCap > len + 1) {
                pBufferOut[len] = ' ';
            }
            len += 1;
        }
    }

    /* Null terminate. Don't increment the length here. */
    if (pBufferOut != NULL && bufferCap > len + 1) {
        pBufferOut[len] = '\0';
    }

    return len;
}

MA_API const char* ma_channel_position_to_string(ma_channel channel)
{
    switch (channel)
    {
        case MA_CHANNEL_NONE              : return "CHANNEL_NONE";
        case MA_CHANNEL_MONO              : return "CHANNEL_MONO";
        case MA_CHANNEL_FRONT_LEFT        : return "CHANNEL_FRONT_LEFT";
        case MA_CHANNEL_FRONT_RIGHT       : return "CHANNEL_FRONT_RIGHT";
        case MA_CHANNEL_FRONT_CENTER      : return "CHANNEL_FRONT_CENTER";
        case MA_CHANNEL_LFE               : return "CHANNEL_LFE";
        case MA_CHANNEL_BACK_LEFT         : return "CHANNEL_BACK_LEFT";
        case MA_CHANNEL_BACK_RIGHT        : return "CHANNEL_BACK_RIGHT";
        case MA_CHANNEL_FRONT_LEFT_CENTER : return "CHANNEL_FRONT_LEFT_CENTER";
        case MA_CHANNEL_FRONT_RIGHT_CENTER: return "CHANNEL_FRONT_RIGHT_CENTER";
        case MA_CHANNEL_BACK_CENTER       : return "CHANNEL_BACK_CENTER";
        case MA_CHANNEL_SIDE_LEFT         : return "CHANNEL_SIDE_LEFT";
        case MA_CHANNEL_SIDE_RIGHT        : return "CHANNEL_SIDE_RIGHT";
        case MA_CHANNEL_TOP_CENTER        : return "CHANNEL_TOP_CENTER";
        case MA_CHANNEL_TOP_FRONT_LEFT    : return "CHANNEL_TOP_FRONT_LEFT";
        case MA_CHANNEL_TOP_FRONT_CENTER  : return "CHANNEL_TOP_FRONT_CENTER";
        case MA_CHANNEL_TOP_FRONT_RIGHT   : return "CHANNEL_TOP_FRONT_RIGHT";
        case MA_CHANNEL_TOP_BACK_LEFT     : return "CHANNEL_TOP_BACK_LEFT";
        case MA_CHANNEL_TOP_BACK_CENTER   : return "CHANNEL_TOP_BACK_CENTER";
        case MA_CHANNEL_TOP_BACK_RIGHT    : return "CHANNEL_TOP_BACK_RIGHT";
        case MA_CHANNEL_AUX_0             : return "CHANNEL_AUX_0";
        case MA_CHANNEL_AUX_1             : return "CHANNEL_AUX_1";
        case MA_CHANNEL_AUX_2             : return "CHANNEL_AUX_2";
        case MA_CHANNEL_AUX_3             : return "CHANNEL_AUX_3";
        case MA_CHANNEL_AUX_4             : return "CHANNEL_AUX_4";
        case MA_CHANNEL_AUX_5             : return "CHANNEL_AUX_5";
        case MA_CHANNEL_AUX_6             : return "CHANNEL_AUX_6";
        case MA_CHANNEL_AUX_7             : return "CHANNEL_AUX_7";
        case MA_CHANNEL_AUX_8             : return "CHANNEL_AUX_8";
        case MA_CHANNEL_AUX_9             : return "CHANNEL_AUX_9";
        case MA_CHANNEL_AUX_10            : return "CHANNEL_AUX_10";
        case MA_CHANNEL_AUX_11            : return "CHANNEL_AUX_11";
        case MA_CHANNEL_AUX_12            : return "CHANNEL_AUX_12";
        case MA_CHANNEL_AUX_13            : return "CHANNEL_AUX_13";
        case MA_CHANNEL_AUX_14            : return "CHANNEL_AUX_14";
        case MA_CHANNEL_AUX_15            : return "CHANNEL_AUX_15";
        case MA_CHANNEL_AUX_16            : return "CHANNEL_AUX_16";
        case MA_CHANNEL_AUX_17            : return "CHANNEL_AUX_17";
        case MA_CHANNEL_AUX_18            : return "CHANNEL_AUX_18";
        case MA_CHANNEL_AUX_19            : return "CHANNEL_AUX_19";
        case MA_CHANNEL_AUX_20            : return "CHANNEL_AUX_20";
        case MA_CHANNEL_AUX_21            : return "CHANNEL_AUX_21";
        case MA_CHANNEL_AUX_22            : return "CHANNEL_AUX_22";
        case MA_CHANNEL_AUX_23            : return "CHANNEL_AUX_23";
        case MA_CHANNEL_AUX_24            : return "CHANNEL_AUX_24";
        case MA_CHANNEL_AUX_25            : return "CHANNEL_AUX_25";
        case MA_CHANNEL_AUX_26            : return "CHANNEL_AUX_26";
        case MA_CHANNEL_AUX_27            : return "CHANNEL_AUX_27";
        case MA_CHANNEL_AUX_28            : return "CHANNEL_AUX_28";
        case MA_CHANNEL_AUX_29            : return "CHANNEL_AUX_29";
        case MA_CHANNEL_AUX_30            : return "CHANNEL_AUX_30";
        case MA_CHANNEL_AUX_31            : return "CHANNEL_AUX_31";
        default: break;
    }

    return "UNKNOWN";
}



/**************************************************************************************************************************************************************

Conversion Helpers

**************************************************************************************************************************************************************/
MA_API ma_uint64 ma_convert_frames(void* pOut, ma_uint64 frameCountOut, ma_format formatOut, ma_uint32 channelsOut, ma_uint32 sampleRateOut, const void* pIn, ma_uint64 frameCountIn, ma_format formatIn, ma_uint32 channelsIn, ma_uint32 sampleRateIn)
{
    ma_data_converter_config config;

    config = ma_data_converter_config_init(formatIn, formatOut, channelsIn, channelsOut, sampleRateIn, sampleRateOut);
    config.resampling.linear.lpfOrder = ma_min(MA_DEFAULT_RESAMPLER_LPF_ORDER, MA_MAX_FILTER_ORDER);

    return ma_convert_frames_ex(pOut, frameCountOut, pIn, frameCountIn, &config);
}

MA_API ma_uint64 ma_convert_frames_ex(void* pOut, ma_uint64 frameCountOut, const void* pIn, ma_uint64 frameCountIn, const ma_data_converter_config* pConfig)
{
    ma_result result;
    ma_data_converter converter;

    if (frameCountIn == 0 || pConfig == NULL) {
        return 0;
    }

    result = ma_data_converter_init(pConfig, NULL, &converter);
    if (result != MA_SUCCESS) {
        return 0;   /* Failed to initialize the data converter. */
    }

    if (pOut == NULL) {
        result = ma_data_converter_get_expected_output_frame_count(&converter, frameCountIn, &frameCountOut);
        if (result != MA_SUCCESS) {
            if (result == MA_NOT_IMPLEMENTED) {
                /* No way to calculate the number of frames, so we'll need to brute force it and loop. */
                frameCountOut = 0;

                while (frameCountIn > 0) {
                    ma_uint64 framesProcessedIn  = frameCountIn;
                    ma_uint64 framesProcessedOut = 0xFFFFFFFF;

                    result = ma_data_converter_process_pcm_frames(&converter, pIn, &framesProcessedIn, NULL, &framesProcessedOut);
                    if (result != MA_SUCCESS) {
                        break;
                    }

                    frameCountIn  -= framesProcessedIn;
                }
            }
        }
    } else {
        result = ma_data_converter_process_pcm_frames(&converter, pIn, &frameCountIn, pOut, &frameCountOut);
        if (result != MA_SUCCESS) {
            frameCountOut = 0;
        }
    }

    ma_data_converter_uninit(&converter, NULL);
    return frameCountOut;
}


/**************************************************************************************************************************************************************

Ring Buffer

**************************************************************************************************************************************************************/
static MA_INLINE ma_uint32 ma_rb__extract_offset_in_bytes(ma_uint32 encodedOffset)
{
    return encodedOffset & 0x7FFFFFFF;
}

static MA_INLINE ma_uint32 ma_rb__extract_offset_loop_flag(ma_uint32 encodedOffset)
{
    return encodedOffset & 0x80000000;
}

static MA_INLINE void* ma_rb__get_read_ptr(ma_rb* pRB)
{
    MA_ASSERT(pRB != NULL);
    return ma_offset_ptr(pRB->pBuffer, ma_rb__extract_offset_in_bytes(ma_atomic_load_32(&pRB->encodedReadOffset)));
}

static MA_INLINE void* ma_rb__get_write_ptr(ma_rb* pRB)
{
    MA_ASSERT(pRB != NULL);
    return ma_offset_ptr(pRB->pBuffer, ma_rb__extract_offset_in_bytes(ma_atomic_load_32(&pRB->encodedWriteOffset)));
}

static MA_INLINE ma_uint32 ma_rb__construct_offset(ma_uint32 offsetInBytes, ma_uint32 offsetLoopFlag)
{
    return offsetLoopFlag | offsetInBytes;
}

static MA_INLINE void ma_rb__deconstruct_offset(ma_uint32 encodedOffset, ma_uint32* pOffsetInBytes, ma_uint32* pOffsetLoopFlag)
{
    MA_ASSERT(pOffsetInBytes != NULL);
    MA_ASSERT(pOffsetLoopFlag != NULL);

    *pOffsetInBytes  = ma_rb__extract_offset_in_bytes(encodedOffset);
    *pOffsetLoopFlag = ma_rb__extract_offset_loop_flag(encodedOffset);
}


MA_API ma_result ma_rb_init_ex(size_t subbufferSizeInBytes, size_t subbufferCount, size_t subbufferStrideInBytes, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_rb* pRB)
{
    ma_result result;
    const ma_uint32 maxSubBufferSize = 0x7FFFFFFF - (MA_SIMD_ALIGNMENT-1);

    if (pRB == NULL) {
        return MA_INVALID_ARGS;
    }

    if (subbufferSizeInBytes == 0 || subbufferCount == 0) {
        return MA_INVALID_ARGS;
    }

    if (subbufferSizeInBytes > maxSubBufferSize) {
        return MA_INVALID_ARGS;    /* Maximum buffer size is ~2GB. The most significant bit is a flag for use internally. */
    }


    MA_ZERO_OBJECT(pRB);

    result = ma_allocation_callbacks_init_copy(&pRB->allocationCallbacks, pAllocationCallbacks);
    if (result != MA_SUCCESS) {
        return result;
    }

    pRB->subbufferSizeInBytes = (ma_uint32)subbufferSizeInBytes;
    pRB->subbufferCount = (ma_uint32)subbufferCount;

    if (pOptionalPreallocatedBuffer != NULL) {
        pRB->subbufferStrideInBytes = (ma_uint32)subbufferStrideInBytes;
        pRB->pBuffer = pOptionalPreallocatedBuffer;
    } else {
        size_t bufferSizeInBytes;

        /*
        Here is where we allocate our own buffer. We always want to align this to MA_SIMD_ALIGNMENT for future SIMD optimization opportunity. To do this
        we need to make sure the stride is a multiple of MA_SIMD_ALIGNMENT.
        */
        pRB->subbufferStrideInBytes = (pRB->subbufferSizeInBytes + (MA_SIMD_ALIGNMENT-1)) & ~MA_SIMD_ALIGNMENT;

        bufferSizeInBytes = (size_t)pRB->subbufferCount*pRB->subbufferStrideInBytes;
        pRB->pBuffer = ma_aligned_malloc(bufferSizeInBytes, MA_SIMD_ALIGNMENT, &pRB->allocationCallbacks);
        if (pRB->pBuffer == NULL) {
            return MA_OUT_OF_MEMORY;
        }

        MA_ZERO_MEMORY(pRB->pBuffer, bufferSizeInBytes);
        pRB->ownsBuffer = MA_TRUE;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_rb_init(size_t bufferSizeInBytes, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_rb* pRB)
{
    return ma_rb_init_ex(bufferSizeInBytes, 1, 0, pOptionalPreallocatedBuffer, pAllocationCallbacks, pRB);
}

MA_API void ma_rb_uninit(ma_rb* pRB)
{
    if (pRB == NULL) {
        return;
    }

    if (pRB->ownsBuffer) {
        ma_aligned_free(pRB->pBuffer, &pRB->allocationCallbacks);
    }
}

MA_API void ma_rb_reset(ma_rb* pRB)
{
    if (pRB == NULL) {
        return;
    }

    ma_atomic_exchange_32(&pRB->encodedReadOffset, 0);
    ma_atomic_exchange_32(&pRB->encodedWriteOffset, 0);
}

MA_API ma_result ma_rb_acquire_read(ma_rb* pRB, size_t* pSizeInBytes, void** ppBufferOut)
{
    ma_uint32 writeOffset;
    ma_uint32 writeOffsetInBytes;
    ma_uint32 writeOffsetLoopFlag;
    ma_uint32 readOffset;
    ma_uint32 readOffsetInBytes;
    ma_uint32 readOffsetLoopFlag;
    size_t bytesAvailable;
    size_t bytesRequested;

    if (pRB == NULL || pSizeInBytes == NULL || ppBufferOut == NULL) {
        return MA_INVALID_ARGS;
    }

    /* The returned buffer should never move ahead of the write pointer. */
    writeOffset = ma_atomic_load_32(&pRB->encodedWriteOffset);
    ma_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

    readOffset = ma_atomic_load_32(&pRB->encodedReadOffset);
    ma_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

    /*
    The number of bytes available depends on whether or not the read and write pointers are on the same loop iteration. If so, we
    can only read up to the write pointer. If not, we can only read up to the end of the buffer.
    */
    if (readOffsetLoopFlag == writeOffsetLoopFlag) {
        bytesAvailable = writeOffsetInBytes - readOffsetInBytes;
    } else {
        bytesAvailable = pRB->subbufferSizeInBytes - readOffsetInBytes;
    }

    bytesRequested = *pSizeInBytes;
    if (bytesRequested > bytesAvailable) {
        bytesRequested = bytesAvailable;
    }

    *pSizeInBytes = bytesRequested;
    (*ppBufferOut) = ma_rb__get_read_ptr(pRB);

    return MA_SUCCESS;
}

MA_API ma_result ma_rb_commit_read(ma_rb* pRB, size_t sizeInBytes)
{
    ma_uint32 readOffset;
    ma_uint32 readOffsetInBytes;
    ma_uint32 readOffsetLoopFlag;
    ma_uint32 newReadOffsetInBytes;
    ma_uint32 newReadOffsetLoopFlag;

    if (pRB == NULL) {
        return MA_INVALID_ARGS;
    }

    readOffset = ma_atomic_load_32(&pRB->encodedReadOffset);
    ma_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

    /* Check that sizeInBytes is correct. It should never go beyond the end of the buffer. */
    newReadOffsetInBytes = (ma_uint32)(readOffsetInBytes + sizeInBytes);
    if (newReadOffsetInBytes > pRB->subbufferSizeInBytes) {
        return MA_INVALID_ARGS;    /* <-- sizeInBytes will cause the read offset to overflow. */
    }

    /* Move the read pointer back to the start if necessary. */
    newReadOffsetLoopFlag = readOffsetLoopFlag;
    if (newReadOffsetInBytes == pRB->subbufferSizeInBytes) {
        newReadOffsetInBytes = 0;
        newReadOffsetLoopFlag ^= 0x80000000;
    }

    ma_atomic_exchange_32(&pRB->encodedReadOffset, ma_rb__construct_offset(newReadOffsetInBytes, newReadOffsetLoopFlag));

    return MA_SUCCESS;
}

MA_API ma_result ma_rb_acquire_write(ma_rb* pRB, size_t* pSizeInBytes, void** ppBufferOut)
{
    ma_uint32 readOffset;
    ma_uint32 readOffsetInBytes;
    ma_uint32 readOffsetLoopFlag;
    ma_uint32 writeOffset;
    ma_uint32 writeOffsetInBytes;
    ma_uint32 writeOffsetLoopFlag;
    size_t bytesAvailable;
    size_t bytesRequested;

    if (pRB == NULL || pSizeInBytes == NULL || ppBufferOut == NULL) {
        return MA_INVALID_ARGS;
    }

    /* The returned buffer should never overtake the read buffer. */
    readOffset = ma_atomic_load_32(&pRB->encodedReadOffset);
    ma_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

    writeOffset = ma_atomic_load_32(&pRB->encodedWriteOffset);
    ma_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

    /*
    In the case of writing, if the write pointer and the read pointer are on the same loop iteration we can only
    write up to the end of the buffer. Otherwise we can only write up to the read pointer. The write pointer should
    never overtake the read pointer.
    */
    if (writeOffsetLoopFlag == readOffsetLoopFlag) {
        bytesAvailable = pRB->subbufferSizeInBytes - writeOffsetInBytes;
    } else {
        bytesAvailable = readOffsetInBytes - writeOffsetInBytes;
    }

    bytesRequested = *pSizeInBytes;
    if (bytesRequested > bytesAvailable) {
        bytesRequested = bytesAvailable;
    }

    *pSizeInBytes = bytesRequested;
    *ppBufferOut  = ma_rb__get_write_ptr(pRB);

    /* Clear the buffer if desired. */
    if (pRB->clearOnWriteAcquire) {
        MA_ZERO_MEMORY(*ppBufferOut, *pSizeInBytes);
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_rb_commit_write(ma_rb* pRB, size_t sizeInBytes)
{
    ma_uint32 writeOffset;
    ma_uint32 writeOffsetInBytes;
    ma_uint32 writeOffsetLoopFlag;
    ma_uint32 newWriteOffsetInBytes;
    ma_uint32 newWriteOffsetLoopFlag;

    if (pRB == NULL) {
        return MA_INVALID_ARGS;
    }

    writeOffset = ma_atomic_load_32(&pRB->encodedWriteOffset);
    ma_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

    /* Check that sizeInBytes is correct. It should never go beyond the end of the buffer. */
    newWriteOffsetInBytes = (ma_uint32)(writeOffsetInBytes + sizeInBytes);
    if (newWriteOffsetInBytes > pRB->subbufferSizeInBytes) {
        return MA_INVALID_ARGS;    /* <-- sizeInBytes will cause the read offset to overflow. */
    }

    /* Move the read pointer back to the start if necessary. */
    newWriteOffsetLoopFlag = writeOffsetLoopFlag;
    if (newWriteOffsetInBytes == pRB->subbufferSizeInBytes) {
        newWriteOffsetInBytes = 0;
        newWriteOffsetLoopFlag ^= 0x80000000;
    }

    ma_atomic_exchange_32(&pRB->encodedWriteOffset, ma_rb__construct_offset(newWriteOffsetInBytes, newWriteOffsetLoopFlag));

    return MA_SUCCESS;
}

MA_API ma_result ma_rb_seek_read(ma_rb* pRB, size_t offsetInBytes)
{
    ma_uint32 readOffset;
    ma_uint32 readOffsetInBytes;
    ma_uint32 readOffsetLoopFlag;
    ma_uint32 writeOffset;
    ma_uint32 writeOffsetInBytes;
    ma_uint32 writeOffsetLoopFlag;
    ma_uint32 newReadOffsetInBytes;
    ma_uint32 newReadOffsetLoopFlag;

    if (pRB == NULL || offsetInBytes > pRB->subbufferSizeInBytes) {
        return MA_INVALID_ARGS;
    }

    readOffset = ma_atomic_load_32(&pRB->encodedReadOffset);
    ma_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

    writeOffset = ma_atomic_load_32(&pRB->encodedWriteOffset);
    ma_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

    newReadOffsetLoopFlag = readOffsetLoopFlag;

    /* We cannot go past the write buffer. */
    if (readOffsetLoopFlag == writeOffsetLoopFlag) {
        if ((readOffsetInBytes + offsetInBytes) > writeOffsetInBytes) {
            newReadOffsetInBytes = writeOffsetInBytes;
        } else {
            newReadOffsetInBytes = (ma_uint32)(readOffsetInBytes + offsetInBytes);
        }
    } else {
        /* May end up looping. */
        if ((readOffsetInBytes + offsetInBytes) >= pRB->subbufferSizeInBytes) {
            newReadOffsetInBytes = (ma_uint32)(readOffsetInBytes + offsetInBytes) - pRB->subbufferSizeInBytes;
            newReadOffsetLoopFlag ^= 0x80000000;    /* <-- Looped. */
        } else {
            newReadOffsetInBytes = (ma_uint32)(readOffsetInBytes + offsetInBytes);
        }
    }

    ma_atomic_exchange_32(&pRB->encodedReadOffset, ma_rb__construct_offset(newReadOffsetInBytes, newReadOffsetLoopFlag));
    return MA_SUCCESS;
}

MA_API ma_result ma_rb_seek_write(ma_rb* pRB, size_t offsetInBytes)
{
    ma_uint32 readOffset;
    ma_uint32 readOffsetInBytes;
    ma_uint32 readOffsetLoopFlag;
    ma_uint32 writeOffset;
    ma_uint32 writeOffsetInBytes;
    ma_uint32 writeOffsetLoopFlag;
    ma_uint32 newWriteOffsetInBytes;
    ma_uint32 newWriteOffsetLoopFlag;

    if (pRB == NULL) {
        return MA_INVALID_ARGS;
    }

    readOffset = ma_atomic_load_32(&pRB->encodedReadOffset);
    ma_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

    writeOffset = ma_atomic_load_32(&pRB->encodedWriteOffset);
    ma_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

    newWriteOffsetLoopFlag = writeOffsetLoopFlag;

    /* We cannot go past the write buffer. */
    if (readOffsetLoopFlag == writeOffsetLoopFlag) {
        /* May end up looping. */
        if ((writeOffsetInBytes + offsetInBytes) >= pRB->subbufferSizeInBytes) {
            newWriteOffsetInBytes = (ma_uint32)(writeOffsetInBytes + offsetInBytes) - pRB->subbufferSizeInBytes;
            newWriteOffsetLoopFlag ^= 0x80000000;    /* <-- Looped. */
        } else {
            newWriteOffsetInBytes = (ma_uint32)(writeOffsetInBytes + offsetInBytes);
        }
    } else {
        if ((writeOffsetInBytes + offsetInBytes) > readOffsetInBytes) {
            newWriteOffsetInBytes = readOffsetInBytes;
        } else {
            newWriteOffsetInBytes = (ma_uint32)(writeOffsetInBytes + offsetInBytes);
        }
    }

    ma_atomic_exchange_32(&pRB->encodedWriteOffset, ma_rb__construct_offset(newWriteOffsetInBytes, newWriteOffsetLoopFlag));
    return MA_SUCCESS;
}

MA_API ma_int32 ma_rb_pointer_distance(ma_rb* pRB)
{
    ma_uint32 readOffset;
    ma_uint32 readOffsetInBytes;
    ma_uint32 readOffsetLoopFlag;
    ma_uint32 writeOffset;
    ma_uint32 writeOffsetInBytes;
    ma_uint32 writeOffsetLoopFlag;

    if (pRB == NULL) {
        return 0;
    }

    readOffset = ma_atomic_load_32(&pRB->encodedReadOffset);
    ma_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

    writeOffset = ma_atomic_load_32(&pRB->encodedWriteOffset);
    ma_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

    if (readOffsetLoopFlag == writeOffsetLoopFlag) {
        return writeOffsetInBytes - readOffsetInBytes;
    } else {
        return writeOffsetInBytes + (pRB->subbufferSizeInBytes - readOffsetInBytes);
    }
}

MA_API ma_uint32 ma_rb_available_read(ma_rb* pRB)
{
    ma_int32 dist;

    if (pRB == NULL) {
        return 0;
    }

    dist = ma_rb_pointer_distance(pRB);
    if (dist < 0) {
        return 0;
    }

    return dist;
}

MA_API ma_uint32 ma_rb_available_write(ma_rb* pRB)
{
    if (pRB == NULL) {
        return 0;
    }

    return (ma_uint32)(ma_rb_get_subbuffer_size(pRB) - ma_rb_pointer_distance(pRB));
}

MA_API size_t ma_rb_get_subbuffer_size(ma_rb* pRB)
{
    if (pRB == NULL) {
        return 0;
    }

    return pRB->subbufferSizeInBytes;
}

MA_API size_t ma_rb_get_subbuffer_stride(ma_rb* pRB)
{
    if (pRB == NULL) {
        return 0;
    }

    if (pRB->subbufferStrideInBytes == 0) {
        return (size_t)pRB->subbufferSizeInBytes;
    }

    return (size_t)pRB->subbufferStrideInBytes;
}

MA_API size_t ma_rb_get_subbuffer_offset(ma_rb* pRB, size_t subbufferIndex)
{
    if (pRB == NULL) {
        return 0;
    }

    return subbufferIndex * ma_rb_get_subbuffer_stride(pRB);
}

MA_API void* ma_rb_get_subbuffer_ptr(ma_rb* pRB, size_t subbufferIndex, void* pBuffer)
{
    if (pRB == NULL) {
        return NULL;
    }

    return ma_offset_ptr(pBuffer, ma_rb_get_subbuffer_offset(pRB, subbufferIndex));
}



static ma_result ma_pcm_rb_data_source__on_read(ma_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    /* Since there's no notion of an end, we don't ever want to return MA_AT_END here. But it is possible to return 0. */
    ma_pcm_rb* pRB = (ma_pcm_rb*)pDataSource;
    ma_result result;
    ma_uint64 totalFramesRead;

    MA_ASSERT(pRB != NULL);

    /* We need to run this in a loop since the ring buffer itself may loop. */
    totalFramesRead = 0;
    while (totalFramesRead < frameCount) {
        void* pMappedBuffer;
        ma_uint32 mappedFrameCount;
        ma_uint64 framesToRead = frameCount - totalFramesRead;
        if (framesToRead > 0xFFFFFFFF) {
            framesToRead = 0xFFFFFFFF;
        }

        mappedFrameCount = (ma_uint32)framesToRead;
        result = ma_pcm_rb_acquire_read(pRB, &mappedFrameCount, &pMappedBuffer);
        if (result != MA_SUCCESS) {
            break;
        }

        if (mappedFrameCount == 0) {
            break;  /* <-- End of ring buffer. */
        }

        ma_copy_pcm_frames(ma_offset_pcm_frames_ptr(pFramesOut, totalFramesRead, pRB->format, pRB->channels), pMappedBuffer, mappedFrameCount, pRB->format, pRB->channels);

        result = ma_pcm_rb_commit_read(pRB, mappedFrameCount);
        if (result != MA_SUCCESS) {
            break;
        }

        totalFramesRead += mappedFrameCount;
    }

    /*
    There is no notion of an "end" in a ring buffer. If we didn't have enough data to fill the requested frame
    count we'll need to pad with silence. If we don't do this, totalFramesRead might equal 0 which will result
    in the data source layer at a higher level translating this to MA_AT_END which is incorrect for a ring buffer.
    */
    if (totalFramesRead < frameCount) {
        ma_silence_pcm_frames(ma_offset_pcm_frames_ptr(pFramesOut, totalFramesRead, pRB->format, pRB->channels), (frameCount - totalFramesRead), pRB->format, pRB->channels);
        totalFramesRead = frameCount;
    }

    *pFramesRead = totalFramesRead;
    return MA_SUCCESS;
}

static ma_result ma_pcm_rb_data_source__on_get_data_format(ma_data_source* pDataSource, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)
{
    ma_pcm_rb* pRB = (ma_pcm_rb*)pDataSource;
    MA_ASSERT(pRB != NULL);

    if (pFormat != NULL) {
        *pFormat = pRB->format;
    }

    if (pChannels != NULL) {
        *pChannels = pRB->channels;
    }

    if (pSampleRate != NULL) {
        *pSampleRate = pRB->sampleRate;
    }

    /* Just assume the default channel map. */
    if (pChannelMap != NULL) {
        ma_channel_map_init_standard(ma_standard_channel_map_default, pChannelMap, channelMapCap, pRB->channels);
    }

    return MA_SUCCESS;
}

static ma_data_source_vtable ma_gRBDataSourceVTable =
{
    ma_pcm_rb_data_source__on_read,
    NULL,   /* onSeek */
    ma_pcm_rb_data_source__on_get_data_format,
    NULL,   /* onGetCursor */
    NULL,   /* onGetLength */
    NULL,   /* onSetLooping */
    0
};

static MA_INLINE ma_uint32 ma_pcm_rb_get_bpf(ma_pcm_rb* pRB)
{
    MA_ASSERT(pRB != NULL);

    return ma_get_bytes_per_frame(pRB->format, pRB->channels);
}

MA_API ma_result ma_pcm_rb_init_ex(ma_format format, ma_uint32 channels, ma_uint32 subbufferSizeInFrames, ma_uint32 subbufferCount, ma_uint32 subbufferStrideInFrames, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_pcm_rb* pRB)
{
    ma_uint32 bpf;
    ma_result result;

    if (pRB == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pRB);

    bpf = ma_get_bytes_per_frame(format, channels);
    if (bpf == 0) {
        return MA_INVALID_ARGS;
    }

    result = ma_rb_init_ex(subbufferSizeInFrames*bpf, subbufferCount, subbufferStrideInFrames*bpf, pOptionalPreallocatedBuffer, pAllocationCallbacks, &pRB->rb);
    if (result != MA_SUCCESS) {
        return result;
    }

    pRB->format     = format;
    pRB->channels   = channels;
    pRB->sampleRate = 0;    /* The sample rate is not passed in as a parameter. */

    /* The PCM ring buffer is a data source. We need to get that set up as well. */
    {
        ma_data_source_config dataSourceConfig = ma_data_source_config_init();
        dataSourceConfig.vtable = &ma_gRBDataSourceVTable;

        result = ma_data_source_init(&dataSourceConfig, &pRB->ds);
        if (result != MA_SUCCESS) {
            ma_rb_uninit(&pRB->rb);
            return result;
        }
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_pcm_rb_init(ma_format format, ma_uint32 channels, ma_uint32 bufferSizeInFrames, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_pcm_rb* pRB)
{
    return ma_pcm_rb_init_ex(format, channels, bufferSizeInFrames, 1, 0, pOptionalPreallocatedBuffer, pAllocationCallbacks, pRB);
}

MA_API void ma_pcm_rb_uninit(ma_pcm_rb* pRB)
{
    if (pRB == NULL) {
        return;
    }

    ma_data_source_uninit(&pRB->ds);
    ma_rb_uninit(&pRB->rb);
}

MA_API void ma_pcm_rb_reset(ma_pcm_rb* pRB)
{
    if (pRB == NULL) {
        return;
    }

    ma_rb_reset(&pRB->rb);
}

MA_API ma_result ma_pcm_rb_acquire_read(ma_pcm_rb* pRB, ma_uint32* pSizeInFrames, void** ppBufferOut)
{
    size_t sizeInBytes;
    ma_result result;

    if (pRB == NULL || pSizeInFrames == NULL) {
        return MA_INVALID_ARGS;
    }

    sizeInBytes = *pSizeInFrames * ma_pcm_rb_get_bpf(pRB);

    result = ma_rb_acquire_read(&pRB->rb, &sizeInBytes, ppBufferOut);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pSizeInFrames = (ma_uint32)(sizeInBytes / (size_t)ma_pcm_rb_get_bpf(pRB));
    return MA_SUCCESS;
}

MA_API ma_result ma_pcm_rb_commit_read(ma_pcm_rb* pRB, ma_uint32 sizeInFrames)
{
    if (pRB == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_rb_commit_read(&pRB->rb, sizeInFrames * ma_pcm_rb_get_bpf(pRB));
}

MA_API ma_result ma_pcm_rb_acquire_write(ma_pcm_rb* pRB, ma_uint32* pSizeInFrames, void** ppBufferOut)
{
    size_t sizeInBytes;
    ma_result result;

    if (pRB == NULL) {
        return MA_INVALID_ARGS;
    }

    sizeInBytes = *pSizeInFrames * ma_pcm_rb_get_bpf(pRB);

    result = ma_rb_acquire_write(&pRB->rb, &sizeInBytes, ppBufferOut);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pSizeInFrames = (ma_uint32)(sizeInBytes / ma_pcm_rb_get_bpf(pRB));
    return MA_SUCCESS;
}

MA_API ma_result ma_pcm_rb_commit_write(ma_pcm_rb* pRB, ma_uint32 sizeInFrames)
{
    if (pRB == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_rb_commit_write(&pRB->rb, sizeInFrames * ma_pcm_rb_get_bpf(pRB));
}

MA_API ma_result ma_pcm_rb_seek_read(ma_pcm_rb* pRB, ma_uint32 offsetInFrames)
{
    if (pRB == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_rb_seek_read(&pRB->rb, offsetInFrames * ma_pcm_rb_get_bpf(pRB));
}

MA_API ma_result ma_pcm_rb_seek_write(ma_pcm_rb* pRB, ma_uint32 offsetInFrames)
{
    if (pRB == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_rb_seek_write(&pRB->rb, offsetInFrames * ma_pcm_rb_get_bpf(pRB));
}

MA_API ma_int32 ma_pcm_rb_pointer_distance(ma_pcm_rb* pRB)
{
    if (pRB == NULL) {
        return 0;
    }

    return ma_rb_pointer_distance(&pRB->rb) / ma_pcm_rb_get_bpf(pRB);
}

MA_API ma_uint32 ma_pcm_rb_available_read(ma_pcm_rb* pRB)
{
    if (pRB == NULL) {
        return 0;
    }

    return ma_rb_available_read(&pRB->rb) / ma_pcm_rb_get_bpf(pRB);
}

MA_API ma_uint32 ma_pcm_rb_available_write(ma_pcm_rb* pRB)
{
    if (pRB == NULL) {
        return 0;
    }

    return ma_rb_available_write(&pRB->rb) / ma_pcm_rb_get_bpf(pRB);
}

MA_API ma_uint32 ma_pcm_rb_get_subbuffer_size(ma_pcm_rb* pRB)
{
    if (pRB == NULL) {
        return 0;
    }

    return (ma_uint32)(ma_rb_get_subbuffer_size(&pRB->rb) / ma_pcm_rb_get_bpf(pRB));
}

MA_API ma_uint32 ma_pcm_rb_get_subbuffer_stride(ma_pcm_rb* pRB)
{
    if (pRB == NULL) {
        return 0;
    }

    return (ma_uint32)(ma_rb_get_subbuffer_stride(&pRB->rb) / ma_pcm_rb_get_bpf(pRB));
}

MA_API ma_uint32 ma_pcm_rb_get_subbuffer_offset(ma_pcm_rb* pRB, ma_uint32 subbufferIndex)
{
    if (pRB == NULL) {
        return 0;
    }

    return (ma_uint32)(ma_rb_get_subbuffer_offset(&pRB->rb, subbufferIndex) / ma_pcm_rb_get_bpf(pRB));
}

MA_API void* ma_pcm_rb_get_subbuffer_ptr(ma_pcm_rb* pRB, ma_uint32 subbufferIndex, void* pBuffer)
{
    if (pRB == NULL) {
        return NULL;
    }

    return ma_rb_get_subbuffer_ptr(&pRB->rb, subbufferIndex, pBuffer);
}

MA_API ma_format ma_pcm_rb_get_format(const ma_pcm_rb* pRB)
{
    if (pRB == NULL) {
        return ma_format_unknown;
    }

    return pRB->format;
}

MA_API ma_uint32 ma_pcm_rb_get_channels(const ma_pcm_rb* pRB)
{
    if (pRB == NULL) {
        return 0;
    }

    return pRB->channels;
}

MA_API ma_uint32 ma_pcm_rb_get_sample_rate(const ma_pcm_rb* pRB)
{
    if (pRB == NULL) {
        return 0;
    }

    return pRB->sampleRate;
}

MA_API void ma_pcm_rb_set_sample_rate(ma_pcm_rb* pRB, ma_uint32 sampleRate)
{
    if (pRB == NULL) {
        return;
    }

    pRB->sampleRate = sampleRate;
}



MA_API ma_result ma_duplex_rb_init(ma_format captureFormat, ma_uint32 captureChannels, ma_uint32 sampleRate, ma_uint32 captureInternalSampleRate, ma_uint32 captureInternalPeriodSizeInFrames, const ma_allocation_callbacks* pAllocationCallbacks, ma_duplex_rb* pRB)
{
    ma_result result;
    ma_uint32 sizeInFrames;

    sizeInFrames = (ma_uint32)ma_calculate_frame_count_after_resampling(sampleRate, captureInternalSampleRate, captureInternalPeriodSizeInFrames * 5);
    if (sizeInFrames == 0) {
        return MA_INVALID_ARGS;
    }

    result = ma_pcm_rb_init(captureFormat, captureChannels, sizeInFrames, NULL, pAllocationCallbacks, &pRB->rb);
    if (result != MA_SUCCESS) {
        return result;
    }

    /* Seek forward a bit so we have a bit of a buffer in case of desyncs. */
    ma_pcm_rb_seek_write((ma_pcm_rb*)pRB, captureInternalPeriodSizeInFrames * 2);

    return MA_SUCCESS;
}

MA_API ma_result ma_duplex_rb_uninit(ma_duplex_rb* pRB)
{
    ma_pcm_rb_uninit((ma_pcm_rb*)pRB);
    return MA_SUCCESS;
}



/**************************************************************************************************************************************************************

Miscellaneous Helpers

**************************************************************************************************************************************************************/
MA_API const char* ma_result_description(ma_result result)
{
    switch (result)
    {
        case MA_SUCCESS:                       return "No error";
        case MA_ERROR:                         return "Unknown error";
        case MA_INVALID_ARGS:                  return "Invalid argument";
        case MA_INVALID_OPERATION:             return "Invalid operation";
        case MA_OUT_OF_MEMORY:                 return "Out of memory";
        case MA_OUT_OF_RANGE:                  return "Out of range";
        case MA_ACCESS_DENIED:                 return "Permission denied";
        case MA_DOES_NOT_EXIST:                return "Resource does not exist";
        case MA_ALREADY_EXISTS:                return "Resource already exists";
        case MA_TOO_MANY_OPEN_FILES:           return "Too many open files";
        case MA_INVALID_FILE:                  return "Invalid file";
        case MA_TOO_BIG:                       return "Too large";
        case MA_PATH_TOO_LONG:                 return "Path too long";
        case MA_NAME_TOO_LONG:                 return "Name too long";
        case MA_NOT_DIRECTORY:                 return "Not a directory";
        case MA_IS_DIRECTORY:                  return "Is a directory";
        case MA_DIRECTORY_NOT_EMPTY:           return "Directory not empty";
        case MA_AT_END:                        return "At end";
        case MA_NO_SPACE:                      return "No space available";
        case MA_BUSY:                          return "Device or resource busy";
        case MA_IO_ERROR:                      return "Input/output error";
        case MA_INTERRUPT:                     return "Interrupted";
        case MA_UNAVAILABLE:                   return "Resource unavailable";
        case MA_ALREADY_IN_USE:                return "Resource already in use";
        case MA_BAD_ADDRESS:                   return "Bad address";
        case MA_BAD_SEEK:                      return "Illegal seek";
        case MA_BAD_PIPE:                      return "Broken pipe";
        case MA_DEADLOCK:                      return "Deadlock";
        case MA_TOO_MANY_LINKS:                return "Too many links";
        case MA_NOT_IMPLEMENTED:               return "Not implemented";
        case MA_NO_MESSAGE:                    return "No message of desired type";
        case MA_BAD_MESSAGE:                   return "Invalid message";
        case MA_NO_DATA_AVAILABLE:             return "No data available";
        case MA_INVALID_DATA:                  return "Invalid data";
        case MA_TIMEOUT:                       return "Timeout";
        case MA_NO_NETWORK:                    return "Network unavailable";
        case MA_NOT_UNIQUE:                    return "Not unique";
        case MA_NOT_SOCKET:                    return "Socket operation on non-socket";
        case MA_NO_ADDRESS:                    return "Destination address required";
        case MA_BAD_PROTOCOL:                  return "Protocol wrong type for socket";
        case MA_PROTOCOL_UNAVAILABLE:          return "Protocol not available";
        case MA_PROTOCOL_NOT_SUPPORTED:        return "Protocol not supported";
        case MA_PROTOCOL_FAMILY_NOT_SUPPORTED: return "Protocol family not supported";
        case MA_ADDRESS_FAMILY_NOT_SUPPORTED:  return "Address family not supported";
        case MA_SOCKET_NOT_SUPPORTED:          return "Socket type not supported";
        case MA_CONNECTION_RESET:              return "Connection reset";
        case MA_ALREADY_CONNECTED:             return "Already connected";
        case MA_NOT_CONNECTED:                 return "Not connected";
        case MA_CONNECTION_REFUSED:            return "Connection refused";
        case MA_NO_HOST:                       return "No host";
        case MA_IN_PROGRESS:                   return "Operation in progress";
        case MA_CANCELLED:                     return "Operation cancelled";
        case MA_MEMORY_ALREADY_MAPPED:         return "Memory already mapped";

        case MA_FORMAT_NOT_SUPPORTED:          return "Format not supported";
        case MA_DEVICE_TYPE_NOT_SUPPORTED:     return "Device type not supported";
        case MA_SHARE_MODE_NOT_SUPPORTED:      return "Share mode not supported";
        case MA_NO_BACKEND:                    return "No backend";
        case MA_NO_DEVICE:                     return "No device";
        case MA_API_NOT_FOUND:                 return "API not found";
        case MA_INVALID_DEVICE_CONFIG:         return "Invalid device config";

        case MA_DEVICE_NOT_INITIALIZED:        return "Device not initialized";
        case MA_DEVICE_NOT_STARTED:            return "Device not started";

        case MA_FAILED_TO_INIT_BACKEND:        return "Failed to initialize backend";
        case MA_FAILED_TO_OPEN_BACKEND_DEVICE: return "Failed to open backend device";
        case MA_FAILED_TO_START_BACKEND_DEVICE: return "Failed to start backend device";
        case MA_FAILED_TO_STOP_BACKEND_DEVICE: return "Failed to stop backend device";

        default:                               return "Unknown error";
    }
}

MA_API void* ma_malloc(size_t sz, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pAllocationCallbacks != NULL) {
        if (pAllocationCallbacks->onMalloc != NULL) {
            return pAllocationCallbacks->onMalloc(sz, pAllocationCallbacks->pUserData);
        } else {
            return NULL;    /* Do not fall back to the default implementation. */
        }
    } else {
        return ma__malloc_default(sz, NULL);
    }
}

MA_API void* ma_calloc(size_t sz, const ma_allocation_callbacks* pAllocationCallbacks)
{
    void* p = ma_malloc(sz, pAllocationCallbacks);
    if (p != NULL) {
        MA_ZERO_MEMORY(p, sz);
    }

    return p;
}

MA_API void* ma_realloc(void* p, size_t sz, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pAllocationCallbacks != NULL) {
        if (pAllocationCallbacks->onRealloc != NULL) {
            return pAllocationCallbacks->onRealloc(p, sz, pAllocationCallbacks->pUserData);
        } else {
            return NULL;    /* Do not fall back to the default implementation. */
        }
    } else {
        return ma__realloc_default(p, sz, NULL);
    }
}

MA_API void ma_free(void* p, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (p == NULL) {
        return;
    }

    if (pAllocationCallbacks != NULL) {
        if (pAllocationCallbacks->onFree != NULL) {
            pAllocationCallbacks->onFree(p, pAllocationCallbacks->pUserData);
        } else {
            return; /* Do no fall back to the default implementation. */
        }
    } else {
        ma__free_default(p, NULL);
    }
}

MA_API void* ma_aligned_malloc(size_t sz, size_t alignment, const ma_allocation_callbacks* pAllocationCallbacks)
{
    size_t extraBytes;
    void* pUnaligned;
    void* pAligned;

    if (alignment == 0) {
        return 0;
    }

    extraBytes = alignment-1 + sizeof(void*);

    pUnaligned = ma_malloc(sz + extraBytes, pAllocationCallbacks);
    if (pUnaligned == NULL) {
        return NULL;
    }

    pAligned = (void*)(((ma_uintptr)pUnaligned + extraBytes) & ~((ma_uintptr)(alignment-1)));
    ((void**)pAligned)[-1] = pUnaligned;

    return pAligned;
}

MA_API void ma_aligned_free(void* p, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_free(((void**)p)[-1], pAllocationCallbacks);
}

MA_API const char* ma_get_format_name(ma_format format)
{
    switch (format)
    {
        case ma_format_unknown: return "Unknown";
        case ma_format_u8:      return "8-bit Unsigned Integer";
        case ma_format_s16:     return "16-bit Signed Integer";
        case ma_format_s24:     return "24-bit Signed Integer (Tightly Packed)";
        case ma_format_s32:     return "32-bit Signed Integer";
        case ma_format_f32:     return "32-bit IEEE Floating Point";
        default:                return "Invalid";
    }
}

MA_API void ma_blend_f32(float* pOut, float* pInA, float* pInB, float factor, ma_uint32 channels)
{
    ma_uint32 i;
    for (i = 0; i < channels; ++i) {
        pOut[i] = ma_mix_f32(pInA[i], pInB[i], factor);
    }
}


MA_API ma_uint32 ma_get_bytes_per_sample(ma_format format)
{
    ma_uint32 sizes[] = {
        0,  /* unknown */
        1,  /* u8 */
        2,  /* s16 */
        3,  /* s24 */
        4,  /* s32 */
        4,  /* f32 */
    };
    return sizes[format];
}



#define MA_DATA_SOURCE_DEFAULT_RANGE_BEG        0
#define MA_DATA_SOURCE_DEFAULT_RANGE_END        ~((ma_uint64)0)
#define MA_DATA_SOURCE_DEFAULT_LOOP_POINT_BEG   0
#define MA_DATA_SOURCE_DEFAULT_LOOP_POINT_END   ~((ma_uint64)0)

MA_API ma_data_source_config ma_data_source_config_init(void)
{
    ma_data_source_config config;

    MA_ZERO_OBJECT(&config);

    return config;
}


MA_API ma_result ma_data_source_init(const ma_data_source_config* pConfig, ma_data_source* pDataSource)
{
    ma_data_source_base* pDataSourceBase = (ma_data_source_base*)pDataSource;

    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pDataSourceBase);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->vtable == NULL) {
        return MA_INVALID_ARGS;
    }

    pDataSourceBase->vtable           = pConfig->vtable;
    pDataSourceBase->rangeBegInFrames = MA_DATA_SOURCE_DEFAULT_RANGE_BEG;
    pDataSourceBase->rangeEndInFrames = MA_DATA_SOURCE_DEFAULT_RANGE_END;
    pDataSourceBase->loopBegInFrames  = MA_DATA_SOURCE_DEFAULT_LOOP_POINT_BEG;
    pDataSourceBase->loopEndInFrames  = MA_DATA_SOURCE_DEFAULT_LOOP_POINT_END;
    pDataSourceBase->pCurrent         = pDataSource;    /* Always read from ourself by default. */
    pDataSourceBase->pNext            = NULL;
    pDataSourceBase->onGetNext        = NULL;

    return MA_SUCCESS;
}

MA_API void ma_data_source_uninit(ma_data_source* pDataSource)
{
    if (pDataSource == NULL) {
        return;
    }

    /*
    This is placeholder in case we need this later. Data sources need to call this in their
    uninitialization routine to ensure things work later on if something is added here.
    */
}

static ma_result ma_data_source_resolve_current(ma_data_source* pDataSource, ma_data_source** ppCurrentDataSource)
{
    ma_data_source_base* pCurrentDataSource = (ma_data_source_base*)pDataSource;

    MA_ASSERT(pDataSource         != NULL);
    MA_ASSERT(ppCurrentDataSource != NULL);

    if (pCurrentDataSource->pCurrent == NULL) {
        /*
        The current data source is NULL. If we're using this in the context of a chain we need to return NULL
        here so that we don't end up looping. Otherwise we just return the data source itself.
        */
        if (pCurrentDataSource->pNext != NULL || pCurrentDataSource->onGetNext != NULL) {
            pCurrentDataSource = NULL;
        } else {
            pCurrentDataSource = (ma_data_source_base*)pDataSource; /* Not being used in a chain. Make sure we just always read from the data source itself at all times. */
        }
    } else {
        pCurrentDataSource = (ma_data_source_base*)pCurrentDataSource->pCurrent;
    }

    *ppCurrentDataSource = pCurrentDataSource;

    return MA_SUCCESS;
}

static ma_result ma_data_source_read_pcm_frames_from_backend(ma_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    ma_data_source_base* pDataSourceBase = (ma_data_source_base*)pDataSource;

    MA_ASSERT(pDataSourceBase                 != NULL);
    MA_ASSERT(pDataSourceBase->vtable         != NULL);
    MA_ASSERT(pDataSourceBase->vtable->onRead != NULL);
    MA_ASSERT(pFramesRead != NULL);

    if (pFramesOut != NULL) {
        return pDataSourceBase->vtable->onRead(pDataSourceBase, pFramesOut, frameCount, pFramesRead);
    } else {
        /*
        No output buffer. Probably seeking forward. Read and discard. Can probably optimize this in terms of
        onSeek and onGetCursor, but need to keep in mind that the data source may not implement these functions.
        */
        ma_result result;
        ma_uint64 framesRead;
        ma_format format;
        ma_uint32 channels;
        ma_uint64 discardBufferCapInFrames;
        ma_uint8  pDiscardBuffer[4096];

        result = ma_data_source_get_data_format(pDataSource, &format, &channels, NULL, NULL, 0);
        if (result != MA_SUCCESS) {
            return result;
        }

        discardBufferCapInFrames = sizeof(pDiscardBuffer) / ma_get_bytes_per_frame(format, channels);

        framesRead = 0;
        while (framesRead < frameCount) {
            ma_uint64 framesReadThisIteration = 0;
            ma_uint64 framesToRead = frameCount - framesRead;
            if (framesToRead > discardBufferCapInFrames) {
                framesToRead = discardBufferCapInFrames;
            }

            result = pDataSourceBase->vtable->onRead(pDataSourceBase, pDiscardBuffer, framesToRead, &framesReadThisIteration);
            if (result != MA_SUCCESS) {
                return result;
            }

            framesRead += framesReadThisIteration;
        }

        *pFramesRead = framesRead;

        return MA_SUCCESS;
    }
}

static ma_result ma_data_source_read_pcm_frames_within_range(ma_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    ma_data_source_base* pDataSourceBase = (ma_data_source_base*)pDataSource;
    ma_result result;
    ma_uint64 framesRead = 0;
    ma_bool32 loop = ma_data_source_is_looping(pDataSource);

    if (pDataSourceBase == NULL) {
        return MA_AT_END;
    }

    if (frameCount == 0) {
        return MA_INVALID_ARGS;
    }

    MA_ASSERT(pDataSourceBase->vtable != NULL);

    if ((pDataSourceBase->vtable->flags & MA_DATA_SOURCE_SELF_MANAGED_RANGE_AND_LOOP_POINT) != 0 || (pDataSourceBase->rangeEndInFrames == ~((ma_uint64)0) && (pDataSourceBase->loopEndInFrames == ~((ma_uint64)0) || loop == MA_FALSE))) {
        /* Either the data source is self-managing the range, or no range is set - just read like normal. The data source itself will tell us when the end is reached. */
        result = ma_data_source_read_pcm_frames_from_backend(pDataSource, pFramesOut, frameCount, &framesRead);
    } else {
        /* Need to clamp to within the range. */
        ma_uint64 relativeCursor;
        ma_uint64 absoluteCursor;

        result = ma_data_source_get_cursor_in_pcm_frames(pDataSourceBase, &relativeCursor);
        if (result != MA_SUCCESS) {
            /* Failed to retrieve the cursor. Cannot read within a range or loop points. Just read like normal - this may happen for things like noise data sources where it doesn't really matter. */
            result = ma_data_source_read_pcm_frames_from_backend(pDataSource, pFramesOut, frameCount, &framesRead);
        } else {
            ma_uint64 rangeBeg;
            ma_uint64 rangeEnd;

            /* We have the cursor. We need to make sure we don't read beyond our range. */
            rangeBeg = pDataSourceBase->rangeBegInFrames;
            rangeEnd = pDataSourceBase->rangeEndInFrames;

            absoluteCursor = rangeBeg + relativeCursor;

            /* If looping, make sure we're within range. */
            if (loop) {
                if (pDataSourceBase->loopEndInFrames != ~((ma_uint64)0)) {
                    rangeEnd = ma_min(rangeEnd, pDataSourceBase->rangeBegInFrames + pDataSourceBase->loopEndInFrames);
                }
            }

            if (frameCount > (rangeEnd - absoluteCursor) && rangeEnd != ~((ma_uint64)0)) {
                frameCount = (rangeEnd - absoluteCursor);
            }

            /*
            If the cursor is sitting on the end of the range the frame count will be set to 0 which can
            result in MA_INVALID_ARGS. In this case, we don't want to try reading, but instead return
            MA_AT_END so the higher level function can know about it.
            */
            if (frameCount > 0) {
                result = ma_data_source_read_pcm_frames_from_backend(pDataSource, pFramesOut, frameCount, &framesRead);
            } else {
                result = MA_AT_END; /* The cursor is sitting on the end of the range which means we're at the end. */
            }
        }
    }

    if (pFramesRead != NULL) {
        *pFramesRead = framesRead;
    }

    /* We need to make sure MA_AT_END is returned if we hit the end of the range. */
    if (result == MA_SUCCESS && framesRead == 0) {
        result  = MA_AT_END;
    }

    return result;
}

MA_API ma_result ma_data_source_read_pcm_frames(ma_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    ma_result result = MA_SUCCESS;
    ma_data_source_base* pDataSourceBase = (ma_data_source_base*)pDataSource;
    ma_data_source_base* pCurrentDataSource;
    void* pRunningFramesOut = pFramesOut;
    ma_uint64 totalFramesProcessed = 0;
    ma_format format;
    ma_uint32 channels;
    ma_uint32 emptyLoopCounter = 0; /* Keeps track of how many times 0 frames have been read. For infinite loop detection of sounds with no audio data. */
    ma_bool32 loop;

    if (pFramesRead != NULL) {
        *pFramesRead = 0;
    }

    if (frameCount == 0) {
        return MA_INVALID_ARGS;
    }

    if (pDataSourceBase == NULL) {
        return MA_INVALID_ARGS;
    }

    loop = ma_data_source_is_looping(pDataSource);

    /*
    We need to know the data format so we can advance the output buffer as we read frames. If this
    fails, chaining will not work and we'll just read as much as we can from the current source.
    */
    if (ma_data_source_get_data_format(pDataSource, &format, &channels, NULL, NULL, 0) != MA_SUCCESS) {
        result = ma_data_source_resolve_current(pDataSource, (ma_data_source**)&pCurrentDataSource);
        if (result != MA_SUCCESS) {
            return result;
        }

        return ma_data_source_read_pcm_frames_within_range(pCurrentDataSource, pFramesOut, frameCount, pFramesRead);
    }

    /*
    Looping is a bit of a special case. When the `loop` argument is true, chaining will not work and
    only the current data source will be read from.
    */

    /* Keep reading until we've read as many frames as possible. */
    while (totalFramesProcessed < frameCount) {
        ma_uint64 framesProcessed;
        ma_uint64 framesRemaining = frameCount - totalFramesProcessed;

        /* We need to resolve the data source that we'll actually be reading from. */
        result = ma_data_source_resolve_current(pDataSource, (ma_data_source**)&pCurrentDataSource);
        if (result != MA_SUCCESS) {
            break;
        }

        if (pCurrentDataSource == NULL) {
            break;
        }

        result = ma_data_source_read_pcm_frames_within_range(pCurrentDataSource, pRunningFramesOut, framesRemaining, &framesProcessed);
        totalFramesProcessed += framesProcessed;

        /*
        If we encountered an error from the read callback, make sure it's propagated to the caller. The caller may need to know whether or not MA_BUSY is returned which is
        not necessarily considered an error.
        */
        if (result != MA_SUCCESS && result != MA_AT_END) {
            break;
        }

        /*
        We can determine if we've reached the end by checking if ma_data_source_read_pcm_frames_within_range() returned
        MA_AT_END. To loop back to the start, all we need to do is seek back to the first frame.
        */
        if (result == MA_AT_END) {
            /*
            The result needs to be reset back to MA_SUCCESS (from MA_AT_END) so that we don't
            accidentally return MA_AT_END when data has been read in prior loop iterations. at the
            end of this function, the result will be checked for MA_SUCCESS, and if the total
            number of frames processed is 0, will be explicitly set to MA_AT_END.
            */
            result = MA_SUCCESS;

            /*
            We reached the end. If we're looping, we just loop back to the start of the current
            data source. If we're not looping we need to check if we have another in the chain, and
            if so, switch to it.
            */
            if (loop) {
                if (framesProcessed == 0) {
                    emptyLoopCounter += 1;
                    if (emptyLoopCounter > 1) {
                        break;  /* Infinite loop detected. Get out. */
                    }
                } else {
                    emptyLoopCounter = 0;
                }

                result = ma_data_source_seek_to_pcm_frame(pCurrentDataSource, pCurrentDataSource->loopBegInFrames);
                if (result != MA_SUCCESS) {
                    break;  /* Failed to loop. Abort. */
                }

                /* Don't return MA_AT_END for looping sounds. */
                result = MA_SUCCESS;
            } else {
                if (pCurrentDataSource->pNext != NULL) {
                    pDataSourceBase->pCurrent = pCurrentDataSource->pNext;
                } else if (pCurrentDataSource->onGetNext != NULL) {
                    pDataSourceBase->pCurrent = pCurrentDataSource->onGetNext(pCurrentDataSource);
                    if (pDataSourceBase->pCurrent == NULL) {
                        break;  /* Our callback did not return a next data source. We're done. */
                    }
                } else {
                    /* Reached the end of the chain. We're done. */
                    break;
                }

                /* The next data source needs to be rewound to ensure data is read in looping scenarios. */
                result = ma_data_source_seek_to_pcm_frame(pDataSourceBase->pCurrent, 0);
                if (result != MA_SUCCESS) {
                    break;
                }
            }
        }

        if (pRunningFramesOut != NULL) {
            pRunningFramesOut = ma_offset_ptr(pRunningFramesOut, framesProcessed * ma_get_bytes_per_frame(format, channels));
        }
    }

    if (pFramesRead != NULL) {
        *pFramesRead = totalFramesProcessed;
    }

    MA_ASSERT(!(result == MA_AT_END && totalFramesProcessed > 0));  /* We should never be returning MA_AT_END if we read some data. */

    if (result == MA_SUCCESS && totalFramesProcessed == 0) {
        result  = MA_AT_END;
    }

    return result;
}

MA_API ma_result ma_data_source_seek_pcm_frames(ma_data_source* pDataSource, ma_uint64 frameCount, ma_uint64* pFramesSeeked)
{
    return ma_data_source_read_pcm_frames(pDataSource, NULL, frameCount, pFramesSeeked);
}

MA_API ma_result ma_data_source_seek_to_pcm_frame(ma_data_source* pDataSource, ma_uint64 frameIndex)
{
    ma_data_source_base* pDataSourceBase = (ma_data_source_base*)pDataSource;

    if (pDataSourceBase == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pDataSourceBase->vtable->onSeek == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    if (frameIndex > pDataSourceBase->rangeEndInFrames) {
        return MA_INVALID_OPERATION;    /* Trying to seek too far forward. */
    }

    MA_ASSERT(pDataSourceBase->vtable != NULL);

    return pDataSourceBase->vtable->onSeek(pDataSource, pDataSourceBase->rangeBegInFrames + frameIndex);
}

MA_API ma_result ma_data_source_seek_seconds(ma_data_source* pDataSource, float secondCount, float* pSecondsSeeked)
{
    ma_uint64 frameCount;
    ma_uint64 framesSeeked = 0;
    ma_uint32 sampleRate;
    ma_result result;

    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    result = ma_data_source_get_data_format(pDataSource, NULL, NULL, &sampleRate, NULL, 0);
    if (result != MA_SUCCESS) {
        return result;
    }

    /* We need PCM frames instead of seconds */
    frameCount = (ma_uint64)(secondCount * sampleRate);

    result = ma_data_source_seek_pcm_frames(pDataSource, frameCount, &framesSeeked);

    /* VC6 doesn't support division between unsigned 64-bit integer and floating point number. Signed integer needed. This shouldn't affect anything in practice */
    *pSecondsSeeked = (ma_int64)framesSeeked / (float)sampleRate;
    return result;
}

MA_API ma_result ma_data_source_seek_to_second(ma_data_source* pDataSource, float seekPointInSeconds)
{
    ma_uint64 frameIndex;
    ma_uint32 sampleRate;
    ma_result result;

    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    result = ma_data_source_get_data_format(pDataSource, NULL, NULL, &sampleRate, NULL, 0);
    if (result != MA_SUCCESS) {
        return result;
    }

    /* We need PCM frames instead of seconds */
    frameIndex = (ma_uint64)(seekPointInSeconds * sampleRate);

    return ma_data_source_seek_to_pcm_frame(pDataSource, frameIndex);
}

MA_API ma_result ma_data_source_get_data_format(ma_data_source* pDataSource, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)
{
    ma_data_source_base* pDataSourceBase = (ma_data_source_base*)pDataSource;
    ma_result result;
    ma_format format;
    ma_uint32 channels;
    ma_uint32 sampleRate;

    /* Initialize to defaults for safety just in case the data source does not implement this callback. */
    if (pFormat != NULL) {
        *pFormat = ma_format_unknown;
    }
    if (pChannels != NULL) {
        *pChannels = 0;
    }
    if (pSampleRate != NULL) {
        *pSampleRate = 0;
    }
    if (pChannelMap != NULL) {
        MA_ZERO_MEMORY(pChannelMap, sizeof(*pChannelMap) * channelMapCap);
    }

    if (pDataSourceBase == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ASSERT(pDataSourceBase->vtable != NULL);

    if (pDataSourceBase->vtable->onGetDataFormat == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    result = pDataSourceBase->vtable->onGetDataFormat(pDataSource, &format, &channels, &sampleRate, pChannelMap, channelMapCap);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (pFormat != NULL) {
        *pFormat = format;
    }
    if (pChannels != NULL) {
        *pChannels = channels;
    }
    if (pSampleRate != NULL) {
        *pSampleRate = sampleRate;
    }

    /* Channel map was passed in directly to the callback. This is safe due to the channelMapCap parameter. */

    return MA_SUCCESS;
}

MA_API ma_result ma_data_source_get_cursor_in_pcm_frames(ma_data_source* pDataSource, ma_uint64* pCursor)
{
    ma_data_source_base* pDataSourceBase = (ma_data_source_base*)pDataSource;
    ma_result result;
    ma_uint64 cursor;

    if (pCursor == NULL) {
        return MA_INVALID_ARGS;
    }

    *pCursor = 0;

    if (pDataSourceBase == NULL) {
        return MA_SUCCESS;
    }

    MA_ASSERT(pDataSourceBase->vtable != NULL);

    if (pDataSourceBase->vtable->onGetCursor == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    result = pDataSourceBase->vtable->onGetCursor(pDataSourceBase, &cursor);
    if (result != MA_SUCCESS) {
        return result;
    }

    /* The cursor needs to be made relative to the start of the range. */
    if (cursor < pDataSourceBase->rangeBegInFrames) {   /* Safety check so we don't return some huge number. */
        *pCursor = 0;
    } else {
        *pCursor = cursor - pDataSourceBase->rangeBegInFrames;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_data_source_get_length_in_pcm_frames(ma_data_source* pDataSource, ma_uint64* pLength)
{
    ma_data_source_base* pDataSourceBase = (ma_data_source_base*)pDataSource;

    if (pLength == NULL) {
        return MA_INVALID_ARGS;
    }

    *pLength = 0;

    if (pDataSourceBase == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ASSERT(pDataSourceBase->vtable != NULL);

    /*
    If we have a range defined we'll use that to determine the length. This is one of rare times
    where we'll actually trust the caller. If they've set the range, I think it's mostly safe to
    assume they've set it based on some higher level knowledge of the structure of the sound bank.
    */
    if (pDataSourceBase->rangeEndInFrames != ~((ma_uint64)0)) {
        *pLength = pDataSourceBase->rangeEndInFrames - pDataSourceBase->rangeBegInFrames;
        return MA_SUCCESS;
    }

    /*
    Getting here means a range is not defined so we'll need to get the data source itself to tell
    us the length.
    */
    if (pDataSourceBase->vtable->onGetLength == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    return pDataSourceBase->vtable->onGetLength(pDataSource, pLength);
}

MA_API ma_result ma_data_source_get_cursor_in_seconds(ma_data_source* pDataSource, float* pCursor)
{
    ma_result result;
    ma_uint64 cursorInPCMFrames;
    ma_uint32 sampleRate;

    if (pCursor == NULL) {
        return MA_INVALID_ARGS;
    }

    *pCursor = 0;

    result = ma_data_source_get_cursor_in_pcm_frames(pDataSource, &cursorInPCMFrames);
    if (result != MA_SUCCESS) {
        return result;
    }

    result = ma_data_source_get_data_format(pDataSource, NULL, NULL, &sampleRate, NULL, 0);
    if (result != MA_SUCCESS) {
        return result;
    }

    /* VC6 does not support division of unsigned 64-bit integers with floating point numbers. Need to use a signed number. This shouldn't effect anything in practice. */
    *pCursor = (ma_int64)cursorInPCMFrames / (float)sampleRate;

    return MA_SUCCESS;
}

MA_API ma_result ma_data_source_get_length_in_seconds(ma_data_source* pDataSource, float* pLength)
{
    ma_result result;
    ma_uint64 lengthInPCMFrames;
    ma_uint32 sampleRate;

    if (pLength == NULL) {
        return MA_INVALID_ARGS;
    }

    *pLength = 0;

    result = ma_data_source_get_length_in_pcm_frames(pDataSource, &lengthInPCMFrames);
    if (result != MA_SUCCESS) {
        return result;
    }

    result = ma_data_source_get_data_format(pDataSource, NULL, NULL, &sampleRate, NULL, 0);
    if (result != MA_SUCCESS) {
        return result;
    }

    /* VC6 does not support division of unsigned 64-bit integers with floating point numbers. Need to use a signed number. This shouldn't effect anything in practice. */
    *pLength = (ma_int64)lengthInPCMFrames / (float)sampleRate;

    return MA_SUCCESS;
}

MA_API ma_result ma_data_source_set_looping(ma_data_source* pDataSource, ma_bool32 isLooping)
{
    ma_data_source_base* pDataSourceBase = (ma_data_source_base*)pDataSource;

    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    ma_atomic_exchange_32(&pDataSourceBase->isLooping, isLooping);

    MA_ASSERT(pDataSourceBase->vtable != NULL);

    /* If there's no callback for this just treat it as a successful no-op. */
    if (pDataSourceBase->vtable->onSetLooping == NULL) {
        return MA_SUCCESS;
    }

    return pDataSourceBase->vtable->onSetLooping(pDataSource, isLooping);
}

MA_API ma_bool32 ma_data_source_is_looping(const ma_data_source* pDataSource)
{
    const ma_data_source_base* pDataSourceBase = (const ma_data_source_base*)pDataSource;

    if (pDataSource == NULL) {
        return MA_FALSE;
    }

    return ma_atomic_load_32(&pDataSourceBase->isLooping);
}

MA_API ma_result ma_data_source_set_range_in_pcm_frames(ma_data_source* pDataSource, ma_uint64 rangeBegInFrames, ma_uint64 rangeEndInFrames)
{
    ma_data_source_base* pDataSourceBase = (ma_data_source_base*)pDataSource;
    ma_result result;
    ma_uint64 relativeCursor;
    ma_uint64 absoluteCursor;
    ma_bool32 doSeekAdjustment = MA_FALSE;

    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    if (rangeEndInFrames < rangeBegInFrames) {
        return MA_INVALID_ARGS; /* The end of the range must come after the beginning. */
    }

    /*
    We may need to adjust the position of the cursor to ensure it's clamped to the range. Grab it now
    so we can calculate its absolute position before we change the range.
    */
    result = ma_data_source_get_cursor_in_pcm_frames(pDataSource, &relativeCursor);
    if (result == MA_SUCCESS) {
        doSeekAdjustment = MA_TRUE;
        absoluteCursor = relativeCursor + pDataSourceBase->rangeBegInFrames;
    } else {
        /*
        We couldn't get the position of the cursor. It probably means the data source has no notion
        of a cursor. We'll just leave it at position 0. Don't treat this as an error.
        */
        doSeekAdjustment = MA_FALSE;
        relativeCursor = 0;
        absoluteCursor = 0;
    }

    pDataSourceBase->rangeBegInFrames = rangeBegInFrames;
    pDataSourceBase->rangeEndInFrames = rangeEndInFrames;

    /*
    The commented out logic below was intended to maintain loop points in response to a change in the
    range. However, this is not useful because it results in the sound breaking when you move the range
    outside of the old loop points. I'm simplifying this by simply resetting the loop points. The
    caller is expected to update their loop points if they change the range.

    In practice this should be mostly a non-issue because the majority of the time the range will be
    set once right after initialization.
    */
    pDataSourceBase->loopBegInFrames = 0;
    pDataSourceBase->loopEndInFrames = ~((ma_uint64)0);


    /*
    Seek to within range. Note that our seek positions here are relative to the new range. We don't want
    to do this if we failed to retrieve the cursor earlier on because it probably means the data source
    has no notion of a cursor. In practice the seek would probably fail (which we silently ignore), but
    I'm just not even going to attempt it.
    */
    if (doSeekAdjustment) {
        if (absoluteCursor < rangeBegInFrames) {
            ma_data_source_seek_to_pcm_frame(pDataSource, 0);
        } else if (absoluteCursor > rangeEndInFrames) {
            ma_data_source_seek_to_pcm_frame(pDataSource, rangeEndInFrames - rangeBegInFrames);
        }
    }

    return MA_SUCCESS;
}

MA_API void ma_data_source_get_range_in_pcm_frames(const ma_data_source* pDataSource, ma_uint64* pRangeBegInFrames, ma_uint64* pRangeEndInFrames)
{
    const ma_data_source_base* pDataSourceBase = (const ma_data_source_base*)pDataSource;

    if (pRangeBegInFrames != NULL) {
        *pRangeBegInFrames = 0;
    }
    if (pRangeEndInFrames != NULL) {
        *pRangeEndInFrames = 0;
    }

    if (pDataSource == NULL) {
        return;
    }

    if (pRangeBegInFrames != NULL) {
        *pRangeBegInFrames = pDataSourceBase->rangeBegInFrames;
    }

    if (pRangeEndInFrames != NULL) {
        *pRangeEndInFrames = pDataSourceBase->rangeEndInFrames;
    }
}

MA_API ma_result ma_data_source_set_loop_point_in_pcm_frames(ma_data_source* pDataSource, ma_uint64 loopBegInFrames, ma_uint64 loopEndInFrames)
{
    ma_data_source_base* pDataSourceBase = (ma_data_source_base*)pDataSource;

    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    if (loopEndInFrames < loopBegInFrames) {
        return MA_INVALID_ARGS; /* The end of the loop point must come after the beginning. */
    }

    if (loopEndInFrames > pDataSourceBase->rangeEndInFrames && loopEndInFrames != ~((ma_uint64)0)) {
        return MA_INVALID_ARGS; /* The end of the loop point must not go beyond the range. */
    }

    pDataSourceBase->loopBegInFrames = loopBegInFrames;
    pDataSourceBase->loopEndInFrames = loopEndInFrames;

    /* The end cannot exceed the range. */
    if (pDataSourceBase->loopEndInFrames > (pDataSourceBase->rangeEndInFrames - pDataSourceBase->rangeBegInFrames) && pDataSourceBase->loopEndInFrames != ~((ma_uint64)0)) {
        pDataSourceBase->loopEndInFrames = (pDataSourceBase->rangeEndInFrames - pDataSourceBase->rangeBegInFrames);
    }

    return MA_SUCCESS;
}

MA_API void ma_data_source_get_loop_point_in_pcm_frames(const ma_data_source* pDataSource, ma_uint64* pLoopBegInFrames, ma_uint64* pLoopEndInFrames)
{
    const ma_data_source_base* pDataSourceBase = (const ma_data_source_base*)pDataSource;

    if (pLoopBegInFrames != NULL) {
        *pLoopBegInFrames = 0;
    }
    if (pLoopEndInFrames != NULL) {
        *pLoopEndInFrames = 0;
    }

    if (pDataSource == NULL) {
        return;
    }

    if (pLoopBegInFrames != NULL) {
        *pLoopBegInFrames = pDataSourceBase->loopBegInFrames;
    }

    if (pLoopEndInFrames != NULL) {
        *pLoopEndInFrames = pDataSourceBase->loopEndInFrames;
    }
}

MA_API ma_result ma_data_source_set_current(ma_data_source* pDataSource, ma_data_source* pCurrentDataSource)
{
    ma_data_source_base* pDataSourceBase = (ma_data_source_base*)pDataSource;

    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    pDataSourceBase->pCurrent = pCurrentDataSource;

    return MA_SUCCESS;
}

MA_API ma_data_source* ma_data_source_get_current(const ma_data_source* pDataSource)
{
    const ma_data_source_base* pDataSourceBase = (const ma_data_source_base*)pDataSource;

    if (pDataSource == NULL) {
        return NULL;
    }

    return pDataSourceBase->pCurrent;
}

MA_API ma_result ma_data_source_set_next(ma_data_source* pDataSource, ma_data_source* pNextDataSource)
{
    ma_data_source_base* pDataSourceBase = (ma_data_source_base*)pDataSource;

    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    pDataSourceBase->pNext = pNextDataSource;

    return MA_SUCCESS;
}

MA_API ma_data_source* ma_data_source_get_next(const ma_data_source* pDataSource)
{
    const ma_data_source_base* pDataSourceBase = (const ma_data_source_base*)pDataSource;

    if (pDataSource == NULL) {
        return NULL;
    }

    return pDataSourceBase->pNext;
}

MA_API ma_result ma_data_source_set_next_callback(ma_data_source* pDataSource, ma_data_source_get_next_proc onGetNext)
{
    ma_data_source_base* pDataSourceBase = (ma_data_source_base*)pDataSource;

    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    pDataSourceBase->onGetNext = onGetNext;

    return MA_SUCCESS;
}

MA_API ma_data_source_get_next_proc ma_data_source_get_next_callback(const ma_data_source* pDataSource)
{
    const ma_data_source_base* pDataSourceBase = (const ma_data_source_base*)pDataSource;

    if (pDataSource == NULL) {
        return NULL;
    }

    return pDataSourceBase->onGetNext;
}


static ma_result ma_audio_buffer_ref__data_source_on_read(ma_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    ma_audio_buffer_ref* pAudioBufferRef = (ma_audio_buffer_ref*)pDataSource;
    ma_uint64 framesRead = ma_audio_buffer_ref_read_pcm_frames(pAudioBufferRef, pFramesOut, frameCount, MA_FALSE);

    if (pFramesRead != NULL) {
        *pFramesRead = framesRead;
    }

    if (framesRead < frameCount || framesRead == 0) {
        return MA_AT_END;
    }

    return MA_SUCCESS;
}

static ma_result ma_audio_buffer_ref__data_source_on_seek(ma_data_source* pDataSource, ma_uint64 frameIndex)
{
    return ma_audio_buffer_ref_seek_to_pcm_frame((ma_audio_buffer_ref*)pDataSource, frameIndex);
}

static ma_result ma_audio_buffer_ref__data_source_on_get_data_format(ma_data_source* pDataSource, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)
{
    ma_audio_buffer_ref* pAudioBufferRef = (ma_audio_buffer_ref*)pDataSource;

    *pFormat     = pAudioBufferRef->format;
    *pChannels   = pAudioBufferRef->channels;
    *pSampleRate = pAudioBufferRef->sampleRate;
    ma_channel_map_init_standard(ma_standard_channel_map_default, pChannelMap, channelMapCap, pAudioBufferRef->channels);

    return MA_SUCCESS;
}

static ma_result ma_audio_buffer_ref__data_source_on_get_cursor(ma_data_source* pDataSource, ma_uint64* pCursor)
{
    ma_audio_buffer_ref* pAudioBufferRef = (ma_audio_buffer_ref*)pDataSource;

    *pCursor = pAudioBufferRef->cursor;

    return MA_SUCCESS;
}

static ma_result ma_audio_buffer_ref__data_source_on_get_length(ma_data_source* pDataSource, ma_uint64* pLength)
{
    ma_audio_buffer_ref* pAudioBufferRef = (ma_audio_buffer_ref*)pDataSource;

    *pLength = pAudioBufferRef->sizeInFrames;

    return MA_SUCCESS;
}

static ma_data_source_vtable g_ma_audio_buffer_ref_data_source_vtable =
{
    ma_audio_buffer_ref__data_source_on_read,
    ma_audio_buffer_ref__data_source_on_seek,
    ma_audio_buffer_ref__data_source_on_get_data_format,
    ma_audio_buffer_ref__data_source_on_get_cursor,
    ma_audio_buffer_ref__data_source_on_get_length,
    NULL,   /* onSetLooping */
    0
};

MA_API ma_result ma_audio_buffer_ref_init(ma_format format, ma_uint32 channels, const void* pData, ma_uint64 sizeInFrames, ma_audio_buffer_ref* pAudioBufferRef)
{
    ma_result result;
    ma_data_source_config dataSourceConfig;

    if (pAudioBufferRef == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pAudioBufferRef);

    dataSourceConfig = ma_data_source_config_init();
    dataSourceConfig.vtable = &g_ma_audio_buffer_ref_data_source_vtable;

    result = ma_data_source_init(&dataSourceConfig, &pAudioBufferRef->ds);
    if (result != MA_SUCCESS) {
        return result;
    }

    pAudioBufferRef->format       = format;
    pAudioBufferRef->channels     = channels;
    pAudioBufferRef->sampleRate   = 0;  /* TODO: Version 0.12. Set this to sampleRate. */
    pAudioBufferRef->cursor       = 0;
    pAudioBufferRef->sizeInFrames = sizeInFrames;
    pAudioBufferRef->pData        = pData;

    return MA_SUCCESS;
}

MA_API void ma_audio_buffer_ref_uninit(ma_audio_buffer_ref* pAudioBufferRef)
{
    if (pAudioBufferRef == NULL) {
        return;
    }

    ma_data_source_uninit(&pAudioBufferRef->ds);
}

MA_API ma_result ma_audio_buffer_ref_set_data(ma_audio_buffer_ref* pAudioBufferRef, const void* pData, ma_uint64 sizeInFrames)
{
    if (pAudioBufferRef == NULL) {
        return MA_INVALID_ARGS;
    }

    pAudioBufferRef->cursor       = 0;
    pAudioBufferRef->sizeInFrames = sizeInFrames;
    pAudioBufferRef->pData        = pData;

    return MA_SUCCESS;
}

MA_API ma_uint64 ma_audio_buffer_ref_read_pcm_frames(ma_audio_buffer_ref* pAudioBufferRef, void* pFramesOut, ma_uint64 frameCount, ma_bool32 loop)
{
    ma_uint64 totalFramesRead = 0;

    if (pAudioBufferRef == NULL) {
        return 0;
    }

    if (frameCount == 0) {
        return 0;
    }

    while (totalFramesRead < frameCount) {
        ma_uint64 framesAvailable = pAudioBufferRef->sizeInFrames - pAudioBufferRef->cursor;
        ma_uint64 framesRemaining = frameCount - totalFramesRead;
        ma_uint64 framesToRead;

        framesToRead = framesRemaining;
        if (framesToRead > framesAvailable) {
            framesToRead = framesAvailable;
        }

        if (pFramesOut != NULL) {
            ma_copy_pcm_frames(ma_offset_ptr(pFramesOut, totalFramesRead * ma_get_bytes_per_frame(pAudioBufferRef->format, pAudioBufferRef->channels)), ma_offset_ptr(pAudioBufferRef->pData, pAudioBufferRef->cursor * ma_get_bytes_per_frame(pAudioBufferRef->format, pAudioBufferRef->channels)), framesToRead, pAudioBufferRef->format, pAudioBufferRef->channels);
        }

        totalFramesRead += framesToRead;

        pAudioBufferRef->cursor += framesToRead;
        if (pAudioBufferRef->cursor == pAudioBufferRef->sizeInFrames) {
            if (loop) {
                pAudioBufferRef->cursor = 0;
            } else {
                break;  /* We've reached the end and we're not looping. Done. */
            }
        }

        MA_ASSERT(pAudioBufferRef->cursor < pAudioBufferRef->sizeInFrames);
    }

    return totalFramesRead;
}

MA_API ma_result ma_audio_buffer_ref_seek_to_pcm_frame(ma_audio_buffer_ref* pAudioBufferRef, ma_uint64 frameIndex)
{
    if (pAudioBufferRef == NULL) {
        return MA_INVALID_ARGS;
    }

    if (frameIndex > pAudioBufferRef->sizeInFrames) {
        return MA_INVALID_ARGS;
    }

    pAudioBufferRef->cursor = (size_t)frameIndex;

    return MA_SUCCESS;
}

MA_API ma_result ma_audio_buffer_ref_map(ma_audio_buffer_ref* pAudioBufferRef, void** ppFramesOut, ma_uint64* pFrameCount)
{
    ma_uint64 framesAvailable;
    ma_uint64 frameCount = 0;

    if (ppFramesOut != NULL) {
        *ppFramesOut = NULL;    /* Safety. */
    }

    if (pFrameCount != NULL) {
        frameCount = *pFrameCount;
        *pFrameCount = 0;       /* Safety. */
    }

    if (pAudioBufferRef == NULL || ppFramesOut == NULL || pFrameCount == NULL) {
        return MA_INVALID_ARGS;
    }

    framesAvailable = pAudioBufferRef->sizeInFrames - pAudioBufferRef->cursor;
    if (frameCount > framesAvailable) {
        frameCount = framesAvailable;
    }

    *ppFramesOut = ma_offset_ptr(pAudioBufferRef->pData, pAudioBufferRef->cursor * ma_get_bytes_per_frame(pAudioBufferRef->format, pAudioBufferRef->channels));
    *pFrameCount = frameCount;

    return MA_SUCCESS;
}

MA_API ma_result ma_audio_buffer_ref_unmap(ma_audio_buffer_ref* pAudioBufferRef, ma_uint64 frameCount)
{
    ma_uint64 framesAvailable;

    if (pAudioBufferRef == NULL) {
        return MA_INVALID_ARGS;
    }

    framesAvailable = pAudioBufferRef->sizeInFrames - pAudioBufferRef->cursor;
    if (frameCount > framesAvailable) {
        return MA_INVALID_ARGS;   /* The frame count was too big. This should never happen in an unmapping. Need to make sure the caller is aware of this. */
    }

    pAudioBufferRef->cursor += frameCount;

    if (pAudioBufferRef->cursor == pAudioBufferRef->sizeInFrames) {
        return MA_AT_END;   /* Successful. Need to tell the caller that the end has been reached so that it can loop if desired. */
    } else {
        return MA_SUCCESS;
    }
}

MA_API ma_bool32 ma_audio_buffer_ref_at_end(const ma_audio_buffer_ref* pAudioBufferRef)
{
    if (pAudioBufferRef == NULL) {
        return MA_FALSE;
    }

    return pAudioBufferRef->cursor == pAudioBufferRef->sizeInFrames;
}

MA_API ma_result ma_audio_buffer_ref_get_cursor_in_pcm_frames(const ma_audio_buffer_ref* pAudioBufferRef, ma_uint64* pCursor)
{
    if (pCursor == NULL) {
        return MA_INVALID_ARGS;
    }

    *pCursor = 0;

    if (pAudioBufferRef == NULL) {
        return MA_INVALID_ARGS;
    }

    *pCursor = pAudioBufferRef->cursor;

    return MA_SUCCESS;
}

MA_API ma_result ma_audio_buffer_ref_get_length_in_pcm_frames(const ma_audio_buffer_ref* pAudioBufferRef, ma_uint64* pLength)
{
    if (pLength == NULL) {
        return MA_INVALID_ARGS;
    }

    *pLength = 0;

    if (pAudioBufferRef == NULL) {
        return MA_INVALID_ARGS;
    }

    *pLength = pAudioBufferRef->sizeInFrames;

    return MA_SUCCESS;
}

MA_API ma_result ma_audio_buffer_ref_get_available_frames(const ma_audio_buffer_ref* pAudioBufferRef, ma_uint64* pAvailableFrames)
{
    if (pAvailableFrames == NULL) {
        return MA_INVALID_ARGS;
    }

    *pAvailableFrames = 0;

    if (pAudioBufferRef == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pAudioBufferRef->sizeInFrames <= pAudioBufferRef->cursor) {
        *pAvailableFrames = 0;
    } else {
        *pAvailableFrames = pAudioBufferRef->sizeInFrames - pAudioBufferRef->cursor;
    }

    return MA_SUCCESS;
}




MA_API ma_audio_buffer_config ma_audio_buffer_config_init(ma_format format, ma_uint32 channels, ma_uint64 sizeInFrames, const void* pData, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_audio_buffer_config config;

    MA_ZERO_OBJECT(&config);
    config.format       = format;
    config.channels     = channels;
    config.sampleRate   = 0;    /* TODO: Version 0.12. Set this to sampleRate. */
    config.sizeInFrames = sizeInFrames;
    config.pData        = pData;
    ma_allocation_callbacks_init_copy(&config.allocationCallbacks, pAllocationCallbacks);

    return config;
}

static ma_result ma_audio_buffer_init_ex(const ma_audio_buffer_config* pConfig, ma_bool32 doCopy, ma_audio_buffer* pAudioBuffer)
{
    ma_result result;

    if (pAudioBuffer == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_MEMORY(pAudioBuffer, sizeof(*pAudioBuffer) - sizeof(pAudioBuffer->_pExtraData));   /* Safety. Don't overwrite the extra data. */

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->sizeInFrames == 0) {
        return MA_INVALID_ARGS; /* Not allowing buffer sizes of 0 frames. */
    }

    result = ma_audio_buffer_ref_init(pConfig->format, pConfig->channels, NULL, 0, &pAudioBuffer->ref);
    if (result != MA_SUCCESS) {
        return result;
    }

    /* TODO: Version 0.12. Set this in ma_audio_buffer_ref_init() instead of here. */
    pAudioBuffer->ref.sampleRate = pConfig->sampleRate;

    ma_allocation_callbacks_init_copy(&pAudioBuffer->allocationCallbacks, &pConfig->allocationCallbacks);

    if (doCopy) {
        ma_uint64 allocationSizeInBytes;
        void* pData;

        allocationSizeInBytes = pConfig->sizeInFrames * ma_get_bytes_per_frame(pConfig->format, pConfig->channels);
        if (allocationSizeInBytes > MA_SIZE_MAX) {
            return MA_OUT_OF_MEMORY;    /* Too big. */
        }

        pData = ma_malloc((size_t)allocationSizeInBytes, &pAudioBuffer->allocationCallbacks);   /* Safe cast to size_t. */
        if (pData == NULL) {
            return MA_OUT_OF_MEMORY;
        }

        if (pConfig->pData != NULL) {
            ma_copy_pcm_frames(pData, pConfig->pData, pConfig->sizeInFrames, pConfig->format, pConfig->channels);
        } else {
            ma_silence_pcm_frames(pData, pConfig->sizeInFrames, pConfig->format, pConfig->channels);
        }

        ma_audio_buffer_ref_set_data(&pAudioBuffer->ref, pData, pConfig->sizeInFrames);
        pAudioBuffer->ownsData = MA_TRUE;
    } else {
        ma_audio_buffer_ref_set_data(&pAudioBuffer->ref, pConfig->pData, pConfig->sizeInFrames);
        pAudioBuffer->ownsData = MA_FALSE;
    }

    return MA_SUCCESS;
}

static void ma_audio_buffer_uninit_ex(ma_audio_buffer* pAudioBuffer, ma_bool32 doFree)
{
    if (pAudioBuffer == NULL) {
        return;
    }

    if (pAudioBuffer->ownsData && pAudioBuffer->ref.pData != &pAudioBuffer->_pExtraData[0]) {
        ma_free((void*)pAudioBuffer->ref.pData, &pAudioBuffer->allocationCallbacks);    /* Naugty const cast, but OK in this case since we've guarded it with the ownsData check. */
    }

    if (doFree) {
        ma_free(pAudioBuffer, &pAudioBuffer->allocationCallbacks);
    }

    ma_audio_buffer_ref_uninit(&pAudioBuffer->ref);
}

MA_API ma_result ma_audio_buffer_init(const ma_audio_buffer_config* pConfig, ma_audio_buffer* pAudioBuffer)
{
    return ma_audio_buffer_init_ex(pConfig, MA_FALSE, pAudioBuffer);
}

MA_API ma_result ma_audio_buffer_init_copy(const ma_audio_buffer_config* pConfig, ma_audio_buffer* pAudioBuffer)
{
    return ma_audio_buffer_init_ex(pConfig, MA_TRUE, pAudioBuffer);
}

MA_API ma_result ma_audio_buffer_alloc_and_init(const ma_audio_buffer_config* pConfig, ma_audio_buffer** ppAudioBuffer)
{
    ma_result result;
    ma_audio_buffer* pAudioBuffer;
    ma_audio_buffer_config innerConfig; /* We'll be making some changes to the config, so need to make a copy. */
    ma_uint64 allocationSizeInBytes;

    if (ppAudioBuffer == NULL) {
        return MA_INVALID_ARGS;
    }

    *ppAudioBuffer = NULL;  /* Safety. */

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    innerConfig = *pConfig;
    ma_allocation_callbacks_init_copy(&innerConfig.allocationCallbacks, &pConfig->allocationCallbacks);

    allocationSizeInBytes = sizeof(*pAudioBuffer) - sizeof(pAudioBuffer->_pExtraData) + (pConfig->sizeInFrames * ma_get_bytes_per_frame(pConfig->format, pConfig->channels));
    if (allocationSizeInBytes > MA_SIZE_MAX) {
        return MA_OUT_OF_MEMORY;    /* Too big. */
    }

    pAudioBuffer = (ma_audio_buffer*)ma_malloc((size_t)allocationSizeInBytes, &innerConfig.allocationCallbacks);  /* Safe cast to size_t. */
    if (pAudioBuffer == NULL) {
        return MA_OUT_OF_MEMORY;
    }

    if (pConfig->pData != NULL) {
        ma_copy_pcm_frames(&pAudioBuffer->_pExtraData[0], pConfig->pData, pConfig->sizeInFrames, pConfig->format, pConfig->channels);
    } else {
        ma_silence_pcm_frames(&pAudioBuffer->_pExtraData[0], pConfig->sizeInFrames, pConfig->format, pConfig->channels);
    }

    innerConfig.pData = &pAudioBuffer->_pExtraData[0];

    result = ma_audio_buffer_init_ex(&innerConfig, MA_FALSE, pAudioBuffer);
    if (result != MA_SUCCESS) {
        ma_free(pAudioBuffer, &innerConfig.allocationCallbacks);
        return result;
    }

    *ppAudioBuffer = pAudioBuffer;

    return MA_SUCCESS;
}

MA_API void ma_audio_buffer_uninit(ma_audio_buffer* pAudioBuffer)
{
    ma_audio_buffer_uninit_ex(pAudioBuffer, MA_FALSE);
}

MA_API void ma_audio_buffer_uninit_and_free(ma_audio_buffer* pAudioBuffer)
{
    ma_audio_buffer_uninit_ex(pAudioBuffer, MA_TRUE);
}

MA_API ma_uint64 ma_audio_buffer_read_pcm_frames(ma_audio_buffer* pAudioBuffer, void* pFramesOut, ma_uint64 frameCount, ma_bool32 loop)
{
    if (pAudioBuffer == NULL) {
        return 0;
    }

    return ma_audio_buffer_ref_read_pcm_frames(&pAudioBuffer->ref, pFramesOut, frameCount, loop);
}

MA_API ma_result ma_audio_buffer_seek_to_pcm_frame(ma_audio_buffer* pAudioBuffer, ma_uint64 frameIndex)
{
    if (pAudioBuffer == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_audio_buffer_ref_seek_to_pcm_frame(&pAudioBuffer->ref, frameIndex);
}

MA_API ma_result ma_audio_buffer_map(ma_audio_buffer* pAudioBuffer, void** ppFramesOut, ma_uint64* pFrameCount)
{
    if (ppFramesOut != NULL) {
        *ppFramesOut = NULL;    /* Safety. */
    }

    if (pAudioBuffer == NULL) {
        if (pFrameCount != NULL) {
            *pFrameCount = 0;
        }

        return MA_INVALID_ARGS;
    }

    return ma_audio_buffer_ref_map(&pAudioBuffer->ref, ppFramesOut, pFrameCount);
}

MA_API ma_result ma_audio_buffer_unmap(ma_audio_buffer* pAudioBuffer, ma_uint64 frameCount)
{
    if (pAudioBuffer == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_audio_buffer_ref_unmap(&pAudioBuffer->ref, frameCount);
}

MA_API ma_bool32 ma_audio_buffer_at_end(const ma_audio_buffer* pAudioBuffer)
{
    if (pAudioBuffer == NULL) {
        return MA_FALSE;
    }

    return ma_audio_buffer_ref_at_end(&pAudioBuffer->ref);
}

MA_API ma_result ma_audio_buffer_get_cursor_in_pcm_frames(const ma_audio_buffer* pAudioBuffer, ma_uint64* pCursor)
{
    if (pAudioBuffer == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_audio_buffer_ref_get_cursor_in_pcm_frames(&pAudioBuffer->ref, pCursor);
}

MA_API ma_result ma_audio_buffer_get_length_in_pcm_frames(const ma_audio_buffer* pAudioBuffer, ma_uint64* pLength)
{
    if (pAudioBuffer == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_audio_buffer_ref_get_length_in_pcm_frames(&pAudioBuffer->ref, pLength);
}

MA_API ma_result ma_audio_buffer_get_available_frames(const ma_audio_buffer* pAudioBuffer, ma_uint64* pAvailableFrames)
{
    if (pAvailableFrames == NULL) {
        return MA_INVALID_ARGS;
    }

    *pAvailableFrames = 0;

    if (pAudioBuffer == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_audio_buffer_ref_get_available_frames(&pAudioBuffer->ref, pAvailableFrames);
}





MA_API ma_result ma_paged_audio_buffer_data_init(ma_format format, ma_uint32 channels, ma_paged_audio_buffer_data* pData)
{
    if (pData == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pData);

    pData->format   = format;
    pData->channels = channels;
    pData->pTail    = &pData->head;

    return MA_SUCCESS;
}

MA_API void ma_paged_audio_buffer_data_uninit(ma_paged_audio_buffer_data* pData, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_paged_audio_buffer_page* pPage;

    if (pData == NULL) {
        return;
    }

    /* All pages need to be freed. */
    pPage = (ma_paged_audio_buffer_page*)ma_atomic_load_ptr(&pData->head.pNext);
    while (pPage != NULL) {
        ma_paged_audio_buffer_page* pNext = (ma_paged_audio_buffer_page*)ma_atomic_load_ptr(&pPage->pNext);

        ma_free(pPage, pAllocationCallbacks);
        pPage = pNext;
    }
}

MA_API ma_paged_audio_buffer_page* ma_paged_audio_buffer_data_get_head(ma_paged_audio_buffer_data* pData)
{
    if (pData == NULL) {
        return NULL;
    }

    return &pData->head;
}

MA_API ma_paged_audio_buffer_page* ma_paged_audio_buffer_data_get_tail(ma_paged_audio_buffer_data* pData)
{
    if (pData == NULL) {
        return NULL;
    }

    return pData->pTail;
}

MA_API ma_result ma_paged_audio_buffer_data_get_length_in_pcm_frames(ma_paged_audio_buffer_data* pData, ma_uint64* pLength)
{
    ma_paged_audio_buffer_page* pPage;

    if (pLength == NULL) {
        return MA_INVALID_ARGS;
    }

    *pLength = 0;

    if (pData == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Calculate the length from the linked list. */
    for (pPage = (ma_paged_audio_buffer_page*)ma_atomic_load_ptr(&pData->head.pNext); pPage != NULL; pPage = (ma_paged_audio_buffer_page*)ma_atomic_load_ptr(&pPage->pNext)) {
        *pLength += pPage->sizeInFrames;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_paged_audio_buffer_data_allocate_page(ma_paged_audio_buffer_data* pData, ma_uint64 pageSizeInFrames, const void* pInitialData, const ma_allocation_callbacks* pAllocationCallbacks, ma_paged_audio_buffer_page** ppPage)
{
    ma_paged_audio_buffer_page* pPage;
    ma_uint64 allocationSize;

    if (ppPage == NULL) {
        return MA_INVALID_ARGS;
    }

    *ppPage = NULL;

    if (pData == NULL) {
        return MA_INVALID_ARGS;
    }

    allocationSize = sizeof(*pPage) + (pageSizeInFrames * ma_get_bytes_per_frame(pData->format, pData->channels));
    if (allocationSize > MA_SIZE_MAX) {
        return MA_OUT_OF_MEMORY;    /* Too big. */
    }

    pPage = (ma_paged_audio_buffer_page*)ma_malloc((size_t)allocationSize, pAllocationCallbacks);   /* Safe cast to size_t. */
    if (pPage == NULL) {
        return MA_OUT_OF_MEMORY;
    }

    pPage->pNext = NULL;
    pPage->sizeInFrames = pageSizeInFrames;

    if (pInitialData != NULL) {
        ma_copy_pcm_frames(pPage->pAudioData, pInitialData, pageSizeInFrames, pData->format, pData->channels);
    }

    *ppPage = pPage;

    return MA_SUCCESS;
}

MA_API ma_result ma_paged_audio_buffer_data_free_page(ma_paged_audio_buffer_data* pData, ma_paged_audio_buffer_page* pPage, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pData == NULL || pPage == NULL) {
        return MA_INVALID_ARGS;
    }

    /* It's assumed the page is not attached to the list. */
    ma_free(pPage, pAllocationCallbacks);

    return MA_SUCCESS;
}

MA_API ma_result ma_paged_audio_buffer_data_append_page(ma_paged_audio_buffer_data* pData, ma_paged_audio_buffer_page* pPage)
{
    if (pData == NULL || pPage == NULL) {
        return MA_INVALID_ARGS;
    }

    /* This function assumes the page has been filled with audio data by this point. As soon as we append, the page will be available for reading. */

    /* First thing to do is update the tail. */
    for (;;) {
        ma_paged_audio_buffer_page* pOldTail = (ma_paged_audio_buffer_page*)ma_atomic_load_ptr(&pData->pTail);
        ma_paged_audio_buffer_page* pNewTail = pPage;

        if (ma_atomic_compare_exchange_weak_ptr((volatile void**)&pData->pTail, (void**)&pOldTail, pNewTail)) {
            /* Here is where we append the page to the list. After this, the page is attached to the list and ready to be read from. */
            ma_atomic_exchange_ptr(&pOldTail->pNext, pPage);
            break;  /* Done. */
        }
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_paged_audio_buffer_data_allocate_and_append_page(ma_paged_audio_buffer_data* pData, ma_uint32 pageSizeInFrames, const void* pInitialData, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_result result;
    ma_paged_audio_buffer_page* pPage;

    result = ma_paged_audio_buffer_data_allocate_page(pData, pageSizeInFrames, pInitialData, pAllocationCallbacks, &pPage);
    if (result != MA_SUCCESS) {
        return result;
    }

    return ma_paged_audio_buffer_data_append_page(pData, pPage);    /* <-- Should never fail. */
}


MA_API ma_paged_audio_buffer_config ma_paged_audio_buffer_config_init(ma_paged_audio_buffer_data* pData)
{
    ma_paged_audio_buffer_config config;

    MA_ZERO_OBJECT(&config);
    config.pData = pData;

    return config;
}


static ma_result ma_paged_audio_buffer__data_source_on_read(ma_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    return ma_paged_audio_buffer_read_pcm_frames((ma_paged_audio_buffer*)pDataSource, pFramesOut, frameCount, pFramesRead);
}

static ma_result ma_paged_audio_buffer__data_source_on_seek(ma_data_source* pDataSource, ma_uint64 frameIndex)
{
    return ma_paged_audio_buffer_seek_to_pcm_frame((ma_paged_audio_buffer*)pDataSource, frameIndex);
}

static ma_result ma_paged_audio_buffer__data_source_on_get_data_format(ma_data_source* pDataSource, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)
{
    ma_paged_audio_buffer* pPagedAudioBuffer = (ma_paged_audio_buffer*)pDataSource;

    *pFormat     = pPagedAudioBuffer->pData->format;
    *pChannels   = pPagedAudioBuffer->pData->channels;
    *pSampleRate = 0;   /* There is no notion of a sample rate with audio buffers. */
    ma_channel_map_init_standard(ma_standard_channel_map_default, pChannelMap, channelMapCap, pPagedAudioBuffer->pData->channels);

    return MA_SUCCESS;
}

static ma_result ma_paged_audio_buffer__data_source_on_get_cursor(ma_data_source* pDataSource, ma_uint64* pCursor)
{
    return ma_paged_audio_buffer_get_cursor_in_pcm_frames((ma_paged_audio_buffer*)pDataSource, pCursor);
}

static ma_result ma_paged_audio_buffer__data_source_on_get_length(ma_data_source* pDataSource, ma_uint64* pLength)
{
    return ma_paged_audio_buffer_get_length_in_pcm_frames((ma_paged_audio_buffer*)pDataSource, pLength);
}

static ma_data_source_vtable g_ma_paged_audio_buffer_data_source_vtable =
{
    ma_paged_audio_buffer__data_source_on_read,
    ma_paged_audio_buffer__data_source_on_seek,
    ma_paged_audio_buffer__data_source_on_get_data_format,
    ma_paged_audio_buffer__data_source_on_get_cursor,
    ma_paged_audio_buffer__data_source_on_get_length,
    NULL,   /* onSetLooping */
    0
};

MA_API ma_result ma_paged_audio_buffer_init(const ma_paged_audio_buffer_config* pConfig, ma_paged_audio_buffer* pPagedAudioBuffer)
{
    ma_result result;
    ma_data_source_config dataSourceConfig;

    if (pPagedAudioBuffer == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pPagedAudioBuffer);

    /* A config is required for the format and channel count. */
    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->pData == NULL) {
        return MA_INVALID_ARGS; /* No underlying data specified. */
    }

    dataSourceConfig = ma_data_source_config_init();
    dataSourceConfig.vtable = &g_ma_paged_audio_buffer_data_source_vtable;

    result = ma_data_source_init(&dataSourceConfig, &pPagedAudioBuffer->ds);
    if (result != MA_SUCCESS) {
        return result;
    }

    pPagedAudioBuffer->pData          = pConfig->pData;
    pPagedAudioBuffer->pCurrent       = ma_paged_audio_buffer_data_get_head(pConfig->pData);
    pPagedAudioBuffer->relativeCursor = 0;
    pPagedAudioBuffer->absoluteCursor = 0;

    return MA_SUCCESS;
}

MA_API void ma_paged_audio_buffer_uninit(ma_paged_audio_buffer* pPagedAudioBuffer)
{
    if (pPagedAudioBuffer == NULL) {
        return;
    }

    /* Nothing to do. The data needs to be deleted separately. */
}

MA_API ma_result ma_paged_audio_buffer_read_pcm_frames(ma_paged_audio_buffer* pPagedAudioBuffer, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    ma_result result = MA_SUCCESS;
    ma_uint64 totalFramesRead = 0;
    ma_format format;
    ma_uint32 channels;

    if (pPagedAudioBuffer == NULL) {
        return MA_INVALID_ARGS;
    }

    format   = pPagedAudioBuffer->pData->format;
    channels = pPagedAudioBuffer->pData->channels;

    while (totalFramesRead < frameCount) {
        /* Read from the current page. The buffer should never be in a state where this is NULL. */
        ma_uint64 framesRemainingInCurrentPage;
        ma_uint64 framesRemainingToRead = frameCount - totalFramesRead;
        ma_uint64 framesToReadThisIteration;

        MA_ASSERT(pPagedAudioBuffer->pCurrent != NULL);

        framesRemainingInCurrentPage = pPagedAudioBuffer->pCurrent->sizeInFrames - pPagedAudioBuffer->relativeCursor;

        framesToReadThisIteration = ma_min(framesRemainingInCurrentPage, framesRemainingToRead);
        ma_copy_pcm_frames(ma_offset_pcm_frames_ptr(pFramesOut, totalFramesRead, format, channels), ma_offset_pcm_frames_ptr(pPagedAudioBuffer->pCurrent->pAudioData, pPagedAudioBuffer->relativeCursor, format, channels), framesToReadThisIteration, format, channels);
        totalFramesRead += framesToReadThisIteration;

        pPagedAudioBuffer->absoluteCursor += framesToReadThisIteration;
        pPagedAudioBuffer->relativeCursor += framesToReadThisIteration;

        /* Move to the next page if necessary. If there's no more pages, we need to return MA_AT_END. */
        MA_ASSERT(pPagedAudioBuffer->relativeCursor <= pPagedAudioBuffer->pCurrent->sizeInFrames);

        if (pPagedAudioBuffer->relativeCursor == pPagedAudioBuffer->pCurrent->sizeInFrames) {
            /* We reached the end of the page. Need to move to the next. If there's no more pages, we're done. */
            ma_paged_audio_buffer_page* pNext = (ma_paged_audio_buffer_page*)ma_atomic_load_ptr(&pPagedAudioBuffer->pCurrent->pNext);
            if (pNext == NULL) {
                result = MA_AT_END;
                break;  /* We've reached the end. */
            } else {
                pPagedAudioBuffer->pCurrent       = pNext;
                pPagedAudioBuffer->relativeCursor = 0;
            }
        }
    }

    if (pFramesRead != NULL) {
        *pFramesRead = totalFramesRead;
    }

    return result;
}

MA_API ma_result ma_paged_audio_buffer_seek_to_pcm_frame(ma_paged_audio_buffer* pPagedAudioBuffer, ma_uint64 frameIndex)
{
    if (pPagedAudioBuffer == NULL) {
        return MA_INVALID_ARGS;
    }

    if (frameIndex == pPagedAudioBuffer->absoluteCursor) {
        return MA_SUCCESS;  /* Nothing to do. */
    }

    if (frameIndex < pPagedAudioBuffer->absoluteCursor) {
        /* Moving backwards. Need to move the cursor back to the start, and then move forward. */
        pPagedAudioBuffer->pCurrent       = ma_paged_audio_buffer_data_get_head(pPagedAudioBuffer->pData);
        pPagedAudioBuffer->absoluteCursor = 0;
        pPagedAudioBuffer->relativeCursor = 0;

        /* Fall through to the forward seeking section below. */
    }

    if (frameIndex > pPagedAudioBuffer->absoluteCursor) {
        /* Moving forward. */
        ma_paged_audio_buffer_page* pPage;
        ma_uint64 runningCursor = 0;

        for (pPage = (ma_paged_audio_buffer_page*)ma_atomic_load_ptr(&ma_paged_audio_buffer_data_get_head(pPagedAudioBuffer->pData)->pNext); pPage != NULL; pPage = (ma_paged_audio_buffer_page*)ma_atomic_load_ptr(&pPage->pNext)) {
            ma_uint64 pageRangeBeg = runningCursor;
            ma_uint64 pageRangeEnd = pageRangeBeg + pPage->sizeInFrames;

            if (frameIndex >= pageRangeBeg) {
                if (frameIndex < pageRangeEnd || (frameIndex == pageRangeEnd && pPage == (ma_paged_audio_buffer_page*)ma_atomic_load_ptr(ma_paged_audio_buffer_data_get_tail(pPagedAudioBuffer->pData)))) {  /* A small edge case - allow seeking to the very end of the buffer. */
                    /* We found the page. */
                    pPagedAudioBuffer->pCurrent       = pPage;
                    pPagedAudioBuffer->absoluteCursor = frameIndex;
                    pPagedAudioBuffer->relativeCursor = frameIndex - pageRangeBeg;
                    return MA_SUCCESS;
                }
            }

            runningCursor = pageRangeEnd;
        }

        /* Getting here means we tried seeking too far forward. Don't change any state. */
        return MA_BAD_SEEK;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_paged_audio_buffer_get_cursor_in_pcm_frames(ma_paged_audio_buffer* pPagedAudioBuffer, ma_uint64* pCursor)
{
    if (pCursor == NULL) {
        return MA_INVALID_ARGS;
    }

    *pCursor = 0;   /* Safety. */

    if (pPagedAudioBuffer == NULL) {
        return MA_INVALID_ARGS;
    }

    *pCursor = pPagedAudioBuffer->absoluteCursor;

    return MA_SUCCESS;
}

MA_API ma_result ma_paged_audio_buffer_get_length_in_pcm_frames(ma_paged_audio_buffer* pPagedAudioBuffer, ma_uint64* pLength)
{
    return ma_paged_audio_buffer_data_get_length_in_pcm_frames(pPagedAudioBuffer->pData, pLength);
}



/**************************************************************************************************************************************************************

VFS

**************************************************************************************************************************************************************/
MA_API ma_result ma_vfs_open(ma_vfs* pVFS, const char* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile)
{
    ma_vfs_callbacks* pCallbacks = (ma_vfs_callbacks*)pVFS;

    if (pFile == NULL) {
        return MA_INVALID_ARGS;
    }

    *pFile = NULL;

    if (pVFS == NULL || pFilePath == NULL || openMode == 0) {
        return MA_INVALID_ARGS;
    }

    if (pCallbacks->onOpen == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    return pCallbacks->onOpen(pVFS, pFilePath, openMode, pFile);
}

MA_API ma_result ma_vfs_open_w(ma_vfs* pVFS, const wchar_t* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile)
{
    ma_vfs_callbacks* pCallbacks = (ma_vfs_callbacks*)pVFS;

    if (pFile == NULL) {
        return MA_INVALID_ARGS;
    }

    *pFile = NULL;

    if (pVFS == NULL || pFilePath == NULL || openMode == 0) {
        return MA_INVALID_ARGS;
    }

    if (pCallbacks->onOpenW == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    return pCallbacks->onOpenW(pVFS, pFilePath, openMode, pFile);
}

MA_API ma_result ma_vfs_close(ma_vfs* pVFS, ma_vfs_file file)
{
    ma_vfs_callbacks* pCallbacks = (ma_vfs_callbacks*)pVFS;

    if (pVFS == NULL || file == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pCallbacks->onClose == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    return pCallbacks->onClose(pVFS, file);
}

MA_API ma_result ma_vfs_read(ma_vfs* pVFS, ma_vfs_file file, void* pDst, size_t sizeInBytes, size_t* pBytesRead)
{
    ma_vfs_callbacks* pCallbacks = (ma_vfs_callbacks*)pVFS;
    ma_result result;
    size_t bytesRead = 0;

    if (pBytesRead != NULL) {
        *pBytesRead = 0;
    }

    if (pVFS == NULL || file == NULL || pDst == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pCallbacks->onRead == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    result = pCallbacks->onRead(pVFS, file, pDst, sizeInBytes, &bytesRead);

    if (pBytesRead != NULL) {
        *pBytesRead = bytesRead;
    }

    if (result == MA_SUCCESS && bytesRead == 0 && sizeInBytes > 0) {
        result  = MA_AT_END;
    }

    return result;
}

MA_API ma_result ma_vfs_write(ma_vfs* pVFS, ma_vfs_file file, const void* pSrc, size_t sizeInBytes, size_t* pBytesWritten)
{
    ma_vfs_callbacks* pCallbacks = (ma_vfs_callbacks*)pVFS;

    if (pBytesWritten != NULL) {
        *pBytesWritten = 0;
    }

    if (pVFS == NULL || file == NULL || pSrc == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pCallbacks->onWrite == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    return pCallbacks->onWrite(pVFS, file, pSrc, sizeInBytes, pBytesWritten);
}

MA_API ma_result ma_vfs_seek(ma_vfs* pVFS, ma_vfs_file file, ma_int64 offset, ma_seek_origin origin)
{
    ma_vfs_callbacks* pCallbacks = (ma_vfs_callbacks*)pVFS;

    if (pVFS == NULL || file == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pCallbacks->onSeek == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    return pCallbacks->onSeek(pVFS, file, offset, origin);
}

MA_API ma_result ma_vfs_tell(ma_vfs* pVFS, ma_vfs_file file, ma_int64* pCursor)
{
    ma_vfs_callbacks* pCallbacks = (ma_vfs_callbacks*)pVFS;

    if (pCursor == NULL) {
        return MA_INVALID_ARGS;
    }

    *pCursor = 0;

    if (pVFS == NULL || file == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pCallbacks->onTell == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    return pCallbacks->onTell(pVFS, file, pCursor);
}

MA_API ma_result ma_vfs_info(ma_vfs* pVFS, ma_vfs_file file, ma_file_info* pInfo)
{
    ma_vfs_callbacks* pCallbacks = (ma_vfs_callbacks*)pVFS;

    if (pInfo == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pInfo);

    if (pVFS == NULL || file == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pCallbacks->onInfo == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    return pCallbacks->onInfo(pVFS, file, pInfo);
}


#if !defined(MA_USE_WIN32_FILEIO) && (defined(MA_WIN32) && defined(MA_WIN32_DESKTOP) && !defined(MA_NO_WIN32_FILEIO) && !defined(MA_POSIX))
    #define MA_USE_WIN32_FILEIO
#endif

#if defined(MA_USE_WIN32_FILEIO)
/*
We need to dynamically load SetFilePointer or SetFilePointerEx because older versions of Windows do
not have the Ex version. We therefore need to do some dynamic branching depending on what's available.

We load these when we load our first file from the default VFS. It's left open for the life of the
program and is left to the OS to uninitialize when the program terminates.
*/
typedef DWORD (__stdcall * ma_SetFilePointer_proc)(HANDLE hFile, LONG lDistanceToMove, LONG* lpDistanceToMoveHigh, DWORD dwMoveMethod);
typedef BOOL  (__stdcall * ma_SetFilePointerEx_proc)(HANDLE hFile, LARGE_INTEGER liDistanceToMove, LARGE_INTEGER* lpNewFilePointer, DWORD dwMoveMethod);

static ma_handle hKernel32DLL = NULL;
static ma_SetFilePointer_proc   ma_SetFilePointer   = NULL;
static ma_SetFilePointerEx_proc ma_SetFilePointerEx = NULL;

static void ma_win32_fileio_init(void)
{
    if (hKernel32DLL == NULL) {
        hKernel32DLL = ma_dlopen(NULL, "kernel32.dll");
        if (hKernel32DLL != NULL) {
            ma_SetFilePointer   = (ma_SetFilePointer_proc)  ma_dlsym(NULL, hKernel32DLL, "SetFilePointer");
            ma_SetFilePointerEx = (ma_SetFilePointerEx_proc)ma_dlsym(NULL, hKernel32DLL, "SetFilePointerEx");
        }
    }
}

static void ma_default_vfs__get_open_settings_win32(ma_uint32 openMode, DWORD* pDesiredAccess, DWORD* pShareMode, DWORD* pCreationDisposition)
{
    *pDesiredAccess = 0;
    if ((openMode & MA_OPEN_MODE_READ) != 0) {
        *pDesiredAccess |= GENERIC_READ;
    }
    if ((openMode & MA_OPEN_MODE_WRITE) != 0) {
        *pDesiredAccess |= GENERIC_WRITE;
    }

    *pShareMode = 0;
    if ((openMode & MA_OPEN_MODE_READ) != 0) {
        *pShareMode |= FILE_SHARE_READ;
    }

    if ((openMode & MA_OPEN_MODE_WRITE) != 0) {
        *pCreationDisposition = CREATE_ALWAYS;  /* Opening in write mode. Truncate. */
    } else {
        *pCreationDisposition = OPEN_EXISTING;  /* Opening in read mode. File must exist. */
    }
}

static ma_result ma_default_vfs_open__win32(ma_vfs* pVFS, const char* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile)
{
    HANDLE hFile;
    DWORD dwDesiredAccess;
    DWORD dwShareMode;
    DWORD dwCreationDisposition;

    (void)pVFS;

    /* Load some Win32 symbols dynamically so we can dynamically check for the existence of SetFilePointerEx. */
    ma_win32_fileio_init();

    ma_default_vfs__get_open_settings_win32(openMode, &dwDesiredAccess, &dwShareMode, &dwCreationDisposition);

    hFile = CreateFileA(pFilePath, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        return ma_result_from_GetLastError(GetLastError());
    }

    *pFile = hFile;
    return MA_SUCCESS;
}

static ma_result ma_default_vfs_open_w__win32(ma_vfs* pVFS, const wchar_t* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile)
{
    HANDLE hFile;
    DWORD dwDesiredAccess;
    DWORD dwShareMode;
    DWORD dwCreationDisposition;

    (void)pVFS;

    /* Load some Win32 symbols dynamically so we can dynamically check for the existence of SetFilePointerEx. */
    ma_win32_fileio_init();

    ma_default_vfs__get_open_settings_win32(openMode, &dwDesiredAccess, &dwShareMode, &dwCreationDisposition);

    hFile = CreateFileW(pFilePath, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        return ma_result_from_GetLastError(GetLastError());
    }

    *pFile = hFile;
    return MA_SUCCESS;
}

static ma_result ma_default_vfs_close__win32(ma_vfs* pVFS, ma_vfs_file file)
{
    (void)pVFS;

    if (CloseHandle((HANDLE)file) == 0) {
        return ma_result_from_GetLastError(GetLastError());
    }

    return MA_SUCCESS;
}


static ma_result ma_default_vfs_read__win32(ma_vfs* pVFS, ma_vfs_file file, void* pDst, size_t sizeInBytes, size_t* pBytesRead)
{
    ma_result result = MA_SUCCESS;
    size_t totalBytesRead;

    (void)pVFS;

    totalBytesRead = 0;
    while (totalBytesRead < sizeInBytes) {
        size_t bytesRemaining;
        DWORD bytesToRead;
        DWORD bytesRead;
        BOOL readResult;

        bytesRemaining = sizeInBytes - totalBytesRead;
        if (bytesRemaining >= 0xFFFFFFFF) {
            bytesToRead = 0xFFFFFFFF;
        } else {
            bytesToRead = (DWORD)bytesRemaining;
        }

        readResult = ReadFile((HANDLE)file, ma_offset_ptr(pDst, totalBytesRead), bytesToRead, &bytesRead, NULL);
        if (readResult == 1 && bytesRead == 0) {
            result = MA_AT_END;
            break;  /* EOF */
        }

        totalBytesRead += bytesRead;

        if (bytesRead < bytesToRead) {
            break;  /* EOF */
        }

        if (readResult == 0) {
            result = ma_result_from_GetLastError(GetLastError());
            break;
        }
    }

    if (pBytesRead != NULL) {
        *pBytesRead = totalBytesRead;
    }

    return result;
}

static ma_result ma_default_vfs_write__win32(ma_vfs* pVFS, ma_vfs_file file, const void* pSrc, size_t sizeInBytes, size_t* pBytesWritten)
{
    ma_result result = MA_SUCCESS;
    size_t totalBytesWritten;

    (void)pVFS;

    totalBytesWritten = 0;
    while (totalBytesWritten < sizeInBytes) {
        size_t bytesRemaining;
        DWORD bytesToWrite;
        DWORD bytesWritten;
        BOOL writeResult;

        bytesRemaining = sizeInBytes - totalBytesWritten;
        if (bytesRemaining >= 0xFFFFFFFF) {
            bytesToWrite = 0xFFFFFFFF;
        } else {
            bytesToWrite = (DWORD)bytesRemaining;
        }

        writeResult = WriteFile((HANDLE)file, ma_offset_ptr(pSrc, totalBytesWritten), bytesToWrite, &bytesWritten, NULL);
        totalBytesWritten += bytesWritten;

        if (writeResult == 0) {
            result = ma_result_from_GetLastError(GetLastError());
            break;
        }
    }

    if (pBytesWritten != NULL) {
        *pBytesWritten = totalBytesWritten;
    }

    return result;
}


static ma_result ma_default_vfs_seek__win32(ma_vfs* pVFS, ma_vfs_file file, ma_int64 offset, ma_seek_origin origin)
{
    LARGE_INTEGER liDistanceToMove;
    DWORD dwMoveMethod;
    BOOL result;

    (void)pVFS;

    liDistanceToMove.QuadPart = offset;

    /*  */ if (origin == ma_seek_origin_current) {
        dwMoveMethod = FILE_CURRENT;
    } else if (origin == ma_seek_origin_end) {
        dwMoveMethod = FILE_END;
    } else {
        dwMoveMethod = FILE_BEGIN;
    }

    if (ma_SetFilePointerEx != NULL) {
        result = ma_SetFilePointerEx((HANDLE)file, liDistanceToMove, NULL, dwMoveMethod);
    } else if (ma_SetFilePointer != NULL) {
        /* No SetFilePointerEx() so restrict to 31 bits. */
        if (offset > 0x7FFFFFFF) {
            return MA_OUT_OF_RANGE;
        }

        result = ma_SetFilePointer((HANDLE)file, (LONG)liDistanceToMove.QuadPart, NULL, dwMoveMethod);
    } else {
        return MA_NOT_IMPLEMENTED;
    }

    if (result == 0) {
        return ma_result_from_GetLastError(GetLastError());
    }

    return MA_SUCCESS;
}

static ma_result ma_default_vfs_tell__win32(ma_vfs* pVFS, ma_vfs_file file, ma_int64* pCursor)
{
    LARGE_INTEGER liZero;
    LARGE_INTEGER liTell;
    BOOL result;

    (void)pVFS;

    liZero.QuadPart = 0;

    if (ma_SetFilePointerEx != NULL) {
        result = ma_SetFilePointerEx((HANDLE)file, liZero, &liTell, FILE_CURRENT);
    } else if (ma_SetFilePointer != NULL) {
        LONG tell;

        result = ma_SetFilePointer((HANDLE)file, (LONG)liZero.QuadPart, &tell, FILE_CURRENT);
        liTell.QuadPart = tell;
    } else {
        return MA_NOT_IMPLEMENTED;
    }

    if (result == 0) {
        return ma_result_from_GetLastError(GetLastError());
    }

    if (pCursor != NULL) {
        *pCursor = liTell.QuadPart;
    }

    return MA_SUCCESS;
}

static ma_result ma_default_vfs_info__win32(ma_vfs* pVFS, ma_vfs_file file, ma_file_info* pInfo)
{
    BY_HANDLE_FILE_INFORMATION fi;
    BOOL result;

    (void)pVFS;

    result = GetFileInformationByHandle((HANDLE)file, &fi);
    if (result == 0) {
        return ma_result_from_GetLastError(GetLastError());
    }

    pInfo->sizeInBytes = ((ma_uint64)fi.nFileSizeHigh << 32) | ((ma_uint64)fi.nFileSizeLow);

    return MA_SUCCESS;
}
#else
static ma_result ma_default_vfs_open__stdio(ma_vfs* pVFS, const char* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile)
{
    ma_result result;
    FILE* pFileStd;
    const char* pOpenModeStr;

    MA_ASSERT(pFilePath != NULL);
    MA_ASSERT(openMode  != 0);
    MA_ASSERT(pFile     != NULL);

    (void)pVFS;

    if ((openMode & MA_OPEN_MODE_READ) != 0) {
        if ((openMode & MA_OPEN_MODE_WRITE) != 0) {
            pOpenModeStr = "r+";
        } else {
            pOpenModeStr = "rb";
        }
    } else {
        pOpenModeStr = "wb";
    }

    result = ma_fopen(&pFileStd, pFilePath, pOpenModeStr);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pFile = pFileStd;

    return MA_SUCCESS;
}

static ma_result ma_default_vfs_open_w__stdio(ma_vfs* pVFS, const wchar_t* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile)
{
    ma_result result;
    FILE* pFileStd;
    const wchar_t* pOpenModeStr;

    MA_ASSERT(pFilePath != NULL);
    MA_ASSERT(openMode  != 0);
    MA_ASSERT(pFile     != NULL);

    (void)pVFS;

    if ((openMode & MA_OPEN_MODE_READ) != 0) {
        if ((openMode & MA_OPEN_MODE_WRITE) != 0) {
            pOpenModeStr = L"r+";
        } else {
            pOpenModeStr = L"rb";
        }
    } else {
        pOpenModeStr = L"wb";
    }

    result = ma_wfopen(&pFileStd, pFilePath, pOpenModeStr, (pVFS != NULL) ? &((ma_default_vfs*)pVFS)->allocationCallbacks : NULL);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pFile = pFileStd;

    return MA_SUCCESS;
}

static ma_result ma_default_vfs_close__stdio(ma_vfs* pVFS, ma_vfs_file file)
{
    MA_ASSERT(file != NULL);

    (void)pVFS;

    fclose((FILE*)file);

    return MA_SUCCESS;
}

static ma_result ma_default_vfs_read__stdio(ma_vfs* pVFS, ma_vfs_file file, void* pDst, size_t sizeInBytes, size_t* pBytesRead)
{
    size_t result;

    MA_ASSERT(file != NULL);
    MA_ASSERT(pDst != NULL);

    (void)pVFS;

    result = fread(pDst, 1, sizeInBytes, (FILE*)file);

    if (pBytesRead != NULL) {
        *pBytesRead = result;
    }

    if (result != sizeInBytes) {
        if (result == 0 && feof((FILE*)file)) {
            return MA_AT_END;
        } else {
            return ma_result_from_errno(ferror((FILE*)file));
        }
    }

    return MA_SUCCESS;
}

static ma_result ma_default_vfs_write__stdio(ma_vfs* pVFS, ma_vfs_file file, const void* pSrc, size_t sizeInBytes, size_t* pBytesWritten)
{
    size_t result;

    MA_ASSERT(file != NULL);
    MA_ASSERT(pSrc != NULL);

    (void)pVFS;

    result = fwrite(pSrc, 1, sizeInBytes, (FILE*)file);

    if (pBytesWritten != NULL) {
        *pBytesWritten = result;
    }

    if (result != sizeInBytes) {
        return ma_result_from_errno(ferror((FILE*)file));
    }

    return MA_SUCCESS;
}

static ma_result ma_default_vfs_seek__stdio(ma_vfs* pVFS, ma_vfs_file file, ma_int64 offset, ma_seek_origin origin)
{
    int result;
    int whence;

    MA_ASSERT(file != NULL);

    (void)pVFS;

    if (origin == ma_seek_origin_start) {
        whence = SEEK_SET;
    } else if (origin == ma_seek_origin_end) {
        whence = SEEK_END;
    } else {
        whence = SEEK_CUR;
    }

#if defined(_WIN32)
    #if defined(_MSC_VER) && _MSC_VER > 1200
        result = _fseeki64((FILE*)file, offset, whence);
    #else
        /* No _fseeki64() so restrict to 31 bits. */
        if (offset > 0x7FFFFFFF) {
            return MA_OUT_OF_RANGE;
        }

        result = fseek((FILE*)file, (int)offset, whence);
    #endif
#else
    result = fseek((FILE*)file, (long int)offset, whence);
#endif
    if (result != 0) {
        return MA_ERROR;
    }

    return MA_SUCCESS;
}

static ma_result ma_default_vfs_tell__stdio(ma_vfs* pVFS, ma_vfs_file file, ma_int64* pCursor)
{
    ma_int64 result;

    MA_ASSERT(file    != NULL);
    MA_ASSERT(pCursor != NULL);

    (void)pVFS;

#if defined(_WIN32)
    #if defined(_MSC_VER) && _MSC_VER > 1200
        result = _ftelli64((FILE*)file);
    #else
        result = ftell((FILE*)file);
    #endif
#else
    result = ftell((FILE*)file);
#endif

    *pCursor = result;

    return MA_SUCCESS;
}

#if !defined(_MSC_VER) && !((defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 1) || defined(_XOPEN_SOURCE) || defined(_POSIX_SOURCE)) && !defined(MA_BSD)
int fileno(FILE *stream);
#endif

static ma_result ma_default_vfs_info__stdio(ma_vfs* pVFS, ma_vfs_file file, ma_file_info* pInfo)
{
    int fd;
    struct stat info;

    MA_ASSERT(file  != NULL);
    MA_ASSERT(pInfo != NULL);

    (void)pVFS;

#if defined(_MSC_VER)
    fd = _fileno((FILE*)file);
#else
    fd =  fileno((FILE*)file);
#endif

    if (fstat(fd, &info) != 0) {
        return ma_result_from_errno(errno);
    }

    pInfo->sizeInBytes = info.st_size;

    return MA_SUCCESS;
}
#endif


static ma_result ma_default_vfs_open(ma_vfs* pVFS, const char* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile)
{
    if (pFile == NULL) {
        return MA_INVALID_ARGS;
    }

    *pFile = NULL;

    if (pFilePath == NULL || openMode == 0) {
        return MA_INVALID_ARGS;
    }

#if defined(MA_USE_WIN32_FILEIO)
    return ma_default_vfs_open__win32(pVFS, pFilePath, openMode, pFile);
#else
    return ma_default_vfs_open__stdio(pVFS, pFilePath, openMode, pFile);
#endif
}

static ma_result ma_default_vfs_open_w(ma_vfs* pVFS, const wchar_t* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile)
{
    if (pFile == NULL) {
        return MA_INVALID_ARGS;
    }

    *pFile = NULL;

    if (pFilePath == NULL || openMode == 0) {
        return MA_INVALID_ARGS;
    }

#if defined(MA_USE_WIN32_FILEIO)
    return ma_default_vfs_open_w__win32(pVFS, pFilePath, openMode, pFile);
#else
    return ma_default_vfs_open_w__stdio(pVFS, pFilePath, openMode, pFile);
#endif
}

static ma_result ma_default_vfs_close(ma_vfs* pVFS, ma_vfs_file file)
{
    if (file == NULL) {
        return MA_INVALID_ARGS;
    }

#if defined(MA_USE_WIN32_FILEIO)
    return ma_default_vfs_close__win32(pVFS, file);
#else
    return ma_default_vfs_close__stdio(pVFS, file);
#endif
}

static ma_result ma_default_vfs_read(ma_vfs* pVFS, ma_vfs_file file, void* pDst, size_t sizeInBytes, size_t* pBytesRead)
{
    if (pBytesRead != NULL) {
        *pBytesRead = 0;
    }

    if (file == NULL || pDst == NULL) {
        return MA_INVALID_ARGS;
    }

#if defined(MA_USE_WIN32_FILEIO)
    return ma_default_vfs_read__win32(pVFS, file, pDst, sizeInBytes, pBytesRead);
#else
    return ma_default_vfs_read__stdio(pVFS, file, pDst, sizeInBytes, pBytesRead);
#endif
}

static ma_result ma_default_vfs_write(ma_vfs* pVFS, ma_vfs_file file, const void* pSrc, size_t sizeInBytes, size_t* pBytesWritten)
{
    if (pBytesWritten != NULL) {
        *pBytesWritten = 0;
    }

    if (file == NULL || pSrc == NULL) {
        return MA_INVALID_ARGS;
    }

#if defined(MA_USE_WIN32_FILEIO)
    return ma_default_vfs_write__win32(pVFS, file, pSrc, sizeInBytes, pBytesWritten);
#else
    return ma_default_vfs_write__stdio(pVFS, file, pSrc, sizeInBytes, pBytesWritten);
#endif
}

static ma_result ma_default_vfs_seek(ma_vfs* pVFS, ma_vfs_file file, ma_int64 offset, ma_seek_origin origin)
{
    if (file == NULL) {
        return MA_INVALID_ARGS;
    }

#if defined(MA_USE_WIN32_FILEIO)
    return ma_default_vfs_seek__win32(pVFS, file, offset, origin);
#else
    return ma_default_vfs_seek__stdio(pVFS, file, offset, origin);
#endif
}

static ma_result ma_default_vfs_tell(ma_vfs* pVFS, ma_vfs_file file, ma_int64* pCursor)
{
    if (pCursor == NULL) {
        return MA_INVALID_ARGS;
    }

    *pCursor = 0;

    if (file == NULL) {
        return MA_INVALID_ARGS;
    }

#if defined(MA_USE_WIN32_FILEIO)
    return ma_default_vfs_tell__win32(pVFS, file, pCursor);
#else
    return ma_default_vfs_tell__stdio(pVFS, file, pCursor);
#endif
}

static ma_result ma_default_vfs_info(ma_vfs* pVFS, ma_vfs_file file, ma_file_info* pInfo)
{
    if (pInfo == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pInfo);

    if (file == NULL) {
        return MA_INVALID_ARGS;
    }

#if defined(MA_USE_WIN32_FILEIO)
    return ma_default_vfs_info__win32(pVFS, file, pInfo);
#else
    return ma_default_vfs_info__stdio(pVFS, file, pInfo);
#endif
}


MA_API ma_result ma_default_vfs_init(ma_default_vfs* pVFS, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pVFS == NULL) {
        return MA_INVALID_ARGS;
    }

    pVFS->cb.onOpen  = ma_default_vfs_open;
    pVFS->cb.onOpenW = ma_default_vfs_open_w;
    pVFS->cb.onClose = ma_default_vfs_close;
    pVFS->cb.onRead  = ma_default_vfs_read;
    pVFS->cb.onWrite = ma_default_vfs_write;
    pVFS->cb.onSeek  = ma_default_vfs_seek;
    pVFS->cb.onTell  = ma_default_vfs_tell;
    pVFS->cb.onInfo  = ma_default_vfs_info;
    ma_allocation_callbacks_init_copy(&pVFS->allocationCallbacks, pAllocationCallbacks);

    return MA_SUCCESS;
}


MA_API ma_result ma_vfs_or_default_open(ma_vfs* pVFS, const char* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile)
{
    if (pVFS != NULL) {
        return ma_vfs_open(pVFS, pFilePath, openMode, pFile);
    } else {
        return ma_default_vfs_open(pVFS, pFilePath, openMode, pFile);
    }
}

MA_API ma_result ma_vfs_or_default_open_w(ma_vfs* pVFS, const wchar_t* pFilePath, ma_uint32 openMode, ma_vfs_file* pFile)
{
    if (pVFS != NULL) {
        return ma_vfs_open_w(pVFS, pFilePath, openMode, pFile);
    } else {
        return ma_default_vfs_open_w(pVFS, pFilePath, openMode, pFile);
    }
}

MA_API ma_result ma_vfs_or_default_close(ma_vfs* pVFS, ma_vfs_file file)
{
    if (pVFS != NULL) {
        return ma_vfs_close(pVFS, file);
    } else {
        return ma_default_vfs_close(pVFS, file);
    }
}

MA_API ma_result ma_vfs_or_default_read(ma_vfs* pVFS, ma_vfs_file file, void* pDst, size_t sizeInBytes, size_t* pBytesRead)
{
    if (pVFS != NULL) {
        return ma_vfs_read(pVFS, file, pDst, sizeInBytes, pBytesRead);
    } else {
        return ma_default_vfs_read(pVFS, file, pDst, sizeInBytes, pBytesRead);
    }
}

MA_API ma_result ma_vfs_or_default_write(ma_vfs* pVFS, ma_vfs_file file, const void* pSrc, size_t sizeInBytes, size_t* pBytesWritten)
{
    if (pVFS != NULL) {
        return ma_vfs_write(pVFS, file, pSrc, sizeInBytes, pBytesWritten);
    } else {
        return ma_default_vfs_write(pVFS, file, pSrc, sizeInBytes, pBytesWritten);
    }
}

MA_API ma_result ma_vfs_or_default_seek(ma_vfs* pVFS, ma_vfs_file file, ma_int64 offset, ma_seek_origin origin)
{
    if (pVFS != NULL) {
        return ma_vfs_seek(pVFS, file, offset, origin);
    } else {
        return ma_default_vfs_seek(pVFS, file, offset, origin);
    }
}

MA_API ma_result ma_vfs_or_default_tell(ma_vfs* pVFS, ma_vfs_file file, ma_int64* pCursor)
{
    if (pVFS != NULL) {
        return ma_vfs_tell(pVFS, file, pCursor);
    } else {
        return ma_default_vfs_tell(pVFS, file, pCursor);
    }
}

MA_API ma_result ma_vfs_or_default_info(ma_vfs* pVFS, ma_vfs_file file, ma_file_info* pInfo)
{
    if (pVFS != NULL) {
        return ma_vfs_info(pVFS, file, pInfo);
    } else {
        return ma_default_vfs_info(pVFS, file, pInfo);
    }
}



static ma_result ma_vfs_open_and_read_file_ex(ma_vfs* pVFS, const char* pFilePath, const wchar_t* pFilePathW, void** ppData, size_t* pSize, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_result result;
    ma_vfs_file file;
    ma_file_info info;
    void* pData;
    size_t bytesRead;

    if (ppData != NULL) {
        *ppData = NULL;
    }
    if (pSize != NULL) {
        *pSize = 0;
    }

    if (ppData == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pFilePath != NULL) {
        result = ma_vfs_or_default_open(pVFS, pFilePath, MA_OPEN_MODE_READ, &file);
    } else {
        result = ma_vfs_or_default_open_w(pVFS, pFilePathW, MA_OPEN_MODE_READ, &file);
    }
    if (result != MA_SUCCESS) {
        return result;
    }

    result = ma_vfs_or_default_info(pVFS, file, &info);
    if (result != MA_SUCCESS) {
        ma_vfs_or_default_close(pVFS, file);
        return result;
    }

    if (info.sizeInBytes > MA_SIZE_MAX) {
        ma_vfs_or_default_close(pVFS, file);
        return MA_TOO_BIG;
    }

    pData = ma_malloc((size_t)info.sizeInBytes, pAllocationCallbacks);  /* Safe cast. */
    if (pData == NULL) {
        ma_vfs_or_default_close(pVFS, file);
        return result;
    }

    result = ma_vfs_or_default_read(pVFS, file, pData, (size_t)info.sizeInBytes, &bytesRead);  /* Safe cast. */
    ma_vfs_or_default_close(pVFS, file);

    if (result != MA_SUCCESS) {
        ma_free(pData, pAllocationCallbacks);
        return result;
    }

    if (pSize != NULL) {
        *pSize = bytesRead;
    }

    MA_ASSERT(ppData != NULL);
    *ppData = pData;

    return MA_SUCCESS;
}

MA_API ma_result ma_vfs_open_and_read_file(ma_vfs* pVFS, const char* pFilePath, void** ppData, size_t* pSize, const ma_allocation_callbacks* pAllocationCallbacks)
{
    return ma_vfs_open_and_read_file_ex(pVFS, pFilePath, NULL, ppData, pSize, pAllocationCallbacks);
}

MA_API ma_result ma_vfs_open_and_read_file_w(ma_vfs* pVFS, const wchar_t* pFilePath, void** ppData, size_t* pSize, const ma_allocation_callbacks* pAllocationCallbacks)
{
    return ma_vfs_open_and_read_file_ex(pVFS, NULL, pFilePath, ppData, pSize, pAllocationCallbacks);
}



/**************************************************************************************************************************************************************

Decoding and Encoding Headers. These are auto-generated from a tool.

**************************************************************************************************************************************************************/




/**************************************************************************************************************************************************************

Decoding

**************************************************************************************************************************************************************/
#ifndef MA_NO_DECODING

static ma_result ma_decoder_read_bytes(ma_decoder* pDecoder, void* pBufferOut, size_t bytesToRead, size_t* pBytesRead)
{
    MA_ASSERT(pDecoder != NULL);

    return pDecoder->onRead(pDecoder, pBufferOut, bytesToRead, pBytesRead);
}

static ma_result ma_decoder_seek_bytes(ma_decoder* pDecoder, ma_int64 byteOffset, ma_seek_origin origin)
{
    MA_ASSERT(pDecoder != NULL);

    return pDecoder->onSeek(pDecoder, byteOffset, origin);
}

static ma_result ma_decoder_tell_bytes(ma_decoder* pDecoder, ma_int64* pCursor)
{
    MA_ASSERT(pDecoder != NULL);

    if (pDecoder->onTell == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    return pDecoder->onTell(pDecoder, pCursor);
}


MA_API ma_decoding_backend_config ma_decoding_backend_config_init(ma_format preferredFormat, ma_uint32 seekPointCount)
{
    ma_decoding_backend_config config;

    MA_ZERO_OBJECT(&config);
    config.preferredFormat = preferredFormat;
    config.seekPointCount  = seekPointCount;

    return config;
}


MA_API ma_decoder_config ma_decoder_config_init(ma_format outputFormat, ma_uint32 outputChannels, ma_uint32 outputSampleRate)
{
    ma_decoder_config config;
    MA_ZERO_OBJECT(&config);
    config.format         = outputFormat;
    config.channels       = outputChannels;
    config.sampleRate     = outputSampleRate;
    config.resampling     = ma_resampler_config_init(ma_format_unknown, 0, 0, 0, ma_resample_algorithm_linear); /* Format/channels/rate doesn't matter here. */
    config.encodingFormat = ma_encoding_format_unknown;

    /* Note that we are intentionally leaving the channel map empty here which will cause the default channel map to be used. */

    return config;
}

MA_API ma_decoder_config ma_decoder_config_init_default(void)
{
    return ma_decoder_config_init(ma_format_unknown, 0, 0);
}

MA_API ma_decoder_config ma_decoder_config_init_copy(const ma_decoder_config* pConfig)
{
    ma_decoder_config config;
    if (pConfig != NULL) {
        config = *pConfig;
    } else {
        MA_ZERO_OBJECT(&config);
    }

    return config;
}

static ma_result ma_decoder__init_data_converter(ma_decoder* pDecoder, const ma_decoder_config* pConfig)
{
    ma_result result;
    ma_data_converter_config converterConfig;
    ma_format internalFormat;
    ma_uint32 internalChannels;
    ma_uint32 internalSampleRate;
    ma_channel internalChannelMap[MA_MAX_CHANNELS];

    MA_ASSERT(pDecoder != NULL);
    MA_ASSERT(pConfig  != NULL);

    result = ma_data_source_get_data_format(pDecoder->pBackend, &internalFormat, &internalChannels, &internalSampleRate, internalChannelMap, ma_countof(internalChannelMap));
    if (result != MA_SUCCESS) {
        return result;  /* Failed to retrieve the internal data format. */
    }


    /* Make sure we're not asking for too many channels. */
    if (pConfig->channels > MA_MAX_CHANNELS) {
        return MA_INVALID_ARGS;
    }

    /* The internal channels should have already been validated at a higher level, but we'll do it again explicitly here for safety. */
    if (internalChannels > MA_MAX_CHANNELS) {
        return MA_INVALID_ARGS;
    }


    /* Output format. */
    if (pConfig->format == ma_format_unknown) {
        pDecoder->outputFormat = internalFormat;
    } else {
        pDecoder->outputFormat = pConfig->format;
    }

    if (pConfig->channels == 0) {
        pDecoder->outputChannels = internalChannels;
    } else {
        pDecoder->outputChannels = pConfig->channels;
    }

    if (pConfig->sampleRate == 0) {
        pDecoder->outputSampleRate = internalSampleRate;
    } else {
        pDecoder->outputSampleRate = pConfig->sampleRate;
    }

    converterConfig = ma_data_converter_config_init(
        internalFormat,     pDecoder->outputFormat,
        internalChannels,   pDecoder->outputChannels,
        internalSampleRate, pDecoder->outputSampleRate
    );
    converterConfig.pChannelMapIn          = internalChannelMap;
    converterConfig.pChannelMapOut         = pConfig->pChannelMap;
    converterConfig.channelMixMode         = pConfig->channelMixMode;
    converterConfig.ditherMode             = pConfig->ditherMode;
    converterConfig.allowDynamicSampleRate = MA_FALSE;   /* Never allow dynamic sample rate conversion. Setting this to true will disable passthrough optimizations. */
    converterConfig.resampling             = pConfig->resampling;

    result = ma_data_converter_init(&converterConfig, &pDecoder->allocationCallbacks, &pDecoder->converter);
    if (result != MA_SUCCESS) {
        return result;
    }

    /*
    Now that we have the decoder we need to determine whether or not we need a heap-allocated cache. We'll
    need this if the data converter does not support calculation of the required input frame count. To
    determine support for this we'll just run a test.
    */
    {
        ma_uint64 unused;

        result = ma_data_converter_get_required_input_frame_count(&pDecoder->converter, 1, &unused);
        if (result != MA_SUCCESS) {
            /*
            We were unable to calculate the required input frame count which means we'll need to use
            a heap-allocated cache.
            */
            ma_uint64 inputCacheCapSizeInBytes;

            pDecoder->inputCacheCap = MA_DATA_CONVERTER_STACK_BUFFER_SIZE / ma_get_bytes_per_frame(internalFormat, internalChannels);

            /* Not strictly necessary, but keeping here for safety in case we change the default value of pDecoder->inputCacheCap. */
            inputCacheCapSizeInBytes = pDecoder->inputCacheCap * ma_get_bytes_per_frame(internalFormat, internalChannels);
            if (inputCacheCapSizeInBytes > MA_SIZE_MAX) {
                ma_data_converter_uninit(&pDecoder->converter, &pDecoder->allocationCallbacks);
                return MA_OUT_OF_MEMORY;
            }

            pDecoder->pInputCache = ma_malloc((size_t)inputCacheCapSizeInBytes, &pDecoder->allocationCallbacks);    /* Safe cast to size_t. */
            if (pDecoder->pInputCache == NULL) {
                ma_data_converter_uninit(&pDecoder->converter, &pDecoder->allocationCallbacks);
                return MA_OUT_OF_MEMORY;
            }
        }
    }

    return MA_SUCCESS;
}



static ma_result ma_decoder_internal_on_read__custom(void* pUserData, void* pBufferOut, size_t bytesToRead, size_t* pBytesRead)
{
    ma_decoder* pDecoder = (ma_decoder*)pUserData;
    MA_ASSERT(pDecoder != NULL);

    return ma_decoder_read_bytes(pDecoder, pBufferOut, bytesToRead, pBytesRead);
}

static ma_result ma_decoder_internal_on_seek__custom(void* pUserData, ma_int64 offset, ma_seek_origin origin)
{
    ma_decoder* pDecoder = (ma_decoder*)pUserData;
    MA_ASSERT(pDecoder != NULL);

    return ma_decoder_seek_bytes(pDecoder, offset, origin);
}

static ma_result ma_decoder_internal_on_tell__custom(void* pUserData, ma_int64* pCursor)
{
    ma_decoder* pDecoder = (ma_decoder*)pUserData;
    MA_ASSERT(pDecoder != NULL);

    return ma_decoder_tell_bytes(pDecoder, pCursor);
}


static ma_result ma_decoder_init_from_vtable__internal(const ma_decoding_backend_vtable* pVTable, void* pVTableUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result;
    ma_decoding_backend_config backendConfig;
    ma_data_source* pBackend;

    MA_ASSERT(pVTable  != NULL);
    MA_ASSERT(pConfig  != NULL);
    MA_ASSERT(pDecoder != NULL);

    if (pVTable->onInit == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    backendConfig = ma_decoding_backend_config_init(pConfig->format, pConfig->seekPointCount);

    result = pVTable->onInit(pVTableUserData, ma_decoder_internal_on_read__custom, ma_decoder_internal_on_seek__custom, ma_decoder_internal_on_tell__custom, pDecoder, &backendConfig, &pDecoder->allocationCallbacks, &pBackend);
    if (result != MA_SUCCESS) {
        return result;  /* Failed to initialize the backend from this vtable. */
    }

    /* Getting here means we were able to initialize the backend so we can now initialize the decoder. */
    pDecoder->pBackend         = pBackend;
    pDecoder->pBackendVTable   = pVTable;
    pDecoder->pBackendUserData = pConfig->pCustomBackendUserData;

    return MA_SUCCESS;
}

static ma_result ma_decoder_init_from_file__internal(const ma_decoding_backend_vtable* pVTable, void* pVTableUserData, const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result;
    ma_decoding_backend_config backendConfig;
    ma_data_source* pBackend;

    MA_ASSERT(pVTable  != NULL);
    MA_ASSERT(pConfig  != NULL);
    MA_ASSERT(pDecoder != NULL);

    if (pVTable->onInitFile == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    backendConfig = ma_decoding_backend_config_init(pConfig->format, pConfig->seekPointCount);

    result = pVTable->onInitFile(pVTableUserData, pFilePath, &backendConfig, &pDecoder->allocationCallbacks, &pBackend);
    if (result != MA_SUCCESS) {
        return result;  /* Failed to initialize the backend from this vtable. */
    }

    /* Getting here means we were able to initialize the backend so we can now initialize the decoder. */
    pDecoder->pBackend         = pBackend;
    pDecoder->pBackendVTable   = pVTable;
    pDecoder->pBackendUserData = pConfig->pCustomBackendUserData;

    return MA_SUCCESS;
}

static ma_result ma_decoder_init_from_file_w__internal(const ma_decoding_backend_vtable* pVTable, void* pVTableUserData, const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result;
    ma_decoding_backend_config backendConfig;
    ma_data_source* pBackend;

    MA_ASSERT(pVTable  != NULL);
    MA_ASSERT(pConfig  != NULL);
    MA_ASSERT(pDecoder != NULL);

    if (pVTable->onInitFileW == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    backendConfig = ma_decoding_backend_config_init(pConfig->format, pConfig->seekPointCount);

    result = pVTable->onInitFileW(pVTableUserData, pFilePath, &backendConfig, &pDecoder->allocationCallbacks, &pBackend);
    if (result != MA_SUCCESS) {
        return result;  /* Failed to initialize the backend from this vtable. */
    }

    /* Getting here means we were able to initialize the backend so we can now initialize the decoder. */
    pDecoder->pBackend         = pBackend;
    pDecoder->pBackendVTable   = pVTable;
    pDecoder->pBackendUserData = pConfig->pCustomBackendUserData;

    return MA_SUCCESS;
}

static ma_result ma_decoder_init_from_memory__internal(const ma_decoding_backend_vtable* pVTable, void* pVTableUserData, const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result;
    ma_decoding_backend_config backendConfig;
    ma_data_source* pBackend;

    MA_ASSERT(pVTable  != NULL);
    MA_ASSERT(pConfig  != NULL);
    MA_ASSERT(pDecoder != NULL);

    if (pVTable->onInitMemory == NULL) {
        return MA_NOT_IMPLEMENTED;
    }

    backendConfig = ma_decoding_backend_config_init(pConfig->format, pConfig->seekPointCount);

    result = pVTable->onInitMemory(pVTableUserData, pData, dataSize, &backendConfig, &pDecoder->allocationCallbacks, &pBackend);
    if (result != MA_SUCCESS) {
        return result;  /* Failed to initialize the backend from this vtable. */
    }

    /* Getting here means we were able to initialize the backend so we can now initialize the decoder. */
    pDecoder->pBackend         = pBackend;
    pDecoder->pBackendVTable   = pVTable;
    pDecoder->pBackendUserData = pConfig->pCustomBackendUserData;

    return MA_SUCCESS;
}



static ma_result ma_decoder_init_custom__internal(const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result = MA_NO_BACKEND;
    size_t ivtable;

    MA_ASSERT(pConfig != NULL);
    MA_ASSERT(pDecoder != NULL);

    if (pConfig->ppCustomBackendVTables == NULL) {
        return MA_NO_BACKEND;
    }

    /* The order each backend is listed is what defines the priority. */
    for (ivtable = 0; ivtable < pConfig->customBackendCount; ivtable += 1) {
        const ma_decoding_backend_vtable* pVTable = pConfig->ppCustomBackendVTables[ivtable];
        if (pVTable != NULL) {
            result = ma_decoder_init_from_vtable__internal(pVTable, pConfig->pCustomBackendUserData, pConfig, pDecoder);
            if (result == MA_SUCCESS) {
                return MA_SUCCESS;
            } else {
                /* Initialization failed. Move on to the next one, but seek back to the start first so the next vtable starts from the first byte of the file. */
                result = ma_decoder_seek_bytes(pDecoder, 0, ma_seek_origin_start);
                if (result != MA_SUCCESS) {
                    return result;  /* Failed to seek back to the start. */
                }
            }
        } else {
            /* No vtable. */
        }
    }

    /* Getting here means we couldn't find a backend. */
    return MA_NO_BACKEND;
}

static ma_result ma_decoder_init_custom_from_file__internal(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result = MA_NO_BACKEND;
    size_t ivtable;

    MA_ASSERT(pConfig != NULL);
    MA_ASSERT(pDecoder != NULL);

    if (pConfig->ppCustomBackendVTables == NULL) {
        return MA_NO_BACKEND;
    }

    /* The order each backend is listed is what defines the priority. */
    for (ivtable = 0; ivtable < pConfig->customBackendCount; ivtable += 1) {
        const ma_decoding_backend_vtable* pVTable = pConfig->ppCustomBackendVTables[ivtable];
        if (pVTable != NULL) {
            result = ma_decoder_init_from_file__internal(pVTable, pConfig->pCustomBackendUserData, pFilePath, pConfig, pDecoder);
            if (result == MA_SUCCESS) {
                return MA_SUCCESS;
            }
        } else {
            /* No vtable. */
        }
    }

    /* Getting here means we couldn't find a backend. */
    return MA_NO_BACKEND;
}

static ma_result ma_decoder_init_custom_from_file_w__internal(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result = MA_NO_BACKEND;
    size_t ivtable;

    MA_ASSERT(pConfig != NULL);
    MA_ASSERT(pDecoder != NULL);

    if (pConfig->ppCustomBackendVTables == NULL) {
        return MA_NO_BACKEND;
    }

    /* The order each backend is listed is what defines the priority. */
    for (ivtable = 0; ivtable < pConfig->customBackendCount; ivtable += 1) {
        const ma_decoding_backend_vtable* pVTable = pConfig->ppCustomBackendVTables[ivtable];
        if (pVTable != NULL) {
            result = ma_decoder_init_from_file_w__internal(pVTable, pConfig->pCustomBackendUserData, pFilePath, pConfig, pDecoder);
            if (result == MA_SUCCESS) {
                return MA_SUCCESS;
            }
        } else {
            /* No vtable. */
        }
    }

    /* Getting here means we couldn't find a backend. */
    return MA_NO_BACKEND;
}

static ma_result ma_decoder_init_custom_from_memory__internal(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result = MA_NO_BACKEND;
    size_t ivtable;

    MA_ASSERT(pConfig != NULL);
    MA_ASSERT(pDecoder != NULL);

    if (pConfig->ppCustomBackendVTables == NULL) {
        return MA_NO_BACKEND;
    }

    /* The order each backend is listed is what defines the priority. */
    for (ivtable = 0; ivtable < pConfig->customBackendCount; ivtable += 1) {
        const ma_decoding_backend_vtable* pVTable = pConfig->ppCustomBackendVTables[ivtable];
        if (pVTable != NULL) {
            result = ma_decoder_init_from_memory__internal(pVTable, pConfig->pCustomBackendUserData, pData, dataSize, pConfig, pDecoder);
            if (result == MA_SUCCESS) {
                return MA_SUCCESS;
            }
        } else {
            /* No vtable. */
        }
    }

    /* Getting here means we couldn't find a backend. */
    return MA_NO_BACKEND;
}


/* WAV */

/* FLAC */

/* MP3 */

/* Vorbis */
#ifdef STB_VORBIS_INCLUDE_STB_VORBIS_H
#define MA_HAS_VORBIS

/* The size in bytes of each chunk of data to read from the Vorbis stream. */
#define MA_VORBIS_DATA_CHUNK_SIZE  4096

typedef struct
{
    ma_data_source_base ds;
    ma_read_proc onRead;
    ma_seek_proc onSeek;
    ma_tell_proc onTell;
    void* pReadSeekTellUserData;
    ma_allocation_callbacks allocationCallbacks;    /* Store the allocation callbacks within the structure because we may need to dynamically expand a buffer in ma_stbvorbis_read_pcm_frames() when using push mode. */
    ma_format format;               /* Only f32 is allowed with stb_vorbis. */
    ma_uint32 channels;
    ma_uint32 sampleRate;
    ma_uint64 cursor;
#if !defined(MA_NO_VORBIS)
    stb_vorbis* stb;
    ma_bool32 usingPushMode;
    struct
    {
        ma_uint8* pData;
        size_t dataSize;
        size_t dataCapacity;
        size_t audioStartOffsetInBytes;
        ma_uint32 framesConsumed;   /* The number of frames consumed in ppPacketData. */
        ma_uint32 framesRemaining;  /* The number of frames remaining in ppPacketData. */
        float** ppPacketData;
    } push;
#endif
} ma_stbvorbis;

MA_API ma_result ma_stbvorbis_init(ma_read_proc onRead, ma_seek_proc onSeek, ma_tell_proc onTell, void* pReadSeekTellUserData, const ma_decoding_backend_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_stbvorbis* pVorbis);
MA_API ma_result ma_stbvorbis_init_file(const char* pFilePath, const ma_decoding_backend_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_stbvorbis* pVorbis);
MA_API ma_result ma_stbvorbis_init_memory(const void* pData, size_t dataSize, const ma_decoding_backend_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_stbvorbis* pVorbis);
MA_API void ma_stbvorbis_uninit(ma_stbvorbis* pVorbis, const ma_allocation_callbacks* pAllocationCallbacks);
MA_API ma_result ma_stbvorbis_read_pcm_frames(ma_stbvorbis* pVorbis, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead);
MA_API ma_result ma_stbvorbis_seek_to_pcm_frame(ma_stbvorbis* pVorbis, ma_uint64 frameIndex);
MA_API ma_result ma_stbvorbis_get_data_format(ma_stbvorbis* pVorbis, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap);
MA_API ma_result ma_stbvorbis_get_cursor_in_pcm_frames(ma_stbvorbis* pVorbis, ma_uint64* pCursor);
MA_API ma_result ma_stbvorbis_get_length_in_pcm_frames(ma_stbvorbis* pVorbis, ma_uint64* pLength);


static ma_result ma_stbvorbis_ds_read(ma_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    return ma_stbvorbis_read_pcm_frames((ma_stbvorbis*)pDataSource, pFramesOut, frameCount, pFramesRead);
}

static ma_result ma_stbvorbis_ds_seek(ma_data_source* pDataSource, ma_uint64 frameIndex)
{
    return ma_stbvorbis_seek_to_pcm_frame((ma_stbvorbis*)pDataSource, frameIndex);
}

static ma_result ma_stbvorbis_ds_get_data_format(ma_data_source* pDataSource, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)
{
    return ma_stbvorbis_get_data_format((ma_stbvorbis*)pDataSource, pFormat, pChannels, pSampleRate, pChannelMap, channelMapCap);
}

static ma_result ma_stbvorbis_ds_get_cursor(ma_data_source* pDataSource, ma_uint64* pCursor)
{
    return ma_stbvorbis_get_cursor_in_pcm_frames((ma_stbvorbis*)pDataSource, pCursor);
}

static ma_result ma_stbvorbis_ds_get_length(ma_data_source* pDataSource, ma_uint64* pLength)
{
    return ma_stbvorbis_get_length_in_pcm_frames((ma_stbvorbis*)pDataSource, pLength);
}

static ma_data_source_vtable g_ma_stbvorbis_ds_vtable =
{
    ma_stbvorbis_ds_read,
    ma_stbvorbis_ds_seek,
    ma_stbvorbis_ds_get_data_format,
    ma_stbvorbis_ds_get_cursor,
    ma_stbvorbis_ds_get_length,
    NULL,   /* onSetLooping */
    0
};


static ma_result ma_stbvorbis_init_internal(const ma_decoding_backend_config* pConfig, ma_stbvorbis* pVorbis)
{
    ma_result result;
    ma_data_source_config dataSourceConfig;

    (void)pConfig;

    if (pVorbis == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pVorbis);
    pVorbis->format = ma_format_f32;    /* Only supporting f32. */

    dataSourceConfig = ma_data_source_config_init();
    dataSourceConfig.vtable = &g_ma_stbvorbis_ds_vtable;

    result = ma_data_source_init(&dataSourceConfig, &pVorbis->ds);
    if (result != MA_SUCCESS) {
        return result;  /* Failed to initialize the base data source. */
    }

    return MA_SUCCESS;
}

#if !defined(MA_NO_VORBIS)
static ma_result ma_stbvorbis_post_init(ma_stbvorbis* pVorbis)
{
    stb_vorbis_info info;

    MA_ASSERT(pVorbis != NULL);

    info = stb_vorbis_get_info(pVorbis->stb);

    pVorbis->channels   = info.channels;
    pVorbis->sampleRate = info.sample_rate;

    return MA_SUCCESS;
}

static ma_result ma_stbvorbis_init_internal_decoder_push(ma_stbvorbis* pVorbis)
{
    ma_result result;
    stb_vorbis* stb;
    size_t dataSize = 0;
    size_t dataCapacity = 0;
    ma_uint8* pData = NULL; /* <-- Must be initialized to NULL. */

    for (;;) {
        int vorbisError;
        int consumedDataSize;   /* <-- Fill by stb_vorbis_open_pushdata(). */
        size_t bytesRead;
        ma_uint8* pNewData;

        /* Allocate memory for the new chunk. */
        dataCapacity += MA_VORBIS_DATA_CHUNK_SIZE;
        pNewData = (ma_uint8*)ma_realloc(pData, dataCapacity, &pVorbis->allocationCallbacks);
        if (pNewData == NULL) {
            ma_free(pData, &pVorbis->allocationCallbacks);
            return MA_OUT_OF_MEMORY;
        }

        pData = pNewData;

        /* Read in the next chunk. */
        result = pVorbis->onRead(pVorbis->pReadSeekTellUserData, ma_offset_ptr(pData, dataSize), (dataCapacity - dataSize), &bytesRead);
        dataSize += bytesRead;

        if (result != MA_SUCCESS) {
            ma_free(pData, &pVorbis->allocationCallbacks);
            return result;
        }

        /* We have a maximum of 31 bits with stb_vorbis. */
        if (dataSize > INT_MAX) {
            ma_free(pData, &pVorbis->allocationCallbacks);
            return MA_TOO_BIG;
        }

        stb = stb_vorbis_open_pushdata(pData, (int)dataSize, &consumedDataSize, &vorbisError, NULL);
        if (stb != NULL) {
            /*
            Successfully opened the Vorbis decoder. We might have some leftover unprocessed
            data so we'll need to move that down to the front.
            */
            dataSize -= (size_t)consumedDataSize;   /* Consume the data. */
            MA_MOVE_MEMORY(pData, ma_offset_ptr(pData, consumedDataSize), dataSize);

            /*
            We need to track the start point so we can seek back to the start of the audio
            data when seeking.
            */
            pVorbis->push.audioStartOffsetInBytes = consumedDataSize;

            break;
        } else {
            /* Failed to open the decoder. */
            if (vorbisError == VORBIS_need_more_data) {
                continue;
            } else {
                ma_free(pData, &pVorbis->allocationCallbacks);
                return MA_ERROR;   /* Failed to open the stb_vorbis decoder. */
            }
        }
    }

    MA_ASSERT(stb != NULL);
    pVorbis->stb = stb;
    pVorbis->push.pData = pData;
    pVorbis->push.dataSize = dataSize;
    pVorbis->push.dataCapacity = dataCapacity;

    return MA_SUCCESS;
}
#endif

MA_API ma_result ma_stbvorbis_init(ma_read_proc onRead, ma_seek_proc onSeek, ma_tell_proc onTell, void* pReadSeekTellUserData, const ma_decoding_backend_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_stbvorbis* pVorbis)
{
    ma_result result;

    result = ma_stbvorbis_init_internal(pConfig, pVorbis);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (onRead == NULL || onSeek == NULL) {
        return MA_INVALID_ARGS; /* onRead and onSeek are mandatory. */
    }

    pVorbis->onRead = onRead;
    pVorbis->onSeek = onSeek;
    pVorbis->onTell = onTell;
    pVorbis->pReadSeekTellUserData = pReadSeekTellUserData;
    ma_allocation_callbacks_init_copy(&pVorbis->allocationCallbacks, pAllocationCallbacks);

    #if !defined(MA_NO_VORBIS)
    {
        /*
        stb_vorbis lacks a callback based API for its pulling API which means we're stuck with the
        pushing API. In order for us to be able to successfully initialize the decoder we need to
        supply it with enough data. We need to keep loading data until we have enough.
        */
        result = ma_stbvorbis_init_internal_decoder_push(pVorbis);
        if (result != MA_SUCCESS) {
            return result;
        }

        pVorbis->usingPushMode = MA_TRUE;

        result = ma_stbvorbis_post_init(pVorbis);
        if (result != MA_SUCCESS) {
            stb_vorbis_close(pVorbis->stb);
            ma_free(pVorbis->push.pData, pAllocationCallbacks);
            return result;
        }

        return MA_SUCCESS;
    }
    #else
    {
        /* vorbis is disabled. */
        (void)pAllocationCallbacks;
        return MA_NOT_IMPLEMENTED;
    }
    #endif
}

MA_API ma_result ma_stbvorbis_init_file(const char* pFilePath, const ma_decoding_backend_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_stbvorbis* pVorbis)
{
    ma_result result;

    result = ma_stbvorbis_init_internal(pConfig, pVorbis);
    if (result != MA_SUCCESS) {
        return result;
    }

    #if !defined(MA_NO_VORBIS)
    {
        (void)pAllocationCallbacks; /* Don't know how to make use of this with stb_vorbis. */

        /* We can use stb_vorbis' pull mode for file based streams. */
        pVorbis->stb = stb_vorbis_open_filename(pFilePath, NULL, NULL);
        if (pVorbis->stb == NULL) {
            return MA_INVALID_FILE;
        }

        pVorbis->usingPushMode = MA_FALSE;

        result = ma_stbvorbis_post_init(pVorbis);
        if (result != MA_SUCCESS) {
            stb_vorbis_close(pVorbis->stb);
            return result;
        }

        return MA_SUCCESS;
    }
    #else
    {
        /* vorbis is disabled. */
        (void)pFilePath;
        (void)pAllocationCallbacks;
        return MA_NOT_IMPLEMENTED;
    }
    #endif
}

MA_API ma_result ma_stbvorbis_init_memory(const void* pData, size_t dataSize, const ma_decoding_backend_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_stbvorbis* pVorbis)
{
    ma_result result;

    result = ma_stbvorbis_init_internal(pConfig, pVorbis);
    if (result != MA_SUCCESS) {
        return result;
    }

    #if !defined(MA_NO_VORBIS)
    {
        (void)pAllocationCallbacks;

        /* stb_vorbis uses an int as its size specifier, restricting it to 32-bit even on 64-bit systems. *sigh*. */
        if (dataSize > INT_MAX) {
            return MA_TOO_BIG;
        }

        pVorbis->stb = stb_vorbis_open_memory((const unsigned char*)pData, (int)dataSize, NULL, NULL);
        if (pVorbis->stb == NULL) {
            return MA_INVALID_FILE;
        }

        pVorbis->usingPushMode = MA_FALSE;

        result = ma_stbvorbis_post_init(pVorbis);
        if (result != MA_SUCCESS) {
            stb_vorbis_close(pVorbis->stb);
            return result;
        }

        return MA_SUCCESS;
    }
    #else
    {
        /* vorbis is disabled. */
        (void)pData;
        (void)dataSize;
        (void)pAllocationCallbacks;
        return MA_NOT_IMPLEMENTED;
    }
    #endif
}

MA_API void ma_stbvorbis_uninit(ma_stbvorbis* pVorbis, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pVorbis == NULL) {
        return;
    }

    #if !defined(MA_NO_VORBIS)
    {
        stb_vorbis_close(pVorbis->stb);

        /* We'll have to clear some memory if we're using push mode. */
        if (pVorbis->usingPushMode) {
            ma_free(pVorbis->push.pData, pAllocationCallbacks);
        }
    }
    #else
    {
        /* vorbis is disabled. Should never hit this since initialization would have failed. */
        MA_ASSERT(MA_FALSE);
    }
    #endif

    ma_data_source_uninit(&pVorbis->ds);
}

MA_API ma_result ma_stbvorbis_read_pcm_frames(ma_stbvorbis* pVorbis, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    if (pFramesRead != NULL) {
        *pFramesRead = 0;
    }

    if (frameCount == 0) {
        return MA_INVALID_ARGS;
    }

    if (pVorbis == NULL) {
        return MA_INVALID_ARGS;
    }

    #if !defined(MA_NO_VORBIS)
    {
        /* We always use floating point format. */
        ma_result result = MA_SUCCESS;  /* Must be initialized to MA_SUCCESS. */
        ma_uint64 totalFramesRead = 0;
        ma_format format;
        ma_uint32 channels;

        ma_stbvorbis_get_data_format(pVorbis, &format, &channels, NULL, NULL, 0);

        if (format == ma_format_f32) {
            /* We read differently depending on whether or not we're using push mode. */
            if (pVorbis->usingPushMode) {
                /* Push mode. This is the complex case. */
                float* pFramesOutF32 = (float*)pFramesOut;

                while (totalFramesRead < frameCount) {
                    /* The first thing to do is read from any already-cached frames. */
                    ma_uint32 framesToReadFromCache = (ma_uint32)ma_min(pVorbis->push.framesRemaining, (frameCount - totalFramesRead));  /* Safe cast because pVorbis->framesRemaining is 32-bit. */

                    /* The output pointer can be null in which case we just treat it as a seek. */
                    if (pFramesOut != NULL) {
                        ma_uint64 iFrame;
                        for (iFrame = 0; iFrame < framesToReadFromCache; iFrame += 1) {
                            ma_uint32 iChannel;
                            for (iChannel = 0; iChannel < pVorbis->channels; iChannel += 1) {
                                pFramesOutF32[iChannel] = pVorbis->push.ppPacketData[iChannel][pVorbis->push.framesConsumed + iFrame];
                            }

                            pFramesOutF32 += pVorbis->channels;
                        }
                    }

                    /* Update pointers and counters. */
                    pVorbis->push.framesConsumed  += framesToReadFromCache;
                    pVorbis->push.framesRemaining -= framesToReadFromCache;
                    totalFramesRead               += framesToReadFromCache;

                    /* Don't bother reading any more frames right now if we've just finished loading. */
                    if (totalFramesRead == frameCount) {
                        break;
                    }

                    MA_ASSERT(pVorbis->push.framesRemaining == 0);

                    /* Getting here means we've run out of cached frames. We'll need to load some more. */
                    for (;;) {
                        int samplesRead = 0;
                        int consumedDataSize;

                        /* We need to case dataSize to an int, so make sure we can do it safely. */
                        if (pVorbis->push.dataSize > INT_MAX) {
                            break;  /* Too big. */
                        }

                        consumedDataSize = stb_vorbis_decode_frame_pushdata(pVorbis->stb, pVorbis->push.pData, (int)pVorbis->push.dataSize, NULL, &pVorbis->push.ppPacketData, &samplesRead);
                        if (consumedDataSize != 0) {
                            /* Successfully decoded a Vorbis frame. Consume the data. */
                            pVorbis->push.dataSize -= (size_t)consumedDataSize;
                            MA_MOVE_MEMORY(pVorbis->push.pData, ma_offset_ptr(pVorbis->push.pData, consumedDataSize), pVorbis->push.dataSize);

                            pVorbis->push.framesConsumed  = 0;
                            pVorbis->push.framesRemaining = samplesRead;

                            break;
                        } else {
                            /* Not enough data. Read more. */
                            size_t bytesRead;

                            /* Expand the data buffer if necessary. */
                            if (pVorbis->push.dataCapacity == pVorbis->push.dataSize) {
                                size_t newCap = pVorbis->push.dataCapacity + MA_VORBIS_DATA_CHUNK_SIZE;
                                ma_uint8* pNewData;

                                pNewData = (ma_uint8*)ma_realloc(pVorbis->push.pData, newCap, &pVorbis->allocationCallbacks);
                                if (pNewData == NULL) {
                                    result = MA_OUT_OF_MEMORY;
                                    break;
                                }

                                pVorbis->push.pData = pNewData;
                                pVorbis->push.dataCapacity = newCap;
                            }

                            /* We should have enough room to load some data. */
                            result = pVorbis->onRead(pVorbis->pReadSeekTellUserData, ma_offset_ptr(pVorbis->push.pData, pVorbis->push.dataSize), (pVorbis->push.dataCapacity - pVorbis->push.dataSize), &bytesRead);
                            pVorbis->push.dataSize += bytesRead;

                            if (result != MA_SUCCESS) {
                                break;  /* Failed to read any data. Get out. */
                            }
                        }
                    }

                    /* If we don't have a success code at this point it means we've encountered an error or the end of the file has been reached (probably the latter). */
                    if (result != MA_SUCCESS) {
                        break;
                    }
                }
            } else {
                /* Pull mode. This is the simple case, but we still need to run in a loop because stb_vorbis loves using 32-bit instead of 64-bit. */
                while (totalFramesRead < frameCount) {
                    ma_uint64 framesRemaining = (frameCount - totalFramesRead);
                    int framesRead;

                    if (framesRemaining > INT_MAX) {
                        framesRemaining = INT_MAX;
                    }

                    framesRead = stb_vorbis_get_samples_float_interleaved(pVorbis->stb, channels, (float*)ma_offset_pcm_frames_ptr(pFramesOut, totalFramesRead, format, channels), (int)framesRemaining * channels);   /* Safe cast. */
                    totalFramesRead += framesRead;

                    if (framesRead < (int)framesRemaining) {
                        break;  /* Nothing left to read. Get out. */
                    }
                }
            }
        } else {
            result = MA_INVALID_ARGS;
        }

        pVorbis->cursor += totalFramesRead;

        if (totalFramesRead == 0) {
            result = MA_AT_END;
        }

        if (pFramesRead != NULL) {
            *pFramesRead = totalFramesRead;
        }

        if (result == MA_SUCCESS && totalFramesRead == 0) {
            result  = MA_AT_END;
        }

        return result;
    }
    #else
    {
        /* vorbis is disabled. Should never hit this since initialization would have failed. */
        MA_ASSERT(MA_FALSE);

        (void)pFramesOut;
        (void)frameCount;
        (void)pFramesRead;

        return MA_NOT_IMPLEMENTED;
    }
    #endif
}

MA_API ma_result ma_stbvorbis_seek_to_pcm_frame(ma_stbvorbis* pVorbis, ma_uint64 frameIndex)
{
    if (pVorbis == NULL) {
        return MA_INVALID_ARGS;
    }

    #if !defined(MA_NO_VORBIS)
    {
        /* Different seeking methods depending on whether or not we're using push mode. */
        if (pVorbis->usingPushMode) {
            /* Push mode. This is the complex case. */
            ma_result result;
            float buffer[4096];

            /* If we're seeking backwards, we need to seek back to the start and then brute-force forward. */
            if (frameIndex < pVorbis->cursor) {
                if (frameIndex > 0x7FFFFFFF) {
                    return MA_INVALID_ARGS; /* Trying to seek beyond the 32-bit maximum of stb_vorbis. */
                }

                /*
                This is wildly inefficient due to me having trouble getting sample exact seeking working
                robustly with stb_vorbis_flush_pushdata(). The only way I can think to make this work
                perfectly is to reinitialize the decoder. Note that we only enter this path when seeking
                backwards. This will hopefully be removed once we get our own Vorbis decoder implemented.
                */
                stb_vorbis_close(pVorbis->stb);
                ma_free(pVorbis->push.pData, &pVorbis->allocationCallbacks);

                MA_ZERO_OBJECT(&pVorbis->push);

                /* Seek to the start of the file. */
                result = pVorbis->onSeek(pVorbis->pReadSeekTellUserData, 0, ma_seek_origin_start);
                if (result != MA_SUCCESS) {
                    return result;
                }

                result = ma_stbvorbis_init_internal_decoder_push(pVorbis);
                if (result != MA_SUCCESS) {
                    return result;
                }

                /* At this point we should be sitting on the first frame. */
                pVorbis->cursor = 0;
            }

            /* We're just brute-forcing this for now. */
            while (pVorbis->cursor < frameIndex) {
                ma_uint64 framesRead;
                ma_uint64 framesToRead = ma_countof(buffer)/pVorbis->channels;
                if (framesToRead > (frameIndex - pVorbis->cursor)) {
                    framesToRead = (frameIndex - pVorbis->cursor);
                }

                result = ma_stbvorbis_read_pcm_frames(pVorbis, buffer, framesToRead, &framesRead);
                if (result != MA_SUCCESS) {
                    return result;
                }
            }
        } else {
            /* Pull mode. This is the simple case. */
            int vorbisResult;

            if (frameIndex > UINT_MAX) {
                return MA_INVALID_ARGS; /* Trying to seek beyond the 32-bit maximum of stb_vorbis. */
            }

            vorbisResult = stb_vorbis_seek(pVorbis->stb, (unsigned int)frameIndex);  /* Safe cast. */
            if (vorbisResult == 0) {
                return MA_ERROR;    /* See failed. */
            }

            pVorbis->cursor = frameIndex;
        }

        return MA_SUCCESS;
    }
    #else
    {
        /* vorbis is disabled. Should never hit this since initialization would have failed. */
        MA_ASSERT(MA_FALSE);

        (void)frameIndex;

        return MA_NOT_IMPLEMENTED;
    }
    #endif
}

MA_API ma_result ma_stbvorbis_get_data_format(ma_stbvorbis* pVorbis, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)
{
    /* Defaults for safety. */
    if (pFormat != NULL) {
        *pFormat = ma_format_unknown;
    }
    if (pChannels != NULL) {
        *pChannels = 0;
    }
    if (pSampleRate != NULL) {
        *pSampleRate = 0;
    }
    if (pChannelMap != NULL) {
        MA_ZERO_MEMORY(pChannelMap, sizeof(*pChannelMap) * channelMapCap);
    }

    if (pVorbis == NULL) {
        return MA_INVALID_OPERATION;
    }

    if (pFormat != NULL) {
        *pFormat = pVorbis->format;
    }

    #if !defined(MA_NO_VORBIS)
    {
        if (pChannels != NULL) {
            *pChannels = pVorbis->channels;
        }

        if (pSampleRate != NULL) {
            *pSampleRate = pVorbis->sampleRate;
        }

        if (pChannelMap != NULL) {
            ma_channel_map_init_standard(ma_standard_channel_map_vorbis, pChannelMap, channelMapCap, pVorbis->channels);
        }

        return MA_SUCCESS;
    }
    #else
    {
        /* vorbis is disabled. Should never hit this since initialization would have failed. */
        MA_ASSERT(MA_FALSE);
        return MA_NOT_IMPLEMENTED;
    }
    #endif
}

MA_API ma_result ma_stbvorbis_get_cursor_in_pcm_frames(ma_stbvorbis* pVorbis, ma_uint64* pCursor)
{
    if (pCursor == NULL) {
        return MA_INVALID_ARGS;
    }

    *pCursor = 0;   /* Safety. */

    if (pVorbis == NULL) {
        return MA_INVALID_ARGS;
    }

    #if !defined(MA_NO_VORBIS)
    {
        *pCursor = pVorbis->cursor;

        return MA_SUCCESS;
    }
    #else
    {
        /* vorbis is disabled. Should never hit this since initialization would have failed. */
        MA_ASSERT(MA_FALSE);
        return MA_NOT_IMPLEMENTED;
    }
    #endif
}

MA_API ma_result ma_stbvorbis_get_length_in_pcm_frames(ma_stbvorbis* pVorbis, ma_uint64* pLength)
{
    if (pLength == NULL) {
        return MA_INVALID_ARGS;
    }

    *pLength = 0;   /* Safety. */

    if (pVorbis == NULL) {
        return MA_INVALID_ARGS;
    }

    #if !defined(MA_NO_VORBIS)
    {
        if (pVorbis->usingPushMode) {
            *pLength = 0;   /* I don't know of a good way to determine this reliably with stb_vorbis and push mode. */
        } else {
            *pLength = stb_vorbis_stream_length_in_samples(pVorbis->stb);
        }

        return MA_SUCCESS;
    }
    #else
    {
        /* vorbis is disabled. Should never hit this since initialization would have failed. */
        MA_ASSERT(MA_FALSE);
        return MA_NOT_IMPLEMENTED;
    }
    #endif
}


static ma_result ma_decoding_backend_init__stbvorbis(void* pUserData, ma_read_proc onRead, ma_seek_proc onSeek, ma_tell_proc onTell, void* pReadSeekTellUserData, const ma_decoding_backend_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_data_source** ppBackend)
{
    ma_result result;
    ma_stbvorbis* pVorbis;

    (void)pUserData;    /* For now not using pUserData, but once we start storing the vorbis decoder state within the ma_decoder structure this will be set to the decoder so we can avoid a malloc. */

    /* For now we're just allocating the decoder backend on the heap. */
    pVorbis = (ma_stbvorbis*)ma_malloc(sizeof(*pVorbis), pAllocationCallbacks);
    if (pVorbis == NULL) {
        return MA_OUT_OF_MEMORY;
    }

    result = ma_stbvorbis_init(onRead, onSeek, onTell, pReadSeekTellUserData, pConfig, pAllocationCallbacks, pVorbis);
    if (result != MA_SUCCESS) {
        ma_free(pVorbis, pAllocationCallbacks);
        return result;
    }

    *ppBackend = pVorbis;

    return MA_SUCCESS;
}

static ma_result ma_decoding_backend_init_file__stbvorbis(void* pUserData, const char* pFilePath, const ma_decoding_backend_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_data_source** ppBackend)
{
    ma_result result;
    ma_stbvorbis* pVorbis;

    (void)pUserData;    /* For now not using pUserData, but once we start storing the vorbis decoder state within the ma_decoder structure this will be set to the decoder so we can avoid a malloc. */

    /* For now we're just allocating the decoder backend on the heap. */
    pVorbis = (ma_stbvorbis*)ma_malloc(sizeof(*pVorbis), pAllocationCallbacks);
    if (pVorbis == NULL) {
        return MA_OUT_OF_MEMORY;
    }

    result = ma_stbvorbis_init_file(pFilePath, pConfig, pAllocationCallbacks, pVorbis);
    if (result != MA_SUCCESS) {
        ma_free(pVorbis, pAllocationCallbacks);
        return result;
    }

    *ppBackend = pVorbis;

    return MA_SUCCESS;
}

static ma_result ma_decoding_backend_init_memory__stbvorbis(void* pUserData, const void* pData, size_t dataSize, const ma_decoding_backend_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_data_source** ppBackend)
{
    ma_result result;
    ma_stbvorbis* pVorbis;

    (void)pUserData;    /* For now not using pUserData, but once we start storing the vorbis decoder state within the ma_decoder structure this will be set to the decoder so we can avoid a malloc. */

    /* For now we're just allocating the decoder backend on the heap. */
    pVorbis = (ma_stbvorbis*)ma_malloc(sizeof(*pVorbis), pAllocationCallbacks);
    if (pVorbis == NULL) {
        return MA_OUT_OF_MEMORY;
    }

    result = ma_stbvorbis_init_memory(pData, dataSize, pConfig, pAllocationCallbacks, pVorbis);
    if (result != MA_SUCCESS) {
        ma_free(pVorbis, pAllocationCallbacks);
        return result;
    }

    *ppBackend = pVorbis;

    return MA_SUCCESS;
}

static void ma_decoding_backend_uninit__stbvorbis(void* pUserData, ma_data_source* pBackend, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_stbvorbis* pVorbis = (ma_stbvorbis*)pBackend;

    (void)pUserData;

    ma_stbvorbis_uninit(pVorbis, pAllocationCallbacks);
    ma_free(pVorbis, pAllocationCallbacks);
}

static ma_decoding_backend_vtable g_ma_decoding_backend_vtable_stbvorbis =
{
    ma_decoding_backend_init__stbvorbis,
    ma_decoding_backend_init_file__stbvorbis,
    NULL, /* onInitFileW() */
    ma_decoding_backend_init_memory__stbvorbis,
    ma_decoding_backend_uninit__stbvorbis
};

static ma_result ma_decoder_init_vorbis__internal(const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    return ma_decoder_init_from_vtable__internal(&g_ma_decoding_backend_vtable_stbvorbis, NULL, pConfig, pDecoder);
}

static ma_result ma_decoder_init_vorbis_from_file__internal(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    return ma_decoder_init_from_file__internal(&g_ma_decoding_backend_vtable_stbvorbis, NULL, pFilePath, pConfig, pDecoder);
}

static ma_result ma_decoder_init_vorbis_from_file_w__internal(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    return ma_decoder_init_from_file_w__internal(&g_ma_decoding_backend_vtable_stbvorbis, NULL, pFilePath, pConfig, pDecoder);
}

static ma_result ma_decoder_init_vorbis_from_memory__internal(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    return ma_decoder_init_from_memory__internal(&g_ma_decoding_backend_vtable_stbvorbis, NULL, pData, dataSize, pConfig, pDecoder);
}
#endif  /* STB_VORBIS_INCLUDE_STB_VORBIS_H */



static ma_result ma_decoder__init_allocation_callbacks(const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    MA_ASSERT(pDecoder != NULL);

    if (pConfig != NULL) {
        return ma_allocation_callbacks_init_copy(&pDecoder->allocationCallbacks, &pConfig->allocationCallbacks);
    } else {
        pDecoder->allocationCallbacks = ma_allocation_callbacks_init_default();
        return MA_SUCCESS;
    }
}

static ma_result ma_decoder__data_source_on_read(ma_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    return ma_decoder_read_pcm_frames((ma_decoder*)pDataSource, pFramesOut, frameCount, pFramesRead);
}

static ma_result ma_decoder__data_source_on_seek(ma_data_source* pDataSource, ma_uint64 frameIndex)
{
    return ma_decoder_seek_to_pcm_frame((ma_decoder*)pDataSource, frameIndex);
}

static ma_result ma_decoder__data_source_on_get_data_format(ma_data_source* pDataSource, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)
{
    return ma_decoder_get_data_format((ma_decoder*)pDataSource, pFormat, pChannels, pSampleRate, pChannelMap, channelMapCap);
}

static ma_result ma_decoder__data_source_on_get_cursor(ma_data_source* pDataSource, ma_uint64* pCursor)
{
    return ma_decoder_get_cursor_in_pcm_frames((ma_decoder*)pDataSource, pCursor);
}

static ma_result ma_decoder__data_source_on_get_length(ma_data_source* pDataSource, ma_uint64* pLength)
{
    return ma_decoder_get_length_in_pcm_frames((ma_decoder*)pDataSource, pLength);
}

static ma_data_source_vtable g_ma_decoder_data_source_vtable =
{
    ma_decoder__data_source_on_read,
    ma_decoder__data_source_on_seek,
    ma_decoder__data_source_on_get_data_format,
    ma_decoder__data_source_on_get_cursor,
    ma_decoder__data_source_on_get_length,
    NULL,   /* onSetLooping */
    0
};

static ma_result ma_decoder__preinit(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, ma_decoder_tell_proc onTell, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result;
    ma_data_source_config dataSourceConfig;

    MA_ASSERT(pConfig != NULL);

    if (pDecoder == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pDecoder);

    dataSourceConfig = ma_data_source_config_init();
    dataSourceConfig.vtable = &g_ma_decoder_data_source_vtable;

    result = ma_data_source_init(&dataSourceConfig, &pDecoder->ds);
    if (result != MA_SUCCESS) {
        return result;
    }

    pDecoder->onRead    = onRead;
    pDecoder->onSeek    = onSeek;
    pDecoder->onTell    = onTell;
    pDecoder->pUserData = pUserData;

    result = ma_decoder__init_allocation_callbacks(pConfig, pDecoder);
    if (result != MA_SUCCESS) {
        ma_data_source_uninit(&pDecoder->ds);
        return result;
    }

    return MA_SUCCESS;
}

static ma_result ma_decoder__postinit(const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result;

    result = ma_decoder__init_data_converter(pDecoder, pConfig);

    /* If we failed post initialization we need to uninitialize the decoder before returning to prevent a memory leak. */
    if (result != MA_SUCCESS) {
        ma_decoder_uninit(pDecoder);
        return result;
    }

    return result;
}


static ma_result ma_decoder_init__internal(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result = MA_NO_BACKEND;

    MA_ASSERT(pConfig != NULL);
    MA_ASSERT(pDecoder != NULL);

    /* Silence some warnings in the case that we don't have any decoder backends enabled. */
    (void)onRead;
    (void)onSeek;
    (void)pUserData;


    /* If we've specified a specific encoding type, try that first. */
    if (pConfig->encodingFormat != ma_encoding_format_unknown) {
    #ifdef MA_HAS_VORBIS
        if (pConfig->encodingFormat == ma_encoding_format_vorbis) {
            result = ma_decoder_init_vorbis__internal(pConfig, pDecoder);
        }
    #endif

        /* If we weren't able to initialize the decoder, seek back to the start to give the next attempts a clean start. */
        if (result != MA_SUCCESS) {
            onSeek(pDecoder, 0, ma_seek_origin_start);
        }
    }

    if (result != MA_SUCCESS) {
        /* Getting here means we couldn't load a specific decoding backend based on the encoding format. */

        /*
        We use trial and error to open a decoder. We prioritize custom decoders so that if they
        implement the same encoding format they take priority over the built-in decoders.
        */
        if (result != MA_SUCCESS) {
            result = ma_decoder_init_custom__internal(pConfig, pDecoder);
            if (result != MA_SUCCESS) {
                onSeek(pDecoder, 0, ma_seek_origin_start);
            }
        }

        /*
        If we get to this point and we still haven't found a decoder, and the caller has requested a
        specific encoding format, there's no hope for it. Abort.
        */
        if (pConfig->encodingFormat != ma_encoding_format_unknown) {
            return MA_NO_BACKEND;
        }

    #ifdef MA_HAS_VORBIS
        if (result != MA_SUCCESS) {
            result = ma_decoder_init_vorbis__internal(pConfig, pDecoder);
            if (result != MA_SUCCESS) {
                onSeek(pDecoder, 0, ma_seek_origin_start);
            }
        }
    #endif
    }

    if (result != MA_SUCCESS) {
        return result;
    }

    return ma_decoder__postinit(pConfig, pDecoder);
}

MA_API ma_result ma_decoder_init(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_decoder_config config;
    ma_result result;

    config = ma_decoder_config_init_copy(pConfig);

    result = ma_decoder__preinit(onRead, onSeek, NULL, pUserData, &config, pDecoder);
    if (result != MA_SUCCESS) {
        return result;
    }

    return ma_decoder_init__internal(onRead, onSeek, pUserData, &config, pDecoder);
}


static ma_result ma_decoder__on_read_memory(ma_decoder* pDecoder, void* pBufferOut, size_t bytesToRead, size_t* pBytesRead)
{
    size_t bytesRemaining;

    MA_ASSERT(pDecoder->data.memory.dataSize >= pDecoder->data.memory.currentReadPos);

    if (pBytesRead != NULL) {
        *pBytesRead = 0;
    }

    bytesRemaining = pDecoder->data.memory.dataSize - pDecoder->data.memory.currentReadPos;
    if (bytesToRead > bytesRemaining) {
        bytesToRead = bytesRemaining;
    }

    if (bytesRemaining == 0) {
        return MA_AT_END;
    }

    if (bytesToRead > 0) {
        MA_COPY_MEMORY(pBufferOut, pDecoder->data.memory.pData + pDecoder->data.memory.currentReadPos, bytesToRead);
        pDecoder->data.memory.currentReadPos += bytesToRead;
    }

    if (pBytesRead != NULL) {
        *pBytesRead = bytesToRead;
    }

    return MA_SUCCESS;
}

static ma_result ma_decoder__on_seek_memory(ma_decoder* pDecoder, ma_int64 byteOffset, ma_seek_origin origin)
{
    if (byteOffset > 0 && (ma_uint64)byteOffset > MA_SIZE_MAX) {
        return MA_BAD_SEEK;
    }

    if (origin == ma_seek_origin_current) {
        if (byteOffset > 0) {
            if (pDecoder->data.memory.currentReadPos + byteOffset > pDecoder->data.memory.dataSize) {
                byteOffset = (ma_int64)(pDecoder->data.memory.dataSize - pDecoder->data.memory.currentReadPos);  /* Trying to seek too far forward. */
            }

            pDecoder->data.memory.currentReadPos += (size_t)byteOffset;
        } else {
            if (pDecoder->data.memory.currentReadPos < (size_t)-byteOffset) {
                byteOffset = -(ma_int64)pDecoder->data.memory.currentReadPos;  /* Trying to seek too far backwards. */
            }

            pDecoder->data.memory.currentReadPos -= (size_t)-byteOffset;
        }
    } else {
        if (origin == ma_seek_origin_end) {
            if (byteOffset < 0) {
                byteOffset = -byteOffset;
            }

            if (byteOffset > (ma_int64)pDecoder->data.memory.dataSize) {
                pDecoder->data.memory.currentReadPos = 0;   /* Trying to seek too far back. */
            } else {
                pDecoder->data.memory.currentReadPos = pDecoder->data.memory.dataSize - (size_t)byteOffset;
            }
        } else {
            if ((size_t)byteOffset <= pDecoder->data.memory.dataSize) {
                pDecoder->data.memory.currentReadPos = (size_t)byteOffset;
            } else {
                pDecoder->data.memory.currentReadPos = pDecoder->data.memory.dataSize;  /* Trying to seek too far forward. */
            }
        }
    }

    return MA_SUCCESS;
}

static ma_result ma_decoder__on_tell_memory(ma_decoder* pDecoder, ma_int64* pCursor)
{
    MA_ASSERT(pDecoder != NULL);
    MA_ASSERT(pCursor  != NULL);

    *pCursor = (ma_int64)pDecoder->data.memory.currentReadPos;

    return MA_SUCCESS;
}

static ma_result ma_decoder__preinit_memory_wrapper(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result = ma_decoder__preinit(ma_decoder__on_read_memory, ma_decoder__on_seek_memory, ma_decoder__on_tell_memory, NULL, pConfig, pDecoder);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (pData == NULL || dataSize == 0) {
        return MA_INVALID_ARGS;
    }

    pDecoder->data.memory.pData = (const ma_uint8*)pData;
    pDecoder->data.memory.dataSize = dataSize;
    pDecoder->data.memory.currentReadPos = 0;

    (void)pConfig;
    return MA_SUCCESS;
}

MA_API ma_result ma_decoder_init_memory(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result;
    ma_decoder_config config;

    config = ma_decoder_config_init_copy(pConfig);

    result = ma_decoder__preinit(NULL, NULL, NULL, NULL, &config, pDecoder);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (pData == NULL || dataSize == 0) {
        return MA_INVALID_ARGS;
    }

    /* If the backend has support for loading from a file path we'll want to use that. If that all fails we'll fall back to the VFS path. */
    result = MA_NO_BACKEND;

    if (config.encodingFormat != ma_encoding_format_unknown) {
    #ifdef MA_HAS_VORBIS
        if (config.encodingFormat == ma_encoding_format_vorbis) {
            result = ma_decoder_init_vorbis_from_memory__internal(pData, dataSize, &config, pDecoder);
        }
    #endif
    }

    if (result != MA_SUCCESS) {
        /* Getting here means we weren't able to initialize a decoder of a specific encoding format. */

        /*
        We use trial and error to open a decoder. We prioritize custom decoders so that if they
        implement the same encoding format they take priority over the built-in decoders.
        */
        result = ma_decoder_init_custom_from_memory__internal(pData, dataSize, &config, pDecoder);

        /*
        If we get to this point and we still haven't found a decoder, and the caller has requested a
        specific encoding format, there's no hope for it. Abort.
        */
        if (result != MA_SUCCESS && config.encodingFormat != ma_encoding_format_unknown) {
            return MA_NO_BACKEND;
        }

        /* Use trial and error for stock decoders. */
        if (result != MA_SUCCESS) {
        #ifdef MA_HAS_VORBIS
            if (result != MA_SUCCESS) {
                result = ma_decoder_init_vorbis_from_memory__internal(pData, dataSize, &config, pDecoder);
            }
        #endif
        }
    }

    /*
    If at this point we still haven't successfully initialized the decoder it most likely means
    the backend doesn't have an implementation for loading from a file path. We'll try using
    miniaudio's built-in file IO for loading file.
    */
    if (result == MA_SUCCESS) {
        /* Initialization was successful. Finish up. */
        result = ma_decoder__postinit(&config, pDecoder);
        if (result != MA_SUCCESS) {
            /*
            The backend was initialized successfully, but for some reason post-initialization failed. This is most likely
            due to an out of memory error. We're going to abort with an error here and not try to recover.
            */
            if (pDecoder->pBackendVTable != NULL && pDecoder->pBackendVTable->onUninit != NULL) {
                pDecoder->pBackendVTable->onUninit(pDecoder->pBackendUserData, &pDecoder->pBackend, &pDecoder->allocationCallbacks);
            }

            return result;
        }
    } else {
        /* Probably no implementation for loading from a block of memory. Use miniaudio's abstraction instead. */
        result = ma_decoder__preinit_memory_wrapper(pData, dataSize, &config, pDecoder);
        if (result != MA_SUCCESS) {
            return result;
        }

        result = ma_decoder_init__internal(ma_decoder__on_read_memory, ma_decoder__on_seek_memory, NULL, &config, pDecoder);
        if (result != MA_SUCCESS) {
            return result;
        }
    }

    return MA_SUCCESS;
}


#if defined(MA_HAS_WAV)    || \
    defined(MA_HAS_MP3)    || \
    defined(MA_HAS_FLAC)   || \
    defined(MA_HAS_VORBIS)
#define MA_HAS_PATH_API
#endif

#if defined(MA_HAS_PATH_API)
static const char* ma_path_file_name(const char* path)
{
    const char* fileName;

    if (path == NULL) {
        return NULL;
    }

    fileName = path;

    /* We just loop through the path until we find the last slash. */
    while (path[0] != '\0') {
        if (path[0] == '/' || path[0] == '\\') {
            fileName = path;
        }

        path += 1;
    }

    /* At this point the file name is sitting on a slash, so just move forward. */
    while (fileName[0] != '\0' && (fileName[0] == '/' || fileName[0] == '\\')) {
        fileName += 1;
    }

    return fileName;
}

static const wchar_t* ma_path_file_name_w(const wchar_t* path)
{
    const wchar_t* fileName;

    if (path == NULL) {
        return NULL;
    }

    fileName = path;

    /* We just loop through the path until we find the last slash. */
    while (path[0] != '\0') {
        if (path[0] == '/' || path[0] == '\\') {
            fileName = path;
        }

        path += 1;
    }

    /* At this point the file name is sitting on a slash, so just move forward. */
    while (fileName[0] != '\0' && (fileName[0] == '/' || fileName[0] == '\\')) {
        fileName += 1;
    }

    return fileName;
}


static const char* ma_path_extension(const char* path)
{
    const char* extension;
    const char* lastOccurance;

    if (path == NULL) {
        path = "";
    }

    extension = ma_path_file_name(path);
    lastOccurance = NULL;

    /* Just find the last '.' and return. */
    while (extension[0] != '\0') {
        if (extension[0] == '.') {
            extension += 1;
            lastOccurance = extension;
        }

        extension += 1;
    }

    return (lastOccurance != NULL) ? lastOccurance : extension;
}

static const wchar_t* ma_path_extension_w(const wchar_t* path)
{
    const wchar_t* extension;
    const wchar_t* lastOccurance;

    if (path == NULL) {
        path = L"";
    }

    extension = ma_path_file_name_w(path);
    lastOccurance = NULL;

    /* Just find the last '.' and return. */
    while (extension[0] != '\0') {
        if (extension[0] == '.') {
            extension += 1;
            lastOccurance = extension;
        }

        extension += 1;
    }

    return (lastOccurance != NULL) ? lastOccurance : extension;
}


static ma_bool32 ma_path_extension_equal(const char* path, const char* extension)
{
    const char* ext1;
    const char* ext2;

    if (path == NULL || extension == NULL) {
        return MA_FALSE;
    }

    ext1 = extension;
    ext2 = ma_path_extension(path);

#if defined(_MSC_VER) || defined(__DMC__)
    return _stricmp(ext1, ext2) == 0;
#else
    return strcasecmp(ext1, ext2) == 0;
#endif
}

static ma_bool32 ma_path_extension_equal_w(const wchar_t* path, const wchar_t* extension)
{
    const wchar_t* ext1;
    const wchar_t* ext2;

    if (path == NULL || extension == NULL) {
        return MA_FALSE;
    }

    ext1 = extension;
    ext2 = ma_path_extension_w(path);

#if defined(_MSC_VER) || defined(__WATCOMC__) || defined(__DMC__)
    return _wcsicmp(ext1, ext2) == 0;
#else
    /*
    I'm not aware of a wide character version of strcasecmp(). I'm therefore converting the extensions to multibyte strings and comparing those. This
    isn't the most efficient way to do it, but it should work OK.
    */
    {
        char ext1MB[4096];
        char ext2MB[4096];
        const wchar_t* pext1 = ext1;
        const wchar_t* pext2 = ext2;
        mbstate_t mbs1;
        mbstate_t mbs2;

        MA_ZERO_OBJECT(&mbs1);
        MA_ZERO_OBJECT(&mbs2);

        if (wcsrtombs(ext1MB, &pext1, sizeof(ext1MB), &mbs1) == (size_t)-1) {
            return MA_FALSE;
        }
        if (wcsrtombs(ext2MB, &pext2, sizeof(ext2MB), &mbs2) == (size_t)-1) {
            return MA_FALSE;
        }

        return strcasecmp(ext1MB, ext2MB) == 0;
    }
#endif
}
#endif  /* MA_HAS_PATH_API */



static ma_result ma_decoder__on_read_vfs(ma_decoder* pDecoder, void* pBufferOut, size_t bytesToRead, size_t* pBytesRead)
{
    MA_ASSERT(pDecoder   != NULL);
    MA_ASSERT(pBufferOut != NULL);

    return ma_vfs_or_default_read(pDecoder->data.vfs.pVFS, pDecoder->data.vfs.file, pBufferOut, bytesToRead, pBytesRead);
}

static ma_result ma_decoder__on_seek_vfs(ma_decoder* pDecoder, ma_int64 offset, ma_seek_origin origin)
{
    MA_ASSERT(pDecoder != NULL);

    return ma_vfs_or_default_seek(pDecoder->data.vfs.pVFS, pDecoder->data.vfs.file, offset, origin);
}

static ma_result ma_decoder__on_tell_vfs(ma_decoder* pDecoder, ma_int64* pCursor)
{
    MA_ASSERT(pDecoder != NULL);

    return ma_vfs_or_default_tell(pDecoder->data.vfs.pVFS, pDecoder->data.vfs.file, pCursor);
}

static ma_result ma_decoder__preinit_vfs(ma_vfs* pVFS, const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result;
    ma_vfs_file file;

    result = ma_decoder__preinit(ma_decoder__on_read_vfs, ma_decoder__on_seek_vfs, ma_decoder__on_tell_vfs, NULL, pConfig, pDecoder);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (pFilePath == NULL || pFilePath[0] == '\0') {
        return MA_INVALID_ARGS;
    }

    result = ma_vfs_or_default_open(pVFS, pFilePath, MA_OPEN_MODE_READ, &file);
    if (result != MA_SUCCESS) {
        return result;
    }

    pDecoder->data.vfs.pVFS = pVFS;
    pDecoder->data.vfs.file = file;

    return MA_SUCCESS;
}

MA_API ma_result ma_decoder_init_vfs(ma_vfs* pVFS, const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result;
    ma_decoder_config config;

    config = ma_decoder_config_init_copy(pConfig);
    result = ma_decoder__preinit_vfs(pVFS, pFilePath, &config, pDecoder);
    if (result != MA_SUCCESS) {
        return result;
    }

    result = MA_NO_BACKEND;

    if (config.encodingFormat != ma_encoding_format_unknown) {
    #ifdef MA_HAS_VORBIS
        if (config.encodingFormat == ma_encoding_format_vorbis) {
            result = ma_decoder_init_vorbis__internal(&config, pDecoder);
        }
    #endif

        /* Make sure we seek back to the start if we didn't initialize a decoder successfully so the next attempts have a fresh start. */
        if (result != MA_SUCCESS) {
            ma_decoder__on_seek_vfs(pDecoder, 0, ma_seek_origin_start);
        }
    }

    if (result != MA_SUCCESS) {
        /* Getting here means we weren't able to initialize a decoder of a specific encoding format. */

        /*
        We use trial and error to open a decoder. We prioritize custom decoders so that if they
        implement the same encoding format they take priority over the built-in decoders.
        */
        if (result != MA_SUCCESS) {
            result = ma_decoder_init_custom__internal(&config, pDecoder);
            if (result != MA_SUCCESS) {
                ma_decoder__on_seek_vfs(pDecoder, 0, ma_seek_origin_start);
            }
        }

        /*
        If we get to this point and we still haven't found a decoder, and the caller has requested a
        specific encoding format, there's no hope for it. Abort.
        */
        if (config.encodingFormat != ma_encoding_format_unknown) {
            return MA_NO_BACKEND;
        }

    }

    /* If we still haven't got a result just use trial and error. Otherwise we can finish up. */
    if (result != MA_SUCCESS) {
        result = ma_decoder_init__internal(ma_decoder__on_read_vfs, ma_decoder__on_seek_vfs, NULL, &config, pDecoder);
    } else {
        result = ma_decoder__postinit(&config, pDecoder);
    }

    if (result != MA_SUCCESS) {
        if (pDecoder->data.vfs.file != NULL) {   /* <-- Will be reset to NULL if ma_decoder_uninit() is called in one of the steps above which allows us to avoid a double close of the file. */
            ma_vfs_or_default_close(pVFS, pDecoder->data.vfs.file);
        }

        return result;
    }

    return MA_SUCCESS;
}


static ma_result ma_decoder__preinit_vfs_w(ma_vfs* pVFS, const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result;
    ma_vfs_file file;

    result = ma_decoder__preinit(ma_decoder__on_read_vfs, ma_decoder__on_seek_vfs, ma_decoder__on_tell_vfs, NULL, pConfig, pDecoder);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (pFilePath == NULL || pFilePath[0] == '\0') {
        return MA_INVALID_ARGS;
    }

    result = ma_vfs_or_default_open_w(pVFS, pFilePath, MA_OPEN_MODE_READ, &file);
    if (result != MA_SUCCESS) {
        return result;
    }

    pDecoder->data.vfs.pVFS = pVFS;
    pDecoder->data.vfs.file = file;

    return MA_SUCCESS;
}

MA_API ma_result ma_decoder_init_vfs_w(ma_vfs* pVFS, const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result;
    ma_decoder_config config;

    config = ma_decoder_config_init_copy(pConfig);
    result = ma_decoder__preinit_vfs_w(pVFS, pFilePath, &config, pDecoder);
    if (result != MA_SUCCESS) {
        return result;
    }

    result = MA_NO_BACKEND;

    if (config.encodingFormat != ma_encoding_format_unknown) {
    #ifdef MA_HAS_VORBIS
        if (config.encodingFormat == ma_encoding_format_vorbis) {
            result = ma_decoder_init_vorbis__internal(&config, pDecoder);
        }
    #endif

        /* Make sure we seek back to the start if we didn't initialize a decoder successfully so the next attempts have a fresh start. */
        if (result != MA_SUCCESS) {
            ma_decoder__on_seek_vfs(pDecoder, 0, ma_seek_origin_start);
        }
    }

    if (result != MA_SUCCESS) {
        /* Getting here means we weren't able to initialize a decoder of a specific encoding format. */

        /*
        We use trial and error to open a decoder. We prioritize custom decoders so that if they
        implement the same encoding format they take priority over the built-in decoders.
        */
        if (result != MA_SUCCESS) {
            result = ma_decoder_init_custom__internal(&config, pDecoder);
            if (result != MA_SUCCESS) {
                ma_decoder__on_seek_vfs(pDecoder, 0, ma_seek_origin_start);
            }
        }

        /*
        If we get to this point and we still haven't found a decoder, and the caller has requested a
        specific encoding format, there's no hope for it. Abort.
        */
        if (config.encodingFormat != ma_encoding_format_unknown) {
            return MA_NO_BACKEND;
        }

    }

    /* If we still haven't got a result just use trial and error. Otherwise we can finish up. */
    if (result != MA_SUCCESS) {
        result = ma_decoder_init__internal(ma_decoder__on_read_vfs, ma_decoder__on_seek_vfs, NULL, &config, pDecoder);
    } else {
        result = ma_decoder__postinit(&config, pDecoder);
    }

    if (result != MA_SUCCESS) {
        ma_vfs_or_default_close(pVFS, pDecoder->data.vfs.file);
        return result;
    }

    return MA_SUCCESS;
}


static ma_result ma_decoder__preinit_file(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result;

    result = ma_decoder__preinit(NULL, NULL, NULL, NULL, pConfig, pDecoder);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (pFilePath == NULL || pFilePath[0] == '\0') {
        return MA_INVALID_ARGS;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_decoder_init_file(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result;
    ma_decoder_config config;

    config = ma_decoder_config_init_copy(pConfig);
    result = ma_decoder__preinit_file(pFilePath, &config, pDecoder);
    if (result != MA_SUCCESS) {
        return result;
    }

    /* If the backend has support for loading from a file path we'll want to use that. If that all fails we'll fall back to the VFS path. */
    result = MA_NO_BACKEND;

    if (config.encodingFormat != ma_encoding_format_unknown) {
    #ifdef MA_HAS_VORBIS
        if (config.encodingFormat == ma_encoding_format_vorbis) {
            result = ma_decoder_init_vorbis_from_file__internal(pFilePath, &config, pDecoder);
        }
    #endif
    }

    if (result != MA_SUCCESS) {
        /* Getting here means we weren't able to initialize a decoder of a specific encoding format. */

        /*
        We use trial and error to open a decoder. We prioritize custom decoders so that if they
        implement the same encoding format they take priority over the built-in decoders.
        */
        result = ma_decoder_init_custom_from_file__internal(pFilePath, &config, pDecoder);

        /*
        If we get to this point and we still haven't found a decoder, and the caller has requested a
        specific encoding format, there's no hope for it. Abort.
        */
        if (result != MA_SUCCESS && config.encodingFormat != ma_encoding_format_unknown) {
            return MA_NO_BACKEND;
        }

        /* First try loading based on the file extension so we don't waste time opening and closing files. */
    #ifdef MA_HAS_VORBIS
        if (result != MA_SUCCESS && ma_path_extension_equal(pFilePath, "ogg")) {
            result = ma_decoder_init_vorbis_from_file__internal(pFilePath, &config, pDecoder);
        }
    #endif

        /*
        If we still haven't got a result just use trial and error. Custom decoders have already been attempted, so here we
        need only iterate over our stock decoders.
        */
        if (result != MA_SUCCESS) {
        #ifdef MA_HAS_VORBIS
            if (result != MA_SUCCESS) {
                result = ma_decoder_init_vorbis_from_file__internal(pFilePath, &config, pDecoder);
            }
        #endif
        }
    }

    /*
    If at this point we still haven't successfully initialized the decoder it most likely means
    the backend doesn't have an implementation for loading from a file path. We'll try using
    miniaudio's built-in file IO for loading file.
    */
    if (result == MA_SUCCESS) {
        /* Initialization was successful. Finish up. */
        result = ma_decoder__postinit(&config, pDecoder);
        if (result != MA_SUCCESS) {
            /*
            The backend was initialized successfully, but for some reason post-initialization failed. This is most likely
            due to an out of memory error. We're going to abort with an error here and not try to recover.
            */
            if (pDecoder->pBackendVTable != NULL && pDecoder->pBackendVTable->onUninit != NULL) {
                pDecoder->pBackendVTable->onUninit(pDecoder->pBackendUserData, &pDecoder->pBackend, &pDecoder->allocationCallbacks);
            }

            return result;
        }
    } else {
        /* Probably no implementation for loading from a file path. Use miniaudio's file IO instead. */
        result = ma_decoder_init_vfs(NULL, pFilePath, pConfig, pDecoder);
        if (result != MA_SUCCESS) {
            return result;
        }
    }

    return MA_SUCCESS;
}

static ma_result ma_decoder__preinit_file_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result;

    result = ma_decoder__preinit(NULL, NULL, NULL, NULL, pConfig, pDecoder);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (pFilePath == NULL || pFilePath[0] == '\0') {
        return MA_INVALID_ARGS;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_decoder_init_file_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
    ma_result result;
    ma_decoder_config config;

    config = ma_decoder_config_init_copy(pConfig);
    result = ma_decoder__preinit_file_w(pFilePath, &config, pDecoder);
    if (result != MA_SUCCESS) {
        return result;
    }

    /* If the backend has support for loading from a file path we'll want to use that. If that all fails we'll fall back to the VFS path. */
    result = MA_NO_BACKEND;

    if (config.encodingFormat != ma_encoding_format_unknown) {
    #ifdef MA_HAS_VORBIS
        if (config.encodingFormat == ma_encoding_format_vorbis) {
            result = ma_decoder_init_vorbis_from_file_w__internal(pFilePath, &config, pDecoder);
        }
    #endif
    }

    if (result != MA_SUCCESS) {
        /* Getting here means we weren't able to initialize a decoder of a specific encoding format. */

        /*
        We use trial and error to open a decoder. We prioritize custom decoders so that if they
        implement the same encoding format they take priority over the built-in decoders.
        */
        result = ma_decoder_init_custom_from_file_w__internal(pFilePath, &config, pDecoder);

        /*
        If we get to this point and we still haven't found a decoder, and the caller has requested a
        specific encoding format, there's no hope for it. Abort.
        */
        if (result != MA_SUCCESS && config.encodingFormat != ma_encoding_format_unknown) {
            return MA_NO_BACKEND;
        }

        /* First try loading based on the file extension so we don't waste time opening and closing files. */
    #ifdef MA_HAS_VORBIS
        if (result != MA_SUCCESS && ma_path_extension_equal_w(pFilePath, L"ogg")) {
            result = ma_decoder_init_vorbis_from_file_w__internal(pFilePath, &config, pDecoder);
        }
    #endif

        /*
        If we still haven't got a result just use trial and error. Custom decoders have already been attempted, so here we
        need only iterate over our stock decoders.
        */
        if (result != MA_SUCCESS) {
        #ifdef MA_HAS_VORBIS
            if (result != MA_SUCCESS) {
                result = ma_decoder_init_vorbis_from_file_w__internal(pFilePath, &config, pDecoder);
            }
        #endif
        }
    }

    /*
    If at this point we still haven't successfully initialized the decoder it most likely means
    the backend doesn't have an implementation for loading from a file path. We'll try using
    miniaudio's built-in file IO for loading file.
    */
    if (result == MA_SUCCESS) {
        /* Initialization was successful. Finish up. */
        result = ma_decoder__postinit(&config, pDecoder);
        if (result != MA_SUCCESS) {
            /*
            The backend was initialized successfully, but for some reason post-initialization failed. This is most likely
            due to an out of memory error. We're going to abort with an error here and not try to recover.
            */
            if (pDecoder->pBackendVTable != NULL && pDecoder->pBackendVTable->onUninit != NULL) {
                pDecoder->pBackendVTable->onUninit(pDecoder->pBackendUserData, &pDecoder->pBackend, &pDecoder->allocationCallbacks);
            }

            return result;
        }
    } else {
        /* Probably no implementation for loading from a file path. Use miniaudio's file IO instead. */
        result = ma_decoder_init_vfs_w(NULL, pFilePath, pConfig, pDecoder);
        if (result != MA_SUCCESS) {
            return result;
        }
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_decoder_uninit(ma_decoder* pDecoder)
{
    if (pDecoder == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pDecoder->pBackend != NULL) {
        if (pDecoder->pBackendVTable != NULL && pDecoder->pBackendVTable->onUninit != NULL) {
            pDecoder->pBackendVTable->onUninit(pDecoder->pBackendUserData, pDecoder->pBackend, &pDecoder->allocationCallbacks);
        }
    }

    if (pDecoder->onRead == ma_decoder__on_read_vfs) {
        ma_vfs_or_default_close(pDecoder->data.vfs.pVFS, pDecoder->data.vfs.file);
        pDecoder->data.vfs.file = NULL;
    }

    ma_data_converter_uninit(&pDecoder->converter, &pDecoder->allocationCallbacks);
    ma_data_source_uninit(&pDecoder->ds);

    if (pDecoder->pInputCache != NULL) {
        ma_free(pDecoder->pInputCache, &pDecoder->allocationCallbacks);
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_decoder_read_pcm_frames(ma_decoder* pDecoder, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    ma_result result = MA_SUCCESS;
    ma_uint64 totalFramesReadOut;
    void* pRunningFramesOut;

    if (pFramesRead != NULL) {
        *pFramesRead = 0;   /* Safety. */
    }

    if (frameCount == 0) {
        return MA_INVALID_ARGS;
    }

    if (pDecoder == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pDecoder->pBackend == NULL) {
        return MA_INVALID_OPERATION;
    }

    /* Fast path. */
    if (pDecoder->converter.isPassthrough) {
        result = ma_data_source_read_pcm_frames(pDecoder->pBackend, pFramesOut, frameCount, &totalFramesReadOut);
    } else {
        /*
        Getting here means we need to do data conversion. If we're seeking forward and are _not_ doing resampling we can run this in a fast path. If we're doing resampling we
        need to run through each sample because we need to ensure its internal cache is updated.
        */
        if (pFramesOut == NULL && pDecoder->converter.hasResampler == MA_FALSE) {
            result = ma_data_source_read_pcm_frames(pDecoder->pBackend, NULL, frameCount, &totalFramesReadOut);
        } else {
            /* Slow path. Need to run everything through the data converter. */
            ma_format internalFormat;
            ma_uint32 internalChannels;

            totalFramesReadOut = 0;
            pRunningFramesOut  = pFramesOut;

            result = ma_data_source_get_data_format(pDecoder->pBackend, &internalFormat, &internalChannels, NULL, NULL, 0);
            if (result != MA_SUCCESS) {
                return result;   /* Failed to retrieve the internal format and channel count. */
            }

            /*
            We run a different path depending on whether or not we are using a heap-allocated
            intermediary buffer or not. If the data converter does not support the calculation of
            the required number of input frames, we'll use the heap-allocated path. Otherwise we'll
            use the stack-allocated path.
            */
            if (pDecoder->pInputCache != NULL) {
                /* We don't have a way of determining the required number of input frames, so need to persistently store input data in a cache. */
                while (totalFramesReadOut < frameCount) {
                    ma_uint64 framesToReadThisIterationIn;
                    ma_uint64 framesToReadThisIterationOut;

                    /* If there's any data available in the cache, that needs to get processed first. */
                    if (pDecoder->inputCacheRemaining > 0) {
                        framesToReadThisIterationOut = (frameCount - totalFramesReadOut);
                        framesToReadThisIterationIn  = framesToReadThisIterationOut;
                        if (framesToReadThisIterationIn > pDecoder->inputCacheRemaining) {
                            framesToReadThisIterationIn = pDecoder->inputCacheRemaining;
                        }

                        result = ma_data_converter_process_pcm_frames(&pDecoder->converter, ma_offset_pcm_frames_ptr(pDecoder->pInputCache, pDecoder->inputCacheConsumed, internalFormat, internalChannels), &framesToReadThisIterationIn, pRunningFramesOut, &framesToReadThisIterationOut);
                        if (result != MA_SUCCESS) {
                            break;
                        }

                        pDecoder->inputCacheConsumed  += framesToReadThisIterationIn;
                        pDecoder->inputCacheRemaining -= framesToReadThisIterationIn;

                        totalFramesReadOut += framesToReadThisIterationOut;

                        if (pRunningFramesOut != NULL) {
                            pRunningFramesOut = ma_offset_ptr(pRunningFramesOut, framesToReadThisIterationOut * ma_get_bytes_per_frame(pDecoder->outputFormat, pDecoder->outputChannels));
                        }

                        if (framesToReadThisIterationIn == 0 && framesToReadThisIterationOut == 0) {
                            break;  /* We're done. */
                        }
                    }

                    /* Getting here means there's no data in the cache and we need to fill it up from the data source. */
                    if (pDecoder->inputCacheRemaining == 0) {
                        pDecoder->inputCacheConsumed = 0;

                        result = ma_data_source_read_pcm_frames(pDecoder->pBackend, pDecoder->pInputCache, pDecoder->inputCacheCap, &pDecoder->inputCacheRemaining);
                        if (result != MA_SUCCESS) {
                            break;
                        }
                    }
                }
            } else {
                /* We have a way of determining the required number of input frames so just use the stack. */
                while (totalFramesReadOut < frameCount) {
                    ma_uint8 pIntermediaryBuffer[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];  /* In internal format. */
                    ma_uint64 intermediaryBufferCap = sizeof(pIntermediaryBuffer) / ma_get_bytes_per_frame(internalFormat, internalChannels);
                    ma_uint64 framesToReadThisIterationIn;
                    ma_uint64 framesReadThisIterationIn;
                    ma_uint64 framesToReadThisIterationOut;
                    ma_uint64 framesReadThisIterationOut;
                    ma_uint64 requiredInputFrameCount;

                    framesToReadThisIterationOut = (frameCount - totalFramesReadOut);
                    framesToReadThisIterationIn = framesToReadThisIterationOut;
                    if (framesToReadThisIterationIn > intermediaryBufferCap) {
                        framesToReadThisIterationIn = intermediaryBufferCap;
                    }

                    ma_data_converter_get_required_input_frame_count(&pDecoder->converter, framesToReadThisIterationOut, &requiredInputFrameCount);
                    if (framesToReadThisIterationIn > requiredInputFrameCount) {
                        framesToReadThisIterationIn = requiredInputFrameCount;
                    }

                    if (requiredInputFrameCount > 0) {
                        result = ma_data_source_read_pcm_frames(pDecoder->pBackend, pIntermediaryBuffer, framesToReadThisIterationIn, &framesReadThisIterationIn);

                        /*
                        Note here that even if we've reached the end, we don't want to abort because there might be more output frames needing to be
                        generated from cached input data, which might happen if resampling is being performed.
                        */
                        if (result != MA_SUCCESS && result != MA_AT_END) {
                            break;
                        }
                    } else {
                        framesReadThisIterationIn = 0;
                        pIntermediaryBuffer[0] = 0; /* <-- This is just to silence a static analysis warning. */
                    }

                    /*
                    At this point we have our decoded data in input format and now we need to convert to output format. Note that even if we didn't read any
                    input frames, we still want to try processing frames because there may some output frames generated from cached input data.
                    */
                    framesReadThisIterationOut = framesToReadThisIterationOut;
                    result = ma_data_converter_process_pcm_frames(&pDecoder->converter, pIntermediaryBuffer, &framesReadThisIterationIn, pRunningFramesOut, &framesReadThisIterationOut);
                    if (result != MA_SUCCESS) {
                        break;
                    }

                    totalFramesReadOut += framesReadThisIterationOut;

                    if (pRunningFramesOut != NULL) {
                        pRunningFramesOut = ma_offset_ptr(pRunningFramesOut, framesReadThisIterationOut * ma_get_bytes_per_frame(pDecoder->outputFormat, pDecoder->outputChannels));
                    }

                    if (framesReadThisIterationIn == 0 && framesReadThisIterationOut == 0) {
                        break;  /* We're done. */
                    }
                }
            }
        }
    }

    pDecoder->readPointerInPCMFrames += totalFramesReadOut;

    if (pFramesRead != NULL) {
        *pFramesRead = totalFramesReadOut;
    }

    if (result == MA_SUCCESS && totalFramesReadOut == 0) {
        result =  MA_AT_END;
    }

    return result;
}

MA_API ma_result ma_decoder_seek_to_pcm_frame(ma_decoder* pDecoder, ma_uint64 frameIndex)
{
    if (pDecoder == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pDecoder->pBackend != NULL) {
        ma_result result;
        ma_uint64 internalFrameIndex;
        ma_uint32 internalSampleRate;
        ma_uint64 currentFrameIndex;

        result = ma_data_source_get_data_format(pDecoder->pBackend, NULL, NULL, &internalSampleRate, NULL, 0);
        if (result != MA_SUCCESS) {
            return result;  /* Failed to retrieve the internal sample rate. */
        }

        if (internalSampleRate == pDecoder->outputSampleRate) {
            internalFrameIndex = frameIndex;
        } else {
            internalFrameIndex = ma_calculate_frame_count_after_resampling(internalSampleRate, pDecoder->outputSampleRate, frameIndex);
        }

        /* Only seek if we're requesting a different frame to what we're currently sitting on. */
        ma_data_source_get_cursor_in_pcm_frames(pDecoder->pBackend, &currentFrameIndex);
        if (currentFrameIndex != internalFrameIndex) {
            result = ma_data_source_seek_to_pcm_frame(pDecoder->pBackend, internalFrameIndex);
            if (result == MA_SUCCESS) {
                pDecoder->readPointerInPCMFrames = frameIndex;
            }

            /* Reset the data converter so that any cached data in the resampler is cleared. */
            ma_data_converter_reset(&pDecoder->converter);
        }

        return result;
    }

    /* Should never get here, but if we do it means onSeekToPCMFrame was not set by the backend. */
    return MA_INVALID_ARGS;
}

MA_API ma_result ma_decoder_get_data_format(ma_decoder* pDecoder, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)
{
    if (pDecoder == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pFormat != NULL) {
        *pFormat = pDecoder->outputFormat;
    }

    if (pChannels != NULL) {
        *pChannels = pDecoder->outputChannels;
    }

    if (pSampleRate != NULL) {
        *pSampleRate = pDecoder->outputSampleRate;
    }

    if (pChannelMap != NULL) {
        ma_data_converter_get_output_channel_map(&pDecoder->converter, pChannelMap, channelMapCap);
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_decoder_get_cursor_in_pcm_frames(ma_decoder* pDecoder, ma_uint64* pCursor)
{
    if (pCursor == NULL) {
        return MA_INVALID_ARGS;
    }

    *pCursor = 0;

    if (pDecoder == NULL) {
        return MA_INVALID_ARGS;
    }

    *pCursor = pDecoder->readPointerInPCMFrames;

    return MA_SUCCESS;
}

MA_API ma_result ma_decoder_get_length_in_pcm_frames(ma_decoder* pDecoder, ma_uint64* pLength)
{
    if (pLength == NULL) {
        return MA_INVALID_ARGS;
    }

    *pLength = 0;

    if (pDecoder == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pDecoder->pBackend != NULL) {
        ma_result result;
        ma_uint64 internalLengthInPCMFrames;
        ma_uint32 internalSampleRate;

        result = ma_data_source_get_length_in_pcm_frames(pDecoder->pBackend, &internalLengthInPCMFrames);
        if (result != MA_SUCCESS) {
            return result;  /* Failed to retrieve the internal length. */
        }

        result = ma_data_source_get_data_format(pDecoder->pBackend, NULL, NULL, &internalSampleRate, NULL, 0);
        if (result != MA_SUCCESS) {
            return result;   /* Failed to retrieve the internal sample rate. */
        }

        if (internalSampleRate == pDecoder->outputSampleRate) {
            *pLength = internalLengthInPCMFrames;
        } else {
            *pLength = ma_calculate_frame_count_after_resampling(pDecoder->outputSampleRate, internalSampleRate, internalLengthInPCMFrames);
        }

        return MA_SUCCESS;
    } else {
        return MA_NO_BACKEND;
    }
}

MA_API ma_result ma_decoder_get_available_frames(ma_decoder* pDecoder, ma_uint64* pAvailableFrames)
{
    ma_result result;
    ma_uint64 totalFrameCount;

    if (pAvailableFrames == NULL) {
        return MA_INVALID_ARGS;
    }

    *pAvailableFrames = 0;

    if (pDecoder == NULL) {
        return MA_INVALID_ARGS;
    }

    result = ma_decoder_get_length_in_pcm_frames(pDecoder, &totalFrameCount);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (totalFrameCount <= pDecoder->readPointerInPCMFrames) {
        *pAvailableFrames = 0;
    } else {
        *pAvailableFrames = totalFrameCount - pDecoder->readPointerInPCMFrames;
    }

    return MA_SUCCESS;
}


static ma_result ma_decoder__full_decode_and_uninit(ma_decoder* pDecoder, ma_decoder_config* pConfigOut, ma_uint64* pFrameCountOut, void** ppPCMFramesOut)
{
    ma_result result;
    ma_uint64 totalFrameCount;
    ma_uint64 bpf;
    ma_uint64 dataCapInFrames;
    void* pPCMFramesOut;

    MA_ASSERT(pDecoder != NULL);

    totalFrameCount = 0;
    bpf = ma_get_bytes_per_frame(pDecoder->outputFormat, pDecoder->outputChannels);

    /* The frame count is unknown until we try reading. Thus, we just run in a loop. */
    dataCapInFrames = 0;
    pPCMFramesOut = NULL;
    for (;;) {
        ma_uint64 frameCountToTryReading;
        ma_uint64 framesJustRead;

        /* Make room if there's not enough. */
        if (totalFrameCount == dataCapInFrames) {
            void* pNewPCMFramesOut;
            ma_uint64 newDataCapInFrames = dataCapInFrames*2;
            if (newDataCapInFrames == 0) {
                newDataCapInFrames = 4096;
            }

            if ((newDataCapInFrames * bpf) > MA_SIZE_MAX) {
                ma_free(pPCMFramesOut, &pDecoder->allocationCallbacks);
                return MA_TOO_BIG;
            }

            pNewPCMFramesOut = (void*)ma_realloc(pPCMFramesOut, (size_t)(newDataCapInFrames * bpf), &pDecoder->allocationCallbacks);
            if (pNewPCMFramesOut == NULL) {
                ma_free(pPCMFramesOut, &pDecoder->allocationCallbacks);
                return MA_OUT_OF_MEMORY;
            }

            dataCapInFrames = newDataCapInFrames;
            pPCMFramesOut = pNewPCMFramesOut;
        }

        frameCountToTryReading = dataCapInFrames - totalFrameCount;
        MA_ASSERT(frameCountToTryReading > 0);

        result = ma_decoder_read_pcm_frames(pDecoder, (ma_uint8*)pPCMFramesOut + (totalFrameCount * bpf), frameCountToTryReading, &framesJustRead);
        totalFrameCount += framesJustRead;

        if (result != MA_SUCCESS) {
            break;
        }

        if (framesJustRead < frameCountToTryReading) {
            break;
        }
    }


    if (pConfigOut != NULL) {
        pConfigOut->format     = pDecoder->outputFormat;
        pConfigOut->channels   = pDecoder->outputChannels;
        pConfigOut->sampleRate = pDecoder->outputSampleRate;
    }

    if (ppPCMFramesOut != NULL) {
        *ppPCMFramesOut = pPCMFramesOut;
    } else {
        ma_free(pPCMFramesOut, &pDecoder->allocationCallbacks);
    }

    if (pFrameCountOut != NULL) {
        *pFrameCountOut = totalFrameCount;
    }

    ma_decoder_uninit(pDecoder);
    return MA_SUCCESS;
}

MA_API ma_result ma_decode_from_vfs(ma_vfs* pVFS, const char* pFilePath, ma_decoder_config* pConfig, ma_uint64* pFrameCountOut, void** ppPCMFramesOut)
{
    ma_result result;
    ma_decoder_config config;
    ma_decoder decoder;

    if (pFrameCountOut != NULL) {
        *pFrameCountOut = 0;
    }
    if (ppPCMFramesOut != NULL) {
        *ppPCMFramesOut = NULL;
    }

    config = ma_decoder_config_init_copy(pConfig);

    result = ma_decoder_init_vfs(pVFS, pFilePath, &config, &decoder);
    if (result != MA_SUCCESS) {
        return result;
    }

    result = ma_decoder__full_decode_and_uninit(&decoder, pConfig, pFrameCountOut, ppPCMFramesOut);

    return result;
}

MA_API ma_result ma_decode_file(const char* pFilePath, ma_decoder_config* pConfig, ma_uint64* pFrameCountOut, void** ppPCMFramesOut)
{
    return ma_decode_from_vfs(NULL, pFilePath, pConfig, pFrameCountOut, ppPCMFramesOut);
}

MA_API ma_result ma_decode_memory(const void* pData, size_t dataSize, ma_decoder_config* pConfig, ma_uint64* pFrameCountOut, void** ppPCMFramesOut)
{
    ma_decoder_config config;
    ma_decoder decoder;
    ma_result result;

    if (pFrameCountOut != NULL) {
        *pFrameCountOut = 0;
    }
    if (ppPCMFramesOut != NULL) {
        *ppPCMFramesOut = NULL;
    }

    if (pData == NULL || dataSize == 0) {
        return MA_INVALID_ARGS;
    }

    config = ma_decoder_config_init_copy(pConfig);

    result = ma_decoder_init_memory(pData, dataSize, &config, &decoder);
    if (result != MA_SUCCESS) {
        return result;
    }

    return ma_decoder__full_decode_and_uninit(&decoder, pConfig, pFrameCountOut, ppPCMFramesOut);
}
#endif  /* MA_NO_DECODING */





/**************************************************************************************************************************************************************

Generation

**************************************************************************************************************************************************************/



#ifndef MA_NO_RESOURCE_MANAGER
#ifndef MA_RESOURCE_MANAGER_PAGE_SIZE_IN_MILLISECONDS
#define MA_RESOURCE_MANAGER_PAGE_SIZE_IN_MILLISECONDS   1000
#endif

#ifndef MA_JOB_TYPE_RESOURCE_MANAGER_QUEUE_CAPACITY
#define MA_JOB_TYPE_RESOURCE_MANAGER_QUEUE_CAPACITY          1024
#endif

MA_API ma_resource_manager_pipeline_notifications ma_resource_manager_pipeline_notifications_init(void)
{
    ma_resource_manager_pipeline_notifications notifications;

    MA_ZERO_OBJECT(&notifications);

    return notifications;
}

static void ma_resource_manager_pipeline_notifications_signal_all_notifications(const ma_resource_manager_pipeline_notifications* pPipelineNotifications)
{
    if (pPipelineNotifications == NULL) {
        return;
    }

    if (pPipelineNotifications->init.pNotification) { ma_async_notification_signal(pPipelineNotifications->init.pNotification); }
    if (pPipelineNotifications->done.pNotification) { ma_async_notification_signal(pPipelineNotifications->done.pNotification); }
}

static void ma_resource_manager_pipeline_notifications_acquire_all_fences(const ma_resource_manager_pipeline_notifications* pPipelineNotifications)
{
    if (pPipelineNotifications == NULL) {
        return;
    }

    if (pPipelineNotifications->init.pFence != NULL) { ma_fence_acquire(pPipelineNotifications->init.pFence); }
    if (pPipelineNotifications->done.pFence != NULL) { ma_fence_acquire(pPipelineNotifications->done.pFence); }
}

static void ma_resource_manager_pipeline_notifications_release_all_fences(const ma_resource_manager_pipeline_notifications* pPipelineNotifications)
{
    if (pPipelineNotifications == NULL) {
        return;
    }

    if (pPipelineNotifications->init.pFence != NULL) { ma_fence_release(pPipelineNotifications->init.pFence); }
    if (pPipelineNotifications->done.pFence != NULL) { ma_fence_release(pPipelineNotifications->done.pFence); }
}



#ifndef MA_DEFAULT_HASH_SEED
#define MA_DEFAULT_HASH_SEED    42
#endif

/* MurmurHash3. Based on code from https://github.com/PeterScott/murmur3/blob/master/murmur3.c (public domain). */
#if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)))
    #pragma GCC diagnostic push
    #if __GNUC__ >= 7
    #pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
    #endif
#endif

static MA_INLINE ma_uint32 ma_rotl32(ma_uint32 x, ma_int8 r)
{
    return (x << r) | (x >> (32 - r));
}

static MA_INLINE ma_uint32 ma_hash_getblock(const ma_uint32* blocks, int i)
{
    ma_uint32 block;

    /* Try silencing a sanitization warning about unaligned access by doing a memcpy() instead of assignment. */
    MA_COPY_MEMORY(&block, ma_offset_ptr(blocks, i * sizeof(block)), sizeof(block));

    if (ma_is_little_endian()) {
        return block;
    } else {
        return ma_swap_endian_uint32(block);
    }
}

static MA_INLINE ma_uint32 ma_hash_fmix32(ma_uint32 h)
{
    h ^= h >> 16;
    h *= 0x85ebca6b;
    h ^= h >> 13;
    h *= 0xc2b2ae35;
    h ^= h >> 16;

    return h;
}

static ma_uint32 ma_hash_32(const void* key, int len, ma_uint32 seed)
{
    const ma_uint8* data = (const ma_uint8*)key;
    const ma_uint32* blocks;
    const ma_uint8* tail;
    const int nblocks = len / 4;
    ma_uint32 h1 = seed;
    ma_uint32 c1 = 0xcc9e2d51;
    ma_uint32 c2 = 0x1b873593;
    ma_uint32 k1;
    int i;

    blocks = (const ma_uint32 *)(data + nblocks*4);

    for(i = -nblocks; i; i++) {
        k1 = ma_hash_getblock(blocks,i);

        k1 *= c1;
        k1 = ma_rotl32(k1, 15);
        k1 *= c2;

        h1 ^= k1;
        h1 = ma_rotl32(h1, 13);
        h1 = h1*5 + 0xe6546b64;
    }


    tail = (const ma_uint8*)(data + nblocks*4);

    k1 = 0;
    switch(len & 3) {
        case 3: k1 ^= tail[2] << 16;
        case 2: k1 ^= tail[1] << 8;
        case 1: k1 ^= tail[0];
                k1 *= c1; k1 = ma_rotl32(k1, 15); k1 *= c2; h1 ^= k1;
    };


    h1 ^= len;
    h1  = ma_hash_fmix32(h1);

    return h1;
}

#if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)))
    #pragma GCC diagnostic push
#endif
/* End MurmurHash3 */

static ma_uint32 ma_hash_string_32(const char* str)
{
    return ma_hash_32(str, (int)strlen(str), MA_DEFAULT_HASH_SEED);
}

static ma_uint32 ma_hash_string_w_32(const wchar_t* str)
{
    return ma_hash_32(str, (int)wcslen(str) * sizeof(*str), MA_DEFAULT_HASH_SEED);
}




/*
Basic BST Functions
*/
static ma_result ma_resource_manager_data_buffer_node_search(ma_resource_manager* pResourceManager, ma_uint32 hashedName32, ma_resource_manager_data_buffer_node** ppDataBufferNode)
{
    ma_resource_manager_data_buffer_node* pCurrentNode;

    MA_ASSERT(pResourceManager != NULL);
    MA_ASSERT(ppDataBufferNode != NULL);

    pCurrentNode = pResourceManager->pRootDataBufferNode;
    while (pCurrentNode != NULL) {
        if (hashedName32 == pCurrentNode->hashedName32) {
            break;  /* Found. */
        } else if (hashedName32 < pCurrentNode->hashedName32) {
            pCurrentNode = pCurrentNode->pChildLo;
        } else {
            pCurrentNode = pCurrentNode->pChildHi;
        }
    }

    *ppDataBufferNode = pCurrentNode;

    if (pCurrentNode == NULL) {
        return MA_DOES_NOT_EXIST;
    } else {
        return MA_SUCCESS;
    }
}

static ma_result ma_resource_manager_data_buffer_node_insert_point(ma_resource_manager* pResourceManager, ma_uint32 hashedName32, ma_resource_manager_data_buffer_node** ppInsertPoint)
{
    ma_result result = MA_SUCCESS;
    ma_resource_manager_data_buffer_node* pCurrentNode;

    MA_ASSERT(pResourceManager != NULL);
    MA_ASSERT(ppInsertPoint    != NULL);

    *ppInsertPoint = NULL;

    if (pResourceManager->pRootDataBufferNode == NULL) {
        return MA_SUCCESS;  /* No items. */
    }

    /* We need to find the node that will become the parent of the new node. If a node is found that already has the same hashed name we need to return MA_ALREADY_EXISTS. */
    pCurrentNode = pResourceManager->pRootDataBufferNode;
    while (pCurrentNode != NULL) {
        if (hashedName32 == pCurrentNode->hashedName32) {
            result = MA_ALREADY_EXISTS;
            break;
        } else {
            if (hashedName32 < pCurrentNode->hashedName32) {
                if (pCurrentNode->pChildLo == NULL) {
                    result = MA_SUCCESS;
                    break;
                } else {
                    pCurrentNode = pCurrentNode->pChildLo;
                }
            } else {
                if (pCurrentNode->pChildHi == NULL) {
                    result = MA_SUCCESS;
                    break;
                } else {
                    pCurrentNode = pCurrentNode->pChildHi;
                }
            }
        }
    }

    *ppInsertPoint = pCurrentNode;
    return result;
}

static ma_result ma_resource_manager_data_buffer_node_insert_at(ma_resource_manager* pResourceManager, ma_resource_manager_data_buffer_node* pDataBufferNode, ma_resource_manager_data_buffer_node* pInsertPoint)
{
    MA_ASSERT(pResourceManager != NULL);
    MA_ASSERT(pDataBufferNode  != NULL);

    /* The key must have been set before calling this function. */
    MA_ASSERT(pDataBufferNode->hashedName32 != 0);

    if (pInsertPoint == NULL) {
        /* It's the first node. */
        pResourceManager->pRootDataBufferNode = pDataBufferNode;
    } else {
        /* It's not the first node. It needs to be inserted. */
        if (pDataBufferNode->hashedName32 < pInsertPoint->hashedName32) {
            MA_ASSERT(pInsertPoint->pChildLo == NULL);
            pInsertPoint->pChildLo = pDataBufferNode;
        } else {
            MA_ASSERT(pInsertPoint->pChildHi == NULL);
            pInsertPoint->pChildHi = pDataBufferNode;
        }
    }

    pDataBufferNode->pParent = pInsertPoint;

    return MA_SUCCESS;
}

#if 0   /* Unused for now. */
static ma_result ma_resource_manager_data_buffer_node_insert(ma_resource_manager* pResourceManager, ma_resource_manager_data_buffer_node* pDataBufferNode)
{
    ma_result result;
    ma_resource_manager_data_buffer_node* pInsertPoint;

    MA_ASSERT(pResourceManager != NULL);
    MA_ASSERT(pDataBufferNode  != NULL);

    result = ma_resource_manager_data_buffer_node_insert_point(pResourceManager, pDataBufferNode->hashedName32, &pInsertPoint);
    if (result != MA_SUCCESS) {
        return MA_INVALID_ARGS;
    }

    return ma_resource_manager_data_buffer_node_insert_at(pResourceManager, pDataBufferNode, pInsertPoint);
}
#endif

static MA_INLINE ma_resource_manager_data_buffer_node* ma_resource_manager_data_buffer_node_find_min(ma_resource_manager_data_buffer_node* pDataBufferNode)
{
    ma_resource_manager_data_buffer_node* pCurrentNode;

    MA_ASSERT(pDataBufferNode != NULL);

    pCurrentNode = pDataBufferNode;
    while (pCurrentNode->pChildLo != NULL) {
        pCurrentNode = pCurrentNode->pChildLo;
    }

    return pCurrentNode;
}

static MA_INLINE ma_resource_manager_data_buffer_node* ma_resource_manager_data_buffer_node_find_max(ma_resource_manager_data_buffer_node* pDataBufferNode)
{
    ma_resource_manager_data_buffer_node* pCurrentNode;

    MA_ASSERT(pDataBufferNode != NULL);

    pCurrentNode = pDataBufferNode;
    while (pCurrentNode->pChildHi != NULL) {
        pCurrentNode = pCurrentNode->pChildHi;
    }

    return pCurrentNode;
}

static MA_INLINE ma_resource_manager_data_buffer_node* ma_resource_manager_data_buffer_node_find_inorder_successor(ma_resource_manager_data_buffer_node* pDataBufferNode)
{
    MA_ASSERT(pDataBufferNode           != NULL);
    MA_ASSERT(pDataBufferNode->pChildHi != NULL);

    return ma_resource_manager_data_buffer_node_find_min(pDataBufferNode->pChildHi);
}

static MA_INLINE ma_resource_manager_data_buffer_node* ma_resource_manager_data_buffer_node_find_inorder_predecessor(ma_resource_manager_data_buffer_node* pDataBufferNode)
{
    MA_ASSERT(pDataBufferNode           != NULL);
    MA_ASSERT(pDataBufferNode->pChildLo != NULL);

    return ma_resource_manager_data_buffer_node_find_max(pDataBufferNode->pChildLo);
}

static ma_result ma_resource_manager_data_buffer_node_remove(ma_resource_manager* pResourceManager, ma_resource_manager_data_buffer_node* pDataBufferNode)
{
    MA_ASSERT(pResourceManager != NULL);
    MA_ASSERT(pDataBufferNode  != NULL);

    if (pDataBufferNode->pChildLo == NULL) {
        if (pDataBufferNode->pChildHi == NULL) {
            /* Simple case - deleting a buffer with no children. */
            if (pDataBufferNode->pParent == NULL) {
                MA_ASSERT(pResourceManager->pRootDataBufferNode == pDataBufferNode);    /* There is only a single buffer in the tree which should be equal to the root node. */
                pResourceManager->pRootDataBufferNode = NULL;
            } else {
                if (pDataBufferNode->pParent->pChildLo == pDataBufferNode) {
                    pDataBufferNode->pParent->pChildLo = NULL;
                } else {
                    pDataBufferNode->pParent->pChildHi = NULL;
                }
            }
        } else {
            /* Node has one child - pChildHi != NULL. */
            pDataBufferNode->pChildHi->pParent = pDataBufferNode->pParent;

            if (pDataBufferNode->pParent == NULL) {
                MA_ASSERT(pResourceManager->pRootDataBufferNode == pDataBufferNode);
                pResourceManager->pRootDataBufferNode = pDataBufferNode->pChildHi;
            } else {
                if (pDataBufferNode->pParent->pChildLo == pDataBufferNode) {
                    pDataBufferNode->pParent->pChildLo = pDataBufferNode->pChildHi;
                } else {
                    pDataBufferNode->pParent->pChildHi = pDataBufferNode->pChildHi;
                }
            }
        }
    } else {
        if (pDataBufferNode->pChildHi == NULL) {
            /* Node has one child - pChildLo != NULL. */
            pDataBufferNode->pChildLo->pParent = pDataBufferNode->pParent;

            if (pDataBufferNode->pParent == NULL) {
                MA_ASSERT(pResourceManager->pRootDataBufferNode == pDataBufferNode);
                pResourceManager->pRootDataBufferNode = pDataBufferNode->pChildLo;
            } else {
                if (pDataBufferNode->pParent->pChildLo == pDataBufferNode) {
                    pDataBufferNode->pParent->pChildLo = pDataBufferNode->pChildLo;
                } else {
                    pDataBufferNode->pParent->pChildHi = pDataBufferNode->pChildLo;
                }
            }
        } else {
            /* Complex case - deleting a node with two children. */
            ma_resource_manager_data_buffer_node* pReplacementDataBufferNode;

            /* For now we are just going to use the in-order successor as the replacement, but we may want to try to keep this balanced by switching between the two. */
            pReplacementDataBufferNode = ma_resource_manager_data_buffer_node_find_inorder_successor(pDataBufferNode);
            MA_ASSERT(pReplacementDataBufferNode != NULL);

            /*
            Now that we have our replacement node we can make the change. The simple way to do this would be to just exchange the values, and then remove the replacement
            node, however we track specific nodes via pointers which means we can't just swap out the values. We need to instead just change the pointers around. The
            replacement node should have at most 1 child. Therefore, we can detach it in terms of our simpler cases above. What we're essentially doing is detaching the
            replacement node and reinserting it into the same position as the deleted node.
            */
            MA_ASSERT(pReplacementDataBufferNode->pParent  != NULL);  /* The replacement node should never be the root which means it should always have a parent. */
            MA_ASSERT(pReplacementDataBufferNode->pChildLo == NULL);  /* Because we used in-order successor. This would be pChildHi == NULL if we used in-order predecessor. */

            if (pReplacementDataBufferNode->pChildHi == NULL) {
                if (pReplacementDataBufferNode->pParent->pChildLo == pReplacementDataBufferNode) {
                    pReplacementDataBufferNode->pParent->pChildLo = NULL;
                } else {
                    pReplacementDataBufferNode->pParent->pChildHi = NULL;
                }
            } else {
                pReplacementDataBufferNode->pChildHi->pParent = pReplacementDataBufferNode->pParent;
                if (pReplacementDataBufferNode->pParent->pChildLo == pReplacementDataBufferNode) {
                    pReplacementDataBufferNode->pParent->pChildLo = pReplacementDataBufferNode->pChildHi;
                } else {
                    pReplacementDataBufferNode->pParent->pChildHi = pReplacementDataBufferNode->pChildHi;
                }
            }


            /* The replacement node has essentially been detached from the binary tree, so now we need to replace the old data buffer with it. The first thing to update is the parent */
            if (pDataBufferNode->pParent != NULL) {
                if (pDataBufferNode->pParent->pChildLo == pDataBufferNode) {
                    pDataBufferNode->pParent->pChildLo = pReplacementDataBufferNode;
                } else {
                    pDataBufferNode->pParent->pChildHi = pReplacementDataBufferNode;
                }
            }

            /* Now need to update the replacement node's pointers. */
            pReplacementDataBufferNode->pParent  = pDataBufferNode->pParent;
            pReplacementDataBufferNode->pChildLo = pDataBufferNode->pChildLo;
            pReplacementDataBufferNode->pChildHi = pDataBufferNode->pChildHi;

            /* Now the children of the replacement node need to have their parent pointers updated. */
            if (pReplacementDataBufferNode->pChildLo != NULL) {
                pReplacementDataBufferNode->pChildLo->pParent = pReplacementDataBufferNode;
            }
            if (pReplacementDataBufferNode->pChildHi != NULL) {
                pReplacementDataBufferNode->pChildHi->pParent = pReplacementDataBufferNode;
            }

            /* Now the root node needs to be updated. */
            if (pResourceManager->pRootDataBufferNode == pDataBufferNode) {
                pResourceManager->pRootDataBufferNode = pReplacementDataBufferNode;
            }
        }
    }

    return MA_SUCCESS;
}

#if 0   /* Unused for now. */
static ma_result ma_resource_manager_data_buffer_node_remove_by_key(ma_resource_manager* pResourceManager, ma_uint32 hashedName32)
{
    ma_result result;
    ma_resource_manager_data_buffer_node* pDataBufferNode;

    result = ma_resource_manager_data_buffer_search(pResourceManager, hashedName32, &pDataBufferNode);
    if (result != MA_SUCCESS) {
        return result;  /* Could not find the data buffer. */
    }

    return ma_resource_manager_data_buffer_remove(pResourceManager, pDataBufferNode);
}
#endif

static ma_resource_manager_data_supply_type ma_resource_manager_data_buffer_node_get_data_supply_type(ma_resource_manager_data_buffer_node* pDataBufferNode)
{
    return (ma_resource_manager_data_supply_type)ma_atomic_load_i32(&pDataBufferNode->data.type);
}

static void ma_resource_manager_data_buffer_node_set_data_supply_type(ma_resource_manager_data_buffer_node* pDataBufferNode, ma_resource_manager_data_supply_type supplyType)
{
    ma_atomic_exchange_i32(&pDataBufferNode->data.type, supplyType);
}

static ma_result ma_resource_manager_data_buffer_node_increment_ref(ma_resource_manager* pResourceManager, ma_resource_manager_data_buffer_node* pDataBufferNode, ma_uint32* pNewRefCount)
{
    ma_uint32 refCount;

    MA_ASSERT(pResourceManager != NULL);
    MA_ASSERT(pDataBufferNode  != NULL);

    (void)pResourceManager;

    refCount = ma_atomic_fetch_add_32(&pDataBufferNode->refCount, 1) + 1;

    if (pNewRefCount != NULL) {
        *pNewRefCount = refCount;
    }

    return MA_SUCCESS;
}

static ma_result ma_resource_manager_data_buffer_node_decrement_ref(ma_resource_manager* pResourceManager, ma_resource_manager_data_buffer_node* pDataBufferNode, ma_uint32* pNewRefCount)
{
    ma_uint32 refCount;

    MA_ASSERT(pResourceManager != NULL);
    MA_ASSERT(pDataBufferNode  != NULL);

    (void)pResourceManager;

    refCount = ma_atomic_fetch_sub_32(&pDataBufferNode->refCount, 1) - 1;

    if (pNewRefCount != NULL) {
        *pNewRefCount = refCount;
    }

    return MA_SUCCESS;
}

static void ma_resource_manager_data_buffer_node_free(ma_resource_manager* pResourceManager, ma_resource_manager_data_buffer_node* pDataBufferNode)
{
    MA_ASSERT(pResourceManager != NULL);
    MA_ASSERT(pDataBufferNode  != NULL);

    if (pDataBufferNode->isDataOwnedByResourceManager) {
        if (ma_resource_manager_data_buffer_node_get_data_supply_type(pDataBufferNode) == ma_resource_manager_data_supply_type_encoded) {
            ma_free((void*)pDataBufferNode->data.backend.encoded.pData, &pResourceManager->config.allocationCallbacks);
            pDataBufferNode->data.backend.encoded.pData       = NULL;
            pDataBufferNode->data.backend.encoded.sizeInBytes = 0;
        } else if (ma_resource_manager_data_buffer_node_get_data_supply_type(pDataBufferNode) == ma_resource_manager_data_supply_type_decoded) {
            ma_free((void*)pDataBufferNode->data.backend.decoded.pData, &pResourceManager->config.allocationCallbacks);
            pDataBufferNode->data.backend.decoded.pData           = NULL;
            pDataBufferNode->data.backend.decoded.totalFrameCount = 0;
        } else if (ma_resource_manager_data_buffer_node_get_data_supply_type(pDataBufferNode) == ma_resource_manager_data_supply_type_decoded_paged) {
            ma_paged_audio_buffer_data_uninit(&pDataBufferNode->data.backend.decodedPaged.data, &pResourceManager->config.allocationCallbacks);
        } else {
            /* Should never hit this if the node was successfully initialized. */
            MA_ASSERT(pDataBufferNode->result != MA_SUCCESS);
        }
    }

    /* The data buffer itself needs to be freed. */
    ma_free(pDataBufferNode, &pResourceManager->config.allocationCallbacks);
}

static ma_result ma_resource_manager_data_buffer_node_result(const ma_resource_manager_data_buffer_node* pDataBufferNode)
{
    MA_ASSERT(pDataBufferNode != NULL);

    return (ma_result)ma_atomic_load_i32((ma_result*)&pDataBufferNode->result);    /* Need a naughty const-cast here. */
}


static ma_bool32 ma_resource_manager_is_threading_enabled(const ma_resource_manager* pResourceManager)
{
    MA_ASSERT(pResourceManager != NULL);

    return (pResourceManager->config.flags & MA_RESOURCE_MANAGER_FLAG_NO_THREADING) == 0;
}


typedef struct
{
    union
    {
        ma_async_notification_event e;
        ma_async_notification_poll p;
    } backend;  /* Must be the first member. */
    ma_resource_manager* pResourceManager;
} ma_resource_manager_inline_notification;

static ma_result ma_resource_manager_inline_notification_init(ma_resource_manager* pResourceManager, ma_resource_manager_inline_notification* pNotification)
{
    MA_ASSERT(pResourceManager != NULL);
    MA_ASSERT(pNotification    != NULL);

    pNotification->pResourceManager = pResourceManager;

    if (ma_resource_manager_is_threading_enabled(pResourceManager)) {
        return ma_async_notification_event_init(&pNotification->backend.e);
    } else {
        return ma_async_notification_poll_init(&pNotification->backend.p);
    }
}

static void ma_resource_manager_inline_notification_uninit(ma_resource_manager_inline_notification* pNotification)
{
    MA_ASSERT(pNotification != NULL);

    if (ma_resource_manager_is_threading_enabled(pNotification->pResourceManager)) {
        ma_async_notification_event_uninit(&pNotification->backend.e);
    } else {
        /* No need to uninitialize a polling notification. */
    }
}

static void ma_resource_manager_inline_notification_wait(ma_resource_manager_inline_notification* pNotification)
{
    MA_ASSERT(pNotification != NULL);

    if (ma_resource_manager_is_threading_enabled(pNotification->pResourceManager)) {
        ma_async_notification_event_wait(&pNotification->backend.e);
    } else {
        while (ma_async_notification_poll_is_signalled(&pNotification->backend.p) == MA_FALSE) {
            ma_result result = ma_resource_manager_process_next_job(pNotification->pResourceManager);
            if (result == MA_NO_DATA_AVAILABLE || result == MA_CANCELLED) {
                break;
            }
        }
    }
}

static void ma_resource_manager_inline_notification_wait_and_uninit(ma_resource_manager_inline_notification* pNotification)
{
    ma_resource_manager_inline_notification_wait(pNotification);
    ma_resource_manager_inline_notification_uninit(pNotification);
}


static void ma_resource_manager_data_buffer_bst_lock(ma_resource_manager* pResourceManager)
{
    MA_ASSERT(pResourceManager != NULL);

    if (ma_resource_manager_is_threading_enabled(pResourceManager)) {
        #ifndef MA_NO_THREADING
        {
            ma_mutex_lock(&pResourceManager->dataBufferBSTLock);
        }
        #else
        {
            MA_ASSERT(MA_FALSE);    /* Should never hit this. */
        }
        #endif
    } else {
        /* Threading not enabled. Do nothing. */
    }
}

static void ma_resource_manager_data_buffer_bst_unlock(ma_resource_manager* pResourceManager)
{
    MA_ASSERT(pResourceManager != NULL);

    if (ma_resource_manager_is_threading_enabled(pResourceManager)) {
        #ifndef MA_NO_THREADING
        {
            ma_mutex_unlock(&pResourceManager->dataBufferBSTLock);
        }
        #else
        {
            MA_ASSERT(MA_FALSE);    /* Should never hit this. */
        }
        #endif
    } else {
        /* Threading not enabled. Do nothing. */
    }
}

#ifndef MA_NO_THREADING
static ma_thread_result MA_THREADCALL ma_resource_manager_job_thread(void* pUserData)
{
    ma_resource_manager* pResourceManager = (ma_resource_manager*)pUserData;
    MA_ASSERT(pResourceManager != NULL);

    for (;;) {
        ma_result result;
        ma_job job;

        result = ma_resource_manager_next_job(pResourceManager, &job);
        if (result != MA_SUCCESS) {
            break;
        }

        /* Terminate if we got a quit message. */
        if (job.toc.breakup.code == MA_JOB_TYPE_QUIT) {
            break;
        }

        ma_job_process(&job);
    }

    return (ma_thread_result)0;
}
#endif

MA_API ma_resource_manager_config ma_resource_manager_config_init(void)
{
    ma_resource_manager_config config;

    MA_ZERO_OBJECT(&config);
    config.decodedFormat     = ma_format_unknown;
    config.decodedChannels   = 0;
    config.decodedSampleRate = 0;
    config.jobThreadCount    = 1;   /* A single miniaudio-managed job thread by default. */
    config.jobQueueCapacity  = MA_JOB_TYPE_RESOURCE_MANAGER_QUEUE_CAPACITY;

    /* Flags. */
    config.flags = 0;
    #ifdef MA_NO_THREADING
    {
        /* Threading is disabled at compile time so disable threading at runtime as well by default. */
        config.flags |= MA_RESOURCE_MANAGER_FLAG_NO_THREADING;
        config.jobThreadCount = 0;
    }
    #endif

    return config;
}


MA_API ma_result ma_resource_manager_init(const ma_resource_manager_config* pConfig, ma_resource_manager* pResourceManager)
{
    ma_result result;
    ma_job_queue_config jobQueueConfig;

    if (pResourceManager == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pResourceManager);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    #ifndef MA_NO_THREADING
    {
        if (pConfig->jobThreadCount > ma_countof(pResourceManager->jobThreads)) {
            return MA_INVALID_ARGS; /* Requesting too many job threads. */
        }
    }
    #endif

    pResourceManager->config = *pConfig;
    ma_allocation_callbacks_init_copy(&pResourceManager->config.allocationCallbacks, &pConfig->allocationCallbacks);

    /* Get the log set up early so we can start using it as soon as possible. */
    if (pResourceManager->config.pLog == NULL) {
        result = ma_log_init(&pResourceManager->config.allocationCallbacks, &pResourceManager->log);
        if (result == MA_SUCCESS) {
            pResourceManager->config.pLog = &pResourceManager->log;
        } else {
            pResourceManager->config.pLog = NULL;   /* Logging is unavailable. */
        }
    }

    if (pResourceManager->config.pVFS == NULL) {
        result = ma_default_vfs_init(&pResourceManager->defaultVFS, &pResourceManager->config.allocationCallbacks);
        if (result != MA_SUCCESS) {
            return result;  /* Failed to initialize the default file system. */
        }

        pResourceManager->config.pVFS = &pResourceManager->defaultVFS;
    }

    /* If threading has been disabled at compile time, enforce it at run time as well. */
    #ifdef MA_NO_THREADING
    {
        pResourceManager->config.flags |= MA_RESOURCE_MANAGER_FLAG_NO_THREADING;
    }
    #endif

    /* We need to force MA_RESOURCE_MANAGER_FLAG_NON_BLOCKING if MA_RESOURCE_MANAGER_FLAG_NO_THREADING is set. */
    if ((pResourceManager->config.flags & MA_RESOURCE_MANAGER_FLAG_NO_THREADING) != 0) {
        pResourceManager->config.flags |= MA_RESOURCE_MANAGER_FLAG_NON_BLOCKING;

        /* We cannot allow job threads when MA_RESOURCE_MANAGER_FLAG_NO_THREADING has been set. This is an invalid use case. */
        if (pResourceManager->config.jobThreadCount > 0) {
            return MA_INVALID_ARGS;
        }
    }

    /* Job queue. */
    jobQueueConfig.capacity = pResourceManager->config.jobQueueCapacity;
    jobQueueConfig.flags    = 0;
    if ((pResourceManager->config.flags & MA_RESOURCE_MANAGER_FLAG_NON_BLOCKING) != 0) {
        if (pResourceManager->config.jobThreadCount > 0) {
            return MA_INVALID_ARGS; /* Non-blocking mode is only valid for self-managed job threads. */
        }

        jobQueueConfig.flags |= MA_JOB_QUEUE_FLAG_NON_BLOCKING;
    }

    result = ma_job_queue_init(&jobQueueConfig, &pResourceManager->config.allocationCallbacks, &pResourceManager->jobQueue);
    if (result != MA_SUCCESS) {
        return result;
    }


    /* Custom decoding backends. */
    if (pConfig->ppCustomDecodingBackendVTables != NULL && pConfig->customDecodingBackendCount > 0) {
        size_t sizeInBytes = sizeof(*pResourceManager->config.ppCustomDecodingBackendVTables) * pConfig->customDecodingBackendCount;
        ma_decoding_backend_vtable** ppCustomDecodingBackendVTables;

        ppCustomDecodingBackendVTables = (ma_decoding_backend_vtable**)ma_malloc(sizeInBytes, &pResourceManager->config.allocationCallbacks);
        if (pResourceManager->config.ppCustomDecodingBackendVTables == NULL) {
            ma_job_queue_uninit(&pResourceManager->jobQueue, &pResourceManager->config.allocationCallbacks);
            return MA_OUT_OF_MEMORY;
        }

        MA_COPY_MEMORY(ppCustomDecodingBackendVTables, pConfig->ppCustomDecodingBackendVTables, sizeInBytes);

        pResourceManager->config.ppCustomDecodingBackendVTables = ppCustomDecodingBackendVTables;
        pResourceManager->config.customDecodingBackendCount     = pConfig->customDecodingBackendCount;
        pResourceManager->config.pCustomDecodingBackendUserData = pConfig->pCustomDecodingBackendUserData;
    }



    /* Here is where we initialize our threading stuff. We don't do this if we don't support threading. */
    if (ma_resource_manager_is_threading_enabled(pResourceManager)) {
        #ifndef MA_NO_THREADING
        {
            ma_uint32 iJobThread;

            /* Data buffer lock. */
            result = ma_mutex_init(&pResourceManager->dataBufferBSTLock);
            if (result != MA_SUCCESS) {
                ma_job_queue_uninit(&pResourceManager->jobQueue, &pResourceManager->config.allocationCallbacks);
                return result;
            }

            /* Create the job threads last to ensure the threads has access to valid data. */
            for (iJobThread = 0; iJobThread < pResourceManager->config.jobThreadCount; iJobThread += 1) {
                result = ma_thread_create(&pResourceManager->jobThreads[iJobThread], ma_thread_priority_normal, pResourceManager->config.jobThreadStackSize, ma_resource_manager_job_thread, pResourceManager, &pResourceManager->config.allocationCallbacks);
                if (result != MA_SUCCESS) {
                    ma_mutex_uninit(&pResourceManager->dataBufferBSTLock);
                    ma_job_queue_uninit(&pResourceManager->jobQueue, &pResourceManager->config.allocationCallbacks);
                    return result;
                }
            }
        }
        #else
        {
            /* Threading is disabled at compile time. We should never get here because validation checks should have already been performed. */
            MA_ASSERT(MA_FALSE);
        }
        #endif
    }

    return MA_SUCCESS;
}


static void ma_resource_manager_delete_all_data_buffer_nodes(ma_resource_manager* pResourceManager)
{
    MA_ASSERT(pResourceManager);

    /* If everything was done properly, there shouldn't be any active data buffers. */
    while (pResourceManager->pRootDataBufferNode != NULL) {
        ma_resource_manager_data_buffer_node* pDataBufferNode = pResourceManager->pRootDataBufferNode;
        ma_resource_manager_data_buffer_node_remove(pResourceManager, pDataBufferNode);

        /* The data buffer has been removed from the BST, so now we need to free its data. */
        ma_resource_manager_data_buffer_node_free(pResourceManager, pDataBufferNode);
    }
}

MA_API void ma_resource_manager_uninit(ma_resource_manager* pResourceManager)
{
    if (pResourceManager == NULL) {
        return;
    }

    /*
    Job threads need to be killed first. To do this we need to post a quit message to the message queue and then wait for the thread. The quit message will never be removed from the
    queue which means it will never not be returned after being encountered for the first time which means all threads will eventually receive it.
    */
    ma_resource_manager_post_job_quit(pResourceManager);

    /* Wait for every job to finish before continuing to ensure nothing is sill trying to access any of our objects below. */
    if (ma_resource_manager_is_threading_enabled(pResourceManager)) {
        #ifndef MA_NO_THREADING
        {
            ma_uint32 iJobThread;

            for (iJobThread = 0; iJobThread < pResourceManager->config.jobThreadCount; iJobThread += 1) {
                ma_thread_wait(&pResourceManager->jobThreads[iJobThread]);
            }
        }
        #else
        {
            MA_ASSERT(MA_FALSE);    /* Should never hit this. */
        }
        #endif
    }

    /* At this point the thread should have returned and no other thread should be accessing our data. We can now delete all data buffers. */
    ma_resource_manager_delete_all_data_buffer_nodes(pResourceManager);

    /* The job queue is no longer needed. */
    ma_job_queue_uninit(&pResourceManager->jobQueue, &pResourceManager->config.allocationCallbacks);

    /* We're no longer doing anything with data buffers so the lock can now be uninitialized. */
    if (ma_resource_manager_is_threading_enabled(pResourceManager)) {
        #ifndef MA_NO_THREADING
        {
            ma_mutex_uninit(&pResourceManager->dataBufferBSTLock);
        }
        #else
        {
            MA_ASSERT(MA_FALSE);    /* Should never hit this. */
        }
        #endif
    }

    ma_free((ma_decoding_backend_vtable**)pResourceManager->config.ppCustomDecodingBackendVTables, &pResourceManager->config.allocationCallbacks);  /* <-- Naughty const-cast, but this is safe. */

    if (pResourceManager->config.pLog == &pResourceManager->log) {
        ma_log_uninit(&pResourceManager->log);
    }
}

MA_API ma_log* ma_resource_manager_get_log(ma_resource_manager* pResourceManager)
{
    if (pResourceManager == NULL) {
        return NULL;
    }

    return pResourceManager->config.pLog;
}



MA_API ma_resource_manager_data_source_config ma_resource_manager_data_source_config_init(void)
{
    ma_resource_manager_data_source_config config;

    MA_ZERO_OBJECT(&config);
    config.rangeBegInPCMFrames     = MA_DATA_SOURCE_DEFAULT_RANGE_BEG;
    config.rangeEndInPCMFrames     = MA_DATA_SOURCE_DEFAULT_RANGE_END;
    config.loopPointBegInPCMFrames = MA_DATA_SOURCE_DEFAULT_LOOP_POINT_BEG;
    config.loopPointEndInPCMFrames = MA_DATA_SOURCE_DEFAULT_LOOP_POINT_END;
    config.isLooping               = MA_FALSE;

    return config;
}


static ma_decoder_config ma_resource_manager__init_decoder_config(ma_resource_manager* pResourceManager)
{
    ma_decoder_config config;

    config = ma_decoder_config_init(pResourceManager->config.decodedFormat, pResourceManager->config.decodedChannels, pResourceManager->config.decodedSampleRate);
    config.allocationCallbacks    = pResourceManager->config.allocationCallbacks;
    config.ppCustomBackendVTables = pResourceManager->config.ppCustomDecodingBackendVTables;
    config.customBackendCount     = pResourceManager->config.customDecodingBackendCount;
    config.pCustomBackendUserData = pResourceManager->config.pCustomDecodingBackendUserData;

    return config;
}

static ma_result ma_resource_manager__init_decoder(ma_resource_manager* pResourceManager, const char* pFilePath, const wchar_t* pFilePathW, ma_decoder* pDecoder)
{
    ma_result result;
    ma_decoder_config config;

    MA_ASSERT(pResourceManager != NULL);
    MA_ASSERT(pFilePath        != NULL || pFilePathW != NULL);
    MA_ASSERT(pDecoder         != NULL);

    config = ma_resource_manager__init_decoder_config(pResourceManager);

    if (pFilePath != NULL) {
        result = ma_decoder_init_vfs(pResourceManager->config.pVFS, pFilePath, &config, pDecoder);
        if (result != MA_SUCCESS) {
            ma_log_postf(ma_resource_manager_get_log(pResourceManager), MA_LOG_LEVEL_WARNING, "Failed to load file \"%s\". %s.\n", pFilePath, ma_result_description(result));
            return result;
        }
    } else {
        result = ma_decoder_init_vfs_w(pResourceManager->config.pVFS, pFilePathW, &config, pDecoder);
        if (result != MA_SUCCESS) {
            #if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(_MSC_VER)
                ma_log_postf(ma_resource_manager_get_log(pResourceManager), MA_LOG_LEVEL_WARNING, "Failed to load file \"%ls\". %s.\n", pFilePathW, ma_result_description(result));
            #endif
            return result;
        }
    }

    return MA_SUCCESS;
}

static ma_bool32 ma_resource_manager_data_buffer_has_connector(ma_resource_manager_data_buffer* pDataBuffer)
{
    return ma_atomic_bool32_get(&pDataBuffer->isConnectorInitialized);
}

static ma_data_source* ma_resource_manager_data_buffer_get_connector(ma_resource_manager_data_buffer* pDataBuffer)
{
    if (ma_resource_manager_data_buffer_has_connector(pDataBuffer) == MA_FALSE) {
        return NULL;    /* Connector not yet initialized. */
    }

    switch (pDataBuffer->pNode->data.type)
    {
        case ma_resource_manager_data_supply_type_encoded:       return &pDataBuffer->connector.decoder;
        case ma_resource_manager_data_supply_type_decoded:       return &pDataBuffer->connector.buffer;
        case ma_resource_manager_data_supply_type_decoded_paged: return &pDataBuffer->connector.pagedBuffer;

        case ma_resource_manager_data_supply_type_unknown:
        default:
        {
            ma_log_postf(ma_resource_manager_get_log(pDataBuffer->pResourceManager), MA_LOG_LEVEL_ERROR, "Failed to retrieve data buffer connector. Unknown data supply type.\n");
            return NULL;
        };
    };
}

static ma_result ma_resource_manager_data_buffer_init_connector(ma_resource_manager_data_buffer* pDataBuffer, const ma_resource_manager_data_source_config* pConfig, ma_async_notification* pInitNotification, ma_fence* pInitFence)
{
    ma_result result;

    MA_ASSERT(pDataBuffer != NULL);
    MA_ASSERT(pConfig     != NULL);
    MA_ASSERT(ma_resource_manager_data_buffer_has_connector(pDataBuffer) == MA_FALSE);

    /* The underlying data buffer must be initialized before we'll be able to know how to initialize the backend. */
    result = ma_resource_manager_data_buffer_node_result(pDataBuffer->pNode);
    if (result != MA_SUCCESS && result != MA_BUSY) {
        return result;  /* The data buffer is in an erroneous state. */
    }

    /*
    We need to initialize either a ma_decoder or an ma_audio_buffer depending on whether or not the backing data is encoded or decoded. These act as the
    "instance" to the data and are used to form the connection between underlying data buffer and the data source. If the data buffer is decoded, we can use
    an ma_audio_buffer. This enables us to use memory mapping when mixing which saves us a bit of data movement overhead.
    */
    switch (ma_resource_manager_data_buffer_node_get_data_supply_type(pDataBuffer->pNode))
    {
        case ma_resource_manager_data_supply_type_encoded:          /* Connector is a decoder. */
        {
            ma_decoder_config config;
            config = ma_resource_manager__init_decoder_config(pDataBuffer->pResourceManager);
            result = ma_decoder_init_memory(pDataBuffer->pNode->data.backend.encoded.pData, pDataBuffer->pNode->data.backend.encoded.sizeInBytes, &config, &pDataBuffer->connector.decoder);
        } break;

        case ma_resource_manager_data_supply_type_decoded:          /* Connector is an audio buffer. */
        {
            ma_audio_buffer_config config;
            config = ma_audio_buffer_config_init(pDataBuffer->pNode->data.backend.decoded.format, pDataBuffer->pNode->data.backend.decoded.channels, pDataBuffer->pNode->data.backend.decoded.totalFrameCount, pDataBuffer->pNode->data.backend.decoded.pData, NULL);
            result = ma_audio_buffer_init(&config, &pDataBuffer->connector.buffer);
        } break;

        case ma_resource_manager_data_supply_type_decoded_paged:    /* Connector is a paged audio buffer. */
        {
            ma_paged_audio_buffer_config config;
            config = ma_paged_audio_buffer_config_init(&pDataBuffer->pNode->data.backend.decodedPaged.data);
            result = ma_paged_audio_buffer_init(&config, &pDataBuffer->connector.pagedBuffer);
        } break;

        case ma_resource_manager_data_supply_type_unknown:
        default:
        {
            /* Unknown data supply type. Should never happen. Need to post an error here. */
            return MA_INVALID_ARGS;
        };
    }

    /*
    Initialization of the connector is when we can fire the init notification. This will give the application access to
    the format/channels/rate of the data source.
    */
    if (result == MA_SUCCESS) {
        /*
        The resource manager supports the ability to set the range and loop settings via a config at
        initialization time. This results in an case where the ranges could be set explicitly via
        ma_data_source_set_*() before we get to this point here. If this happens, we'll end up
        hitting a case where we just override those settings which results in what feels like a bug.

        To address this we only change the relevant properties if they're not equal to defaults. If
        they're equal to defaults there's no need to change them anyway. If they're *not* set to the
        default values, we can assume the user has set the range and loop settings via the config. If
        they're doing their own calls to ma_data_source_set_*() in addition to setting them via the
        config, that's entirely on the caller and any synchronization issue becomes their problem.
        */
        if (pConfig->rangeBegInPCMFrames != MA_DATA_SOURCE_DEFAULT_RANGE_BEG || pConfig->rangeEndInPCMFrames != MA_DATA_SOURCE_DEFAULT_RANGE_END) {
            ma_data_source_set_range_in_pcm_frames(pDataBuffer, pConfig->rangeBegInPCMFrames, pConfig->rangeEndInPCMFrames);
        }

        if (pConfig->loopPointBegInPCMFrames != MA_DATA_SOURCE_DEFAULT_LOOP_POINT_BEG || pConfig->loopPointEndInPCMFrames != MA_DATA_SOURCE_DEFAULT_LOOP_POINT_END) {
            ma_data_source_set_loop_point_in_pcm_frames(pDataBuffer, pConfig->loopPointBegInPCMFrames, pConfig->loopPointEndInPCMFrames);
        }

        if (pConfig->isLooping != MA_FALSE) {
            ma_data_source_set_looping(pDataBuffer, pConfig->isLooping);
        }

        ma_atomic_bool32_set(&pDataBuffer->isConnectorInitialized, MA_TRUE);

        if (pInitNotification != NULL) {
            ma_async_notification_signal(pInitNotification);
        }

        if (pInitFence != NULL) {
            ma_fence_release(pInitFence);
        }
    }

    /* At this point the backend should be initialized. We do *not* want to set pDataSource->result here - that needs to be done at a higher level to ensure it's done as the last step. */
    return result;
}

static ma_result ma_resource_manager_data_buffer_uninit_connector(ma_resource_manager* pResourceManager, ma_resource_manager_data_buffer* pDataBuffer)
{
    MA_ASSERT(pResourceManager != NULL);
    MA_ASSERT(pDataBuffer      != NULL);

    (void)pResourceManager;

    switch (ma_resource_manager_data_buffer_node_get_data_supply_type(pDataBuffer->pNode))
    {
        case ma_resource_manager_data_supply_type_encoded:          /* Connector is a decoder. */
        {
            ma_decoder_uninit(&pDataBuffer->connector.decoder);
        } break;

        case ma_resource_manager_data_supply_type_decoded:          /* Connector is an audio buffer. */
        {
            ma_audio_buffer_uninit(&pDataBuffer->connector.buffer);
        } break;

        case ma_resource_manager_data_supply_type_decoded_paged:    /* Connector is a paged audio buffer. */
        {
            ma_paged_audio_buffer_uninit(&pDataBuffer->connector.pagedBuffer);
        } break;

        case ma_resource_manager_data_supply_type_unknown:
        default:
        {
            /* Unknown data supply type. Should never happen. Need to post an error here. */
            return MA_INVALID_ARGS;
        };
    }

    return MA_SUCCESS;
}

static ma_uint32 ma_resource_manager_data_buffer_node_next_execution_order(ma_resource_manager_data_buffer_node* pDataBufferNode)
{
    MA_ASSERT(pDataBufferNode != NULL);
    return ma_atomic_fetch_add_32(&pDataBufferNode->executionCounter, 1);
}

static ma_result ma_resource_manager_data_buffer_node_init_supply_encoded(ma_resource_manager* pResourceManager, ma_resource_manager_data_buffer_node* pDataBufferNode, const char* pFilePath, const wchar_t* pFilePathW)
{
    ma_result result;
    size_t dataSizeInBytes;
    void* pData;

    MA_ASSERT(pResourceManager != NULL);
    MA_ASSERT(pDataBufferNode  != NULL);
    MA_ASSERT(pFilePath != NULL || pFilePathW != NULL);

    result = ma_vfs_open_and_read_file_ex(pResourceManager->config.pVFS, pFilePath, pFilePathW, &pData, &dataSizeInBytes, &pResourceManager->config.allocationCallbacks);
    if (result != MA_SUCCESS) {
        if (pFilePath != NULL) {
            ma_log_postf(ma_resource_manager_get_log(pResourceManager), MA_LOG_LEVEL_WARNING, "Failed to load file \"%s\". %s.\n", pFilePath, ma_result_description(result));
        } else {
            #if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(_MSC_VER)
                ma_log_postf(ma_resource_manager_get_log(pResourceManager), MA_LOG_LEVEL_WARNING, "Failed to load file \"%ls\". %s.\n", pFilePathW, ma_result_description(result));
            #endif
        }

        return result;
    }

    pDataBufferNode->data.backend.encoded.pData       = pData;
    pDataBufferNode->data.backend.encoded.sizeInBytes = dataSizeInBytes;
    ma_resource_manager_data_buffer_node_set_data_supply_type(pDataBufferNode, ma_resource_manager_data_supply_type_encoded);  /* <-- Must be set last. */

    return MA_SUCCESS;
}

static ma_result ma_resource_manager_data_buffer_node_init_supply_decoded(ma_resource_manager* pResourceManager, ma_resource_manager_data_buffer_node* pDataBufferNode, const char* pFilePath, const wchar_t* pFilePathW, ma_uint32 flags, ma_decoder** ppDecoder)
{
    ma_result result = MA_SUCCESS;
    ma_decoder* pDecoder;
    ma_uint64 totalFrameCount;

    MA_ASSERT(pResourceManager != NULL);
    MA_ASSERT(pDataBufferNode  != NULL);
    MA_ASSERT(ppDecoder         != NULL);
    MA_ASSERT(pFilePath != NULL || pFilePathW != NULL);

    *ppDecoder = NULL;  /* For safety. */

    pDecoder = (ma_decoder*)ma_malloc(sizeof(*pDecoder), &pResourceManager->config.allocationCallbacks);
    if (pDecoder == NULL) {
        return MA_OUT_OF_MEMORY;
    }

    result = ma_resource_manager__init_decoder(pResourceManager, pFilePath, pFilePathW, pDecoder);
    if (result != MA_SUCCESS) {
        ma_free(pDecoder, &pResourceManager->config.allocationCallbacks);
        return result;
    }

    /*
    At this point we have the decoder and we now need to initialize the data supply. This will
    be either a decoded buffer, or a decoded paged buffer. A regular buffer is just one big heap
    allocated buffer, whereas a paged buffer is a linked list of paged-sized buffers. The latter
    is used when the length of a sound is unknown until a full decode has been performed.
    */
    if ((flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_UNKNOWN_LENGTH) == 0) {
        result = ma_decoder_get_length_in_pcm_frames(pDecoder, &totalFrameCount);
        if (result != MA_SUCCESS) {
            return result;
        }
    } else {
        totalFrameCount = 0;
    }

    if (totalFrameCount > 0) {
        /* It's a known length. The data supply is a regular decoded buffer. */
        ma_uint64 dataSizeInBytes;
        void* pData;

        dataSizeInBytes = totalFrameCount * ma_get_bytes_per_frame(pDecoder->outputFormat, pDecoder->outputChannels);
        if (dataSizeInBytes > MA_SIZE_MAX) {
            ma_decoder_uninit(pDecoder);
            ma_free(pDecoder, &pResourceManager->config.allocationCallbacks);
            return MA_TOO_BIG;
        }

        pData = ma_malloc((size_t)dataSizeInBytes, &pResourceManager->config.allocationCallbacks);
        if (pData == NULL) {
            ma_decoder_uninit(pDecoder);
            ma_free(pDecoder, &pResourceManager->config.allocationCallbacks);
            return MA_OUT_OF_MEMORY;
        }

        /* The buffer needs to be initialized to silence in case the caller reads from it. */
        ma_silence_pcm_frames(pData, totalFrameCount, pDecoder->outputFormat, pDecoder->outputChannels);

        /* Data has been allocated and the data supply can now be initialized. */
        pDataBufferNode->data.backend.decoded.pData             = pData;
        pDataBufferNode->data.backend.decoded.totalFrameCount   = totalFrameCount;
        pDataBufferNode->data.backend.decoded.format            = pDecoder->outputFormat;
        pDataBufferNode->data.backend.decoded.channels          = pDecoder->outputChannels;
        pDataBufferNode->data.backend.decoded.sampleRate        = pDecoder->outputSampleRate;
        pDataBufferNode->data.backend.decoded.decodedFrameCount = 0;
        ma_resource_manager_data_buffer_node_set_data_supply_type(pDataBufferNode, ma_resource_manager_data_supply_type_decoded);  /* <-- Must be set last. */
    } else {
        /*
        It's an unknown length. The data supply is a paged decoded buffer. Setting this up is
        actually easier than the non-paged decoded buffer because we just need to initialize
        a ma_paged_audio_buffer object.
        */
        result = ma_paged_audio_buffer_data_init(pDecoder->outputFormat, pDecoder->outputChannels, &pDataBufferNode->data.backend.decodedPaged.data);
        if (result != MA_SUCCESS) {
            ma_decoder_uninit(pDecoder);
            ma_free(pDecoder, &pResourceManager->config.allocationCallbacks);
            return result;
        }

        pDataBufferNode->data.backend.decodedPaged.sampleRate        = pDecoder->outputSampleRate;
        pDataBufferNode->data.backend.decodedPaged.decodedFrameCount = 0;
        ma_resource_manager_data_buffer_node_set_data_supply_type(pDataBufferNode, ma_resource_manager_data_supply_type_decoded_paged);  /* <-- Must be set last. */
    }

    *ppDecoder = pDecoder;

    return MA_SUCCESS;
}

static ma_result ma_resource_manager_data_buffer_node_decode_next_page(ma_resource_manager* pResourceManager, ma_resource_manager_data_buffer_node* pDataBufferNode, ma_decoder* pDecoder)
{
    ma_result result = MA_SUCCESS;
    ma_uint64 pageSizeInFrames;
    ma_uint64 framesToTryReading;
    ma_uint64 framesRead;

    MA_ASSERT(pResourceManager != NULL);
    MA_ASSERT(pDataBufferNode  != NULL);
    MA_ASSERT(pDecoder         != NULL);

    /* We need to know the size of a page in frames to know how many frames to decode. */
    pageSizeInFrames = MA_RESOURCE_MANAGER_PAGE_SIZE_IN_MILLISECONDS * (pDecoder->outputSampleRate/1000);
    framesToTryReading = pageSizeInFrames;

    /*
    Here is where we do the decoding of the next page. We'll run a slightly different path depending
    on whether or not we're using a flat or paged buffer because the allocation of the page differs
    between the two. For a flat buffer it's an offset to an already-allocated buffer. For a paged
    buffer, we need to allocate a new page and attach it to the linked list.
    */
    switch (ma_resource_manager_data_buffer_node_get_data_supply_type(pDataBufferNode))
    {
        case ma_resource_manager_data_supply_type_decoded:
        {
            /* The destination buffer is an offset to the existing buffer. Don't read more than we originally retrieved when we first initialized the decoder. */
            void* pDst;
            ma_uint64 framesRemaining = pDataBufferNode->data.backend.decoded.totalFrameCount - pDataBufferNode->data.backend.decoded.decodedFrameCount;
            if (framesToTryReading > framesRemaining) {
                framesToTryReading = framesRemaining;
            }

            if (framesToTryReading > 0) {
                pDst = ma_offset_ptr(
                    pDataBufferNode->data.backend.decoded.pData,
                    pDataBufferNode->data.backend.decoded.decodedFrameCount * ma_get_bytes_per_frame(pDataBufferNode->data.backend.decoded.format, pDataBufferNode->data.backend.decoded.channels)
                );
                MA_ASSERT(pDst != NULL);

                result = ma_decoder_read_pcm_frames(pDecoder, pDst, framesToTryReading, &framesRead);
                if (framesRead > 0) {
                    pDataBufferNode->data.backend.decoded.decodedFrameCount += framesRead;
                }
            } else {
                framesRead = 0;
            }
        } break;

        case ma_resource_manager_data_supply_type_decoded_paged:
        {
            /* The destination buffer is a freshly allocated page. */
            ma_paged_audio_buffer_page* pPage;

            result = ma_paged_audio_buffer_data_allocate_page(&pDataBufferNode->data.backend.decodedPaged.data, framesToTryReading, NULL, &pResourceManager->config.allocationCallbacks, &pPage);
            if (result != MA_SUCCESS) {
                return result;
            }

            result = ma_decoder_read_pcm_frames(pDecoder, pPage->pAudioData, framesToTryReading, &framesRead);
            if (result == MA_SUCCESS && framesRead > 0) {
                pPage->sizeInFrames = framesRead;

                result = ma_paged_audio_buffer_data_append_page(&pDataBufferNode->data.backend.decodedPaged.data, pPage);
                if (result == MA_SUCCESS) {
                    pDataBufferNode->data.backend.decodedPaged.decodedFrameCount += framesRead;
                } else {
                    /* Failed to append the page. Just abort and set the status to MA_AT_END. */
                    ma_paged_audio_buffer_data_free_page(&pDataBufferNode->data.backend.decodedPaged.data, pPage, &pResourceManager->config.allocationCallbacks);
                    result = MA_AT_END;
                }
            } else {
                /* No frames were read. Free the page and just set the status to MA_AT_END. */
                ma_paged_audio_buffer_data_free_page(&pDataBufferNode->data.backend.decodedPaged.data, pPage, &pResourceManager->config.allocationCallbacks);
                result = MA_AT_END;
            }
        } break;

        case ma_resource_manager_data_supply_type_encoded:
        case ma_resource_manager_data_supply_type_unknown:
        default:
        {
            /* Unexpected data supply type. */
            ma_log_postf(ma_resource_manager_get_log(pResourceManager), MA_LOG_LEVEL_ERROR, "Unexpected data supply type (%d) when decoding page.", ma_resource_manager_data_buffer_node_get_data_supply_type(pDataBufferNode));
            return MA_ERROR;
        };
    }

    if (result == MA_SUCCESS && framesRead == 0) {
        result = MA_AT_END;
    }

    return result;
}

static ma_result ma_resource_manager_data_buffer_node_acquire_critical_section(ma_resource_manager* pResourceManager, const char* pFilePath, const wchar_t* pFilePathW, ma_uint32 hashedName32, ma_uint32 flags, const ma_resource_manager_data_supply* pExistingData, ma_fence* pInitFence, ma_fence* pDoneFence, ma_resource_manager_inline_notification* pInitNotification, ma_resource_manager_data_buffer_node** ppDataBufferNode)
{
    ma_result result = MA_SUCCESS;
    ma_resource_manager_data_buffer_node* pDataBufferNode = NULL;
    ma_resource_manager_data_buffer_node* pInsertPoint;

    if (ppDataBufferNode != NULL) {
        *ppDataBufferNode = NULL;
    }

    result = ma_resource_manager_data_buffer_node_insert_point(pResourceManager, hashedName32, &pInsertPoint);
    if (result == MA_ALREADY_EXISTS) {
        /* The node already exists. We just need to increment the reference count. */
        pDataBufferNode = pInsertPoint;

        result = ma_resource_manager_data_buffer_node_increment_ref(pResourceManager, pDataBufferNode, NULL);
        if (result != MA_SUCCESS) {
            return result;  /* Should never happen. Failed to increment the reference count. */
        }

        result = MA_ALREADY_EXISTS;
        goto done;
    } else {
        /*
        The node does not already exist. We need to post a LOAD_DATA_BUFFER_NODE job here. This
        needs to be done inside the critical section to ensure an uninitialization of the node
        does not occur before initialization on another thread.
        */
        pDataBufferNode = (ma_resource_manager_data_buffer_node*)ma_malloc(sizeof(*pDataBufferNode), &pResourceManager->config.allocationCallbacks);
        if (pDataBufferNode == NULL) {
            return MA_OUT_OF_MEMORY;
        }

        MA_ZERO_OBJECT(pDataBufferNode);
        pDataBufferNode->hashedName32 = hashedName32;
        pDataBufferNode->refCount     = 1;        /* Always set to 1 by default (this is our first reference). */

        if (pExistingData == NULL) {
            pDataBufferNode->data.type    = ma_resource_manager_data_supply_type_unknown;    /* <-- We won't know this until we start decoding. */
            pDataBufferNode->result       = MA_BUSY;  /* Must be set to MA_BUSY before we leave the critical section, so might as well do it now. */
            pDataBufferNode->isDataOwnedByResourceManager = MA_TRUE;
        } else {
            pDataBufferNode->data         = *pExistingData;
            pDataBufferNode->result       = MA_SUCCESS;   /* Not loading asynchronously, so just set the status */
            pDataBufferNode->isDataOwnedByResourceManager = MA_FALSE;
        }

        result = ma_resource_manager_data_buffer_node_insert_at(pResourceManager, pDataBufferNode, pInsertPoint);
        if (result != MA_SUCCESS) {
            ma_free(pDataBufferNode, &pResourceManager->config.allocationCallbacks);
            return result;  /* Should never happen. Failed to insert the data buffer into the BST. */
        }

        /*
        Here is where we'll post the job, but only if we're loading asynchronously. If we're
        loading synchronously we'll defer loading to a later stage, outside of the critical
        section.
        */
        if (pDataBufferNode->isDataOwnedByResourceManager && (flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC) != 0) {
            /* Loading asynchronously. Post the job. */
            ma_job job;
            char* pFilePathCopy = NULL;
            wchar_t* pFilePathWCopy = NULL;

            /* We need a copy of the file path. We should probably make this more efficient, but for now we'll do a transient memory allocation. */
            if (pFilePath != NULL) {
                pFilePathCopy = ma_copy_string(pFilePath, &pResourceManager->config.allocationCallbacks);
            } else {
                pFilePathWCopy = ma_copy_string_w(pFilePathW, &pResourceManager->config.allocationCallbacks);
            }

            if (pFilePathCopy == NULL && pFilePathWCopy == NULL) {
                ma_resource_manager_data_buffer_node_remove(pResourceManager, pDataBufferNode);
                ma_free(pDataBufferNode, &pResourceManager->config.allocationCallbacks);
                return MA_OUT_OF_MEMORY;
            }

            if ((flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT) != 0) {
                ma_resource_manager_inline_notification_init(pResourceManager, pInitNotification);
            }

            /* Acquire init and done fences before posting the job. These will be unacquired by the job thread. */
            if (pInitFence != NULL) { ma_fence_acquire(pInitFence); }
            if (pDoneFence != NULL) { ma_fence_acquire(pDoneFence); }

            /* We now have everything we need to post the job to the job thread. */
            job = ma_job_init(MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_BUFFER_NODE);
            job.order = ma_resource_manager_data_buffer_node_next_execution_order(pDataBufferNode);
            job.data.resourceManager.loadDataBufferNode.pResourceManager  = pResourceManager;
            job.data.resourceManager.loadDataBufferNode.pDataBufferNode   = pDataBufferNode;
            job.data.resourceManager.loadDataBufferNode.pFilePath         = pFilePathCopy;
            job.data.resourceManager.loadDataBufferNode.pFilePathW        = pFilePathWCopy;
            job.data.resourceManager.loadDataBufferNode.flags             = flags;
            job.data.resourceManager.loadDataBufferNode.pInitNotification = ((flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT) != 0) ? pInitNotification : NULL;
            job.data.resourceManager.loadDataBufferNode.pDoneNotification = NULL;
            job.data.resourceManager.loadDataBufferNode.pInitFence        = pInitFence;
            job.data.resourceManager.loadDataBufferNode.pDoneFence        = pDoneFence;

            if ((flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT) != 0) {
                result = ma_job_process(&job);
            } else {
                result = ma_resource_manager_post_job(pResourceManager, &job);
            }

            if (result != MA_SUCCESS) {
                /* Failed to post job. Probably ran out of memory. */
                ma_log_postf(ma_resource_manager_get_log(pResourceManager), MA_LOG_LEVEL_ERROR, "Failed to post MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_BUFFER_NODE job. %s.\n", ma_result_description(result));

                /*
                Fences were acquired before posting the job, but since the job was not able to
                be posted, we need to make sure we release them so nothing gets stuck waiting.
                */
                if (pInitFence != NULL) { ma_fence_release(pInitFence); }
                if (pDoneFence != NULL) { ma_fence_release(pDoneFence); }

                if ((flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT) != 0) {
                    ma_resource_manager_inline_notification_uninit(pInitNotification);
                } else {
                    /* These will have been freed by the job thread, but with WAIT_INIT they will already have happened since the job has already been handled. */
                    ma_free(pFilePathCopy,  &pResourceManager->config.allocationCallbacks);
                    ma_free(pFilePathWCopy, &pResourceManager->config.allocationCallbacks);
                }

                ma_resource_manager_data_buffer_node_remove(pResourceManager, pDataBufferNode);
                ma_free(pDataBufferNode, &pResourceManager->config.allocationCallbacks);

                return result;
            }
        }
    }

done:
    if (ppDataBufferNode != NULL) {
        *ppDataBufferNode = pDataBufferNode;
    }

    return result;
}

static ma_result ma_resource_manager_data_buffer_node_acquire(ma_resource_manager* pResourceManager, const char* pFilePath, const wchar_t* pFilePathW, ma_uint32 hashedName32, ma_uint32 flags, const ma_resource_manager_data_supply* pExistingData, ma_fence* pInitFence, ma_fence* pDoneFence, ma_resource_manager_data_buffer_node** ppDataBufferNode)
{
    ma_result result = MA_SUCCESS;
    ma_bool32 nodeAlreadyExists = MA_FALSE;
    ma_resource_manager_data_buffer_node* pDataBufferNode = NULL;
    ma_resource_manager_inline_notification initNotification;   /* Used when the WAIT_INIT flag is set. */

    if (ppDataBufferNode != NULL) {
        *ppDataBufferNode = NULL;   /* Safety. */
    }

    if (pResourceManager == NULL || (pFilePath == NULL && pFilePathW == NULL && hashedName32 == 0)) {
        return MA_INVALID_ARGS;
    }

    /* If we're specifying existing data, it must be valid. */
    if (pExistingData != NULL && pExistingData->type == ma_resource_manager_data_supply_type_unknown) {
        return MA_INVALID_ARGS;
    }

    /* If we don't support threading, remove the ASYNC flag to make the rest of this a bit simpler. */
    if (ma_resource_manager_is_threading_enabled(pResourceManager) == MA_FALSE) {
        flags &= ~MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC;
    }

    if (hashedName32 == 0) {
        if (pFilePath != NULL) {
            hashedName32 = ma_hash_string_32(pFilePath);
        } else {
            hashedName32 = ma_hash_string_w_32(pFilePathW);
        }
    }

    /*
    Here is where we either increment the node's reference count or allocate a new one and add it
    to the BST. When allocating a new node, we need to make sure the LOAD_DATA_BUFFER_NODE job is
    posted inside the critical section just in case the caller immediately uninitializes the node
    as this will ensure the FREE_DATA_BUFFER_NODE job is given an execution order such that the
    node is not uninitialized before initialization.
    */
    ma_resource_manager_data_buffer_bst_lock(pResourceManager);
    {
        result = ma_resource_manager_data_buffer_node_acquire_critical_section(pResourceManager, pFilePath, pFilePathW, hashedName32, flags, pExistingData, pInitFence, pDoneFence, &initNotification, &pDataBufferNode);
    }
    ma_resource_manager_data_buffer_bst_unlock(pResourceManager);

    if (result == MA_ALREADY_EXISTS) {
        nodeAlreadyExists = MA_TRUE;
        result = MA_SUCCESS;
    } else {
        if (result != MA_SUCCESS) {
            return result;
        }
    }

    /*
    If we're loading synchronously, we'll need to load everything now. When loading asynchronously,
    a job will have been posted inside the BST critical section so that an uninitialization can be
    allocated an appropriate execution order thereby preventing it from being uninitialized before
    the node is initialized by the decoding thread(s).
    */
    if (nodeAlreadyExists == MA_FALSE) {    /* Don't need to try loading anything if the node already exists. */
        if (pFilePath == NULL && pFilePathW == NULL) {
            /*
            If this path is hit, it means a buffer is being copied (i.e. initialized from only the
            hashed name), but that node has been freed in the meantime, probably from some other
            thread. This is an invalid operation.
            */
            ma_log_postf(ma_resource_manager_get_log(pResourceManager), MA_LOG_LEVEL_WARNING, "Cloning data buffer node failed because the source node was released. The source node must remain valid until the cloning has completed.\n");
            result = MA_INVALID_OPERATION;
            goto done;
        }

        if (pDataBufferNode->isDataOwnedByResourceManager) {
            if ((flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC) == 0) {
                /* Loading synchronously. Load the sound in it's entirety here. */
                if ((flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_DECODE) == 0) {
                    /* No decoding. This is the simple case - just store the file contents in memory. */
                    result = ma_resource_manager_data_buffer_node_init_supply_encoded(pResourceManager, pDataBufferNode, pFilePath, pFilePathW);
                    if (result != MA_SUCCESS) {
                        goto done;
                    }
                } else {
                    /* Decoding. We do this the same way as we do when loading asynchronously. */
                    ma_decoder* pDecoder;
                    result = ma_resource_manager_data_buffer_node_init_supply_decoded(pResourceManager, pDataBufferNode, pFilePath, pFilePathW, flags, &pDecoder);
                    if (result != MA_SUCCESS) {
                        goto done;
                    }

                    /* We have the decoder, now decode page by page just like we do when loading asynchronously. */
                    for (;;) {
                        /* Decode next page. */
                        result = ma_resource_manager_data_buffer_node_decode_next_page(pResourceManager, pDataBufferNode, pDecoder);
                        if (result != MA_SUCCESS) {
                            break;  /* Will return MA_AT_END when the last page has been decoded. */
                        }
                    }

                    /* Reaching the end needs to be considered successful. */
                    if (result == MA_AT_END) {
                        result  = MA_SUCCESS;
                    }

                    /*
                    At this point the data buffer is either fully decoded or some error occurred. Either
                    way, the decoder is no longer necessary.
                    */
                    ma_decoder_uninit(pDecoder);
                    ma_free(pDecoder, &pResourceManager->config.allocationCallbacks);
                }

                /* Getting here means we were successful. Make sure the status of the node is updated accordingly. */
                ma_atomic_exchange_i32(&pDataBufferNode->result, result);
            } else {
                /* Loading asynchronously. We may need to wait for initialization. */
                if ((flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT) != 0) {
                    ma_resource_manager_inline_notification_wait(&initNotification);
                }
            }
        } else {
            /* The data is not managed by the resource manager so there's nothing else to do. */
            MA_ASSERT(pExistingData != NULL);
        }
    }

done:
    /* If we failed to initialize the data buffer we need to free it. */
    if (result != MA_SUCCESS) {
        if (nodeAlreadyExists == MA_FALSE) {
            ma_resource_manager_data_buffer_node_remove(pResourceManager, pDataBufferNode);
            ma_free(pDataBufferNode, &pResourceManager->config.allocationCallbacks);
        }
    }

    /*
    The init notification needs to be uninitialized. This will be used if the node does not already
    exist, and we've specified ASYNC | WAIT_INIT.
    */
    if (nodeAlreadyExists == MA_FALSE && pDataBufferNode->isDataOwnedByResourceManager && (flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC) != 0) {
        if ((flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT) != 0) {
            ma_resource_manager_inline_notification_uninit(&initNotification);
        }
    }

    if (ppDataBufferNode != NULL) {
        *ppDataBufferNode = pDataBufferNode;
    }

    return result;
}

static ma_result ma_resource_manager_data_buffer_node_unacquire(ma_resource_manager* pResourceManager, ma_resource_manager_data_buffer_node* pDataBufferNode, const char* pName, const wchar_t* pNameW)
{
    ma_result result = MA_SUCCESS;
    ma_uint32 refCount = 0xFFFFFFFF; /* The new reference count of the node after decrementing. Initialize to non-0 to be safe we don't fall into the freeing path. */
    ma_uint32 hashedName32 = 0;

    if (pResourceManager == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pDataBufferNode == NULL) {
        if (pName == NULL && pNameW == NULL) {
            return MA_INVALID_ARGS;
        }

        if (pName != NULL) {
            hashedName32 = ma_hash_string_32(pName);
        } else {
            hashedName32 = ma_hash_string_w_32(pNameW);
        }
    }

    /*
    The first thing to do is decrement the reference counter of the node. Then, if the reference
    count is zero, we need to free the node. If the node is still in the process of loading, we'll
    need to post a job to the job queue to free the node. Otherwise we'll just do it here.
    */
    ma_resource_manager_data_buffer_bst_lock(pResourceManager);
    {
        /* Might need to find the node. Must be done inside the critical section. */
        if (pDataBufferNode == NULL) {
            result = ma_resource_manager_data_buffer_node_search(pResourceManager, hashedName32, &pDataBufferNode);
            if (result != MA_SUCCESS) {
                goto stage2;    /* Couldn't find the node. */
            }
        }

        result = ma_resource_manager_data_buffer_node_decrement_ref(pResourceManager, pDataBufferNode, &refCount);
        if (result != MA_SUCCESS) {
            goto stage2;    /* Should never happen. */
        }

        if (refCount == 0) {
            result = ma_resource_manager_data_buffer_node_remove(pResourceManager, pDataBufferNode);
            if (result != MA_SUCCESS) {
                goto stage2;  /* An error occurred when trying to remove the data buffer. This should never happen. */
            }
        }
    }
    ma_resource_manager_data_buffer_bst_unlock(pResourceManager);

stage2:
    if (result != MA_SUCCESS) {
        return result;
    }

    /*
    Here is where we need to free the node. We don't want to do this inside the critical section
    above because we want to keep that as small as possible for multi-threaded efficiency.
    */
    if (refCount == 0) {
        if (ma_resource_manager_data_buffer_node_result(pDataBufferNode) == MA_BUSY) {
            /* The sound is still loading. We need to delay the freeing of the node to a safe time. */
            ma_job job;

            /* We need to mark the node as unavailable for the sake of the resource manager worker threads. */
            ma_atomic_exchange_i32(&pDataBufferNode->result, MA_UNAVAILABLE);

            job = ma_job_init(MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_BUFFER_NODE);
            job.order = ma_resource_manager_data_buffer_node_next_execution_order(pDataBufferNode);
            job.data.resourceManager.freeDataBufferNode.pResourceManager = pResourceManager;
            job.data.resourceManager.freeDataBufferNode.pDataBufferNode  = pDataBufferNode;

            result = ma_resource_manager_post_job(pResourceManager, &job);
            if (result != MA_SUCCESS) {
                ma_log_postf(ma_resource_manager_get_log(pResourceManager), MA_LOG_LEVEL_ERROR, "Failed to post MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_BUFFER_NODE job. %s.\n", ma_result_description(result));
                return result;
            }

            /* If we don't support threading, process the job queue here. */
            if (ma_resource_manager_is_threading_enabled(pResourceManager) == MA_FALSE) {
                while (ma_resource_manager_data_buffer_node_result(pDataBufferNode) == MA_BUSY) {
                    result = ma_resource_manager_process_next_job(pResourceManager);
                    if (result == MA_NO_DATA_AVAILABLE || result == MA_CANCELLED) {
                        result = MA_SUCCESS;
                        break;
                    }
                }
            } else {
                /* Threading is enabled. The job queue will deal with the rest of the cleanup from here. */
            }
        } else {
            /* The sound isn't loading so we can just free the node here. */
            ma_resource_manager_data_buffer_node_free(pResourceManager, pDataBufferNode);
        }
    }

    return result;
}



static ma_uint32 ma_resource_manager_data_buffer_next_execution_order(ma_resource_manager_data_buffer* pDataBuffer)
{
    MA_ASSERT(pDataBuffer != NULL);
    return ma_atomic_fetch_add_32(&pDataBuffer->executionCounter, 1);
}

static ma_result ma_resource_manager_data_buffer_cb__read_pcm_frames(ma_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    return ma_resource_manager_data_buffer_read_pcm_frames((ma_resource_manager_data_buffer*)pDataSource, pFramesOut, frameCount, pFramesRead);
}

static ma_result ma_resource_manager_data_buffer_cb__seek_to_pcm_frame(ma_data_source* pDataSource, ma_uint64 frameIndex)
{
    return ma_resource_manager_data_buffer_seek_to_pcm_frame((ma_resource_manager_data_buffer*)pDataSource, frameIndex);
}

static ma_result ma_resource_manager_data_buffer_cb__get_data_format(ma_data_source* pDataSource, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)
{
    return ma_resource_manager_data_buffer_get_data_format((ma_resource_manager_data_buffer*)pDataSource, pFormat, pChannels, pSampleRate, pChannelMap, channelMapCap);
}

static ma_result ma_resource_manager_data_buffer_cb__get_cursor_in_pcm_frames(ma_data_source* pDataSource, ma_uint64* pCursor)
{
    return ma_resource_manager_data_buffer_get_cursor_in_pcm_frames((ma_resource_manager_data_buffer*)pDataSource, pCursor);
}

static ma_result ma_resource_manager_data_buffer_cb__get_length_in_pcm_frames(ma_data_source* pDataSource, ma_uint64* pLength)
{
    return ma_resource_manager_data_buffer_get_length_in_pcm_frames((ma_resource_manager_data_buffer*)pDataSource, pLength);
}

static ma_result ma_resource_manager_data_buffer_cb__set_looping(ma_data_source* pDataSource, ma_bool32 isLooping)
{
    ma_resource_manager_data_buffer* pDataBuffer = (ma_resource_manager_data_buffer*)pDataSource;
    MA_ASSERT(pDataBuffer != NULL);

    ma_atomic_exchange_32(&pDataBuffer->isLooping, isLooping);

    /* The looping state needs to be set on the connector as well or else looping won't work when we read audio data. */
    ma_data_source_set_looping(ma_resource_manager_data_buffer_get_connector(pDataBuffer), isLooping);

    return MA_SUCCESS;
}

static ma_data_source_vtable g_ma_resource_manager_data_buffer_vtable =
{
    ma_resource_manager_data_buffer_cb__read_pcm_frames,
    ma_resource_manager_data_buffer_cb__seek_to_pcm_frame,
    ma_resource_manager_data_buffer_cb__get_data_format,
    ma_resource_manager_data_buffer_cb__get_cursor_in_pcm_frames,
    ma_resource_manager_data_buffer_cb__get_length_in_pcm_frames,
    ma_resource_manager_data_buffer_cb__set_looping,
    0
};

static ma_result ma_resource_manager_data_buffer_init_ex_internal(ma_resource_manager* pResourceManager, const ma_resource_manager_data_source_config* pConfig, ma_uint32 hashedName32, ma_resource_manager_data_buffer* pDataBuffer)
{
    ma_result result = MA_SUCCESS;
    ma_resource_manager_data_buffer_node* pDataBufferNode;
    ma_data_source_config dataSourceConfig;
    ma_bool32 async;
    ma_uint32 flags;
    ma_resource_manager_pipeline_notifications notifications;

    if (pDataBuffer == NULL) {
        if (pConfig != NULL && pConfig->pNotifications != NULL) {
            ma_resource_manager_pipeline_notifications_signal_all_notifications(pConfig->pNotifications);
        }

        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pDataBuffer);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->pNotifications != NULL) {
        notifications = *pConfig->pNotifications;   /* From here on out we should be referencing `notifications` instead of `pNotifications`. Set this to NULL to catch errors at testing time. */
    } else {
        MA_ZERO_OBJECT(&notifications);
    }

    /* For safety, always remove the ASYNC flag if threading is disabled on the resource manager. */
    flags = pConfig->flags;
    if (ma_resource_manager_is_threading_enabled(pResourceManager) == MA_FALSE) {
        flags &= ~MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC;
    }

    if (pConfig->isLooping) {
        flags |= MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_LOOPING;
    }

    async = (flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC) != 0;

    /*
    Fences need to be acquired before doing anything. These must be acquired and released outside of
    the node to ensure there's no holes where ma_fence_wait() could prematurely return before the
    data buffer has completed initialization.

    When loading asynchronously, the node acquisition routine below will acquire the fences on this
    thread and then release them on the async thread when the operation is complete.

    These fences are always released at the "done" tag at the end of this function. They'll be
    acquired a second if loading asynchronously. This double acquisition system is just done to
    simplify code maintenance.
    */
    ma_resource_manager_pipeline_notifications_acquire_all_fences(&notifications);
    {
        /* We first need to acquire a node. If ASYNC is not set, this will not return until the entire sound has been loaded. */
        result = ma_resource_manager_data_buffer_node_acquire(pResourceManager, pConfig->pFilePath, pConfig->pFilePathW, hashedName32, flags, NULL, notifications.init.pFence, notifications.done.pFence, &pDataBufferNode);
        if (result != MA_SUCCESS) {
            ma_resource_manager_pipeline_notifications_signal_all_notifications(&notifications);
            goto done;
        }

        dataSourceConfig = ma_data_source_config_init();
        dataSourceConfig.vtable = &g_ma_resource_manager_data_buffer_vtable;

        result = ma_data_source_init(&dataSourceConfig, &pDataBuffer->ds);
        if (result != MA_SUCCESS) {
            ma_resource_manager_data_buffer_node_unacquire(pResourceManager, pDataBufferNode, NULL, NULL);
            ma_resource_manager_pipeline_notifications_signal_all_notifications(&notifications);
            goto done;
        }

        pDataBuffer->pResourceManager = pResourceManager;
        pDataBuffer->pNode  = pDataBufferNode;
        pDataBuffer->flags  = flags;
        pDataBuffer->result = MA_BUSY;  /* Always default to MA_BUSY for safety. It'll be overwritten when loading completes or an error occurs. */

        /* If we're loading asynchronously we need to post a job to the job queue to initialize the connector. */
        if (async == MA_FALSE || ma_resource_manager_data_buffer_node_result(pDataBufferNode) == MA_SUCCESS) {
            /* Loading synchronously or the data has already been fully loaded. We can just initialize the connector from here without a job. */
            result = ma_resource_manager_data_buffer_init_connector(pDataBuffer, pConfig, NULL, NULL);
            ma_atomic_exchange_i32(&pDataBuffer->result, result);

            ma_resource_manager_pipeline_notifications_signal_all_notifications(&notifications);
            goto done;
        } else {
            /* The node's data supply isn't initialized yet. The caller has requested that we load asynchronously so we need to post a job to do this. */
            ma_job job;
            ma_resource_manager_inline_notification initNotification;   /* Used when the WAIT_INIT flag is set. */

            if ((flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT) != 0) {
                ma_resource_manager_inline_notification_init(pResourceManager, &initNotification);
            }

            /*
            The status of the data buffer needs to be set to MA_BUSY before posting the job so that the
            worker thread is aware of its busy state. If the LOAD_DATA_BUFFER job sees a status other
            than MA_BUSY, it'll assume an error and fall through to an early exit.
            */
            ma_atomic_exchange_i32(&pDataBuffer->result, MA_BUSY);

            /* Acquire fences a second time. These will be released by the async thread. */
            ma_resource_manager_pipeline_notifications_acquire_all_fences(&notifications);

            job = ma_job_init(MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_BUFFER);
            job.order = ma_resource_manager_data_buffer_next_execution_order(pDataBuffer);
            job.data.resourceManager.loadDataBuffer.pDataBuffer             = pDataBuffer;
            job.data.resourceManager.loadDataBuffer.pInitNotification       = ((flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT) != 0) ? &initNotification : notifications.init.pNotification;
            job.data.resourceManager.loadDataBuffer.pDoneNotification       = notifications.done.pNotification;
            job.data.resourceManager.loadDataBuffer.pInitFence              = notifications.init.pFence;
            job.data.resourceManager.loadDataBuffer.pDoneFence              = notifications.done.pFence;
            job.data.resourceManager.loadDataBuffer.rangeBegInPCMFrames     = pConfig->rangeBegInPCMFrames;
            job.data.resourceManager.loadDataBuffer.rangeEndInPCMFrames     = pConfig->rangeEndInPCMFrames;
            job.data.resourceManager.loadDataBuffer.loopPointBegInPCMFrames = pConfig->loopPointBegInPCMFrames;
            job.data.resourceManager.loadDataBuffer.loopPointEndInPCMFrames = pConfig->loopPointEndInPCMFrames;
            job.data.resourceManager.loadDataBuffer.isLooping               = (flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_LOOPING) != 0;

            /* If we need to wait for initialization to complete we can just process the job in place. */
            if ((flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT) != 0) {
                result = ma_job_process(&job);
            } else {
                result = ma_resource_manager_post_job(pResourceManager, &job);
            }

            if (result != MA_SUCCESS) {
                /* We failed to post the job. Most likely there isn't enough room in the queue's buffer. */
                ma_log_postf(ma_resource_manager_get_log(pResourceManager), MA_LOG_LEVEL_ERROR, "Failed to post MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_BUFFER job. %s.\n", ma_result_description(result));
                ma_atomic_exchange_i32(&pDataBuffer->result, result);

                /* Release the fences after the result has been set on the data buffer. */
                ma_resource_manager_pipeline_notifications_release_all_fences(&notifications);
            } else {
                if ((flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT) != 0) {
                    ma_resource_manager_inline_notification_wait(&initNotification);

                    if (notifications.init.pNotification != NULL) {
                        ma_async_notification_signal(notifications.init.pNotification);
                    }

                    /* NOTE: Do not release the init fence here. It will have been done by the job. */

                    /* Make sure we return an error if initialization failed on the async thread. */
                    result = ma_resource_manager_data_buffer_result(pDataBuffer);
                    if (result == MA_BUSY) {
                        result  = MA_SUCCESS;
                    }
                }
            }

            if ((flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT) != 0) {
                ma_resource_manager_inline_notification_uninit(&initNotification);
            }
        }

        if (result != MA_SUCCESS) {
            ma_resource_manager_data_buffer_node_unacquire(pResourceManager, pDataBufferNode, NULL, NULL);
            goto done;
        }
    }
done:
    if (result == MA_SUCCESS) {
        if (pConfig->initialSeekPointInPCMFrames > 0) {
            ma_resource_manager_data_buffer_seek_to_pcm_frame(pDataBuffer, pConfig->initialSeekPointInPCMFrames);
        }
    }

    ma_resource_manager_pipeline_notifications_release_all_fences(&notifications);

    return result;
}

MA_API ma_result ma_resource_manager_data_buffer_init_ex(ma_resource_manager* pResourceManager, const ma_resource_manager_data_source_config* pConfig, ma_resource_manager_data_buffer* pDataBuffer)
{
    return ma_resource_manager_data_buffer_init_ex_internal(pResourceManager, pConfig, 0, pDataBuffer);
}

MA_API ma_result ma_resource_manager_data_buffer_init(ma_resource_manager* pResourceManager, const char* pFilePath, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_buffer* pDataBuffer)
{
    ma_resource_manager_data_source_config config;

    config = ma_resource_manager_data_source_config_init();
    config.pFilePath      = pFilePath;
    config.flags          = flags;
    config.pNotifications = pNotifications;

    return ma_resource_manager_data_buffer_init_ex(pResourceManager, &config, pDataBuffer);
}

MA_API ma_result ma_resource_manager_data_buffer_init_w(ma_resource_manager* pResourceManager, const wchar_t* pFilePath, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_buffer* pDataBuffer)
{
    ma_resource_manager_data_source_config config;

    config = ma_resource_manager_data_source_config_init();
    config.pFilePathW     = pFilePath;
    config.flags          = flags;
    config.pNotifications = pNotifications;

    return ma_resource_manager_data_buffer_init_ex(pResourceManager, &config, pDataBuffer);
}

MA_API ma_result ma_resource_manager_data_buffer_init_copy(ma_resource_manager* pResourceManager, const ma_resource_manager_data_buffer* pExistingDataBuffer, ma_resource_manager_data_buffer* pDataBuffer)
{
    ma_resource_manager_data_source_config config;

    if (pExistingDataBuffer == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ASSERT(pExistingDataBuffer->pNode != NULL);  /* <-- If you've triggered this, you've passed in an invalid existing data buffer. */

    config = ma_resource_manager_data_source_config_init();
    config.flags = pExistingDataBuffer->flags;

    return ma_resource_manager_data_buffer_init_ex_internal(pResourceManager, &config, pExistingDataBuffer->pNode->hashedName32, pDataBuffer);
}

static ma_result ma_resource_manager_data_buffer_uninit_internal(ma_resource_manager_data_buffer* pDataBuffer)
{
    MA_ASSERT(pDataBuffer != NULL);

    /* The connector should be uninitialized first. */
    ma_resource_manager_data_buffer_uninit_connector(pDataBuffer->pResourceManager, pDataBuffer);

    /* With the connector uninitialized we can unacquire the node. */
    ma_resource_manager_data_buffer_node_unacquire(pDataBuffer->pResourceManager, pDataBuffer->pNode, NULL, NULL);

    /* The base data source needs to be uninitialized as well. */
    ma_data_source_uninit(&pDataBuffer->ds);

    return MA_SUCCESS;
}

MA_API ma_result ma_resource_manager_data_buffer_uninit(ma_resource_manager_data_buffer* pDataBuffer)
{
    ma_result result;

    if (pDataBuffer == NULL) {
        return MA_INVALID_ARGS;
    }

    if (ma_resource_manager_data_buffer_result(pDataBuffer) == MA_SUCCESS) {
        /* The data buffer can be deleted synchronously. */
        return ma_resource_manager_data_buffer_uninit_internal(pDataBuffer);
    } else {
        /*
        The data buffer needs to be deleted asynchronously because it's still loading. With the status set to MA_UNAVAILABLE, no more pages will
        be loaded and the uninitialization should happen fairly quickly. Since the caller owns the data buffer, we need to wait for this event
        to get processed before returning.
        */
        ma_resource_manager_inline_notification notification;
        ma_job job;

        /*
        We need to mark the node as unavailable so we don't try reading from it anymore, but also to
        let the loading thread know that it needs to abort it's loading procedure.
        */
        ma_atomic_exchange_i32(&pDataBuffer->result, MA_UNAVAILABLE);

        result = ma_resource_manager_inline_notification_init(pDataBuffer->pResourceManager, &notification);
        if (result != MA_SUCCESS) {
            return result;  /* Failed to create the notification. This should rarely, if ever, happen. */
        }

        job = ma_job_init(MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_BUFFER);
        job.order = ma_resource_manager_data_buffer_next_execution_order(pDataBuffer);
        job.data.resourceManager.freeDataBuffer.pDataBuffer       = pDataBuffer;
        job.data.resourceManager.freeDataBuffer.pDoneNotification = &notification;
        job.data.resourceManager.freeDataBuffer.pDoneFence        = NULL;

        result = ma_resource_manager_post_job(pDataBuffer->pResourceManager, &job);
        if (result != MA_SUCCESS) {
            ma_resource_manager_inline_notification_uninit(&notification);
            return result;
        }

        ma_resource_manager_inline_notification_wait_and_uninit(&notification);
    }

    return result;
}

MA_API ma_result ma_resource_manager_data_buffer_read_pcm_frames(ma_resource_manager_data_buffer* pDataBuffer, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    ma_result result = MA_SUCCESS;
    ma_uint64 framesRead = 0;
    ma_bool32 isDecodedBufferBusy = MA_FALSE;

    /* Safety. */
    if (pFramesRead != NULL) {
        *pFramesRead = 0;
    }

    if (frameCount == 0) {
        return MA_INVALID_ARGS;
    }

    /*
    We cannot be using the data buffer after it's been uninitialized. If you trigger this assert it means you're trying to read from the data buffer after
    it's been uninitialized or is in the process of uninitializing.
    */
    MA_ASSERT(ma_resource_manager_data_buffer_node_result(pDataBuffer->pNode) != MA_UNAVAILABLE);

    /* If the node is not initialized we need to abort with a busy code. */
    if (ma_resource_manager_data_buffer_has_connector(pDataBuffer) == MA_FALSE) {
        return MA_BUSY; /* Still loading. */
    }

    /*
    If we've got a seek scheduled we'll want to do that before reading. However, for paged buffers, there's
    a chance that the sound hasn't yet been decoded up to the seek point will result in the seek failing. If
    this happens, we need to keep the seek scheduled and return MA_BUSY.
    */
    if (pDataBuffer->seekToCursorOnNextRead) {
        pDataBuffer->seekToCursorOnNextRead = MA_FALSE;

        result = ma_data_source_seek_to_pcm_frame(ma_resource_manager_data_buffer_get_connector(pDataBuffer), pDataBuffer->seekTargetInPCMFrames);
        if (result != MA_SUCCESS) {
            if (result == MA_BAD_SEEK && ma_resource_manager_data_buffer_node_get_data_supply_type(pDataBuffer->pNode) == ma_resource_manager_data_supply_type_decoded_paged) {
                pDataBuffer->seekToCursorOnNextRead = MA_TRUE;  /* Keep the seek scheduled. We just haven't loaded enough data yet to do the seek properly. */
                return MA_BUSY;
            }

            return result;
        }
    }

    /*
    For decoded buffers (not paged) we need to check beforehand how many frames we have available. We cannot
    exceed this amount. We'll read as much as we can, and then return MA_BUSY.
    */
    if (ma_resource_manager_data_buffer_node_get_data_supply_type(pDataBuffer->pNode) == ma_resource_manager_data_supply_type_decoded) {
        ma_uint64 availableFrames;

        isDecodedBufferBusy = (ma_resource_manager_data_buffer_node_result(pDataBuffer->pNode) == MA_BUSY);

        if (ma_resource_manager_data_buffer_get_available_frames(pDataBuffer, &availableFrames) == MA_SUCCESS) {
            /* Don't try reading more than the available frame count if the data buffer node is still loading. */
            if (isDecodedBufferBusy) {
                if (frameCount > availableFrames) {
                    frameCount = availableFrames;

                    /*
                    If there's no frames available we want to set the status to MA_AT_END. The logic below
                    will check if the node is busy, and if so, change it to MA_BUSY. The reason we do this
                    is because we don't want to call `ma_data_source_read_pcm_frames()` if the frame count
                    is 0 because that'll result in a situation where it's possible MA_AT_END won't get
                    returned.
                    */
                    if (frameCount == 0) {
                        result = MA_AT_END;
                    }
                } else {
                    isDecodedBufferBusy = MA_FALSE; /* We have enough frames available in the buffer to avoid a MA_BUSY status. */
                }
            } else {
                /*
                Getting here means the buffer has been fully loaded. We can just pass the frame count straight
                into ma_data_source_read_pcm_frames() below and let ma_data_source handle it.
                */
            }
        }
    }

    /* Don't attempt to read anything if we've got no frames available. */
    if (frameCount > 0) {
        result = ma_data_source_read_pcm_frames(ma_resource_manager_data_buffer_get_connector(pDataBuffer), pFramesOut, frameCount, &framesRead);
    }

    /*
    If we returned MA_AT_END, but the node is still loading, we don't want to return that code or else the caller will interpret the sound
    as at the end and terminate decoding.
    */
    if (result == MA_AT_END) {
        if (ma_resource_manager_data_buffer_node_result(pDataBuffer->pNode) == MA_BUSY) {
            result = MA_BUSY;
        }
    }

    if (isDecodedBufferBusy) {
        result = MA_BUSY;
    }

    if (pFramesRead != NULL) {
        *pFramesRead = framesRead;
    }

    if (result == MA_SUCCESS && framesRead == 0) {
        result  = MA_AT_END;
    }

    return result;
}

MA_API ma_result ma_resource_manager_data_buffer_seek_to_pcm_frame(ma_resource_manager_data_buffer* pDataBuffer, ma_uint64 frameIndex)
{
    ma_result result;

    /* We cannot be using the data source after it's been uninitialized. */
    MA_ASSERT(ma_resource_manager_data_buffer_node_result(pDataBuffer->pNode) != MA_UNAVAILABLE);

    /* If we haven't yet got a connector we need to abort. */
    if (ma_resource_manager_data_buffer_has_connector(pDataBuffer) == MA_FALSE) {
        pDataBuffer->seekTargetInPCMFrames = frameIndex;
        pDataBuffer->seekToCursorOnNextRead = MA_TRUE;
        return MA_BUSY; /* Still loading. */
    }

    result = ma_data_source_seek_to_pcm_frame(ma_resource_manager_data_buffer_get_connector(pDataBuffer), frameIndex);
    if (result != MA_SUCCESS) {
        return result;
    }

    pDataBuffer->seekTargetInPCMFrames = ~(ma_uint64)0; /* <-- For identification purposes. */
    pDataBuffer->seekToCursorOnNextRead = MA_FALSE;

    return MA_SUCCESS;
}

MA_API ma_result ma_resource_manager_data_buffer_get_data_format(ma_resource_manager_data_buffer* pDataBuffer, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)
{
    /* We cannot be using the data source after it's been uninitialized. */
    MA_ASSERT(ma_resource_manager_data_buffer_node_result(pDataBuffer->pNode) != MA_UNAVAILABLE);

    switch (ma_resource_manager_data_buffer_node_get_data_supply_type(pDataBuffer->pNode))
    {
        case ma_resource_manager_data_supply_type_encoded:
        {
            return ma_data_source_get_data_format(&pDataBuffer->connector.decoder, pFormat, pChannels, pSampleRate, pChannelMap, channelMapCap);
        };

        case ma_resource_manager_data_supply_type_decoded:
        {
            *pFormat     = pDataBuffer->pNode->data.backend.decoded.format;
            *pChannels   = pDataBuffer->pNode->data.backend.decoded.channels;
            *pSampleRate = pDataBuffer->pNode->data.backend.decoded.sampleRate;
            ma_channel_map_init_standard(ma_standard_channel_map_default, pChannelMap, channelMapCap, pDataBuffer->pNode->data.backend.decoded.channels);
            return MA_SUCCESS;
        };

        case ma_resource_manager_data_supply_type_decoded_paged:
        {
            *pFormat     = pDataBuffer->pNode->data.backend.decodedPaged.data.format;
            *pChannels   = pDataBuffer->pNode->data.backend.decodedPaged.data.channels;
            *pSampleRate = pDataBuffer->pNode->data.backend.decodedPaged.sampleRate;
            ma_channel_map_init_standard(ma_standard_channel_map_default, pChannelMap, channelMapCap, pDataBuffer->pNode->data.backend.decoded.channels);
            return MA_SUCCESS;
        };

        case ma_resource_manager_data_supply_type_unknown:
        {
            return MA_BUSY; /* Still loading. */
        };

        default:
        {
            /* Unknown supply type. Should never hit this. */
            return MA_INVALID_ARGS;
        }
    }
}

MA_API ma_result ma_resource_manager_data_buffer_get_cursor_in_pcm_frames(ma_resource_manager_data_buffer* pDataBuffer, ma_uint64* pCursor)
{
    /* We cannot be using the data source after it's been uninitialized. */
    MA_ASSERT(ma_resource_manager_data_buffer_node_result(pDataBuffer->pNode) != MA_UNAVAILABLE);

    if (pDataBuffer == NULL || pCursor == NULL) {
        return MA_INVALID_ARGS;
    }

    *pCursor = 0;

    switch (ma_resource_manager_data_buffer_node_get_data_supply_type(pDataBuffer->pNode))
    {
        case ma_resource_manager_data_supply_type_encoded:
        {
            return ma_decoder_get_cursor_in_pcm_frames(&pDataBuffer->connector.decoder, pCursor);
        };

        case ma_resource_manager_data_supply_type_decoded:
        {
            return ma_audio_buffer_get_cursor_in_pcm_frames(&pDataBuffer->connector.buffer, pCursor);
        };

        case ma_resource_manager_data_supply_type_decoded_paged:
        {
            return ma_paged_audio_buffer_get_cursor_in_pcm_frames(&pDataBuffer->connector.pagedBuffer, pCursor);
        };

        case ma_resource_manager_data_supply_type_unknown:
        {
            return MA_BUSY;
        };

        default:
        {
            return MA_INVALID_ARGS;
        }
    }
}

MA_API ma_result ma_resource_manager_data_buffer_get_length_in_pcm_frames(ma_resource_manager_data_buffer* pDataBuffer, ma_uint64* pLength)
{
    /* We cannot be using the data source after it's been uninitialized. */
    MA_ASSERT(ma_resource_manager_data_buffer_node_result(pDataBuffer->pNode) != MA_UNAVAILABLE);

    if (pDataBuffer == NULL || pLength == NULL) {
        return MA_INVALID_ARGS;
    }

    if (ma_resource_manager_data_buffer_node_get_data_supply_type(pDataBuffer->pNode) == ma_resource_manager_data_supply_type_unknown) {
        return MA_BUSY; /* Still loading. */
    }

    return ma_data_source_get_length_in_pcm_frames(ma_resource_manager_data_buffer_get_connector(pDataBuffer), pLength);
}

MA_API ma_result ma_resource_manager_data_buffer_result(const ma_resource_manager_data_buffer* pDataBuffer)
{
    if (pDataBuffer == NULL) {
        return MA_INVALID_ARGS;
    }

    return (ma_result)ma_atomic_load_i32((ma_result*)&pDataBuffer->result);    /* Need a naughty const-cast here. */
}

MA_API ma_result ma_resource_manager_data_buffer_set_looping(ma_resource_manager_data_buffer* pDataBuffer, ma_bool32 isLooping)
{
    return ma_data_source_set_looping(pDataBuffer, isLooping);
}

MA_API ma_bool32 ma_resource_manager_data_buffer_is_looping(const ma_resource_manager_data_buffer* pDataBuffer)
{
    return ma_data_source_is_looping(pDataBuffer);
}

MA_API ma_result ma_resource_manager_data_buffer_get_available_frames(ma_resource_manager_data_buffer* pDataBuffer, ma_uint64* pAvailableFrames)
{
    if (pAvailableFrames == NULL) {
        return MA_INVALID_ARGS;
    }

    *pAvailableFrames = 0;

    if (pDataBuffer == NULL) {
        return MA_INVALID_ARGS;
    }

    if (ma_resource_manager_data_buffer_node_get_data_supply_type(pDataBuffer->pNode) == ma_resource_manager_data_supply_type_unknown) {
        if (ma_resource_manager_data_buffer_node_result(pDataBuffer->pNode) == MA_BUSY) {
            return MA_BUSY;
        } else {
            return MA_INVALID_OPERATION;    /* No connector. */
        }
    }

    switch (ma_resource_manager_data_buffer_node_get_data_supply_type(pDataBuffer->pNode))
    {
        case ma_resource_manager_data_supply_type_encoded:
        {
            return ma_decoder_get_available_frames(&pDataBuffer->connector.decoder, pAvailableFrames);
        };

        case ma_resource_manager_data_supply_type_decoded:
        {
            return ma_audio_buffer_get_available_frames(&pDataBuffer->connector.buffer, pAvailableFrames);
        };

        case ma_resource_manager_data_supply_type_decoded_paged:
        {
            ma_uint64 cursor;
            ma_paged_audio_buffer_get_cursor_in_pcm_frames(&pDataBuffer->connector.pagedBuffer, &cursor);

            if (pDataBuffer->pNode->data.backend.decodedPaged.decodedFrameCount > cursor) {
                *pAvailableFrames = pDataBuffer->pNode->data.backend.decodedPaged.decodedFrameCount - cursor;
            } else {
                *pAvailableFrames = 0;
            }

            return MA_SUCCESS;
        };

        case ma_resource_manager_data_supply_type_unknown:
        default:
        {
            /* Unknown supply type. Should never hit this. */
            return MA_INVALID_ARGS;
        }
    }
}

MA_API ma_result ma_resource_manager_register_file(ma_resource_manager* pResourceManager, const char* pFilePath, ma_uint32 flags)
{
    return ma_resource_manager_data_buffer_node_acquire(pResourceManager, pFilePath, NULL, 0, flags, NULL, NULL, NULL, NULL);
}

MA_API ma_result ma_resource_manager_register_file_w(ma_resource_manager* pResourceManager, const wchar_t* pFilePath, ma_uint32 flags)
{
    return ma_resource_manager_data_buffer_node_acquire(pResourceManager, NULL, pFilePath, 0, flags, NULL, NULL, NULL, NULL);
}


static ma_result ma_resource_manager_register_data(ma_resource_manager* pResourceManager, const char* pName, const wchar_t* pNameW, ma_resource_manager_data_supply* pExistingData)
{
    return ma_resource_manager_data_buffer_node_acquire(pResourceManager, pName, pNameW, 0, 0, pExistingData, NULL, NULL, NULL);
}

static ma_result ma_resource_manager_register_decoded_data_internal(ma_resource_manager* pResourceManager, const char* pName, const wchar_t* pNameW, const void* pData, ma_uint64 frameCount, ma_format format, ma_uint32 channels, ma_uint32 sampleRate)
{
    ma_resource_manager_data_supply data;
    data.type                            = ma_resource_manager_data_supply_type_decoded;
    data.backend.decoded.pData           = pData;
    data.backend.decoded.totalFrameCount = frameCount;
    data.backend.decoded.format          = format;
    data.backend.decoded.channels        = channels;
    data.backend.decoded.sampleRate      = sampleRate;

    return ma_resource_manager_register_data(pResourceManager, pName, pNameW, &data);
}

MA_API ma_result ma_resource_manager_register_decoded_data(ma_resource_manager* pResourceManager, const char* pName, const void* pData, ma_uint64 frameCount, ma_format format, ma_uint32 channels, ma_uint32 sampleRate)
{
    return ma_resource_manager_register_decoded_data_internal(pResourceManager, pName, NULL, pData, frameCount, format, channels, sampleRate);
}

MA_API ma_result ma_resource_manager_register_decoded_data_w(ma_resource_manager* pResourceManager, const wchar_t* pName, const void* pData, ma_uint64 frameCount, ma_format format, ma_uint32 channels, ma_uint32 sampleRate)
{
    return ma_resource_manager_register_decoded_data_internal(pResourceManager, NULL, pName, pData, frameCount, format, channels, sampleRate);
}


static ma_result ma_resource_manager_register_encoded_data_internal(ma_resource_manager* pResourceManager, const char* pName, const wchar_t* pNameW, const void* pData, size_t sizeInBytes)
{
    ma_resource_manager_data_supply data;
    data.type                        = ma_resource_manager_data_supply_type_encoded;
    data.backend.encoded.pData       = pData;
    data.backend.encoded.sizeInBytes = sizeInBytes;

    return ma_resource_manager_register_data(pResourceManager, pName, pNameW, &data);
}

MA_API ma_result ma_resource_manager_register_encoded_data(ma_resource_manager* pResourceManager, const char* pName, const void* pData, size_t sizeInBytes)
{
    return ma_resource_manager_register_encoded_data_internal(pResourceManager, pName, NULL, pData, sizeInBytes);
}

MA_API ma_result ma_resource_manager_register_encoded_data_w(ma_resource_manager* pResourceManager, const wchar_t* pName, const void* pData, size_t sizeInBytes)
{
    return ma_resource_manager_register_encoded_data_internal(pResourceManager, NULL, pName, pData, sizeInBytes);
}


MA_API ma_result ma_resource_manager_unregister_file(ma_resource_manager* pResourceManager, const char* pFilePath)
{
    return ma_resource_manager_unregister_data(pResourceManager, pFilePath);
}

MA_API ma_result ma_resource_manager_unregister_file_w(ma_resource_manager* pResourceManager, const wchar_t* pFilePath)
{
    return ma_resource_manager_unregister_data_w(pResourceManager, pFilePath);
}

MA_API ma_result ma_resource_manager_unregister_data(ma_resource_manager* pResourceManager, const char* pName)
{
    return ma_resource_manager_data_buffer_node_unacquire(pResourceManager, NULL, pName, NULL);
}

MA_API ma_result ma_resource_manager_unregister_data_w(ma_resource_manager* pResourceManager, const wchar_t* pName)
{
    return ma_resource_manager_data_buffer_node_unacquire(pResourceManager, NULL, NULL, pName);
}


static ma_uint32 ma_resource_manager_data_stream_next_execution_order(ma_resource_manager_data_stream* pDataStream)
{
    MA_ASSERT(pDataStream != NULL);
    return ma_atomic_fetch_add_32(&pDataStream->executionCounter, 1);
}

static ma_bool32 ma_resource_manager_data_stream_is_decoder_at_end(const ma_resource_manager_data_stream* pDataStream)
{
    MA_ASSERT(pDataStream != NULL);
    return ma_atomic_load_32((ma_bool32*)&pDataStream->isDecoderAtEnd);
}

static ma_uint32 ma_resource_manager_data_stream_seek_counter(const ma_resource_manager_data_stream* pDataStream)
{
    MA_ASSERT(pDataStream != NULL);
    return ma_atomic_load_32((ma_uint32*)&pDataStream->seekCounter);
}


static ma_result ma_resource_manager_data_stream_cb__read_pcm_frames(ma_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    return ma_resource_manager_data_stream_read_pcm_frames((ma_resource_manager_data_stream*)pDataSource, pFramesOut, frameCount, pFramesRead);
}

static ma_result ma_resource_manager_data_stream_cb__seek_to_pcm_frame(ma_data_source* pDataSource, ma_uint64 frameIndex)
{
    return ma_resource_manager_data_stream_seek_to_pcm_frame((ma_resource_manager_data_stream*)pDataSource, frameIndex);
}

static ma_result ma_resource_manager_data_stream_cb__get_data_format(ma_data_source* pDataSource, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)
{
    return ma_resource_manager_data_stream_get_data_format((ma_resource_manager_data_stream*)pDataSource, pFormat, pChannels, pSampleRate, pChannelMap, channelMapCap);
}

static ma_result ma_resource_manager_data_stream_cb__get_cursor_in_pcm_frames(ma_data_source* pDataSource, ma_uint64* pCursor)
{
    return ma_resource_manager_data_stream_get_cursor_in_pcm_frames((ma_resource_manager_data_stream*)pDataSource, pCursor);
}

static ma_result ma_resource_manager_data_stream_cb__get_length_in_pcm_frames(ma_data_source* pDataSource, ma_uint64* pLength)
{
    return ma_resource_manager_data_stream_get_length_in_pcm_frames((ma_resource_manager_data_stream*)pDataSource, pLength);
}

static ma_result ma_resource_manager_data_stream_cb__set_looping(ma_data_source* pDataSource, ma_bool32 isLooping)
{
    ma_resource_manager_data_stream* pDataStream = (ma_resource_manager_data_stream*)pDataSource;
    MA_ASSERT(pDataStream != NULL);

    ma_atomic_exchange_32(&pDataStream->isLooping, isLooping);

    return MA_SUCCESS;
}

static ma_data_source_vtable g_ma_resource_manager_data_stream_vtable =
{
    ma_resource_manager_data_stream_cb__read_pcm_frames,
    ma_resource_manager_data_stream_cb__seek_to_pcm_frame,
    ma_resource_manager_data_stream_cb__get_data_format,
    ma_resource_manager_data_stream_cb__get_cursor_in_pcm_frames,
    ma_resource_manager_data_stream_cb__get_length_in_pcm_frames,
    ma_resource_manager_data_stream_cb__set_looping,
    0 /*MA_DATA_SOURCE_SELF_MANAGED_RANGE_AND_LOOP_POINT*/
};

static void ma_resource_manager_data_stream_set_absolute_cursor(ma_resource_manager_data_stream* pDataStream, ma_uint64 absoluteCursor)
{
    /* Loop if possible. */
    if (absoluteCursor > pDataStream->totalLengthInPCMFrames && pDataStream->totalLengthInPCMFrames > 0) {
        absoluteCursor = absoluteCursor % pDataStream->totalLengthInPCMFrames;
    }

    ma_atomic_exchange_64(&pDataStream->absoluteCursor, absoluteCursor);
}

MA_API ma_result ma_resource_manager_data_stream_init_ex(ma_resource_manager* pResourceManager, const ma_resource_manager_data_source_config* pConfig, ma_resource_manager_data_stream* pDataStream)
{
    ma_result result;
    ma_data_source_config dataSourceConfig;
    char* pFilePathCopy = NULL;
    wchar_t* pFilePathWCopy = NULL;
    ma_job job;
    ma_bool32 waitBeforeReturning = MA_FALSE;
    ma_resource_manager_inline_notification waitNotification;
    ma_resource_manager_pipeline_notifications notifications;
    ma_uint32 flags;

    if (pDataStream == NULL) {
        if (pConfig != NULL && pConfig->pNotifications != NULL) {
            ma_resource_manager_pipeline_notifications_signal_all_notifications(pConfig->pNotifications);
        }

        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pDataStream);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->pNotifications != NULL) {
        notifications = *pConfig->pNotifications;    /* From here on out, `notifications` should be used instead of `pNotifications`. Setting this to NULL to catch any errors at testing time. */
    } else {
        MA_ZERO_OBJECT(&notifications);
    }

    dataSourceConfig = ma_data_source_config_init();
    dataSourceConfig.vtable = &g_ma_resource_manager_data_stream_vtable;

    result = ma_data_source_init(&dataSourceConfig, &pDataStream->ds);
    if (result != MA_SUCCESS) {
        ma_resource_manager_pipeline_notifications_signal_all_notifications(&notifications);
        return result;
    }

    flags = pConfig->flags;
    if (pConfig->isLooping) {
        flags |= MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_LOOPING;
    }

    pDataStream->pResourceManager = pResourceManager;
    pDataStream->flags            = pConfig->flags;
    pDataStream->result           = MA_BUSY;

    ma_data_source_set_range_in_pcm_frames(pDataStream, pConfig->rangeBegInPCMFrames, pConfig->rangeEndInPCMFrames);
    ma_data_source_set_loop_point_in_pcm_frames(pDataStream, pConfig->loopPointBegInPCMFrames, pConfig->loopPointEndInPCMFrames);
    ma_data_source_set_looping(pDataStream, (flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_LOOPING) != 0);

    if (pResourceManager == NULL || (pConfig->pFilePath == NULL && pConfig->pFilePathW == NULL)) {
        ma_resource_manager_pipeline_notifications_signal_all_notifications(&notifications);
        return MA_INVALID_ARGS;
    }

    /* We want all access to the VFS and the internal decoder to happen on the job thread just to keep things easier to manage for the VFS.  */

    /* We need a copy of the file path. We should probably make this more efficient, but for now we'll do a transient memory allocation. */
    if (pConfig->pFilePath != NULL) {
        pFilePathCopy  = ma_copy_string(pConfig->pFilePath, &pResourceManager->config.allocationCallbacks);
    } else {
        pFilePathWCopy = ma_copy_string_w(pConfig->pFilePathW, &pResourceManager->config.allocationCallbacks);
    }

    if (pFilePathCopy == NULL && pFilePathWCopy == NULL) {
        ma_resource_manager_pipeline_notifications_signal_all_notifications(&notifications);
        return MA_OUT_OF_MEMORY;
    }

    /*
    We need to check for the presence of MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC. If it's not set, we need to wait before returning. Otherwise we
    can return immediately. Likewise, we'll also check for MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT and do the same.
    */
    if ((pConfig->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC) == 0 || (pConfig->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT) != 0) {
        waitBeforeReturning = MA_TRUE;
        ma_resource_manager_inline_notification_init(pResourceManager, &waitNotification);
    }

    ma_resource_manager_pipeline_notifications_acquire_all_fences(&notifications);

    /* Set the absolute cursor to our initial seek position so retrieval of the cursor returns a good value. */
    ma_resource_manager_data_stream_set_absolute_cursor(pDataStream, pConfig->initialSeekPointInPCMFrames);

    /* We now have everything we need to post the job. This is the last thing we need to do from here. The rest will be done by the job thread. */
    job = ma_job_init(MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_STREAM);
    job.order = ma_resource_manager_data_stream_next_execution_order(pDataStream);
    job.data.resourceManager.loadDataStream.pDataStream       = pDataStream;
    job.data.resourceManager.loadDataStream.pFilePath         = pFilePathCopy;
    job.data.resourceManager.loadDataStream.pFilePathW        = pFilePathWCopy;
    job.data.resourceManager.loadDataStream.initialSeekPoint  = pConfig->initialSeekPointInPCMFrames;
    job.data.resourceManager.loadDataStream.pInitNotification = (waitBeforeReturning == MA_TRUE) ? &waitNotification : notifications.init.pNotification;
    job.data.resourceManager.loadDataStream.pInitFence        = notifications.init.pFence;
    result = ma_resource_manager_post_job(pResourceManager, &job);
    if (result != MA_SUCCESS) {
        ma_resource_manager_pipeline_notifications_signal_all_notifications(&notifications);
        ma_resource_manager_pipeline_notifications_release_all_fences(&notifications);

        if (waitBeforeReturning) {
            ma_resource_manager_inline_notification_uninit(&waitNotification);
        }

        ma_free(pFilePathCopy,  &pResourceManager->config.allocationCallbacks);
        ma_free(pFilePathWCopy, &pResourceManager->config.allocationCallbacks);
        return result;
    }

    /* Wait if needed. */
    if (waitBeforeReturning) {
        ma_resource_manager_inline_notification_wait_and_uninit(&waitNotification);

        if (notifications.init.pNotification != NULL) {
            ma_async_notification_signal(notifications.init.pNotification);
        }

        /*
        If there was an error during initialization make sure we return that result here. We don't want to do this
        if we're not waiting because it will most likely be in a busy state.
        */
        if (pDataStream->result != MA_SUCCESS) {
            return pDataStream->result;
        }

        /* NOTE: Do not release pInitFence here. That will be done by the job. */
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_resource_manager_data_stream_init(ma_resource_manager* pResourceManager, const char* pFilePath, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_stream* pDataStream)
{
    ma_resource_manager_data_source_config config;

    config = ma_resource_manager_data_source_config_init();
    config.pFilePath      = pFilePath;
    config.flags          = flags;
    config.pNotifications = pNotifications;

    return ma_resource_manager_data_stream_init_ex(pResourceManager, &config, pDataStream);
}

MA_API ma_result ma_resource_manager_data_stream_init_w(ma_resource_manager* pResourceManager, const wchar_t* pFilePath, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_stream* pDataStream)
{
    ma_resource_manager_data_source_config config;

    config = ma_resource_manager_data_source_config_init();
    config.pFilePathW     = pFilePath;
    config.flags          = flags;
    config.pNotifications = pNotifications;

    return ma_resource_manager_data_stream_init_ex(pResourceManager, &config, pDataStream);
}

MA_API ma_result ma_resource_manager_data_stream_uninit(ma_resource_manager_data_stream* pDataStream)
{
    ma_resource_manager_inline_notification freeEvent;
    ma_job job;

    if (pDataStream == NULL) {
        return MA_INVALID_ARGS;
    }

    /* The first thing to do is set the result to unavailable. This will prevent future page decoding. */
    ma_atomic_exchange_i32(&pDataStream->result, MA_UNAVAILABLE);

    /*
    We need to post a job to ensure we're not in the middle or decoding or anything. Because the object is owned by the caller, we'll need
    to wait for it to complete before returning which means we need an event.
    */
    ma_resource_manager_inline_notification_init(pDataStream->pResourceManager, &freeEvent);

    job = ma_job_init(MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_STREAM);
    job.order = ma_resource_manager_data_stream_next_execution_order(pDataStream);
    job.data.resourceManager.freeDataStream.pDataStream       = pDataStream;
    job.data.resourceManager.freeDataStream.pDoneNotification = &freeEvent;
    job.data.resourceManager.freeDataStream.pDoneFence        = NULL;
    ma_resource_manager_post_job(pDataStream->pResourceManager, &job);

    /* We need to wait for the job to finish processing before we return. */
    ma_resource_manager_inline_notification_wait_and_uninit(&freeEvent);

    return MA_SUCCESS;
}


static ma_uint32 ma_resource_manager_data_stream_get_page_size_in_frames(ma_resource_manager_data_stream* pDataStream)
{
    MA_ASSERT(pDataStream != NULL);
    MA_ASSERT(pDataStream->isDecoderInitialized == MA_TRUE);

    return MA_RESOURCE_MANAGER_PAGE_SIZE_IN_MILLISECONDS * (pDataStream->decoder.outputSampleRate/1000);
}

static void* ma_resource_manager_data_stream_get_page_data_pointer(ma_resource_manager_data_stream* pDataStream, ma_uint32 pageIndex, ma_uint32 relativeCursor)
{
    MA_ASSERT(pDataStream != NULL);
    MA_ASSERT(pDataStream->isDecoderInitialized == MA_TRUE);
    MA_ASSERT(pageIndex == 0 || pageIndex == 1);

    return ma_offset_ptr(pDataStream->pPageData, ((ma_resource_manager_data_stream_get_page_size_in_frames(pDataStream) * pageIndex) + relativeCursor) * ma_get_bytes_per_frame(pDataStream->decoder.outputFormat, pDataStream->decoder.outputChannels));
}

static void ma_resource_manager_data_stream_fill_page(ma_resource_manager_data_stream* pDataStream, ma_uint32 pageIndex)
{
    ma_result result = MA_SUCCESS;
    ma_uint64 pageSizeInFrames;
    ma_uint64 totalFramesReadForThisPage = 0;
    void* pPageData = ma_resource_manager_data_stream_get_page_data_pointer(pDataStream, pageIndex, 0);

    pageSizeInFrames = ma_resource_manager_data_stream_get_page_size_in_frames(pDataStream);

    /* The decoder needs to inherit the stream's looping and range state. */
    {
        ma_uint64 rangeBeg;
        ma_uint64 rangeEnd;
        ma_uint64 loopPointBeg;
        ma_uint64 loopPointEnd;

        ma_data_source_set_looping(&pDataStream->decoder, ma_resource_manager_data_stream_is_looping(pDataStream));

        ma_data_source_get_range_in_pcm_frames(pDataStream, &rangeBeg, &rangeEnd);
        ma_data_source_set_range_in_pcm_frames(&pDataStream->decoder, rangeBeg, rangeEnd);

        ma_data_source_get_loop_point_in_pcm_frames(pDataStream, &loopPointBeg, &loopPointEnd);
        ma_data_source_set_loop_point_in_pcm_frames(&pDataStream->decoder, loopPointBeg, loopPointEnd);
    }

    /* Just read straight from the decoder. It will deal with ranges and looping for us. */
    result = ma_data_source_read_pcm_frames(&pDataStream->decoder, pPageData, pageSizeInFrames, &totalFramesReadForThisPage);
    if (result == MA_AT_END || totalFramesReadForThisPage < pageSizeInFrames) {
        ma_atomic_exchange_32(&pDataStream->isDecoderAtEnd, MA_TRUE);
    }

    ma_atomic_exchange_32(&pDataStream->pageFrameCount[pageIndex], (ma_uint32)totalFramesReadForThisPage);
    ma_atomic_exchange_32(&pDataStream->isPageValid[pageIndex], MA_TRUE);
}

static void ma_resource_manager_data_stream_fill_pages(ma_resource_manager_data_stream* pDataStream)
{
    ma_uint32 iPage;

    MA_ASSERT(pDataStream != NULL);

    for (iPage = 0; iPage < 2; iPage += 1) {
        ma_resource_manager_data_stream_fill_page(pDataStream, iPage);
    }
}


static ma_result ma_resource_manager_data_stream_map(ma_resource_manager_data_stream* pDataStream, void** ppFramesOut, ma_uint64* pFrameCount)
{
    ma_uint64 framesAvailable;
    ma_uint64 frameCount = 0;

    /* We cannot be using the data source after it's been uninitialized. */
    MA_ASSERT(ma_resource_manager_data_stream_result(pDataStream) != MA_UNAVAILABLE);

    if (pFrameCount != NULL) {
        frameCount = *pFrameCount;
        *pFrameCount = 0;
    }
    if (ppFramesOut != NULL) {
        *ppFramesOut = NULL;
    }

    if (pDataStream == NULL || ppFramesOut == NULL || pFrameCount == NULL) {
        return MA_INVALID_ARGS;
    }

    if (ma_resource_manager_data_stream_result(pDataStream) != MA_SUCCESS) {
        return MA_INVALID_OPERATION;
    }

    /* Don't attempt to read while we're in the middle of seeking. Tell the caller that we're busy. */
    if (ma_resource_manager_data_stream_seek_counter(pDataStream) > 0) {
        return MA_BUSY;
    }

    /* If the page we're on is invalid it means we've caught up to the job thread. */
    if (ma_atomic_load_32(&pDataStream->isPageValid[pDataStream->currentPageIndex]) == MA_FALSE) {
        framesAvailable = 0;
    } else {
        /*
        The page we're on is valid so we must have some frames available. We need to make sure that we don't overflow into the next page, even if it's valid. The reason is
        that the unmap process will only post an update for one page at a time. Keeping mapping tied to page boundaries makes this simpler.
        */
        ma_uint32 currentPageFrameCount = ma_atomic_load_32(&pDataStream->pageFrameCount[pDataStream->currentPageIndex]);
        MA_ASSERT(currentPageFrameCount >= pDataStream->relativeCursor);

        framesAvailable = currentPageFrameCount - pDataStream->relativeCursor;
    }

    /* If there's no frames available and the result is set to MA_AT_END we need to return MA_AT_END. */
    if (framesAvailable == 0) {
        if (ma_resource_manager_data_stream_is_decoder_at_end(pDataStream)) {
            return MA_AT_END;
        } else {
            return MA_BUSY; /* There are no frames available, but we're not marked as EOF so we might have caught up to the job thread. Need to return MA_BUSY and wait for more data. */
        }
    }

    MA_ASSERT(framesAvailable > 0);

    if (frameCount > framesAvailable) {
        frameCount = framesAvailable;
    }

    *ppFramesOut = ma_resource_manager_data_stream_get_page_data_pointer(pDataStream, pDataStream->currentPageIndex, pDataStream->relativeCursor);
    *pFrameCount = frameCount;

    return MA_SUCCESS;
}

static ma_result ma_resource_manager_data_stream_unmap(ma_resource_manager_data_stream* pDataStream, ma_uint64 frameCount)
{
    ma_uint32 newRelativeCursor;
    ma_uint32 pageSizeInFrames;
    ma_job job;

    /* We cannot be using the data source after it's been uninitialized. */
    MA_ASSERT(ma_resource_manager_data_stream_result(pDataStream) != MA_UNAVAILABLE);

    if (pDataStream == NULL) {
        return MA_INVALID_ARGS;
    }

    if (ma_resource_manager_data_stream_result(pDataStream) != MA_SUCCESS) {
        return MA_INVALID_OPERATION;
    }

    /* The frame count should always fit inside a 32-bit integer. */
    if (frameCount > 0xFFFFFFFF) {
        return MA_INVALID_ARGS;
    }

    pageSizeInFrames = ma_resource_manager_data_stream_get_page_size_in_frames(pDataStream);

    /* The absolute cursor needs to be updated for ma_resource_manager_data_stream_get_cursor_in_pcm_frames(). */
    ma_resource_manager_data_stream_set_absolute_cursor(pDataStream, ma_atomic_load_64(&pDataStream->absoluteCursor) + frameCount);

    /* Here is where we need to check if we need to load a new page, and if so, post a job to load it. */
    newRelativeCursor = pDataStream->relativeCursor + (ma_uint32)frameCount;

    /* If the new cursor has flowed over to the next page we need to mark the old one as invalid and post an event for it. */
    if (newRelativeCursor >= pageSizeInFrames) {
        newRelativeCursor -= pageSizeInFrames;

        /* Here is where we post the job start decoding. */
        job = ma_job_init(MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_STREAM);
        job.order = ma_resource_manager_data_stream_next_execution_order(pDataStream);
        job.data.resourceManager.pageDataStream.pDataStream = pDataStream;
        job.data.resourceManager.pageDataStream.pageIndex   = pDataStream->currentPageIndex;

        /* The page needs to be marked as invalid so that the public API doesn't try reading from it. */
        ma_atomic_exchange_32(&pDataStream->isPageValid[pDataStream->currentPageIndex], MA_FALSE);

        /* Before posting the job we need to make sure we set some state. */
        pDataStream->relativeCursor   = newRelativeCursor;
        pDataStream->currentPageIndex = (pDataStream->currentPageIndex + 1) & 0x01;
        return ma_resource_manager_post_job(pDataStream->pResourceManager, &job);
    } else {
        /* We haven't moved into a new page so we can just move the cursor forward. */
        pDataStream->relativeCursor = newRelativeCursor;
        return MA_SUCCESS;
    }
}


MA_API ma_result ma_resource_manager_data_stream_read_pcm_frames(ma_resource_manager_data_stream* pDataStream, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    ma_result result = MA_SUCCESS;
    ma_uint64 totalFramesProcessed;
    ma_format format;
    ma_uint32 channels;

    /* Safety. */
    if (pFramesRead != NULL) {
        *pFramesRead = 0;
    }

    if (frameCount == 0) {
        return MA_INVALID_ARGS;
    }

    /* We cannot be using the data source after it's been uninitialized. */
    MA_ASSERT(ma_resource_manager_data_stream_result(pDataStream) != MA_UNAVAILABLE);

    if (pDataStream == NULL) {
        return MA_INVALID_ARGS;
    }

    if (ma_resource_manager_data_stream_result(pDataStream) != MA_SUCCESS) {
        return MA_INVALID_OPERATION;
    }

    /* Don't attempt to read while we're in the middle of seeking. Tell the caller that we're busy. */
    if (ma_resource_manager_data_stream_seek_counter(pDataStream) > 0) {
        return MA_BUSY;
    }

    ma_resource_manager_data_stream_get_data_format(pDataStream, &format, &channels, NULL, NULL, 0);

    /* Reading is implemented in terms of map/unmap. We need to run this in a loop because mapping is clamped against page boundaries. */
    totalFramesProcessed = 0;
    while (totalFramesProcessed < frameCount) {
        void* pMappedFrames;
        ma_uint64 mappedFrameCount;

        mappedFrameCount = frameCount - totalFramesProcessed;
        result = ma_resource_manager_data_stream_map(pDataStream, &pMappedFrames, &mappedFrameCount);
        if (result != MA_SUCCESS) {
            break;
        }

        /* Copy the mapped data to the output buffer if we have one. It's allowed for pFramesOut to be NULL in which case a relative forward seek is performed. */
        if (pFramesOut != NULL) {
            ma_copy_pcm_frames(ma_offset_pcm_frames_ptr(pFramesOut, totalFramesProcessed, format, channels), pMappedFrames, mappedFrameCount, format, channels);
        }

        totalFramesProcessed += mappedFrameCount;

        result = ma_resource_manager_data_stream_unmap(pDataStream, mappedFrameCount);
        if (result != MA_SUCCESS) {
            break;  /* This is really bad - will only get an error here if we failed to post a job to the queue for loading the next page. */
        }
    }

    if (pFramesRead != NULL) {
        *pFramesRead = totalFramesProcessed;
    }

    if (result == MA_SUCCESS && totalFramesProcessed == 0) {
        result  = MA_AT_END;
    }

    return result;
}

MA_API ma_result ma_resource_manager_data_stream_seek_to_pcm_frame(ma_resource_manager_data_stream* pDataStream, ma_uint64 frameIndex)
{
    ma_job job;
    ma_result streamResult;

    streamResult = ma_resource_manager_data_stream_result(pDataStream);

    /* We cannot be using the data source after it's been uninitialized. */
    MA_ASSERT(streamResult != MA_UNAVAILABLE);

    if (pDataStream == NULL) {
        return MA_INVALID_ARGS;
    }

    if (streamResult != MA_SUCCESS && streamResult != MA_BUSY) {
        return MA_INVALID_OPERATION;
    }

    /* If we're not already seeking and we're sitting on the same frame, just make this a no-op. */
    if (ma_atomic_load_32(&pDataStream->seekCounter) == 0) {
        if (ma_atomic_load_64(&pDataStream->absoluteCursor) == frameIndex) {
            return MA_SUCCESS;
        }
    }


    /* Increment the seek counter first to indicate to read_paged_pcm_frames() and map_paged_pcm_frames() that we are in the middle of a seek and MA_BUSY should be returned. */
    ma_atomic_fetch_add_32(&pDataStream->seekCounter, 1);

    /* Update the absolute cursor so that ma_resource_manager_data_stream_get_cursor_in_pcm_frames() returns the new position. */
    ma_resource_manager_data_stream_set_absolute_cursor(pDataStream, frameIndex);

    /*
    We need to clear our currently loaded pages so that the stream starts playback from the new seek point as soon as possible. These are for the purpose of the public
    API and will be ignored by the seek job. The seek job will operate on the assumption that both pages have been marked as invalid and the cursor is at the start of
    the first page.
    */
    pDataStream->relativeCursor   = 0;
    pDataStream->currentPageIndex = 0;
    ma_atomic_exchange_32(&pDataStream->isPageValid[0], MA_FALSE);
    ma_atomic_exchange_32(&pDataStream->isPageValid[1], MA_FALSE);

    /* Make sure the data stream is not marked as at the end or else if we seek in response to hitting the end, we won't be able to read any more data. */
    ma_atomic_exchange_32(&pDataStream->isDecoderAtEnd, MA_FALSE);

    /*
    The public API is not allowed to touch the internal decoder so we need to use a job to perform the seek. When seeking, the job thread will assume both pages
    are invalid and any content contained within them will be discarded and replaced with newly decoded data.
    */
    job = ma_job_init(MA_JOB_TYPE_RESOURCE_MANAGER_SEEK_DATA_STREAM);
    job.order = ma_resource_manager_data_stream_next_execution_order(pDataStream);
    job.data.resourceManager.seekDataStream.pDataStream = pDataStream;
    job.data.resourceManager.seekDataStream.frameIndex  = frameIndex;
    return ma_resource_manager_post_job(pDataStream->pResourceManager, &job);
}

MA_API ma_result ma_resource_manager_data_stream_get_data_format(ma_resource_manager_data_stream* pDataStream, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)
{
    /* We cannot be using the data source after it's been uninitialized. */
    MA_ASSERT(ma_resource_manager_data_stream_result(pDataStream) != MA_UNAVAILABLE);

    if (pFormat != NULL) {
        *pFormat = ma_format_unknown;
    }

    if (pChannels != NULL) {
        *pChannels = 0;
    }

    if (pSampleRate != NULL) {
        *pSampleRate = 0;
    }

    if (pChannelMap != NULL) {
        MA_ZERO_MEMORY(pChannelMap, sizeof(*pChannelMap) * channelMapCap);
    }

    if (pDataStream == NULL) {
        return MA_INVALID_ARGS;
    }

    if (ma_resource_manager_data_stream_result(pDataStream) != MA_SUCCESS) {
        return MA_INVALID_OPERATION;
    }

    /*
    We're being a little bit naughty here and accessing the internal decoder from the public API. The output data format is constant, and we've defined this function
    such that the application is responsible for ensuring it's not called while uninitializing so it should be safe.
    */
    return ma_data_source_get_data_format(&pDataStream->decoder, pFormat, pChannels, pSampleRate, pChannelMap, channelMapCap);
}

MA_API ma_result ma_resource_manager_data_stream_get_cursor_in_pcm_frames(ma_resource_manager_data_stream* pDataStream, ma_uint64* pCursor)
{
    ma_result result;

    if (pCursor == NULL) {
        return MA_INVALID_ARGS;
    }

    *pCursor = 0;

    /* We cannot be using the data source after it's been uninitialized. */
    MA_ASSERT(ma_resource_manager_data_stream_result(pDataStream) != MA_UNAVAILABLE);

    if (pDataStream == NULL) {
        return MA_INVALID_ARGS;
    }

    /*
    If the stream is in an erroneous state we need to return an invalid operation. We can allow
    this to be called when the data stream is in a busy state because the caller may have asked
    for an initial seek position and it's convenient to return that as the cursor position.
    */
    result = ma_resource_manager_data_stream_result(pDataStream);
    if (result != MA_SUCCESS && result != MA_BUSY) {
        return MA_INVALID_OPERATION;
    }

    *pCursor = ma_atomic_load_64(&pDataStream->absoluteCursor);

    return MA_SUCCESS;
}

MA_API ma_result ma_resource_manager_data_stream_get_length_in_pcm_frames(ma_resource_manager_data_stream* pDataStream, ma_uint64* pLength)
{
    ma_result streamResult;

    if (pLength == NULL) {
        return MA_INVALID_ARGS;
    }

    *pLength = 0;

    streamResult = ma_resource_manager_data_stream_result(pDataStream);

    /* We cannot be using the data source after it's been uninitialized. */
    MA_ASSERT(streamResult != MA_UNAVAILABLE);

    if (pDataStream == NULL) {
        return MA_INVALID_ARGS;
    }

    if (streamResult != MA_SUCCESS) {
        return streamResult;
    }

    /*
    We most definitely do not want to be calling ma_decoder_get_length_in_pcm_frames() directly. Instead we want to use a cached value that we
    calculated when we initialized it on the job thread.
    */
    *pLength = pDataStream->totalLengthInPCMFrames;
    if (*pLength == 0) {
        return MA_NOT_IMPLEMENTED;  /* Some decoders may not have a known length. */
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_resource_manager_data_stream_result(const ma_resource_manager_data_stream* pDataStream)
{
    if (pDataStream == NULL) {
        return MA_INVALID_ARGS;
    }

    return (ma_result)ma_atomic_load_i32(&pDataStream->result);
}

MA_API ma_result ma_resource_manager_data_stream_set_looping(ma_resource_manager_data_stream* pDataStream, ma_bool32 isLooping)
{
    return ma_data_source_set_looping(pDataStream, isLooping);
}

MA_API ma_bool32 ma_resource_manager_data_stream_is_looping(const ma_resource_manager_data_stream* pDataStream)
{
    if (pDataStream == NULL) {
        return MA_FALSE;
    }

    return ma_atomic_load_32((ma_bool32*)&pDataStream->isLooping);   /* Naughty const-cast. Value won't change from here in practice (maybe from another thread). */
}

MA_API ma_result ma_resource_manager_data_stream_get_available_frames(ma_resource_manager_data_stream* pDataStream, ma_uint64* pAvailableFrames)
{
    ma_uint32 pageIndex0;
    ma_uint32 pageIndex1;
    ma_uint32 relativeCursor;
    ma_uint64 availableFrames;

    if (pAvailableFrames == NULL) {
        return MA_INVALID_ARGS;
    }

    *pAvailableFrames = 0;

    if (pDataStream == NULL) {
        return MA_INVALID_ARGS;
    }

    pageIndex0     =  pDataStream->currentPageIndex;
    pageIndex1     = (pDataStream->currentPageIndex + 1) & 0x01;
    relativeCursor =  pDataStream->relativeCursor;

    availableFrames = 0;
    if (ma_atomic_load_32(&pDataStream->isPageValid[pageIndex0])) {
        availableFrames += ma_atomic_load_32(&pDataStream->pageFrameCount[pageIndex0]) - relativeCursor;
        if (ma_atomic_load_32(&pDataStream->isPageValid[pageIndex1])) {
            availableFrames += ma_atomic_load_32(&pDataStream->pageFrameCount[pageIndex1]);
        }
    }

    *pAvailableFrames = availableFrames;
    return MA_SUCCESS;
}


static ma_result ma_resource_manager_data_source_preinit(ma_resource_manager* pResourceManager, const ma_resource_manager_data_source_config* pConfig, ma_resource_manager_data_source* pDataSource)
{
    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pDataSource);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pResourceManager == NULL) {
        return MA_INVALID_ARGS;
    }

    pDataSource->flags = pConfig->flags;
    if (pConfig->isLooping) {
        pDataSource->flags |= MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_LOOPING;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_resource_manager_data_source_init_ex(ma_resource_manager* pResourceManager, const ma_resource_manager_data_source_config* pConfig, ma_resource_manager_data_source* pDataSource)
{
    ma_result result;

    result = ma_resource_manager_data_source_preinit(pResourceManager, pConfig, pDataSource);
    if (result != MA_SUCCESS) {
        return result;
    }

    /* The data source itself is just a data stream or a data buffer. */
    if ((pConfig->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM) != 0) {
        return ma_resource_manager_data_stream_init_ex(pResourceManager, pConfig, &pDataSource->backend.stream);
    } else {
        return ma_resource_manager_data_buffer_init_ex(pResourceManager, pConfig, &pDataSource->backend.buffer);
    }
}

MA_API ma_result ma_resource_manager_data_source_init(ma_resource_manager* pResourceManager, const char* pName, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_source* pDataSource)
{
    ma_resource_manager_data_source_config config;

    config = ma_resource_manager_data_source_config_init();
    config.pFilePath      = pName;
    config.flags          = flags;
    config.pNotifications = pNotifications;

    return ma_resource_manager_data_source_init_ex(pResourceManager, &config, pDataSource);
}

MA_API ma_result ma_resource_manager_data_source_init_w(ma_resource_manager* pResourceManager, const wchar_t* pName, ma_uint32 flags, const ma_resource_manager_pipeline_notifications* pNotifications, ma_resource_manager_data_source* pDataSource)
{
    ma_resource_manager_data_source_config config;

    config = ma_resource_manager_data_source_config_init();
    config.pFilePathW     = pName;
    config.flags          = flags;
    config.pNotifications = pNotifications;

    return ma_resource_manager_data_source_init_ex(pResourceManager, &config, pDataSource);
}

MA_API ma_result ma_resource_manager_data_source_init_copy(ma_resource_manager* pResourceManager, const ma_resource_manager_data_source* pExistingDataSource, ma_resource_manager_data_source* pDataSource)
{
    ma_result result;
    ma_resource_manager_data_source_config config;

    if (pExistingDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    config = ma_resource_manager_data_source_config_init();
    config.flags = pExistingDataSource->flags;

    result = ma_resource_manager_data_source_preinit(pResourceManager, &config, pDataSource);
    if (result != MA_SUCCESS) {
        return result;
    }

    /* Copying can only be done from data buffers. Streams cannot be copied. */
    if ((pExistingDataSource->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM) != 0) {
        return MA_INVALID_OPERATION;
    }

    return ma_resource_manager_data_buffer_init_copy(pResourceManager, &pExistingDataSource->backend.buffer, &pDataSource->backend.buffer);
}

MA_API ma_result ma_resource_manager_data_source_uninit(ma_resource_manager_data_source* pDataSource)
{
    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    /* All we need to is uninitialize the underlying data buffer or data stream. */
    if ((pDataSource->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM) != 0) {
        return ma_resource_manager_data_stream_uninit(&pDataSource->backend.stream);
    } else {
        return ma_resource_manager_data_buffer_uninit(&pDataSource->backend.buffer);
    }
}

MA_API ma_result ma_resource_manager_data_source_read_pcm_frames(ma_resource_manager_data_source* pDataSource, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    /* Safety. */
    if (pFramesRead != NULL) {
        *pFramesRead = 0;
    }

    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    if ((pDataSource->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM) != 0) {
        return ma_resource_manager_data_stream_read_pcm_frames(&pDataSource->backend.stream, pFramesOut, frameCount, pFramesRead);
    } else {
        return ma_resource_manager_data_buffer_read_pcm_frames(&pDataSource->backend.buffer, pFramesOut, frameCount, pFramesRead);
    }
}

MA_API ma_result ma_resource_manager_data_source_seek_to_pcm_frame(ma_resource_manager_data_source* pDataSource, ma_uint64 frameIndex)
{
    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    if ((pDataSource->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM) != 0) {
        return ma_resource_manager_data_stream_seek_to_pcm_frame(&pDataSource->backend.stream, frameIndex);
    } else {
        return ma_resource_manager_data_buffer_seek_to_pcm_frame(&pDataSource->backend.buffer, frameIndex);
    }
}

MA_API ma_result ma_resource_manager_data_source_map(ma_resource_manager_data_source* pDataSource, void** ppFramesOut, ma_uint64* pFrameCount)
{
    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    if ((pDataSource->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM) != 0) {
        return ma_resource_manager_data_stream_map(&pDataSource->backend.stream, ppFramesOut, pFrameCount);
    } else {
        return MA_NOT_IMPLEMENTED;  /* Mapping not supported with data buffers. */
    }
}

MA_API ma_result ma_resource_manager_data_source_unmap(ma_resource_manager_data_source* pDataSource, ma_uint64 frameCount)
{
    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    if ((pDataSource->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM) != 0) {
        return ma_resource_manager_data_stream_unmap(&pDataSource->backend.stream, frameCount);
    } else {
        return MA_NOT_IMPLEMENTED;  /* Mapping not supported with data buffers. */
    }
}

MA_API ma_result ma_resource_manager_data_source_get_data_format(ma_resource_manager_data_source* pDataSource, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)
{
    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    if ((pDataSource->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM) != 0) {
        return ma_resource_manager_data_stream_get_data_format(&pDataSource->backend.stream, pFormat, pChannels, pSampleRate, pChannelMap, channelMapCap);
    } else {
        return ma_resource_manager_data_buffer_get_data_format(&pDataSource->backend.buffer, pFormat, pChannels, pSampleRate, pChannelMap, channelMapCap);
    }
}

MA_API ma_result ma_resource_manager_data_source_get_cursor_in_pcm_frames(ma_resource_manager_data_source* pDataSource, ma_uint64* pCursor)
{
    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    if ((pDataSource->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM) != 0) {
        return ma_resource_manager_data_stream_get_cursor_in_pcm_frames(&pDataSource->backend.stream, pCursor);
    } else {
        return ma_resource_manager_data_buffer_get_cursor_in_pcm_frames(&pDataSource->backend.buffer, pCursor);
    }
}

MA_API ma_result ma_resource_manager_data_source_get_length_in_pcm_frames(ma_resource_manager_data_source* pDataSource, ma_uint64* pLength)
{
    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    if ((pDataSource->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM) != 0) {
        return ma_resource_manager_data_stream_get_length_in_pcm_frames(&pDataSource->backend.stream, pLength);
    } else {
        return ma_resource_manager_data_buffer_get_length_in_pcm_frames(&pDataSource->backend.buffer, pLength);
    }
}

MA_API ma_result ma_resource_manager_data_source_result(const ma_resource_manager_data_source* pDataSource)
{
    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    if ((pDataSource->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM) != 0) {
        return ma_resource_manager_data_stream_result(&pDataSource->backend.stream);
    } else {
        return ma_resource_manager_data_buffer_result(&pDataSource->backend.buffer);
    }
}

MA_API ma_result ma_resource_manager_data_source_set_looping(ma_resource_manager_data_source* pDataSource, ma_bool32 isLooping)
{
    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    if ((pDataSource->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM) != 0) {
        return ma_resource_manager_data_stream_set_looping(&pDataSource->backend.stream, isLooping);
    } else {
        return ma_resource_manager_data_buffer_set_looping(&pDataSource->backend.buffer, isLooping);
    }
}

MA_API ma_bool32 ma_resource_manager_data_source_is_looping(const ma_resource_manager_data_source* pDataSource)
{
    if (pDataSource == NULL) {
        return MA_FALSE;
    }

    if ((pDataSource->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM) != 0) {
        return ma_resource_manager_data_stream_is_looping(&pDataSource->backend.stream);
    } else {
        return ma_resource_manager_data_buffer_is_looping(&pDataSource->backend.buffer);
    }
}

MA_API ma_result ma_resource_manager_data_source_get_available_frames(ma_resource_manager_data_source* pDataSource, ma_uint64* pAvailableFrames)
{
    if (pAvailableFrames == NULL) {
        return MA_INVALID_ARGS;
    }

    *pAvailableFrames = 0;

    if (pDataSource == NULL) {
        return MA_INVALID_ARGS;
    }

    if ((pDataSource->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM) != 0) {
        return ma_resource_manager_data_stream_get_available_frames(&pDataSource->backend.stream, pAvailableFrames);
    } else {
        return ma_resource_manager_data_buffer_get_available_frames(&pDataSource->backend.buffer, pAvailableFrames);
    }
}


MA_API ma_result ma_resource_manager_post_job(ma_resource_manager* pResourceManager, const ma_job* pJob)
{
    if (pResourceManager == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_job_queue_post(&pResourceManager->jobQueue, pJob);
}

MA_API ma_result ma_resource_manager_post_job_quit(ma_resource_manager* pResourceManager)
{
    ma_job job = ma_job_init(MA_JOB_TYPE_QUIT);
    return ma_resource_manager_post_job(pResourceManager, &job);
}

MA_API ma_result ma_resource_manager_next_job(ma_resource_manager* pResourceManager, ma_job* pJob)
{
    if (pResourceManager == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_job_queue_next(&pResourceManager->jobQueue, pJob);
}


static ma_result ma_job_process__resource_manager__load_data_buffer_node(ma_job* pJob)
{
    ma_result result = MA_SUCCESS;
    ma_resource_manager* pResourceManager;
    ma_resource_manager_data_buffer_node* pDataBufferNode;

    MA_ASSERT(pJob != NULL);

    pResourceManager = (ma_resource_manager*)pJob->data.resourceManager.loadDataBufferNode.pResourceManager;
    MA_ASSERT(pResourceManager != NULL);

    pDataBufferNode = (ma_resource_manager_data_buffer_node*)pJob->data.resourceManager.loadDataBufferNode.pDataBufferNode;
    MA_ASSERT(pDataBufferNode != NULL);
    MA_ASSERT(pDataBufferNode->isDataOwnedByResourceManager == MA_TRUE);  /* The data should always be owned by the resource manager. */

    /* The data buffer is not getting deleted, but we may be getting executed out of order. If so, we need to push the job back onto the queue and return. */
    if (pJob->order != ma_atomic_load_32(&pDataBufferNode->executionPointer)) {
        return ma_resource_manager_post_job(pResourceManager, pJob);    /* Attempting to execute out of order. Probably interleaved with a MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_BUFFER job. */
    }

    /* First thing we need to do is check whether or not the data buffer is getting deleted. If so we just abort. */
    if (ma_resource_manager_data_buffer_node_result(pDataBufferNode) != MA_BUSY) {
        result = ma_resource_manager_data_buffer_node_result(pDataBufferNode);    /* The data buffer may be getting deleted before it's even been loaded. */
        goto done;
    }

    /*
    We're ready to start loading. Essentially what we're doing here is initializing the data supply
    of the node. Once this is complete, data buffers can have their connectors initialized which
    will allow then to have audio data read from them.

    Note that when the data supply type has been moved away from "unknown", that is when other threads
    will determine that the node is available for data delivery and the data buffer connectors can be
    initialized. Therefore, it's important that it is set after the data supply has been initialized.
    */
    if ((pJob->data.resourceManager.loadDataBufferNode.flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_DECODE) != 0) {
        /*
        Decoding. This is the complex case because we're not going to be doing the entire decoding
        process here. Instead it's going to be split of multiple jobs and loaded in pages. The
        reason for this is to evenly distribute decoding time across multiple sounds, rather than
        having one huge sound hog all the available processing resources.

        The first thing we do is initialize a decoder. This is allocated on the heap and is passed
        around to the paging jobs. When the last paging job has completed it's processing, it'll
        free the decoder for us.

        This job does not do any actual decoding. It instead just posts a PAGE_DATA_BUFFER_NODE job
        which is where the actual decoding work will be done. However, once this job is complete,
        the node will be in a state where data buffer connectors can be initialized.
        */
        ma_decoder* pDecoder;   /* <-- Free'd on the last page decode. */
        ma_job pageDataBufferNodeJob;

        /* Allocate the decoder by initializing a decoded data supply. */
        result = ma_resource_manager_data_buffer_node_init_supply_decoded(pResourceManager, pDataBufferNode, pJob->data.resourceManager.loadDataBufferNode.pFilePath, pJob->data.resourceManager.loadDataBufferNode.pFilePathW, pJob->data.resourceManager.loadDataBufferNode.flags, &pDecoder);

        /*
        Don't ever propagate an MA_BUSY result code or else the resource manager will think the
        node is just busy decoding rather than in an error state. This should never happen, but
        including this logic for safety just in case.
        */
        if (result == MA_BUSY) {
            result  = MA_ERROR;
        }

        if (result != MA_SUCCESS) {
            if (pJob->data.resourceManager.loadDataBufferNode.pFilePath != NULL) {
                ma_log_postf(ma_resource_manager_get_log(pResourceManager), MA_LOG_LEVEL_WARNING, "Failed to initialize data supply for \"%s\". %s.\n", pJob->data.resourceManager.loadDataBufferNode.pFilePath, ma_result_description(result));
            } else {
                #if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(_MSC_VER)
                    ma_log_postf(ma_resource_manager_get_log(pResourceManager), MA_LOG_LEVEL_WARNING, "Failed to initialize data supply for \"%ls\", %s.\n", pJob->data.resourceManager.loadDataBufferNode.pFilePathW, ma_result_description(result));
                #endif
            }

            goto done;
        }

        /*
        At this point the node's data supply is initialized and other threads can start initializing
        their data buffer connectors. However, no data will actually be available until we start to
        actually decode it. To do this, we need to post a paging job which is where the decoding
        work is done.

        Note that if an error occurred at an earlier point, this section will have been skipped.
        */
        pageDataBufferNodeJob = ma_job_init(MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_BUFFER_NODE);
        pageDataBufferNodeJob.order = ma_resource_manager_data_buffer_node_next_execution_order(pDataBufferNode);
        pageDataBufferNodeJob.data.resourceManager.pageDataBufferNode.pResourceManager  = pResourceManager;
        pageDataBufferNodeJob.data.resourceManager.pageDataBufferNode.pDataBufferNode   = pDataBufferNode;
        pageDataBufferNodeJob.data.resourceManager.pageDataBufferNode.pDecoder          = pDecoder;
        pageDataBufferNodeJob.data.resourceManager.pageDataBufferNode.pDoneNotification = pJob->data.resourceManager.loadDataBufferNode.pDoneNotification;
        pageDataBufferNodeJob.data.resourceManager.pageDataBufferNode.pDoneFence        = pJob->data.resourceManager.loadDataBufferNode.pDoneFence;

        /* The job has been set up so it can now be posted. */
        result = ma_resource_manager_post_job(pResourceManager, &pageDataBufferNodeJob);

        /*
        When we get here, we want to make sure the result code is set to MA_BUSY. The reason for
        this is that the result will be copied over to the node's internal result variable. In
        this case, since the decoding is still in-progress, we need to make sure the result code
        is set to MA_BUSY.
        */
        if (result != MA_SUCCESS) {
            ma_log_postf(ma_resource_manager_get_log(pResourceManager), MA_LOG_LEVEL_ERROR, "Failed to post MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_BUFFER_NODE job. %s\n", ma_result_description(result));
            ma_decoder_uninit(pDecoder);
            ma_free(pDecoder, &pResourceManager->config.allocationCallbacks);
        } else {
            result = MA_BUSY;
        }
    } else {
        /* No decoding. This is the simple case. We need only read the file content into memory and we're done. */
        result = ma_resource_manager_data_buffer_node_init_supply_encoded(pResourceManager, pDataBufferNode, pJob->data.resourceManager.loadDataBufferNode.pFilePath, pJob->data.resourceManager.loadDataBufferNode.pFilePathW);
    }


done:
    /* File paths are no longer needed. */
    ma_free(pJob->data.resourceManager.loadDataBufferNode.pFilePath,  &pResourceManager->config.allocationCallbacks);
    ma_free(pJob->data.resourceManager.loadDataBufferNode.pFilePathW, &pResourceManager->config.allocationCallbacks);

    /*
    We need to set the result to at the very end to ensure no other threads try reading the data before we've fully initialized the object. Other threads
    are going to be inspecting this variable to determine whether or not they're ready to read data. We can only change the result if it's set to MA_BUSY
    because otherwise we may be changing away from an error code which would be bad. An example is if the application creates a data buffer, but then
    immediately deletes it before we've got to this point. In this case, pDataBuffer->result will be MA_UNAVAILABLE, and setting it to MA_SUCCESS or any
    other error code would cause the buffer to look like it's in a state that it's not.
    */
    ma_atomic_compare_and_swap_i32(&pDataBufferNode->result, MA_BUSY, result);

    /* At this point initialization is complete and we can signal the notification if any. */
    if (pJob->data.resourceManager.loadDataBufferNode.pInitNotification != NULL) {
        ma_async_notification_signal(pJob->data.resourceManager.loadDataBufferNode.pInitNotification);
    }
    if (pJob->data.resourceManager.loadDataBufferNode.pInitFence != NULL) {
        ma_fence_release(pJob->data.resourceManager.loadDataBufferNode.pInitFence);
    }

    /* If we have a success result it means we've fully loaded the buffer. This will happen in the non-decoding case. */
    if (result != MA_BUSY) {
        if (pJob->data.resourceManager.loadDataBufferNode.pDoneNotification != NULL) {
            ma_async_notification_signal(pJob->data.resourceManager.loadDataBufferNode.pDoneNotification);
        }
        if (pJob->data.resourceManager.loadDataBufferNode.pDoneFence != NULL) {
            ma_fence_release(pJob->data.resourceManager.loadDataBufferNode.pDoneFence);
        }
    }

    /* Increment the node's execution pointer so that the next jobs can be processed. This is how we keep decoding of pages in-order. */
    ma_atomic_fetch_add_32(&pDataBufferNode->executionPointer, 1);

    /* A busy result should be considered successful from the point of view of the job system. */
    if (result == MA_BUSY) {
        result  = MA_SUCCESS;
    }

    return result;
}

static ma_result ma_job_process__resource_manager__free_data_buffer_node(ma_job* pJob)
{
    ma_resource_manager* pResourceManager;
    ma_resource_manager_data_buffer_node* pDataBufferNode;

    MA_ASSERT(pJob != NULL);

    pResourceManager = (ma_resource_manager*)pJob->data.resourceManager.freeDataBufferNode.pResourceManager;
    MA_ASSERT(pResourceManager != NULL);

    pDataBufferNode = (ma_resource_manager_data_buffer_node*)pJob->data.resourceManager.freeDataBufferNode.pDataBufferNode;
    MA_ASSERT(pDataBufferNode != NULL);

    if (pJob->order != ma_atomic_load_32(&pDataBufferNode->executionPointer)) {
        return ma_resource_manager_post_job(pResourceManager, pJob);    /* Out of order. */
    }

    ma_resource_manager_data_buffer_node_free(pResourceManager, pDataBufferNode);

    /* The event needs to be signalled last. */
    if (pJob->data.resourceManager.freeDataBufferNode.pDoneNotification != NULL) {
        ma_async_notification_signal(pJob->data.resourceManager.freeDataBufferNode.pDoneNotification);
    }

    if (pJob->data.resourceManager.freeDataBufferNode.pDoneFence != NULL) {
        ma_fence_release(pJob->data.resourceManager.freeDataBufferNode.pDoneFence);
    }

    ma_atomic_fetch_add_32(&pDataBufferNode->executionPointer, 1);
    return MA_SUCCESS;
}

static ma_result ma_job_process__resource_manager__page_data_buffer_node(ma_job* pJob)
{
    ma_result result = MA_SUCCESS;
    ma_resource_manager* pResourceManager;
    ma_resource_manager_data_buffer_node* pDataBufferNode;

    MA_ASSERT(pJob != NULL);

    pResourceManager = (ma_resource_manager*)pJob->data.resourceManager.pageDataBufferNode.pResourceManager;
    MA_ASSERT(pResourceManager != NULL);

    pDataBufferNode = (ma_resource_manager_data_buffer_node*)pJob->data.resourceManager.pageDataBufferNode.pDataBufferNode;
    MA_ASSERT(pDataBufferNode != NULL);

    if (pJob->order != ma_atomic_load_32(&pDataBufferNode->executionPointer)) {
        return ma_resource_manager_post_job(pResourceManager, pJob);    /* Out of order. */
    }

    /* Don't do any more decoding if the data buffer has started the uninitialization process. */
    result = ma_resource_manager_data_buffer_node_result(pDataBufferNode);
    if (result != MA_BUSY) {
        goto done;
    }

    /* We're ready to decode the next page. */
    result = ma_resource_manager_data_buffer_node_decode_next_page(pResourceManager, pDataBufferNode, (ma_decoder*)pJob->data.resourceManager.pageDataBufferNode.pDecoder);

    /*
    If we have a success code by this point, we want to post another job. We're going to set the
    result back to MA_BUSY to make it clear that there's still more to load.
    */
    if (result == MA_SUCCESS) {
        ma_job newJob;
        newJob = *pJob; /* Everything is the same as the input job, except the execution order. */
        newJob.order = ma_resource_manager_data_buffer_node_next_execution_order(pDataBufferNode);   /* We need a fresh execution order. */

        result = ma_resource_manager_post_job(pResourceManager, &newJob);

        /* Since the sound isn't yet fully decoded we want the status to be set to busy. */
        if (result == MA_SUCCESS) {
            result  = MA_BUSY;
        }
    }

done:
    /* If there's still more to decode the result will be set to MA_BUSY. Otherwise we can free the decoder. */
    if (result != MA_BUSY) {
        ma_decoder_uninit((ma_decoder*)pJob->data.resourceManager.pageDataBufferNode.pDecoder);
        ma_free(pJob->data.resourceManager.pageDataBufferNode.pDecoder, &pResourceManager->config.allocationCallbacks);
    }

    /* If we reached the end we need to treat it as successful. */
    if (result == MA_AT_END) {
        result  = MA_SUCCESS;
    }

    /* Make sure we set the result of node in case some error occurred. */
    ma_atomic_compare_and_swap_i32(&pDataBufferNode->result, MA_BUSY, result);

    /* Signal the notification after setting the result in case the notification callback wants to inspect the result code. */
    if (result != MA_BUSY) {
        if (pJob->data.resourceManager.pageDataBufferNode.pDoneNotification != NULL) {
            ma_async_notification_signal(pJob->data.resourceManager.pageDataBufferNode.pDoneNotification);
        }

        if (pJob->data.resourceManager.pageDataBufferNode.pDoneFence != NULL) {
            ma_fence_release(pJob->data.resourceManager.pageDataBufferNode.pDoneFence);
        }
    }

    ma_atomic_fetch_add_32(&pDataBufferNode->executionPointer, 1);
    return result;
}


static ma_result ma_job_process__resource_manager__load_data_buffer(ma_job* pJob)
{
    ma_result result = MA_SUCCESS;
    ma_resource_manager* pResourceManager;
    ma_resource_manager_data_buffer* pDataBuffer;
    ma_resource_manager_data_supply_type dataSupplyType = ma_resource_manager_data_supply_type_unknown;
    ma_bool32 isConnectorInitialized = MA_FALSE;

    /*
    All we're doing here is checking if the node has finished loading. If not, we just re-post the job
    and keep waiting. Otherwise we increment the execution counter and set the buffer's result code.
    */
    MA_ASSERT(pJob != NULL);

    pDataBuffer = (ma_resource_manager_data_buffer*)pJob->data.resourceManager.loadDataBuffer.pDataBuffer;
    MA_ASSERT(pDataBuffer != NULL);

    pResourceManager = pDataBuffer->pResourceManager;

    if (pJob->order != ma_atomic_load_32(&pDataBuffer->executionPointer)) {
        return ma_resource_manager_post_job(pResourceManager, pJob);    /* Attempting to execute out of order. Probably interleaved with a MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_BUFFER job. */
    }

    /*
    First thing we need to do is check whether or not the data buffer is getting deleted. If so we
    just abort, but making sure we increment the execution pointer.
    */
    result = ma_resource_manager_data_buffer_result(pDataBuffer);
    if (result != MA_BUSY) {
        goto done;  /* <-- This will ensure the execution pointer is incremented. */
    } else {
        result = MA_SUCCESS;    /* <-- Make sure this is reset. */
        (void)result;           /* <-- This is to suppress a static analysis diagnostic about "result" not being used. But for safety when I do future maintenance I don't want to delete that assignment. */
    }

    /* Try initializing the connector if we haven't already. */
    isConnectorInitialized = ma_resource_manager_data_buffer_has_connector(pDataBuffer);
    if (isConnectorInitialized == MA_FALSE) {
        dataSupplyType = ma_resource_manager_data_buffer_node_get_data_supply_type(pDataBuffer->pNode);

        if (dataSupplyType != ma_resource_manager_data_supply_type_unknown) {
            /* We can now initialize the connector. If this fails, we need to abort. It's very rare for this to fail. */
            ma_resource_manager_data_source_config dataSourceConfig;    /* For setting initial looping state and range. */
            dataSourceConfig = ma_resource_manager_data_source_config_init();
            dataSourceConfig.rangeBegInPCMFrames     = pJob->data.resourceManager.loadDataBuffer.rangeBegInPCMFrames;
            dataSourceConfig.rangeEndInPCMFrames     = pJob->data.resourceManager.loadDataBuffer.rangeEndInPCMFrames;
            dataSourceConfig.loopPointBegInPCMFrames = pJob->data.resourceManager.loadDataBuffer.loopPointBegInPCMFrames;
            dataSourceConfig.loopPointEndInPCMFrames = pJob->data.resourceManager.loadDataBuffer.loopPointEndInPCMFrames;
            dataSourceConfig.isLooping               = pJob->data.resourceManager.loadDataBuffer.isLooping;

            result = ma_resource_manager_data_buffer_init_connector(pDataBuffer, &dataSourceConfig, pJob->data.resourceManager.loadDataBuffer.pInitNotification, pJob->data.resourceManager.loadDataBuffer.pInitFence);
            if (result != MA_SUCCESS) {
                ma_log_postf(ma_resource_manager_get_log(pResourceManager), MA_LOG_LEVEL_ERROR, "Failed to initialize connector for data buffer. %s.\n", ma_result_description(result));
                goto done;
            }
        } else {
            /* Don't have a known data supply type. Most likely the data buffer node is still loading, but it could be that an error occurred. */
        }
    } else {
        /* The connector is already initialized. Nothing to do here. */
    }

    /*
    If the data node is still loading, we need to repost the job and *not* increment the execution
    pointer (i.e. we need to not fall through to the "done" label).

    There is a hole between here and the where the data connector is initialized where the data
    buffer node may have finished initializing. We need to check for this by checking the result of
    the data buffer node and whether or not we had an unknown data supply type at the time of
    trying to initialize the data connector.
    */
    result = ma_resource_manager_data_buffer_node_result(pDataBuffer->pNode);
    if (result == MA_BUSY || (result == MA_SUCCESS && isConnectorInitialized == MA_FALSE && dataSupplyType == ma_resource_manager_data_supply_type_unknown)) {
        return ma_resource_manager_post_job(pResourceManager, pJob);
    }

done:
    /* Only move away from a busy code so that we don't trash any existing error codes. */
    ma_atomic_compare_and_swap_i32(&pDataBuffer->result, MA_BUSY, result);

    /* Only signal the other threads after the result has been set just for cleanliness sake. */
    if (pJob->data.resourceManager.loadDataBuffer.pDoneNotification != NULL) {
        ma_async_notification_signal(pJob->data.resourceManager.loadDataBuffer.pDoneNotification);
    }
    if (pJob->data.resourceManager.loadDataBuffer.pDoneFence != NULL) {
        ma_fence_release(pJob->data.resourceManager.loadDataBuffer.pDoneFence);
    }

    /*
    If at this point the data buffer has not had it's connector initialized, it means the
    notification event was never signalled which means we need to signal it here.
    */
    if (ma_resource_manager_data_buffer_has_connector(pDataBuffer) == MA_FALSE && result != MA_SUCCESS) {
        if (pJob->data.resourceManager.loadDataBuffer.pInitNotification != NULL) {
            ma_async_notification_signal(pJob->data.resourceManager.loadDataBuffer.pInitNotification);
        }
        if (pJob->data.resourceManager.loadDataBuffer.pInitFence != NULL) {
            ma_fence_release(pJob->data.resourceManager.loadDataBuffer.pInitFence);
        }
    }

    ma_atomic_fetch_add_32(&pDataBuffer->executionPointer, 1);
    return result;
}

static ma_result ma_job_process__resource_manager__free_data_buffer(ma_job* pJob)
{
    ma_resource_manager* pResourceManager;
    ma_resource_manager_data_buffer* pDataBuffer;

    MA_ASSERT(pJob != NULL);

    pDataBuffer = (ma_resource_manager_data_buffer*)pJob->data.resourceManager.freeDataBuffer.pDataBuffer;
    MA_ASSERT(pDataBuffer != NULL);

    pResourceManager = pDataBuffer->pResourceManager;

    if (pJob->order != ma_atomic_load_32(&pDataBuffer->executionPointer)) {
        return ma_resource_manager_post_job(pResourceManager, pJob);    /* Out of order. */
    }

    ma_resource_manager_data_buffer_uninit_internal(pDataBuffer);

    /* The event needs to be signalled last. */
    if (pJob->data.resourceManager.freeDataBuffer.pDoneNotification != NULL) {
        ma_async_notification_signal(pJob->data.resourceManager.freeDataBuffer.pDoneNotification);
    }

    if (pJob->data.resourceManager.freeDataBuffer.pDoneFence != NULL) {
        ma_fence_release(pJob->data.resourceManager.freeDataBuffer.pDoneFence);
    }

    ma_atomic_fetch_add_32(&pDataBuffer->executionPointer, 1);
    return MA_SUCCESS;
}

static ma_result ma_job_process__resource_manager__load_data_stream(ma_job* pJob)
{
    ma_result result = MA_SUCCESS;
    ma_decoder_config decoderConfig;
    ma_uint32 pageBufferSizeInBytes;
    ma_resource_manager* pResourceManager;
    ma_resource_manager_data_stream* pDataStream;

    MA_ASSERT(pJob != NULL);

    pDataStream = (ma_resource_manager_data_stream*)pJob->data.resourceManager.loadDataStream.pDataStream;
    MA_ASSERT(pDataStream != NULL);

    pResourceManager = pDataStream->pResourceManager;

    if (pJob->order != ma_atomic_load_32(&pDataStream->executionPointer)) {
        return ma_resource_manager_post_job(pResourceManager, pJob);    /* Out of order. */
    }

    if (ma_resource_manager_data_stream_result(pDataStream) != MA_BUSY) {
        result = MA_INVALID_OPERATION;  /* Most likely the data stream is being uninitialized. */
        goto done;
    }

    /* We need to initialize the decoder first so we can determine the size of the pages. */
    decoderConfig = ma_resource_manager__init_decoder_config(pResourceManager);

    if (pJob->data.resourceManager.loadDataStream.pFilePath != NULL) {
        result = ma_decoder_init_vfs(pResourceManager->config.pVFS, pJob->data.resourceManager.loadDataStream.pFilePath, &decoderConfig, &pDataStream->decoder);
    } else {
        result = ma_decoder_init_vfs_w(pResourceManager->config.pVFS, pJob->data.resourceManager.loadDataStream.pFilePathW, &decoderConfig, &pDataStream->decoder);
    }
    if (result != MA_SUCCESS) {
        goto done;
    }

    /* Retrieve the total length of the file before marking the decoder as loaded. */
    if ((pDataStream->flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_UNKNOWN_LENGTH) == 0) {
        result = ma_decoder_get_length_in_pcm_frames(&pDataStream->decoder, &pDataStream->totalLengthInPCMFrames);
        if (result != MA_SUCCESS) {
            goto done;  /* Failed to retrieve the length. */
        }
    } else {
        pDataStream->totalLengthInPCMFrames = 0;
    }

    /*
    Only mark the decoder as initialized when the length of the decoder has been retrieved because that can possibly require a scan over the whole file
    and we don't want to have another thread trying to access the decoder while it's scanning.
    */
    pDataStream->isDecoderInitialized = MA_TRUE;

    /* We have the decoder so we can now initialize our page buffer. */
    pageBufferSizeInBytes = ma_resource_manager_data_stream_get_page_size_in_frames(pDataStream) * 2 * ma_get_bytes_per_frame(pDataStream->decoder.outputFormat, pDataStream->decoder.outputChannels);

    pDataStream->pPageData = ma_malloc(pageBufferSizeInBytes, &pResourceManager->config.allocationCallbacks);
    if (pDataStream->pPageData == NULL) {
        ma_decoder_uninit(&pDataStream->decoder);
        result = MA_OUT_OF_MEMORY;
        goto done;
    }

    /* Seek to our initial seek point before filling the initial pages. */
    ma_decoder_seek_to_pcm_frame(&pDataStream->decoder, pJob->data.resourceManager.loadDataStream.initialSeekPoint);

    /* We have our decoder and our page buffer, so now we need to fill our pages. */
    ma_resource_manager_data_stream_fill_pages(pDataStream);

    /* And now we're done. We want to make sure the result is MA_SUCCESS. */
    result = MA_SUCCESS;

done:
    ma_free(pJob->data.resourceManager.loadDataStream.pFilePath,  &pResourceManager->config.allocationCallbacks);
    ma_free(pJob->data.resourceManager.loadDataStream.pFilePathW, &pResourceManager->config.allocationCallbacks);

    /* We can only change the status away from MA_BUSY. If it's set to anything else it means an error has occurred somewhere or the uninitialization process has started (most likely). */
    ma_atomic_compare_and_swap_i32(&pDataStream->result, MA_BUSY, result);

    /* Only signal the other threads after the result has been set just for cleanliness sake. */
    if (pJob->data.resourceManager.loadDataStream.pInitNotification != NULL) {
        ma_async_notification_signal(pJob->data.resourceManager.loadDataStream.pInitNotification);
    }
    if (pJob->data.resourceManager.loadDataStream.pInitFence != NULL) {
        ma_fence_release(pJob->data.resourceManager.loadDataStream.pInitFence);
    }

    ma_atomic_fetch_add_32(&pDataStream->executionPointer, 1);
    return result;
}

static ma_result ma_job_process__resource_manager__free_data_stream(ma_job* pJob)
{
    ma_resource_manager* pResourceManager;
    ma_resource_manager_data_stream* pDataStream;

    MA_ASSERT(pJob != NULL);

    pDataStream = (ma_resource_manager_data_stream*)pJob->data.resourceManager.freeDataStream.pDataStream;
    MA_ASSERT(pDataStream != NULL);

    pResourceManager = pDataStream->pResourceManager;

    if (pJob->order != ma_atomic_load_32(&pDataStream->executionPointer)) {
        return ma_resource_manager_post_job(pResourceManager, pJob);    /* Out of order. */
    }

    /* If our status is not MA_UNAVAILABLE we have a bug somewhere. */
    MA_ASSERT(ma_resource_manager_data_stream_result(pDataStream) == MA_UNAVAILABLE);

    if (pDataStream->isDecoderInitialized) {
        ma_decoder_uninit(&pDataStream->decoder);
    }

    if (pDataStream->pPageData != NULL) {
        ma_free(pDataStream->pPageData, &pResourceManager->config.allocationCallbacks);
        pDataStream->pPageData = NULL;  /* Just in case... */
    }

    ma_data_source_uninit(&pDataStream->ds);

    /* The event needs to be signalled last. */
    if (pJob->data.resourceManager.freeDataStream.pDoneNotification != NULL) {
        ma_async_notification_signal(pJob->data.resourceManager.freeDataStream.pDoneNotification);
    }
    if (pJob->data.resourceManager.freeDataStream.pDoneFence != NULL) {
        ma_fence_release(pJob->data.resourceManager.freeDataStream.pDoneFence);
    }

    /*ma_atomic_fetch_add_32(&pDataStream->executionPointer, 1);*/
    return MA_SUCCESS;
}

static ma_result ma_job_process__resource_manager__page_data_stream(ma_job* pJob)
{
    ma_result result = MA_SUCCESS;
    ma_resource_manager* pResourceManager;
    ma_resource_manager_data_stream* pDataStream;

    MA_ASSERT(pJob != NULL);

    pDataStream = (ma_resource_manager_data_stream*)pJob->data.resourceManager.pageDataStream.pDataStream;
    MA_ASSERT(pDataStream != NULL);

    pResourceManager = pDataStream->pResourceManager;

    if (pJob->order != ma_atomic_load_32(&pDataStream->executionPointer)) {
        return ma_resource_manager_post_job(pResourceManager, pJob);    /* Out of order. */
    }

    /* For streams, the status should be MA_SUCCESS. */
    if (ma_resource_manager_data_stream_result(pDataStream) != MA_SUCCESS) {
        result = MA_INVALID_OPERATION;
        goto done;
    }

    ma_resource_manager_data_stream_fill_page(pDataStream, pJob->data.resourceManager.pageDataStream.pageIndex);

done:
    ma_atomic_fetch_add_32(&pDataStream->executionPointer, 1);
    return result;
}

static ma_result ma_job_process__resource_manager__seek_data_stream(ma_job* pJob)
{
    ma_result result = MA_SUCCESS;
    ma_resource_manager* pResourceManager;
    ma_resource_manager_data_stream* pDataStream;

    MA_ASSERT(pJob != NULL);

    pDataStream = (ma_resource_manager_data_stream*)pJob->data.resourceManager.seekDataStream.pDataStream;
    MA_ASSERT(pDataStream != NULL);

    pResourceManager = pDataStream->pResourceManager;

    if (pJob->order != ma_atomic_load_32(&pDataStream->executionPointer)) {
        return ma_resource_manager_post_job(pResourceManager, pJob);    /* Out of order. */
    }

    /* For streams the status should be MA_SUCCESS for this to do anything. */
    if (ma_resource_manager_data_stream_result(pDataStream) != MA_SUCCESS || pDataStream->isDecoderInitialized == MA_FALSE) {
        result = MA_INVALID_OPERATION;
        goto done;
    }

    /*
    With seeking we just assume both pages are invalid and the relative frame cursor at position 0. This is basically exactly the same as loading, except
    instead of initializing the decoder, we seek to a frame.
    */
    ma_decoder_seek_to_pcm_frame(&pDataStream->decoder, pJob->data.resourceManager.seekDataStream.frameIndex);

    /* After seeking we'll need to reload the pages. */
    ma_resource_manager_data_stream_fill_pages(pDataStream);

    /* We need to let the public API know that we're done seeking. */
    ma_atomic_fetch_sub_32(&pDataStream->seekCounter, 1);

done:
    ma_atomic_fetch_add_32(&pDataStream->executionPointer, 1);
    return result;
}

MA_API ma_result ma_resource_manager_process_job(ma_resource_manager* pResourceManager, ma_job* pJob)
{
    if (pResourceManager == NULL || pJob == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_job_process(pJob);
}

MA_API ma_result ma_resource_manager_process_next_job(ma_resource_manager* pResourceManager)
{
    ma_result result;
    ma_job job;

    if (pResourceManager == NULL) {
        return MA_INVALID_ARGS;
    }

    /* This will return MA_CANCELLED if the next job is a quit job. */
    result = ma_resource_manager_next_job(pResourceManager, &job);
    if (result != MA_SUCCESS) {
        return result;
    }

    return ma_job_process(&job);
}
#else
/* We'll get here if the resource manager is being excluded from the build. We need to define the job processing callbacks as no-ops. */
static ma_result ma_job_process__resource_manager__load_data_buffer_node(ma_job* pJob) { return ma_job_process__noop(pJob); }
static ma_result ma_job_process__resource_manager__free_data_buffer_node(ma_job* pJob) { return ma_job_process__noop(pJob); }
static ma_result ma_job_process__resource_manager__page_data_buffer_node(ma_job* pJob) { return ma_job_process__noop(pJob); }
static ma_result ma_job_process__resource_manager__load_data_buffer(ma_job* pJob)      { return ma_job_process__noop(pJob); }
static ma_result ma_job_process__resource_manager__free_data_buffer(ma_job* pJob)      { return ma_job_process__noop(pJob); }
static ma_result ma_job_process__resource_manager__load_data_stream(ma_job* pJob)      { return ma_job_process__noop(pJob); }
static ma_result ma_job_process__resource_manager__free_data_stream(ma_job* pJob)      { return ma_job_process__noop(pJob); }
static ma_result ma_job_process__resource_manager__page_data_stream(ma_job* pJob)      { return ma_job_process__noop(pJob); }
static ma_result ma_job_process__resource_manager__seek_data_stream(ma_job* pJob)      { return ma_job_process__noop(pJob); }
#endif  /* MA_NO_RESOURCE_MANAGER */


#ifndef MA_NO_NODE_GRAPH

static ma_stack* ma_stack_init(size_t sizeInBytes, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_stack* pStack;

    if (sizeInBytes == 0) {
        return NULL;
    }

    pStack = (ma_stack*)ma_malloc(sizeof(*pStack) - sizeof(pStack->_data) + sizeInBytes, pAllocationCallbacks);
    if (pStack == NULL) {
        return NULL;
    }

    pStack->offset = 0;
    pStack->sizeInBytes = sizeInBytes;

    return pStack;
}

static void ma_stack_uninit(ma_stack* pStack, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pStack == NULL) {
        return;
    }

    ma_free(pStack, pAllocationCallbacks);
}

static void* ma_stack_alloc(ma_stack* pStack, size_t sz)
{
    /* The size of the allocation is stored in the memory directly before the pointer. This needs to include padding to keep it aligned to ma_uintptr */
    void* p = (void*)((char*)pStack->_data + pStack->offset);
    size_t* pSize = (size_t*)p;

    sz = (sz + (sizeof(ma_uintptr) - 1)) & ~(sizeof(ma_uintptr) - 1);  /* Padding. */
    if (pStack->offset + sz + sizeof(size_t) > pStack->sizeInBytes) {
        return NULL;    /* Out of memory. */
    }

    pStack->offset += sz + sizeof(size_t);

    *pSize = sz;
    return (void*)((char*)p + sizeof(size_t));
}

static void ma_stack_free(ma_stack* pStack, void* p)
{
    size_t* pSize;

    if (p == NULL) {
        return;
    }

    pSize = (size_t*)p - 1;
    pStack->offset -= *pSize + sizeof(size_t);
}



/* 10ms @ 48K = 480. Must never exceed 65535. */
#ifndef MA_DEFAULT_NODE_CACHE_CAP_IN_FRAMES_PER_BUS
#define MA_DEFAULT_NODE_CACHE_CAP_IN_FRAMES_PER_BUS 480
#endif

#ifndef MA_DEFAULT_PREMIX_STACK_SIZE_PER_CHANNEL
#define MA_DEFAULT_PREMIX_STACK_SIZE_PER_CHANNEL    524288
#endif

static ma_result ma_node_read_pcm_frames(ma_node* pNode, ma_uint32 outputBusIndex, float* pFramesOut, ma_uint32 frameCount, ma_uint32* pFramesRead, ma_uint64 globalTime);

MA_API void ma_debug_fill_pcm_frames_with_sine_wave(float* pFramesOut, ma_uint32 frameCount, ma_format format, ma_uint32 channels, ma_uint32 sampleRate)
{
    {
        (void)pFramesOut;
        (void)frameCount;
        (void)format;
        (void)channels;
        (void)sampleRate;
        #if defined(MA_DEBUG_OUTPUT)
        {
            #if _MSC_VER
                #pragma message ("ma_debug_fill_pcm_frames_with_sine_wave() will do nothing because MA_NO_GENERATION is enabled.")
            #endif
        }
        #endif
    }
}



MA_API ma_node_graph_config ma_node_graph_config_init(ma_uint32 channels)
{
    ma_node_graph_config config;

    MA_ZERO_OBJECT(&config);
    config.channels               = channels;
    config.processingSizeInFrames = 0;

    return config;
}


static void ma_node_graph_set_is_reading(ma_node_graph* pNodeGraph, ma_bool32 isReading)
{
    MA_ASSERT(pNodeGraph != NULL);
    ma_atomic_exchange_32(&pNodeGraph->isReading, isReading);
}

#if 0
static ma_bool32 ma_node_graph_is_reading(ma_node_graph* pNodeGraph)
{
    MA_ASSERT(pNodeGraph != NULL);
    return ma_atomic_load_32(&pNodeGraph->isReading);
}
#endif


static void ma_node_graph_node_process_pcm_frames(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    ma_node_graph* pNodeGraph = (ma_node_graph*)pNode;
    ma_uint64 framesRead;

    ma_node_graph_read_pcm_frames(pNodeGraph, ppFramesOut[0], *pFrameCountOut, &framesRead);

    *pFrameCountOut = (ma_uint32)framesRead;    /* Safe cast. */

    (void)ppFramesIn;
    (void)pFrameCountIn;
}

static ma_node_vtable g_node_graph_node_vtable =
{
    ma_node_graph_node_process_pcm_frames,
    NULL,   /* onGetRequiredInputFrameCount */
    0,      /* 0 input buses. */
    1,      /* 1 output bus. */
    0       /* Flags. */
};

static void ma_node_graph_endpoint_process_pcm_frames(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    MA_ASSERT(pNode != NULL);
    MA_ASSERT(ma_node_get_input_bus_count(pNode)  == 1);
    MA_ASSERT(ma_node_get_output_bus_count(pNode) == 1);

    /* Input channel count needs to be the same as the output channel count. */
    MA_ASSERT(ma_node_get_input_channels(pNode, 0) == ma_node_get_output_channels(pNode, 0));

    /* We don't need to do anything here because it's a passthrough. */
    (void)pNode;
    (void)ppFramesIn;
    (void)pFrameCountIn;
    (void)ppFramesOut;
    (void)pFrameCountOut;

#if 0
    /* The data has already been mixed. We just need to move it to the output buffer. */
    if (ppFramesIn != NULL) {
        ma_copy_pcm_frames(ppFramesOut[0], ppFramesIn[0], *pFrameCountOut, ma_format_f32, ma_node_get_output_channels(pNode, 0));
    }
#endif
}

static ma_node_vtable g_node_graph_endpoint_vtable =
{
    ma_node_graph_endpoint_process_pcm_frames,
    NULL,   /* onGetRequiredInputFrameCount */
    1,      /* 1 input bus. */
    1,      /* 1 output bus. */
    MA_NODE_FLAG_PASSTHROUGH    /* Flags. The endpoint is a passthrough. */
};

MA_API ma_result ma_node_graph_init(const ma_node_graph_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_node_graph* pNodeGraph)
{
    ma_result result;
    ma_node_config baseConfig;
    ma_node_config endpointConfig;

    if (pNodeGraph == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pNodeGraph);
    pNodeGraph->processingSizeInFrames = pConfig->processingSizeInFrames;

    /* Base node so we can use the node graph as a node into another graph. */
    baseConfig = ma_node_config_init();
    baseConfig.vtable = &g_node_graph_node_vtable;
    baseConfig.pOutputChannels = &pConfig->channels;

    result = ma_node_init(pNodeGraph, &baseConfig, pAllocationCallbacks, &pNodeGraph->base);
    if (result != MA_SUCCESS) {
        return result;
    }


    /* Endpoint. */
    endpointConfig = ma_node_config_init();
    endpointConfig.vtable          = &g_node_graph_endpoint_vtable;
    endpointConfig.pInputChannels  = &pConfig->channels;
    endpointConfig.pOutputChannels = &pConfig->channels;

    result = ma_node_init(pNodeGraph, &endpointConfig, pAllocationCallbacks, &pNodeGraph->endpoint);
    if (result != MA_SUCCESS) {
        ma_node_uninit(&pNodeGraph->base, pAllocationCallbacks);
        return result;
    }


    /* Processing cache. */
    if (pConfig->processingSizeInFrames > 0) {
        pNodeGraph->pProcessingCache = (float*)ma_malloc(pConfig->processingSizeInFrames * pConfig->channels * sizeof(float), pAllocationCallbacks);
        if (pNodeGraph->pProcessingCache == NULL) {
            ma_node_uninit(&pNodeGraph->endpoint, pAllocationCallbacks);
            ma_node_uninit(&pNodeGraph->base, pAllocationCallbacks);
            return MA_OUT_OF_MEMORY;
        }
    }


    /*
    We need a pre-mix stack. The size of this stack is configurable via the config. The default value depends on the channel count.
    */
    {
        size_t preMixStackSizeInBytes = pConfig->preMixStackSizeInBytes;
        if (preMixStackSizeInBytes == 0) {
            preMixStackSizeInBytes = pConfig->channels * MA_DEFAULT_PREMIX_STACK_SIZE_PER_CHANNEL;
        }

        pNodeGraph->pPreMixStack = ma_stack_init(preMixStackSizeInBytes, pAllocationCallbacks);
        if (pNodeGraph->pPreMixStack == NULL) {
            ma_node_uninit(&pNodeGraph->endpoint, pAllocationCallbacks);
            ma_node_uninit(&pNodeGraph->base, pAllocationCallbacks);
            if (pNodeGraph->pProcessingCache != NULL) {
                ma_free(pNodeGraph->pProcessingCache, pAllocationCallbacks);
            }

            return MA_OUT_OF_MEMORY;
        }
    }


    return MA_SUCCESS;
}

MA_API void ma_node_graph_uninit(ma_node_graph* pNodeGraph, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pNodeGraph == NULL) {
        return;
    }

    ma_node_uninit(&pNodeGraph->endpoint, pAllocationCallbacks);
    ma_node_uninit(&pNodeGraph->base, pAllocationCallbacks);

    if (pNodeGraph->pProcessingCache != NULL) {
        ma_free(pNodeGraph->pProcessingCache, pAllocationCallbacks);
        pNodeGraph->pProcessingCache = NULL;
    }

    if (pNodeGraph->pPreMixStack != NULL) {
        ma_stack_uninit(pNodeGraph->pPreMixStack, pAllocationCallbacks);
        pNodeGraph->pPreMixStack = NULL;
    }
}

MA_API ma_node* ma_node_graph_get_endpoint(ma_node_graph* pNodeGraph)
{
    if (pNodeGraph == NULL) {
        return NULL;
    }

    return &pNodeGraph->endpoint;
}

MA_API ma_result ma_node_graph_read_pcm_frames(ma_node_graph* pNodeGraph, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    ma_result result = MA_SUCCESS;
    ma_uint64 totalFramesRead;
    ma_uint32 channels;

    if (pFramesRead != NULL) {
        *pFramesRead = 0;   /* Safety. */
    }

    if (pNodeGraph == NULL) {
        return MA_INVALID_ARGS;
    }

    channels = ma_node_get_output_channels(&pNodeGraph->endpoint, 0);


    /* We'll be nice and try to do a full read of all frameCount frames. */
    totalFramesRead = 0;
    while (totalFramesRead < frameCount) {
        ma_uint32 framesJustRead;
        ma_uint64 framesToRead;
        float* pRunningFramesOut;

        framesToRead = frameCount - totalFramesRead;
        if (framesToRead > 0xFFFFFFFF) {
            framesToRead = 0xFFFFFFFF;
        }

        pRunningFramesOut = (float*)ma_offset_pcm_frames_ptr(pFramesOut, totalFramesRead, ma_format_f32, channels);

        /* If there's anything in the cache, consume that first. */
        if (pNodeGraph->processingCacheFramesRemaining > 0) {
            ma_uint32 framesToReadFromCache;

            framesToReadFromCache = (ma_uint32)framesToRead;
            if (framesToReadFromCache > pNodeGraph->processingCacheFramesRemaining) {
                framesToReadFromCache = pNodeGraph->processingCacheFramesRemaining;
            }

            MA_COPY_MEMORY(pRunningFramesOut, pNodeGraph->pProcessingCache, framesToReadFromCache * channels * sizeof(float));
            MA_MOVE_MEMORY(pNodeGraph->pProcessingCache, pNodeGraph->pProcessingCache + (framesToReadFromCache * channels), (pNodeGraph->processingCacheFramesRemaining - framesToReadFromCache) * channels * sizeof(float));
            pNodeGraph->processingCacheFramesRemaining -= framesToReadFromCache;

            totalFramesRead += framesToReadFromCache;
            continue;
        } else {
            /*
            If processingSizeInFrames is non-zero, we need to make sure we always read in chunks of that size. If the frame count is less than
            that, we need to read into the cache and then continue on.
            */
            float* pReadDst = pRunningFramesOut;

            if (pNodeGraph->processingSizeInFrames > 0) {
                if (framesToRead < pNodeGraph->processingSizeInFrames) {
                    pReadDst = pNodeGraph->pProcessingCache;    /* We need to read into the cache because otherwise we'll overflow the output buffer. */
                }

                framesToRead = pNodeGraph->processingSizeInFrames;
            }

            ma_node_graph_set_is_reading(pNodeGraph, MA_TRUE);
            {
                result = ma_node_read_pcm_frames(&pNodeGraph->endpoint, 0, pReadDst, (ma_uint32)framesToRead, &framesJustRead, ma_node_get_time(&pNodeGraph->endpoint));
            }
            ma_node_graph_set_is_reading(pNodeGraph, MA_FALSE);

            /*
            Do not increment the total frames read counter if we read into the cache. We use this to determine how many frames have
            been written to the final output buffer.
            */
            if (pReadDst == pNodeGraph->pProcessingCache) {
                /* We read into the cache. */
                pNodeGraph->processingCacheFramesRemaining = framesJustRead;
            } else {
                /* We read straight into the output buffer. */
                totalFramesRead += framesJustRead;
            }

            if (result != MA_SUCCESS) {
                break;
            }

            /* Abort if we weren't able to read any frames or else we risk getting stuck in a loop. */
            if (framesJustRead == 0) {
                break;
            }
        }
    }

    /* Let's go ahead and silence any leftover frames just for some added safety to ensure the caller doesn't try emitting garbage out of the speakers. */
    if (totalFramesRead < frameCount) {
        ma_silence_pcm_frames(ma_offset_pcm_frames_ptr(pFramesOut, totalFramesRead, ma_format_f32, channels), (frameCount - totalFramesRead), ma_format_f32, channels);
    }

    if (pFramesRead != NULL) {
        *pFramesRead = totalFramesRead;
    }

    return result;
}

MA_API ma_uint32 ma_node_graph_get_channels(const ma_node_graph* pNodeGraph)
{
    if (pNodeGraph == NULL) {
        return 0;
    }

    return ma_node_get_output_channels(&pNodeGraph->endpoint, 0);
}

MA_API ma_uint64 ma_node_graph_get_time(const ma_node_graph* pNodeGraph)
{
    if (pNodeGraph == NULL) {
        return 0;
    }

    return ma_node_get_time(&pNodeGraph->endpoint); /* Global time is just the local time of the endpoint. */
}

MA_API ma_result ma_node_graph_set_time(ma_node_graph* pNodeGraph, ma_uint64 globalTime)
{
    if (pNodeGraph == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_node_set_time(&pNodeGraph->endpoint, globalTime); /* Global time is just the local time of the endpoint. */
}


#define MA_NODE_OUTPUT_BUS_FLAG_HAS_READ    0x01    /* Whether or not this bus ready to read more data. Only used on nodes with multiple output buses. */

static ma_result ma_node_output_bus_init(ma_node* pNode, ma_uint32 outputBusIndex, ma_uint32 channels, ma_node_output_bus* pOutputBus)
{
    MA_ASSERT(pOutputBus != NULL);
    MA_ASSERT(outputBusIndex < MA_MAX_NODE_BUS_COUNT);
    MA_ASSERT(outputBusIndex < ma_node_get_output_bus_count(pNode));
    MA_ASSERT(channels < 256);

    MA_ZERO_OBJECT(pOutputBus);

    if (channels == 0) {
        return MA_INVALID_ARGS;
    }

    pOutputBus->pNode          = pNode;
    pOutputBus->outputBusIndex = (ma_uint8)outputBusIndex;
    pOutputBus->channels       = (ma_uint8)channels;
    pOutputBus->flags          = MA_NODE_OUTPUT_BUS_FLAG_HAS_READ; /* <-- Important that this flag is set by default. */
    pOutputBus->volume         = 1;

    return MA_SUCCESS;
}

static void ma_node_output_bus_lock(ma_node_output_bus* pOutputBus)
{
    ma_spinlock_lock(&pOutputBus->lock);
}

static void ma_node_output_bus_unlock(ma_node_output_bus* pOutputBus)
{
    ma_spinlock_unlock(&pOutputBus->lock);
}


static ma_uint32 ma_node_output_bus_get_channels(const ma_node_output_bus* pOutputBus)
{
    return pOutputBus->channels;
}


static void ma_node_output_bus_set_has_read(ma_node_output_bus* pOutputBus, ma_bool32 hasRead)
{
    if (hasRead) {
        ma_atomic_fetch_or_32(&pOutputBus->flags, MA_NODE_OUTPUT_BUS_FLAG_HAS_READ);
    } else {
        ma_atomic_fetch_and_32(&pOutputBus->flags, (ma_uint32)~MA_NODE_OUTPUT_BUS_FLAG_HAS_READ);
    }
}

static ma_bool32 ma_node_output_bus_has_read(ma_node_output_bus* pOutputBus)
{
    return (ma_atomic_load_32(&pOutputBus->flags) & MA_NODE_OUTPUT_BUS_FLAG_HAS_READ) != 0;
}


static void ma_node_output_bus_set_is_attached(ma_node_output_bus* pOutputBus, ma_bool32 isAttached)
{
    ma_atomic_exchange_32(&pOutputBus->isAttached, isAttached);
}

static ma_bool32 ma_node_output_bus_is_attached(ma_node_output_bus* pOutputBus)
{
    return ma_atomic_load_32(&pOutputBus->isAttached);
}


static ma_result ma_node_output_bus_set_volume(ma_node_output_bus* pOutputBus, float volume)
{
    MA_ASSERT(pOutputBus != NULL);

    if (volume < 0.0f) {
        volume = 0.0f;
    }

    ma_atomic_exchange_f32(&pOutputBus->volume, volume);

    return MA_SUCCESS;
}

static float ma_node_output_bus_get_volume(const ma_node_output_bus* pOutputBus)
{
    return ma_atomic_load_f32((float*)&pOutputBus->volume);
}


static ma_result ma_node_input_bus_init(ma_uint32 channels, ma_node_input_bus* pInputBus)
{
    MA_ASSERT(pInputBus != NULL);
    MA_ASSERT(channels < 256);

    MA_ZERO_OBJECT(pInputBus);

    if (channels == 0) {
        return MA_INVALID_ARGS;
    }

    pInputBus->channels = (ma_uint8)channels;

    return MA_SUCCESS;
}

static void ma_node_input_bus_lock(ma_node_input_bus* pInputBus)
{
    MA_ASSERT(pInputBus != NULL);

    ma_spinlock_lock(&pInputBus->lock);
}

static void ma_node_input_bus_unlock(ma_node_input_bus* pInputBus)
{
    MA_ASSERT(pInputBus != NULL);

    ma_spinlock_unlock(&pInputBus->lock);
}


static void ma_node_input_bus_next_begin(ma_node_input_bus* pInputBus)
{
    ma_atomic_fetch_add_32(&pInputBus->nextCounter, 1);
}

static void ma_node_input_bus_next_end(ma_node_input_bus* pInputBus)
{
    ma_atomic_fetch_sub_32(&pInputBus->nextCounter, 1);
}

static ma_uint32 ma_node_input_bus_get_next_counter(ma_node_input_bus* pInputBus)
{
    return ma_atomic_load_32(&pInputBus->nextCounter);
}


static ma_uint32 ma_node_input_bus_get_channels(const ma_node_input_bus* pInputBus)
{
    return pInputBus->channels;
}


static void ma_node_input_bus_detach__no_output_bus_lock(ma_node_input_bus* pInputBus, ma_node_output_bus* pOutputBus)
{
    MA_ASSERT(pInputBus  != NULL);
    MA_ASSERT(pOutputBus != NULL);

    /*
    Mark the output bus as detached first. This will prevent future iterations on the audio thread
    from iterating this output bus.
    */
    ma_node_output_bus_set_is_attached(pOutputBus, MA_FALSE);

    /*
    We cannot use the output bus lock here since it'll be getting used at a higher level, but we do
    still need to use the input bus lock since we'll be updating pointers on two different output
    buses. The same rules apply here as the attaching case. Although we're using a lock here, we're
    *not* using a lock when iterating over the list in the audio thread. We therefore need to craft
    this in a way such that the iteration on the audio thread doesn't break.

    The first thing to do is swap out the "next" pointer of the previous output bus with the
    new "next" output bus. This is the operation that matters for iteration on the audio thread.
    After that, the previous pointer on the new "next" pointer needs to be updated, after which
    point the linked list will be in a good state.
    */
    ma_node_input_bus_lock(pInputBus);
    {
        ma_node_output_bus* pOldPrev = (ma_node_output_bus*)ma_atomic_load_ptr(&pOutputBus->pPrev);
        ma_node_output_bus* pOldNext = (ma_node_output_bus*)ma_atomic_load_ptr(&pOutputBus->pNext);

        if (pOldPrev != NULL) {
            ma_atomic_exchange_ptr(&pOldPrev->pNext, pOldNext); /* <-- This is where the output bus is detached from the list. */
        }
        if (pOldNext != NULL) {
            ma_atomic_exchange_ptr(&pOldNext->pPrev, pOldPrev); /* <-- This is required for detachment. */
        }
    }
    ma_node_input_bus_unlock(pInputBus);

    /* At this point the output bus is detached and the linked list is completely unaware of it. Reset some data for safety. */
    ma_atomic_exchange_ptr(&pOutputBus->pNext, NULL);   /* Using atomic exchanges here, mainly for the benefit of analysis tools which don't always recognize spinlocks. */
    ma_atomic_exchange_ptr(&pOutputBus->pPrev, NULL);   /* As above. */
    pOutputBus->pInputNode             = NULL;
    pOutputBus->inputNodeInputBusIndex = 0;


    /*
    For thread-safety reasons, we don't want to be returning from this straight away. We need to
    wait for the audio thread to finish with the output bus. There's two things we need to wait
    for. The first is the part that selects the next output bus in the list, and the other is the
    part that reads from the output bus. Basically all we're doing is waiting for the input bus
    to stop referencing the output bus.

    We're doing this part last because we want the section above to run while the audio thread
    is finishing up with the output bus, just for efficiency reasons. We marked the output bus as
    detached right at the top of this function which is going to prevent the audio thread from
    iterating the output bus again.
    */

    /* Part 1: Wait for the current iteration to complete. */
    while (ma_node_input_bus_get_next_counter(pInputBus) > 0) {
        ma_yield();
    }

    /* Part 2: Wait for any reads to complete. */
    while (ma_atomic_load_32(&pOutputBus->refCount) > 0) {
        ma_yield();
    }

    /*
    At this point we're done detaching and we can be guaranteed that the audio thread is not going
    to attempt to reference this output bus again (until attached again).
    */
}

#if 0   /* Not used at the moment, but leaving here in case I need it later. */
static void ma_node_input_bus_detach(ma_node_input_bus* pInputBus, ma_node_output_bus* pOutputBus)
{
    MA_ASSERT(pInputBus  != NULL);
    MA_ASSERT(pOutputBus != NULL);

    ma_node_output_bus_lock(pOutputBus);
    {
        ma_node_input_bus_detach__no_output_bus_lock(pInputBus, pOutputBus);
    }
    ma_node_output_bus_unlock(pOutputBus);
}
#endif

static void ma_node_input_bus_attach(ma_node_input_bus* pInputBus, ma_node_output_bus* pOutputBus, ma_node* pNewInputNode, ma_uint32 inputNodeInputBusIndex)
{
    MA_ASSERT(pInputBus  != NULL);
    MA_ASSERT(pOutputBus != NULL);

    ma_node_output_bus_lock(pOutputBus);
    {
        ma_node_output_bus* pOldInputNode = (ma_node_output_bus*)ma_atomic_load_ptr(&pOutputBus->pInputNode);

        /* Detach from any existing attachment first if necessary. */
        if (pOldInputNode != NULL) {
            ma_node_input_bus_detach__no_output_bus_lock(pInputBus, pOutputBus);
        }

        /*
        At this point we can be sure the output bus is not attached to anything. The linked list in the
        old input bus has been updated so that pOutputBus will not get iterated again.
        */
        pOutputBus->pInputNode             = pNewInputNode;                     /* No need for an atomic assignment here because modification of this variable always happens within a lock. */
        pOutputBus->inputNodeInputBusIndex = (ma_uint8)inputNodeInputBusIndex;

        /*
        Now we need to attach the output bus to the linked list. This involves updating two pointers on
        two different output buses so I'm going to go ahead and keep this simple and just use a lock.
        There are ways to do this without a lock, but it's just too hard to maintain for its value.

        Although we're locking here, it's important to remember that we're *not* locking when iterating
        and reading audio data since that'll be running on the audio thread. As a result we need to be
        careful how we craft this so that we don't break iteration. What we're going to do is always
        attach the new item so that it becomes the first item in the list. That way, as we're iterating
        we won't break any links in the list and iteration will continue safely. The detaching case will
        also be crafted in a way as to not break list iteration. It's important to remember to use
        atomic exchanges here since no locking is happening on the audio thread during iteration.
        */
        ma_node_input_bus_lock(pInputBus);
        {
            ma_node_output_bus* pNewPrev = &pInputBus->head;
            ma_node_output_bus* pNewNext = (ma_node_output_bus*)ma_atomic_load_ptr(&pInputBus->head.pNext);

            /* Update the local output bus. */
            ma_atomic_exchange_ptr(&pOutputBus->pPrev, pNewPrev);
            ma_atomic_exchange_ptr(&pOutputBus->pNext, pNewNext);

            /* Update the other output buses to point back to the local output bus. */
            ma_atomic_exchange_ptr(&pInputBus->head.pNext, pOutputBus); /* <-- This is where the output bus is actually attached to the input bus. */

            /* Do the previous pointer last. This is only used for detachment. */
            if (pNewNext != NULL) {
                ma_atomic_exchange_ptr(&pNewNext->pPrev,  pOutputBus);
            }
        }
        ma_node_input_bus_unlock(pInputBus);

        /*
        Mark the node as attached last. This is used to controlling whether or the output bus will be
        iterated on the audio thread. Mainly required for detachment purposes.
        */
        ma_node_output_bus_set_is_attached(pOutputBus, MA_TRUE);
    }
    ma_node_output_bus_unlock(pOutputBus);
}

static ma_node_output_bus* ma_node_input_bus_next(ma_node_input_bus* pInputBus, ma_node_output_bus* pOutputBus)
{
    ma_node_output_bus* pNext;

    MA_ASSERT(pInputBus != NULL);

    if (pOutputBus == NULL) {
        return NULL;
    }

    ma_node_input_bus_next_begin(pInputBus);
    {
        pNext = pOutputBus;
        for (;;) {
            pNext = (ma_node_output_bus*)ma_atomic_load_ptr(&pNext->pNext);
            if (pNext == NULL) {
                break;      /* Reached the end. */
            }

            if (ma_node_output_bus_is_attached(pNext) == MA_FALSE) {
                continue;   /* The node is not attached. Keep checking. */
            }

            /* The next node has been selected. */
            break;
        }

        /* We need to increment the reference count of the selected node. */
        if (pNext != NULL) {
            ma_atomic_fetch_add_32(&pNext->refCount, 1);
        }

        /* The previous node is no longer being referenced. */
        ma_atomic_fetch_sub_32(&pOutputBus->refCount, 1);
    }
    ma_node_input_bus_next_end(pInputBus);

    return pNext;
}

static ma_node_output_bus* ma_node_input_bus_first(ma_node_input_bus* pInputBus)
{
    return ma_node_input_bus_next(pInputBus, &pInputBus->head);
}



static ma_result ma_node_input_bus_read_pcm_frames(ma_node* pInputNode, ma_node_input_bus* pInputBus, float* pFramesOut, ma_uint32 frameCount, ma_uint32* pFramesRead, ma_uint64 globalTime)
{
    ma_result result = MA_SUCCESS;
    ma_node_output_bus* pOutputBus;
    ma_node_output_bus* pFirst;
    ma_uint32 inputChannels;
    ma_bool32 doesOutputBufferHaveContent = MA_FALSE;

    /*
    This will be called from the audio thread which means we can't be doing any locking. Basically,
    this function will not perform any locking, whereas attaching and detaching will, but crafted in
    such a way that we don't need to perform any locking here. The important thing to remember is
    to always iterate in a forward direction.

    In order to process any data we need to first read from all input buses. That's where this
    function comes in. This iterates over each of the attachments and accumulates/mixes them. We
    also convert the channels to the nodes output channel count before mixing. We want to do this
    channel conversion so that the caller of this function can invoke the processing callback
    without having to do it themselves.

    When we iterate over each of the attachments on the input bus, we need to read as much data as
    we can from each of them so that we don't end up with holes between each of the attachments. To
    do this, we need to read from each attachment in a loop and read as many frames as we can, up
    to `frameCount`.
    */
    MA_ASSERT(pInputNode  != NULL);
    MA_ASSERT(pFramesRead != NULL); /* pFramesRead is critical and must always be specified. On input it's undefined and on output it'll be set to the number of frames actually read. */

    *pFramesRead = 0;   /* Safety. */

    inputChannels = ma_node_input_bus_get_channels(pInputBus);

    /*
    We need to be careful with how we call ma_node_input_bus_first() and ma_node_input_bus_next(). They
    are both critical to our lock-free thread-safety system. We can only call ma_node_input_bus_first()
    once per iteration, however we have an optimization to checks whether or not it's the first item in
    the list. We therefore need to store a pointer to the first item rather than repeatedly calling
    ma_node_input_bus_first(). It's safe to keep hold of this pointer, so long as we don't dereference it
    after calling ma_node_input_bus_next(), which we won't be.
    */
    pFirst = ma_node_input_bus_first(pInputBus);
    if (pFirst == NULL) {
        return MA_SUCCESS;  /* No attachments. Read nothing. */
    }

    for (pOutputBus = pFirst; pOutputBus != NULL; pOutputBus = ma_node_input_bus_next(pInputBus, pOutputBus)) {
        ma_uint32 framesProcessed = 0;
        ma_bool32 isSilentOutput = MA_FALSE;

        MA_ASSERT(pOutputBus->pNode != NULL);
        MA_ASSERT(((ma_node_base*)pOutputBus->pNode)->vtable != NULL);

        isSilentOutput = (((ma_node_base*)pOutputBus->pNode)->vtable->flags & MA_NODE_FLAG_SILENT_OUTPUT) != 0;

        if (pFramesOut != NULL) {
            /* Read. */
            while (framesProcessed < frameCount) {
                float* pRunningFramesOut;
                ma_uint32 framesToRead;
                ma_uint32 framesJustRead = 0;

                framesToRead = frameCount - framesProcessed;
                pRunningFramesOut = ma_offset_pcm_frames_ptr_f32(pFramesOut, framesProcessed, inputChannels);

                if (doesOutputBufferHaveContent == MA_FALSE) {
                    /* Fast path. First attachment. We just read straight into the output buffer (no mixing required). */
                    result = ma_node_read_pcm_frames(pOutputBus->pNode, pOutputBus->outputBusIndex, pRunningFramesOut, framesToRead, &framesJustRead, globalTime + framesProcessed);
                } else {
                    /* Slow path. Not the first attachment. Mixing required. */
                    ma_uint32 preMixBufferCapInFrames = ((ma_node_base*)pInputNode)->cachedDataCapInFramesPerBus;
                    float* pPreMixBuffer = (float*)ma_stack_alloc(((ma_node_base*)pInputNode)->pNodeGraph->pPreMixStack, preMixBufferCapInFrames * inputChannels * sizeof(float));

                    if (pPreMixBuffer == NULL) {
                        /*
                        If you're hitting this assert it means you've got an unusually deep chain of nodes, you've got an excessively large processing
                        size, or you have a combination of both, and as a result have run out of stack space. You can increase this using the
                        preMixStackSizeInBytes variable in ma_node_graph_config. If you're using ma_engine, you can do it via the preMixStackSizeInBytes
                        variable in ma_engine_config. It defaults to 512KB per output channel.
                        */
                        MA_ASSERT(MA_FALSE);
                    } else {
                        if (framesToRead > preMixBufferCapInFrames) {
                            framesToRead = preMixBufferCapInFrames;
                        }

                        result = ma_node_read_pcm_frames(pOutputBus->pNode, pOutputBus->outputBusIndex, pPreMixBuffer, framesToRead, &framesJustRead, globalTime + framesProcessed);
                        if (result == MA_SUCCESS || result == MA_AT_END) {
                            if (isSilentOutput == MA_FALSE) {   /* Don't mix if the node outputs silence. */
                                ma_mix_pcm_frames_f32(pRunningFramesOut, pPreMixBuffer, framesJustRead, inputChannels, /*volume*/1);
                            }
                        }

                        /* The pre-mix buffer is no longer required. */
                        ma_stack_free(((ma_node_base*)pInputNode)->pNodeGraph->pPreMixStack, pPreMixBuffer);
                        pPreMixBuffer = NULL;
                    }
                }

                framesProcessed += framesJustRead;

                /* If we reached the end or otherwise failed to read any data we need to finish up with this output node. */
                if (result != MA_SUCCESS) {
                    break;
                }

                /* If we didn't read anything, abort so we don't get stuck in a loop. */
                if (framesJustRead == 0) {
                    break;
                }
            }

            /* If it's the first attachment we didn't do any mixing. Any leftover samples need to be silenced. */
            if (pOutputBus == pFirst && framesProcessed < frameCount) {
                ma_silence_pcm_frames(ma_offset_pcm_frames_ptr(pFramesOut, framesProcessed, ma_format_f32, inputChannels), (frameCount - framesProcessed), ma_format_f32, inputChannels);
            }

            if (isSilentOutput == MA_FALSE) {
                doesOutputBufferHaveContent = MA_TRUE;
            }
        } else {
            /* Seek. */
            ma_node_read_pcm_frames(pOutputBus->pNode, pOutputBus->outputBusIndex, NULL, frameCount, &framesProcessed, globalTime);
        }
    }

    /* If we didn't output anything, output silence. */
    if (doesOutputBufferHaveContent == MA_FALSE && pFramesOut != NULL) {
        ma_silence_pcm_frames(pFramesOut, frameCount, ma_format_f32, inputChannels);
    }

    /* In this path we always "process" the entire amount. */
    *pFramesRead = frameCount;

    return result;
}


MA_API ma_node_config ma_node_config_init(void)
{
    ma_node_config config;

    MA_ZERO_OBJECT(&config);
    config.initialState   = ma_node_state_started;    /* Nodes are started by default. */
    config.inputBusCount  = MA_NODE_BUS_COUNT_UNKNOWN;
    config.outputBusCount = MA_NODE_BUS_COUNT_UNKNOWN;

    return config;
}

static ma_uint16 ma_node_config_get_cache_size_in_frames(const ma_node_config* pConfig, const ma_node_graph* pNodeGraph)
{
    ma_uint32 cacheSizeInFrames;

    (void)pConfig;

    if (pNodeGraph->processingSizeInFrames > 0) {
        cacheSizeInFrames = pNodeGraph->processingSizeInFrames;
    } else {
        cacheSizeInFrames = MA_DEFAULT_NODE_CACHE_CAP_IN_FRAMES_PER_BUS;
    }

    if (cacheSizeInFrames > 0xFFFF) {
        cacheSizeInFrames = 0xFFFF;
    }

    return (ma_uint16)cacheSizeInFrames;
}



static ma_result ma_node_detach_full(ma_node* pNode);

static float* ma_node_get_cached_input_ptr(ma_node* pNode, ma_uint32 inputBusIndex)
{
    ma_node_base* pNodeBase = (ma_node_base*)pNode;
    ma_uint32 iInputBus;
    float* pBasePtr;

    MA_ASSERT(pNodeBase != NULL);

    /* Input data is stored at the front of the buffer. */
    pBasePtr = pNodeBase->pCachedData;
    for (iInputBus = 0; iInputBus < inputBusIndex; iInputBus += 1) {
        pBasePtr += pNodeBase->cachedDataCapInFramesPerBus * ma_node_input_bus_get_channels(&pNodeBase->pInputBuses[iInputBus]);
    }

    return pBasePtr;
}

static float* ma_node_get_cached_output_ptr(ma_node* pNode, ma_uint32 outputBusIndex)
{
    ma_node_base* pNodeBase = (ma_node_base*)pNode;
    ma_uint32 iInputBus;
    ma_uint32 iOutputBus;
    float* pBasePtr;

    MA_ASSERT(pNodeBase != NULL);

    /* Cached output data starts after the input data. */
    pBasePtr = pNodeBase->pCachedData;
    for (iInputBus = 0; iInputBus < ma_node_get_input_bus_count(pNodeBase); iInputBus += 1) {
        pBasePtr += pNodeBase->cachedDataCapInFramesPerBus * ma_node_input_bus_get_channels(&pNodeBase->pInputBuses[iInputBus]);
    }

    for (iOutputBus = 0; iOutputBus < outputBusIndex; iOutputBus += 1) {
        pBasePtr += pNodeBase->cachedDataCapInFramesPerBus * ma_node_output_bus_get_channels(&pNodeBase->pOutputBuses[iOutputBus]);
    }

    return pBasePtr;
}


typedef struct
{
    size_t sizeInBytes;
    size_t inputBusOffset;
    size_t outputBusOffset;
    size_t cachedDataOffset;
    ma_uint32 inputBusCount;    /* So it doesn't have to be calculated twice. */
    ma_uint32 outputBusCount;   /* So it doesn't have to be calculated twice. */
} ma_node_heap_layout;

static ma_result ma_node_translate_bus_counts(const ma_node_config* pConfig, ma_uint32* pInputBusCount, ma_uint32* pOutputBusCount)
{
    ma_uint32 inputBusCount;
    ma_uint32 outputBusCount;

    MA_ASSERT(pConfig != NULL);
    MA_ASSERT(pInputBusCount  != NULL);
    MA_ASSERT(pOutputBusCount != NULL);

    /* Bus counts are determined by the vtable, unless they're set to `MA_NODE_BUS_COUNT_UNKNWON`, in which case they're taken from the config. */
    if (pConfig->vtable->inputBusCount == MA_NODE_BUS_COUNT_UNKNOWN) {
        inputBusCount = pConfig->inputBusCount;
    } else {
        inputBusCount = pConfig->vtable->inputBusCount;

        if (pConfig->inputBusCount != MA_NODE_BUS_COUNT_UNKNOWN && pConfig->inputBusCount != pConfig->vtable->inputBusCount) {
            return MA_INVALID_ARGS; /* Invalid configuration. You must not specify a conflicting bus count between the node's config and the vtable. */
        }
    }

    if (pConfig->vtable->outputBusCount == MA_NODE_BUS_COUNT_UNKNOWN) {
        outputBusCount = pConfig->outputBusCount;
    } else {
        outputBusCount = pConfig->vtable->outputBusCount;

        if (pConfig->outputBusCount != MA_NODE_BUS_COUNT_UNKNOWN && pConfig->outputBusCount != pConfig->vtable->outputBusCount) {
            return MA_INVALID_ARGS; /* Invalid configuration. You must not specify a conflicting bus count between the node's config and the vtable. */
        }
    }

    /* Bus counts must be within limits. */
    if (inputBusCount > MA_MAX_NODE_BUS_COUNT || outputBusCount > MA_MAX_NODE_BUS_COUNT) {
        return MA_INVALID_ARGS;
    }


    /* We must have channel counts for each bus. */
    if ((inputBusCount > 0 && pConfig->pInputChannels == NULL) || (outputBusCount > 0 && pConfig->pOutputChannels == NULL)) {
        return MA_INVALID_ARGS; /* You must specify channel counts for each input and output bus. */
    }


    /* Some special rules for passthrough nodes. */
    if ((pConfig->vtable->flags & MA_NODE_FLAG_PASSTHROUGH) != 0) {
        if ((pConfig->vtable->inputBusCount != 0 && pConfig->vtable->inputBusCount != 1) || pConfig->vtable->outputBusCount != 1) {
            return MA_INVALID_ARGS; /* Passthrough nodes must have exactly 1 output bus and either 0 or 1 input bus. */
        }

        if (pConfig->pInputChannels[0] != pConfig->pOutputChannels[0]) {
            return MA_INVALID_ARGS; /* Passthrough nodes must have the same number of channels between input and output nodes. */
        }
    }


    *pInputBusCount  = inputBusCount;
    *pOutputBusCount = outputBusCount;

    return MA_SUCCESS;
}

static ma_result ma_node_get_heap_layout(ma_node_graph* pNodeGraph, const ma_node_config* pConfig, ma_node_heap_layout* pHeapLayout)
{
    ma_result result;
    ma_uint32 inputBusCount;
    ma_uint32 outputBusCount;

    MA_ASSERT(pHeapLayout != NULL);

    MA_ZERO_OBJECT(pHeapLayout);

    if (pConfig == NULL || pConfig->vtable == NULL || pConfig->vtable->onProcess == NULL) {
        return MA_INVALID_ARGS;
    }

    result = ma_node_translate_bus_counts(pConfig, &inputBusCount, &outputBusCount);
    if (result != MA_SUCCESS) {
        return result;
    }

    pHeapLayout->sizeInBytes = 0;

    /* Input buses. */
    if (inputBusCount > MA_MAX_NODE_LOCAL_BUS_COUNT) {
        pHeapLayout->inputBusOffset = pHeapLayout->sizeInBytes;
        pHeapLayout->sizeInBytes += ma_align_64(sizeof(ma_node_input_bus) * inputBusCount);
    } else {
        pHeapLayout->inputBusOffset = MA_SIZE_MAX;  /* MA_SIZE_MAX indicates that no heap allocation is required for the input bus. */
    }

    /* Output buses. */
    if (outputBusCount > MA_MAX_NODE_LOCAL_BUS_COUNT) {
        pHeapLayout->outputBusOffset = pHeapLayout->sizeInBytes;
        pHeapLayout->sizeInBytes += ma_align_64(sizeof(ma_node_output_bus) * outputBusCount);
    } else {
        pHeapLayout->outputBusOffset = MA_SIZE_MAX;
    }

    /*
    Cached audio data.

    We need to allocate memory for caching both input and output data. We have an optimization
    where no caching is necessary for specific conditions:

        - The node has 0 inputs and 1 output.

    When a node meets the above conditions, no cache is allocated.

    The size choice for this buffer is a little bit finicky. We don't want to be too wasteful by
    allocating too much, but at the same time we want it be large enough so that enough frames can
    be processed for each call to ma_node_read_pcm_frames() so that it keeps things efficient. For
    now I'm going with 10ms @ 48K which is 480 frames per bus. This is configurable at compile
    time. It might also be worth investigating whether or not this can be configured at run time.
    */
    if (inputBusCount == 0 && outputBusCount == 1) {
        /* Fast path. No cache needed. */
        pHeapLayout->cachedDataOffset = MA_SIZE_MAX;
    } else {
        /* Slow path. Cache needed. */
        size_t cachedDataSizeInBytes = 0;
        ma_uint32 cacheCapInFrames;
        ma_uint32 iBus;

        /* The capacity of the cache is based on our callback processing size. */
        cacheCapInFrames = ma_node_config_get_cache_size_in_frames(pConfig, pNodeGraph);

        for (iBus = 0; iBus < inputBusCount; iBus += 1) {
            cachedDataSizeInBytes += cacheCapInFrames * ma_get_bytes_per_frame(ma_format_f32, pConfig->pInputChannels[iBus]);
        }

        for (iBus = 0; iBus < outputBusCount; iBus += 1) {
            cachedDataSizeInBytes += cacheCapInFrames * ma_get_bytes_per_frame(ma_format_f32, pConfig->pOutputChannels[iBus]);
        }

        pHeapLayout->cachedDataOffset = pHeapLayout->sizeInBytes;
        pHeapLayout->sizeInBytes += ma_align_64(cachedDataSizeInBytes);
    }


    /*
    Not technically part of the heap, but we can output the input and output bus counts so we can
    avoid a redundant call to ma_node_translate_bus_counts().
    */
    pHeapLayout->inputBusCount  = inputBusCount;
    pHeapLayout->outputBusCount = outputBusCount;

    /* Make sure allocation size is aligned. */
    pHeapLayout->sizeInBytes = ma_align_64(pHeapLayout->sizeInBytes);

    return MA_SUCCESS;
}

MA_API ma_result ma_node_get_heap_size(ma_node_graph* pNodeGraph, const ma_node_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_node_heap_layout heapLayout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = 0;

    result = ma_node_get_heap_layout(pNodeGraph, pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pHeapSizeInBytes = heapLayout.sizeInBytes;

    return MA_SUCCESS;
}

MA_API ma_result ma_node_init_preallocated(ma_node_graph* pNodeGraph, const ma_node_config* pConfig, void* pHeap, ma_node* pNode)
{
    ma_node_base* pNodeBase = (ma_node_base*)pNode;
    ma_result result;
    ma_node_heap_layout heapLayout;
    ma_uint32 iInputBus;
    ma_uint32 iOutputBus;

    if (pNodeBase == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pNodeBase);

    result = ma_node_get_heap_layout(pNodeGraph, pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    pNodeBase->_pHeap = pHeap;
    MA_ZERO_MEMORY(pHeap, heapLayout.sizeInBytes);

    pNodeBase->pNodeGraph     = pNodeGraph;
    pNodeBase->vtable         = pConfig->vtable;
    pNodeBase->state          = pConfig->initialState;
    pNodeBase->stateTimes[ma_node_state_started] = 0;
    pNodeBase->stateTimes[ma_node_state_stopped] = (ma_uint64)(ma_int64)-1; /* Weird casting for VC6 compatibility. */
    pNodeBase->inputBusCount  = heapLayout.inputBusCount;
    pNodeBase->outputBusCount = heapLayout.outputBusCount;

    if (heapLayout.inputBusOffset != MA_SIZE_MAX) {
        pNodeBase->pInputBuses = (ma_node_input_bus*)ma_offset_ptr(pHeap, heapLayout.inputBusOffset);
    } else {
        pNodeBase->pInputBuses = pNodeBase->_inputBuses;
    }

    if (heapLayout.outputBusOffset != MA_SIZE_MAX) {
        pNodeBase->pOutputBuses = (ma_node_output_bus*)ma_offset_ptr(pHeap, heapLayout.outputBusOffset);
    } else {
        pNodeBase->pOutputBuses = pNodeBase->_outputBuses;
    }

    if (heapLayout.cachedDataOffset != MA_SIZE_MAX) {
        pNodeBase->pCachedData = (float*)ma_offset_ptr(pHeap, heapLayout.cachedDataOffset);
        pNodeBase->cachedDataCapInFramesPerBus = ma_node_config_get_cache_size_in_frames(pConfig, pNodeGraph);
    } else {
        pNodeBase->pCachedData = NULL;
    }


    /* We need to run an initialization step for each input and output bus. */
    for (iInputBus = 0; iInputBus < ma_node_get_input_bus_count(pNodeBase); iInputBus += 1) {
        result = ma_node_input_bus_init(pConfig->pInputChannels[iInputBus], &pNodeBase->pInputBuses[iInputBus]);
        if (result != MA_SUCCESS) {
            return result;
        }
    }

    for (iOutputBus = 0; iOutputBus < ma_node_get_output_bus_count(pNodeBase); iOutputBus += 1) {
        result = ma_node_output_bus_init(pNodeBase, iOutputBus, pConfig->pOutputChannels[iOutputBus], &pNodeBase->pOutputBuses[iOutputBus]);
        if (result != MA_SUCCESS) {
            return result;
        }
    }


    /* The cached data needs to be initialized to silence (or a sine wave tone if we're debugging). */
    if (pNodeBase->pCachedData != NULL) {
        ma_uint32 iBus;

    #if 1   /* Toggle this between 0 and 1 to turn debugging on or off. 1 = fill with a sine wave for debugging; 0 = fill with silence. */
        /* For safety we'll go ahead and default the buffer to silence. */
        for (iBus = 0; iBus < ma_node_get_input_bus_count(pNodeBase); iBus += 1) {
            ma_silence_pcm_frames(ma_node_get_cached_input_ptr(pNode, iBus), pNodeBase->cachedDataCapInFramesPerBus, ma_format_f32, ma_node_input_bus_get_channels(&pNodeBase->pInputBuses[iBus]));
        }
        for (iBus = 0; iBus < ma_node_get_output_bus_count(pNodeBase); iBus += 1) {
            ma_silence_pcm_frames(ma_node_get_cached_output_ptr(pNode, iBus), pNodeBase->cachedDataCapInFramesPerBus, ma_format_f32, ma_node_output_bus_get_channels(&pNodeBase->pOutputBuses[iBus]));
        }
    #else
        /* For debugging. Default to a sine wave. */
        for (iBus = 0; iBus < ma_node_get_input_bus_count(pNodeBase); iBus += 1) {
            ma_debug_fill_pcm_frames_with_sine_wave(ma_node_get_cached_input_ptr(pNode, iBus), pNodeBase->cachedDataCapInFramesPerBus, ma_format_f32, ma_node_input_bus_get_channels(&pNodeBase->pInputBuses[iBus]), 48000);
        }
        for (iBus = 0; iBus < ma_node_get_output_bus_count(pNodeBase); iBus += 1) {
            ma_debug_fill_pcm_frames_with_sine_wave(ma_node_get_cached_output_ptr(pNode, iBus), pNodeBase->cachedDataCapInFramesPerBus, ma_format_f32, ma_node_output_bus_get_channels(&pNodeBase->pOutputBuses[iBus]), 48000);
        }
    #endif
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_node_init(ma_node_graph* pNodeGraph, const ma_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_node* pNode)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_node_get_heap_size(pNodeGraph, pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_node_init_preallocated(pNodeGraph, pConfig, pHeap, pNode);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    ((ma_node_base*)pNode)->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_node_uninit(ma_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_node_base* pNodeBase = (ma_node_base*)pNode;

    if (pNodeBase == NULL) {
        return;
    }

    /*
    The first thing we need to do is fully detach the node. This will detach all inputs and
    outputs. We need to do this first because it will sever the connection with the node graph and
    allow us to complete uninitialization without needing to worry about thread-safety with the
    audio thread. The detachment process will wait for any local processing of the node to finish.
    */
    ma_node_detach_full(pNode);

    /*
    At this point the node should be completely unreferenced by the node graph and we can finish up
    the uninitialization process without needing to worry about thread-safety.
    */
    if (pNodeBase->_ownsHeap) {
        ma_free(pNodeBase->_pHeap, pAllocationCallbacks);
    }
}

MA_API ma_node_graph* ma_node_get_node_graph(const ma_node* pNode)
{
    if (pNode == NULL) {
        return NULL;
    }

    return ((const ma_node_base*)pNode)->pNodeGraph;
}

MA_API ma_uint32 ma_node_get_input_bus_count(const ma_node* pNode)
{
    if (pNode == NULL) {
        return 0;
    }

    return ((ma_node_base*)pNode)->inputBusCount;
}

MA_API ma_uint32 ma_node_get_output_bus_count(const ma_node* pNode)
{
    if (pNode == NULL) {
        return 0;
    }

    return ((ma_node_base*)pNode)->outputBusCount;
}


MA_API ma_uint32 ma_node_get_input_channels(const ma_node* pNode, ma_uint32 inputBusIndex)
{
    const ma_node_base* pNodeBase = (const ma_node_base*)pNode;

    if (pNode == NULL) {
        return 0;
    }

    if (inputBusIndex >= ma_node_get_input_bus_count(pNode)) {
        return 0;   /* Invalid bus index. */
    }

    return ma_node_input_bus_get_channels(&pNodeBase->pInputBuses[inputBusIndex]);
}

MA_API ma_uint32 ma_node_get_output_channels(const ma_node* pNode, ma_uint32 outputBusIndex)
{
    const ma_node_base* pNodeBase = (const ma_node_base*)pNode;

    if (pNode == NULL) {
        return 0;
    }

    if (outputBusIndex >= ma_node_get_output_bus_count(pNode)) {
        return 0;   /* Invalid bus index. */
    }

    return ma_node_output_bus_get_channels(&pNodeBase->pOutputBuses[outputBusIndex]);
}


static ma_result ma_node_detach_full(ma_node* pNode)
{
    ma_node_base* pNodeBase = (ma_node_base*)pNode;
    ma_uint32 iInputBus;

    if (pNodeBase == NULL) {
        return MA_INVALID_ARGS;
    }

    /*
    Make sure the node is completely detached first. This will not return until the output bus is
    guaranteed to no longer be referenced by the audio thread.
    */
    ma_node_detach_all_output_buses(pNode);

    /*
    At this point all output buses will have been detached from the graph and we can be guaranteed
    that none of its input nodes will be getting processed by the graph. We can detach these
    without needing to worry about the audio thread touching them.
    */
    for (iInputBus = 0; iInputBus < ma_node_get_input_bus_count(pNode); iInputBus += 1) {
        ma_node_input_bus* pInputBus;
        ma_node_output_bus* pOutputBus;

        pInputBus = &pNodeBase->pInputBuses[iInputBus];

        /*
        This is important. We cannot be using ma_node_input_bus_first() or ma_node_input_bus_next(). Those
        functions are specifically for the audio thread. We'll instead just manually iterate using standard
        linked list logic. We don't need to worry about the audio thread referencing these because the step
        above severed the connection to the graph.
        */
        for (pOutputBus = (ma_node_output_bus*)ma_atomic_load_ptr(&pInputBus->head.pNext); pOutputBus != NULL; pOutputBus = (ma_node_output_bus*)ma_atomic_load_ptr(&pInputBus->head.pNext)) {
            ma_node_detach_output_bus(pOutputBus->pNode, pOutputBus->outputBusIndex);   /* This won't do any waiting in practice and should be efficient. */
        }
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_node_detach_output_bus(ma_node* pNode, ma_uint32 outputBusIndex)
{
    ma_result result = MA_SUCCESS;
    ma_node_base* pNodeBase = (ma_node_base*)pNode;
    ma_node_base* pInputNodeBase;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    if (outputBusIndex >= ma_node_get_output_bus_count(pNode)) {
        return MA_INVALID_ARGS; /* Invalid output bus index. */
    }

    /* We need to lock the output bus because we need to inspect the input node and grab its input bus. */
    ma_node_output_bus_lock(&pNodeBase->pOutputBuses[outputBusIndex]);
    {
        pInputNodeBase = (ma_node_base*)pNodeBase->pOutputBuses[outputBusIndex].pInputNode;
        if (pInputNodeBase != NULL) {
            ma_node_input_bus_detach__no_output_bus_lock(&pInputNodeBase->pInputBuses[pNodeBase->pOutputBuses[outputBusIndex].inputNodeInputBusIndex], &pNodeBase->pOutputBuses[outputBusIndex]);
        }
    }
    ma_node_output_bus_unlock(&pNodeBase->pOutputBuses[outputBusIndex]);

    return result;
}

MA_API ma_result ma_node_detach_all_output_buses(ma_node* pNode)
{
    ma_uint32 iOutputBus;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    for (iOutputBus = 0; iOutputBus < ma_node_get_output_bus_count(pNode); iOutputBus += 1) {
        ma_node_detach_output_bus(pNode, iOutputBus);
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_node_attach_output_bus(ma_node* pNode, ma_uint32 outputBusIndex, ma_node* pOtherNode, ma_uint32 otherNodeInputBusIndex)
{
    ma_node_base* pNodeBase  = (ma_node_base*)pNode;
    ma_node_base* pOtherNodeBase = (ma_node_base*)pOtherNode;

    if (pNodeBase == NULL || pOtherNodeBase == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pNodeBase == pOtherNodeBase) {
        return MA_INVALID_OPERATION;    /* Cannot attach a node to itself. */
    }

    if (outputBusIndex >= ma_node_get_output_bus_count(pNode) || otherNodeInputBusIndex >= ma_node_get_input_bus_count(pOtherNode)) {
        return MA_INVALID_OPERATION;    /* Invalid bus index. */
    }

    /* The output channel count of the output node must be the same as the input channel count of the input node. */
    if (ma_node_get_output_channels(pNode, outputBusIndex) != ma_node_get_input_channels(pOtherNode, otherNodeInputBusIndex)) {
        return MA_INVALID_OPERATION;    /* Channel count is incompatible. */
    }

    /* This will deal with detaching if the output bus is already attached to something. */
    ma_node_input_bus_attach(&pOtherNodeBase->pInputBuses[otherNodeInputBusIndex], &pNodeBase->pOutputBuses[outputBusIndex], pOtherNode, otherNodeInputBusIndex);

    return MA_SUCCESS;
}

MA_API ma_result ma_node_set_output_bus_volume(ma_node* pNode, ma_uint32 outputBusIndex, float volume)
{
    ma_node_base* pNodeBase = (ma_node_base*)pNode;

    if (pNodeBase == NULL) {
        return MA_INVALID_ARGS;
    }

    if (outputBusIndex >= ma_node_get_output_bus_count(pNode)) {
        return MA_INVALID_ARGS; /* Invalid bus index. */
    }

    return ma_node_output_bus_set_volume(&pNodeBase->pOutputBuses[outputBusIndex], volume);
}

MA_API float ma_node_get_output_bus_volume(const ma_node* pNode, ma_uint32 outputBusIndex)
{
    const ma_node_base* pNodeBase = (const ma_node_base*)pNode;

    if (pNodeBase == NULL) {
        return 0;
    }

    if (outputBusIndex >= ma_node_get_output_bus_count(pNode)) {
        return 0;   /* Invalid bus index. */
    }

    return ma_node_output_bus_get_volume(&pNodeBase->pOutputBuses[outputBusIndex]);
}

MA_API ma_result ma_node_set_state(ma_node* pNode, ma_node_state state)
{
    ma_node_base* pNodeBase = (ma_node_base*)pNode;

    if (pNodeBase == NULL) {
        return MA_INVALID_ARGS;
    }

    ma_atomic_exchange_i32(&pNodeBase->state, state);

    return MA_SUCCESS;
}

MA_API ma_node_state ma_node_get_state(const ma_node* pNode)
{
    const ma_node_base* pNodeBase = (const ma_node_base*)pNode;

    if (pNodeBase == NULL) {
        return ma_node_state_stopped;
    }

    return (ma_node_state)ma_atomic_load_i32(&pNodeBase->state);
}

MA_API ma_result ma_node_set_state_time(ma_node* pNode, ma_node_state state, ma_uint64 globalTime)
{
    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Validation check for safety since we'll be using this as an index into stateTimes[]. */
    if (state != ma_node_state_started && state != ma_node_state_stopped) {
        return MA_INVALID_ARGS;
    }

    ma_atomic_exchange_64(&((ma_node_base*)pNode)->stateTimes[state], globalTime);

    return MA_SUCCESS;
}

MA_API ma_uint64 ma_node_get_state_time(const ma_node* pNode, ma_node_state state)
{
    if (pNode == NULL) {
        return 0;
    }

    /* Validation check for safety since we'll be using this as an index into stateTimes[]. */
    if (state != ma_node_state_started && state != ma_node_state_stopped) {
        return 0;
    }

    return ma_atomic_load_64(&((ma_node_base*)pNode)->stateTimes[state]);
}

MA_API ma_node_state ma_node_get_state_by_time(const ma_node* pNode, ma_uint64 globalTime)
{
    if (pNode == NULL) {
        return ma_node_state_stopped;
    }

    return ma_node_get_state_by_time_range(pNode, globalTime, globalTime);
}

MA_API ma_node_state ma_node_get_state_by_time_range(const ma_node* pNode, ma_uint64 globalTimeBeg, ma_uint64 globalTimeEnd)
{
    ma_node_state state;

    if (pNode == NULL) {
        return ma_node_state_stopped;
    }

    state = ma_node_get_state(pNode);

    /* An explicitly stopped node is always stopped. */
    if (state == ma_node_state_stopped) {
        return ma_node_state_stopped;
    }

    /*
    Getting here means the node is marked as started, but it may still not be truly started due to
    its start time not having been reached yet. Also, the stop time may have also been reached in
    which case it'll be considered stopped.
    */
    if (ma_node_get_state_time(pNode, ma_node_state_started) > globalTimeBeg) {
        return ma_node_state_stopped;   /* Start time has not yet been reached. */
    }

    if (ma_node_get_state_time(pNode, ma_node_state_stopped) <= globalTimeEnd) {
        return ma_node_state_stopped;   /* Stop time has been reached. */
    }

    /* Getting here means the node is marked as started and is within its start/stop times. */
    return ma_node_state_started;
}

MA_API ma_uint64 ma_node_get_time(const ma_node* pNode)
{
    if (pNode == NULL) {
        return 0;
    }

    return ma_atomic_load_64(&((ma_node_base*)pNode)->localTime);
}

MA_API ma_result ma_node_set_time(ma_node* pNode, ma_uint64 localTime)
{
    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    ma_atomic_exchange_64(&((ma_node_base*)pNode)->localTime, localTime);

    return MA_SUCCESS;
}



static void ma_node_process_pcm_frames_internal(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    ma_node_base* pNodeBase = (ma_node_base*)pNode;

    MA_ASSERT(pNode != NULL);

    if (pNodeBase->vtable->onProcess) {
        pNodeBase->vtable->onProcess(pNode, ppFramesIn, pFrameCountIn, ppFramesOut, pFrameCountOut);
    }
}

static ma_result ma_node_read_pcm_frames(ma_node* pNode, ma_uint32 outputBusIndex, float* pFramesOut, ma_uint32 frameCount, ma_uint32* pFramesRead, ma_uint64 globalTime)
{
    ma_node_base* pNodeBase = (ma_node_base*)pNode;
    ma_result result = MA_SUCCESS;
    ma_uint32 iInputBus;
    ma_uint32 iOutputBus;
    ma_uint32 inputBusCount;
    ma_uint32 outputBusCount;
    ma_uint32 totalFramesRead = 0;
    float* ppFramesIn[MA_MAX_NODE_BUS_COUNT];
    float* ppFramesOut[MA_MAX_NODE_BUS_COUNT];
    ma_uint64 globalTimeBeg;
    ma_uint64 globalTimeEnd;
    ma_uint64 startTime;
    ma_uint64 stopTime;
    ma_uint32 timeOffsetBeg;
    ma_uint32 timeOffsetEnd;
    ma_uint32 frameCountIn;
    ma_uint32 frameCountOut;

    /*
    pFramesRead is mandatory. It must be used to determine how many frames were read. It's normal and
    expected that the number of frames read may be different to that requested. Therefore, the caller
    must look at this value to correctly determine how many frames were read.
    */
    MA_ASSERT(pFramesRead != NULL); /* <-- If you've triggered this assert, you're using this function wrong. You *must* use this variable and inspect it after the call returns. */
    if (pFramesRead == NULL) {
        return MA_INVALID_ARGS;
    }

    *pFramesRead = 0;   /* Safety. */

    if (pNodeBase == NULL) {
        return MA_INVALID_ARGS;
    }

    if (outputBusIndex >= ma_node_get_output_bus_count(pNodeBase)) {
        return MA_INVALID_ARGS; /* Invalid output bus index. */
    }

    /* Don't do anything if we're in a stopped state. */
    if (ma_node_get_state_by_time_range(pNode, globalTime, globalTime + frameCount) != ma_node_state_started) {
        return MA_SUCCESS;  /* We're in a stopped state. This is not an error - we just need to not read anything. */
    }


    globalTimeBeg = globalTime;
    globalTimeEnd = globalTime + frameCount;
    startTime = ma_node_get_state_time(pNode, ma_node_state_started);
    stopTime  = ma_node_get_state_time(pNode, ma_node_state_stopped);

    /*
    At this point we know that we are inside our start/stop times. However, we may need to adjust
    our frame count and output pointer to accommodate since we could be straddling the time period
    that this function is getting called for.

    It's possible (and likely) that the start time does not line up with the output buffer. We
    therefore need to offset it by a number of frames to accommodate. The same thing applies for
    the stop time.
    */
    timeOffsetBeg = (globalTimeBeg < startTime) ? (ma_uint32)(globalTimeEnd - startTime) : 0;
    timeOffsetEnd = (globalTimeEnd > stopTime)  ? (ma_uint32)(globalTimeEnd - stopTime)  : 0;

    /* Trim based on the start offset. We need to silence the start of the buffer. */
    if (timeOffsetBeg > 0) {
        ma_silence_pcm_frames(pFramesOut, timeOffsetBeg, ma_format_f32, ma_node_get_output_channels(pNode, outputBusIndex));
        pFramesOut += timeOffsetBeg * ma_node_get_output_channels(pNode, outputBusIndex);
        frameCount -= timeOffsetBeg;
    }

    /* Trim based on the end offset. We don't need to silence the tail section because we'll just have a reduced value written to pFramesRead. */
    if (timeOffsetEnd > 0) {
        frameCount -= timeOffsetEnd;
    }


    /* We run on different paths depending on the bus counts. */
    inputBusCount  = ma_node_get_input_bus_count(pNode);
    outputBusCount = ma_node_get_output_bus_count(pNode);

    /*
    Run a simplified path when there are no inputs and one output. In this case there's nothing to
    actually read and we can go straight to output. This is a very common scenario because the vast
    majority of data source nodes will use this setup so this optimization I think is worthwhile.
    */
    if (inputBusCount == 0 && outputBusCount == 1) {
        /* Fast path. No need to read from input and no need for any caching. */
        frameCountIn  = 0;
        frameCountOut = frameCount;    /* Just read as much as we can. The callback will return what was actually read. */

        ppFramesOut[0] = pFramesOut;

        /*
        If it's a passthrough we won't be expecting the callback to output anything, so we'll
        need to pre-silence the output buffer.
        */
        if ((pNodeBase->vtable->flags & MA_NODE_FLAG_PASSTHROUGH) != 0) {
            ma_silence_pcm_frames(pFramesOut, frameCount, ma_format_f32, ma_node_get_output_channels(pNode, outputBusIndex));
        }

        ma_node_process_pcm_frames_internal(pNode, NULL, &frameCountIn, ppFramesOut, &frameCountOut);
        totalFramesRead = frameCountOut;
    } else {
        /* Slow path. Need to read input data. */
        if ((pNodeBase->vtable->flags & MA_NODE_FLAG_PASSTHROUGH) != 0) {
            /*
            Fast path. We're running a passthrough. We need to read directly into the output buffer, but
            still fire the callback so that event handling and trigger nodes can do their thing. Since
            it's a passthrough there's no need for any kind of caching logic.
            */
            MA_ASSERT(outputBusCount == inputBusCount);
            MA_ASSERT(outputBusCount == 1);
            MA_ASSERT(outputBusIndex == 0);

            /* We just read directly from input bus to output buffer, and then afterwards fire the callback. */
            ppFramesOut[0] = pFramesOut;
            ppFramesIn[0] = ppFramesOut[0];

            result = ma_node_input_bus_read_pcm_frames(pNodeBase, &pNodeBase->pInputBuses[0], ppFramesIn[0], frameCount, &totalFramesRead, globalTime);
            if (result == MA_SUCCESS) {
                /* Even though it's a passthrough, we still need to fire the callback. */
                frameCountIn  = totalFramesRead;
                frameCountOut = totalFramesRead;

                if (totalFramesRead > 0) {
                    ma_node_process_pcm_frames_internal(pNode, (const float**)ppFramesIn, &frameCountIn, ppFramesOut, &frameCountOut);  /* From GCC: expected 'const float **' but argument is of type 'float **'. Shouldn't this be implicit? Explicit cast to silence the warning. */
                }

                /*
                A passthrough should never have modified the input and output frame counts. If you're
                triggering these asserts you need to fix your processing callback.
                */
                MA_ASSERT(frameCountIn  == totalFramesRead);
                MA_ASSERT(frameCountOut == totalFramesRead);
            }
        } else {
            /* Slow path. Need to do caching. */
            ma_uint32 framesToProcessIn;
            ma_uint32 framesToProcessOut;
            ma_bool32 consumeNullInput = MA_FALSE;

            /*
            We use frameCount as a basis for the number of frames to read since that's what's being
            requested, however we still need to clamp it to whatever can fit in the cache.

            This will also be used as the basis for determining how many input frames to read. This is
            not ideal because it can result in too many input frames being read which introduces latency.
            To solve this, nodes can implement an optional callback called onGetRequiredInputFrameCount
            which is used as hint to miniaudio as to how many input frames it needs to read at a time. This
            callback is completely optional, and if it's not set, miniaudio will assume `frameCount`.

            This function will be called multiple times for each period of time, once for each output node.
            We cannot read from each input node each time this function is called. Instead we need to check
            whether or not this is first output bus to be read from for this time period, and if so, read
            from our input data.

            To determine whether or not we're ready to read data, we check a flag. There will be one flag
            for each output. When the flag is set, it means data has been read previously and that we're
            ready to advance time forward for our input nodes by reading fresh data.
            */
            framesToProcessOut = frameCount;
            if (framesToProcessOut > pNodeBase->cachedDataCapInFramesPerBus) {
                framesToProcessOut = pNodeBase->cachedDataCapInFramesPerBus;
            }

            framesToProcessIn  = frameCount;
            if (pNodeBase->vtable->onGetRequiredInputFrameCount) {
                pNodeBase->vtable->onGetRequiredInputFrameCount(pNode, framesToProcessOut, &framesToProcessIn); /* <-- It does not matter if this fails. */
            }
            if (framesToProcessIn > pNodeBase->cachedDataCapInFramesPerBus) {
                framesToProcessIn = pNodeBase->cachedDataCapInFramesPerBus;
            }


            MA_ASSERT(framesToProcessIn  <= 0xFFFF);
            MA_ASSERT(framesToProcessOut <= 0xFFFF);

            if (ma_node_output_bus_has_read(&pNodeBase->pOutputBuses[outputBusIndex])) {
                /* Getting here means we need to do another round of processing. */
                pNodeBase->cachedFrameCountOut = 0;

                for (;;) {
                    frameCountOut = 0;

                    /*
                    We need to prepare our output frame pointers for processing. In the same iteration we need
                    to mark every output bus as unread so that future calls to this function for different buses
                    for the current time period don't pull in data when they should instead be reading from cache.
                    */
                    for (iOutputBus = 0; iOutputBus < outputBusCount; iOutputBus += 1) {
                        ma_node_output_bus_set_has_read(&pNodeBase->pOutputBuses[iOutputBus], MA_FALSE); /* <-- This is what tells the next calls to this function for other output buses for this time period to read from cache instead of pulling in more data. */
                        ppFramesOut[iOutputBus] = ma_node_get_cached_output_ptr(pNode, iOutputBus);
                    }

                    /* We only need to read from input buses if there isn't already some data in the cache. */
                    if (pNodeBase->cachedFrameCountIn == 0) {
                        ma_uint32 maxFramesReadIn = 0;

                        /* Here is where we pull in data from the input buses. This is what will trigger an advance in time. */
                        for (iInputBus = 0; iInputBus < inputBusCount; iInputBus += 1) {
                            ma_uint32 framesRead;

                            /* The first thing to do is get the offset within our bulk allocation to store this input data. */
                            ppFramesIn[iInputBus] = ma_node_get_cached_input_ptr(pNode, iInputBus);

                            /* Once we've determined our destination pointer we can read. Note that we must inspect the number of frames read and fill any leftovers with silence for safety. */
                            result = ma_node_input_bus_read_pcm_frames(pNodeBase, &pNodeBase->pInputBuses[iInputBus], ppFramesIn[iInputBus], framesToProcessIn, &framesRead, globalTime);
                            if (result != MA_SUCCESS) {
                                /* It doesn't really matter if we fail because we'll just fill with silence. */
                                framesRead = 0; /* Just for safety, but I don't think it's really needed. */
                            }

                            /* TODO: Minor optimization opportunity here. If no frames were read and the buffer is already filled with silence, no need to re-silence it. */
                            /* Any leftover frames need to silenced for safety. */
                            if (framesRead < framesToProcessIn) {
                                ma_silence_pcm_frames(ppFramesIn[iInputBus] + (framesRead * ma_node_get_input_channels(pNodeBase, iInputBus)), (framesToProcessIn - framesRead), ma_format_f32, ma_node_get_input_channels(pNodeBase, iInputBus));
                            }

                            maxFramesReadIn = ma_max(maxFramesReadIn, framesRead);
                        }

                        /* This was a fresh load of input data so reset our consumption counter. */
                        pNodeBase->consumedFrameCountIn = 0;

                        /*
                        We don't want to keep processing if there's nothing to process, so set the number of cached
                        input frames to the maximum number we read from each attachment (the lesser will be padded
                        with silence). If we didn't read anything, this will be set to 0 and the entire buffer will
                        have been assigned to silence. This being equal to 0 is an important property for us because
                        it allows us to detect when NULL can be passed into the processing callback for the input
                        buffer for the purpose of continuous processing.
                        */
                        pNodeBase->cachedFrameCountIn = (ma_uint16)maxFramesReadIn;
                    } else {
                        /* We don't need to read anything, but we do need to prepare our input frame pointers. */
                        for (iInputBus = 0; iInputBus < inputBusCount; iInputBus += 1) {
                            ppFramesIn[iInputBus] = ma_node_get_cached_input_ptr(pNode, iInputBus) + (pNodeBase->consumedFrameCountIn * ma_node_get_input_channels(pNodeBase, iInputBus));
                        }
                    }

                    /*
                    At this point we have our input data so now we need to do some processing. Sneaky little
                    optimization here - we can set the pointer to the output buffer for this output bus so
                    that the final copy into the output buffer is done directly by onProcess().
                    */
                    if (pFramesOut != NULL) {
                        ppFramesOut[outputBusIndex] = ma_offset_pcm_frames_ptr_f32(pFramesOut, pNodeBase->cachedFrameCountOut, ma_node_get_output_channels(pNode, outputBusIndex));
                    }


                    /* Give the processing function the entire capacity of the output buffer. */
                    frameCountOut = (framesToProcessOut - pNodeBase->cachedFrameCountOut);

                    /*
                    We need to treat nodes with continuous processing a little differently. For these ones,
                    we always want to fire the callback with the requested number of frames, regardless of
                    pNodeBase->cachedFrameCountIn, which could be 0. Also, we want to check if we can pass
                    in NULL for the input buffer to the callback.
                    */
                    if ((pNodeBase->vtable->flags & MA_NODE_FLAG_CONTINUOUS_PROCESSING) != 0) {
                        /* We're using continuous processing. Make sure we specify the whole frame count at all times. */
                        frameCountIn = framesToProcessIn;    /* Give the processing function as much input data as we've got in the buffer, including any silenced padding from short reads. */

                        if ((pNodeBase->vtable->flags & MA_NODE_FLAG_ALLOW_NULL_INPUT) != 0 && pNodeBase->consumedFrameCountIn == 0 && pNodeBase->cachedFrameCountIn == 0) {
                            consumeNullInput = MA_TRUE;
                        } else {
                            consumeNullInput = MA_FALSE;
                        }

                        /*
                        Since we're using continuous processing we're always passing in a full frame count
                        regardless of how much input data was read. If this is greater than what we read as
                        input, we'll end up with an underflow. We instead need to make sure our cached frame
                        count is set to the number of frames we'll be passing to the data callback. Not
                        doing this will result in an underflow when we "consume" the cached data later on.

                        Note that this check needs to be done after the "consumeNullInput" check above because
                        we use the property of cachedFrameCountIn being 0 to determine whether or not we
                        should be passing in a null pointer to the processing callback for when the node is
                        configured with MA_NODE_FLAG_ALLOW_NULL_INPUT.
                        */
                        if (pNodeBase->cachedFrameCountIn < (ma_uint16)frameCountIn) {
                            pNodeBase->cachedFrameCountIn = (ma_uint16)frameCountIn;
                        }
                    } else {
                        frameCountIn = pNodeBase->cachedFrameCountIn;  /* Give the processing function as much valid input data as we've got. */
                        consumeNullInput = MA_FALSE;
                    }

                    /*
                    Process data slightly differently depending on whether or not we're consuming NULL
                    input (checked just above).
                    */
                    if (consumeNullInput) {
                        ma_node_process_pcm_frames_internal(pNode, NULL, &frameCountIn, ppFramesOut, &frameCountOut);
                    } else {
                        /*
                        We want to skip processing if there's no input data, but we can only do that safely if
                        we know that there is no chance of any output frames being produced. If continuous
                        processing is being used, this won't be a problem because the input frame count will
                        always be non-0. However, if continuous processing is *not* enabled and input and output
                        data is processed at different rates, we still need to process that last input frame
                        because there could be a few excess output frames needing to be produced from cached
                        data. The `MA_NODE_FLAG_DIFFERENT_PROCESSING_RATES` flag is used as the indicator for
                        determining whether or not we need to process the node even when there are no input
                        frames available right now.
                        */
                        if (frameCountIn > 0 || (pNodeBase->vtable->flags & MA_NODE_FLAG_DIFFERENT_PROCESSING_RATES) != 0) {
                            ma_node_process_pcm_frames_internal(pNode, (const float**)ppFramesIn, &frameCountIn, ppFramesOut, &frameCountOut);    /* From GCC: expected 'const float **' but argument is of type 'float **'. Shouldn't this be implicit? Explicit cast to silence the warning. */
                        } else {
                            frameCountOut = 0;  /* No data was processed. */
                        }
                    }

                    /*
                    Thanks to our sneaky optimization above we don't need to do any data copying directly into
                    the output buffer - the onProcess() callback just did that for us. We do, however, need to
                    apply the number of input and output frames that were processed. Note that due to continuous
                    processing above, we need to do explicit checks here. If we just consumed a NULL input
                    buffer it means that no actual input data was processed from the internal buffers and we
                    don't want to be modifying any counters.
                    */
                    if (consumeNullInput == MA_FALSE) {
                        pNodeBase->consumedFrameCountIn += (ma_uint16)frameCountIn;
                        pNodeBase->cachedFrameCountIn   -= (ma_uint16)frameCountIn;
                    }

                    /* The cached output frame count is always equal to what we just read. */
                    pNodeBase->cachedFrameCountOut += (ma_uint16)frameCountOut;

                    /* If we couldn't process any data, we're done. The loop needs to be terminated here or else we'll get stuck in a loop. */
                    if (pNodeBase->cachedFrameCountOut == framesToProcessOut || (frameCountOut == 0 && frameCountIn == 0)) {
                        break;
                    }
                }
            } else {
                /*
                We're not needing to read anything from the input buffer so just read directly from our
                already-processed data.
                */
                if (pFramesOut != NULL) {
                    ma_copy_pcm_frames(pFramesOut, ma_node_get_cached_output_ptr(pNodeBase, outputBusIndex), pNodeBase->cachedFrameCountOut, ma_format_f32, ma_node_get_output_channels(pNodeBase, outputBusIndex));
                }
            }

            /* The number of frames read is always equal to the number of cached output frames. */
            totalFramesRead = pNodeBase->cachedFrameCountOut;

            /* Now that we've read the data, make sure our read flag is set. */
            ma_node_output_bus_set_has_read(&pNodeBase->pOutputBuses[outputBusIndex], MA_TRUE);
        }
    }

    /* Apply volume, if necessary. */
    ma_apply_volume_factor_f32(pFramesOut, totalFramesRead * ma_node_get_output_channels(pNodeBase, outputBusIndex), ma_node_output_bus_get_volume(&pNodeBase->pOutputBuses[outputBusIndex]));

    /* Advance our local time forward. */
    ma_atomic_fetch_add_64(&pNodeBase->localTime, (ma_uint64)totalFramesRead);

    *pFramesRead = totalFramesRead + timeOffsetBeg; /* Must include the silenced section at the start of the buffer. */
    return result;
}




/* Data source node. */
MA_API ma_data_source_node_config ma_data_source_node_config_init(ma_data_source* pDataSource)
{
    ma_data_source_node_config config;

    MA_ZERO_OBJECT(&config);
    config.nodeConfig  = ma_node_config_init();
    config.pDataSource = pDataSource;

    return config;
}


static void ma_data_source_node_process_pcm_frames(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    ma_data_source_node* pDataSourceNode = (ma_data_source_node*)pNode;
    ma_format format;
    ma_uint32 channels;
    ma_uint32 frameCount;
    ma_uint64 framesRead = 0;

    MA_ASSERT(pDataSourceNode != NULL);
    MA_ASSERT(pDataSourceNode->pDataSource != NULL);
    MA_ASSERT(ma_node_get_input_bus_count(pDataSourceNode)  == 0);
    MA_ASSERT(ma_node_get_output_bus_count(pDataSourceNode) == 1);

    /* We don't want to read from ppFramesIn at all. Instead we read from the data source. */
    (void)ppFramesIn;
    (void)pFrameCountIn;

    frameCount = *pFrameCountOut;

    /* miniaudio should never be calling this with a frame count of zero. */
    MA_ASSERT(frameCount > 0);

    if (ma_data_source_get_data_format(pDataSourceNode->pDataSource, &format, &channels, NULL, NULL, 0) == MA_SUCCESS) { /* <-- Don't care about sample rate here. */
        /* The node graph system requires samples be in floating point format. This is checked in ma_data_source_node_init(). */
        MA_ASSERT(format == ma_format_f32);
        (void)format;   /* Just to silence some static analysis tools. */

        ma_data_source_read_pcm_frames(pDataSourceNode->pDataSource, ppFramesOut[0], frameCount, &framesRead);
    }

    *pFrameCountOut = (ma_uint32)framesRead;
}

static ma_node_vtable g_ma_data_source_node_vtable =
{
    ma_data_source_node_process_pcm_frames,
    NULL,   /* onGetRequiredInputFrameCount */
    0,      /* 0 input buses. */
    1,      /* 1 output bus. */
    0
};

MA_API ma_result ma_data_source_node_init(ma_node_graph* pNodeGraph, const ma_data_source_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_data_source_node* pDataSourceNode)
{
    ma_result result;
    ma_format format;   /* For validating the format, which must be ma_format_f32. */
    ma_uint32 channels; /* For specifying the channel count of the output bus. */
    ma_node_config baseConfig;

    if (pDataSourceNode == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pDataSourceNode);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    result = ma_data_source_get_data_format(pConfig->pDataSource, &format, &channels, NULL, NULL, 0);    /* Don't care about sample rate. This will check pDataSource for NULL. */
    if (result != MA_SUCCESS) {
        return result;
    }

    MA_ASSERT(format == ma_format_f32); /* <-- If you've triggered this it means your data source is not outputting floating-point samples. You must configure your data source to use ma_format_f32. */
    if (format != ma_format_f32) {
        return MA_INVALID_ARGS; /* Invalid format. */
    }

    /* The channel count is defined by the data source. If the caller has manually changed the channels we just ignore it. */
    baseConfig = pConfig->nodeConfig;
    baseConfig.vtable = &g_ma_data_source_node_vtable;  /* Explicitly set the vtable here to prevent callers from setting it incorrectly. */

    /*
    The channel count is defined by the data source. It is invalid for the caller to manually set
    the channel counts in the config. `ma_data_source_node_config_init()` will have defaulted the
    channel count pointer to NULL which is how it must remain. If you trigger any of these asserts
    it means you're explicitly setting the channel count. Instead, configure the output channel
    count of your data source to be the necessary channel count.
    */
    if (baseConfig.pOutputChannels != NULL) {
        return MA_INVALID_ARGS;
    }

    baseConfig.pOutputChannels = &channels;

    result = ma_node_init(pNodeGraph, &baseConfig, pAllocationCallbacks, &pDataSourceNode->base);
    if (result != MA_SUCCESS) {
        return result;
    }

    pDataSourceNode->pDataSource = pConfig->pDataSource;

    return MA_SUCCESS;
}

MA_API void ma_data_source_node_uninit(ma_data_source_node* pDataSourceNode, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_node_uninit(&pDataSourceNode->base, pAllocationCallbacks);
}

MA_API ma_result ma_data_source_node_set_looping(ma_data_source_node* pDataSourceNode, ma_bool32 isLooping)
{
    if (pDataSourceNode == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_data_source_set_looping(pDataSourceNode->pDataSource, isLooping);
}

MA_API ma_bool32 ma_data_source_node_is_looping(ma_data_source_node* pDataSourceNode)
{
    if (pDataSourceNode == NULL) {
        return MA_FALSE;
    }

    return ma_data_source_is_looping(pDataSourceNode->pDataSource);
}



/* Splitter Node. */
MA_API ma_splitter_node_config ma_splitter_node_config_init(ma_uint32 channels)
{
    ma_splitter_node_config config;

    MA_ZERO_OBJECT(&config);
    config.nodeConfig     = ma_node_config_init();
    config.channels       = channels;
    config.outputBusCount = 2;

    return config;
}


static void ma_splitter_node_process_pcm_frames(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    ma_node_base* pNodeBase = (ma_node_base*)pNode;
    ma_uint32 iOutputBus;
    ma_uint32 channels;

    MA_ASSERT(pNodeBase != NULL);
    MA_ASSERT(ma_node_get_input_bus_count(pNodeBase) == 1);

    /* We don't need to consider the input frame count - it'll be the same as the output frame count and we process everything. */
    (void)pFrameCountIn;

    /* NOTE: This assumes the same number of channels for all inputs and outputs. This was checked in ma_splitter_node_init(). */
    channels = ma_node_get_input_channels(pNodeBase, 0);

    /* Splitting is just copying the first input bus and copying it over to each output bus. */
    for (iOutputBus = 0; iOutputBus < ma_node_get_output_bus_count(pNodeBase); iOutputBus += 1) {
        ma_copy_pcm_frames(ppFramesOut[iOutputBus], ppFramesIn[0], *pFrameCountOut, ma_format_f32, channels);
    }
}

static ma_node_vtable g_ma_splitter_node_vtable =
{
    ma_splitter_node_process_pcm_frames,
    NULL,                       /* onGetRequiredInputFrameCount */
    1,                          /* 1 input bus. */
    MA_NODE_BUS_COUNT_UNKNOWN,  /* The output bus count is specified on a per-node basis. */
    0
};

MA_API ma_result ma_splitter_node_init(ma_node_graph* pNodeGraph, const ma_splitter_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_splitter_node* pSplitterNode)
{
    ma_result result;
    ma_node_config baseConfig;
    ma_uint32 pInputChannels[1];
    ma_uint32 pOutputChannels[MA_MAX_NODE_BUS_COUNT];
    ma_uint32 iOutputBus;

    if (pSplitterNode == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pSplitterNode);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->outputBusCount > MA_MAX_NODE_BUS_COUNT) {
        return MA_INVALID_ARGS; /* Too many output buses. */
    }

    /* Splitters require the same number of channels between inputs and outputs. */
    pInputChannels[0]  = pConfig->channels;
    for (iOutputBus = 0; iOutputBus < pConfig->outputBusCount; iOutputBus += 1) {
        pOutputChannels[iOutputBus] = pConfig->channels;
    }

    baseConfig = pConfig->nodeConfig;
    baseConfig.vtable = &g_ma_splitter_node_vtable;
    baseConfig.pInputChannels  = pInputChannels;
    baseConfig.pOutputChannels = pOutputChannels;
    baseConfig.outputBusCount  = pConfig->outputBusCount;

    result = ma_node_init(pNodeGraph, &baseConfig, pAllocationCallbacks, &pSplitterNode->base);
    if (result != MA_SUCCESS) {
        return result;  /* Failed to initialize the base node. */
    }

    return MA_SUCCESS;
}

MA_API void ma_splitter_node_uninit(ma_splitter_node* pSplitterNode, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_node_uninit(pSplitterNode, pAllocationCallbacks);
}


/*
Biquad Node
*/
MA_API ma_biquad_node_config ma_biquad_node_config_init(ma_uint32 channels, float b0, float b1, float b2, float a0, float a1, float a2)
{
    ma_biquad_node_config config;

    config.nodeConfig = ma_node_config_init();
    config.biquad = ma_biquad_config_init(ma_format_f32, channels, b0, b1, b2, a0, a1, a2);

    return config;
}

static void ma_biquad_node_process_pcm_frames(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    ma_biquad_node* pLPFNode = (ma_biquad_node*)pNode;

    MA_ASSERT(pNode != NULL);
    (void)pFrameCountIn;

    ma_biquad_process_pcm_frames(&pLPFNode->biquad, ppFramesOut[0], ppFramesIn[0], *pFrameCountOut);
}

static ma_node_vtable g_ma_biquad_node_vtable =
{
    ma_biquad_node_process_pcm_frames,
    NULL,   /* onGetRequiredInputFrameCount */
    1,      /* One input. */
    1,      /* One output. */
    0       /* Default flags. */
};

MA_API ma_result ma_biquad_node_init(ma_node_graph* pNodeGraph, const ma_biquad_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_biquad_node* pNode)
{
    ma_result result;
    ma_node_config baseNodeConfig;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pNode);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->biquad.format != ma_format_f32) {
        return MA_INVALID_ARGS; /* The format must be f32. */
    }

    result = ma_biquad_init(&pConfig->biquad, pAllocationCallbacks, &pNode->biquad);
    if (result != MA_SUCCESS) {
        return result;
    }

    baseNodeConfig = ma_node_config_init();
    baseNodeConfig.vtable          = &g_ma_biquad_node_vtable;
    baseNodeConfig.pInputChannels  = &pConfig->biquad.channels;
    baseNodeConfig.pOutputChannels = &pConfig->biquad.channels;

    result = ma_node_init(pNodeGraph, &baseNodeConfig, pAllocationCallbacks, pNode);
    if (result != MA_SUCCESS) {
        return result;
    }

    return result;
}

MA_API ma_result ma_biquad_node_reinit(const ma_biquad_config* pConfig, ma_biquad_node* pNode)
{
    ma_biquad_node* pLPFNode = (ma_biquad_node*)pNode;

    MA_ASSERT(pNode != NULL);

    return ma_biquad_reinit(pConfig, &pLPFNode->biquad);
}

MA_API void ma_biquad_node_uninit(ma_biquad_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_biquad_node* pLPFNode = (ma_biquad_node*)pNode;

    if (pNode == NULL) {
        return;
    }

    ma_node_uninit(pNode, pAllocationCallbacks);
    ma_biquad_uninit(&pLPFNode->biquad, pAllocationCallbacks);
}



/*
Low Pass Filter Node
*/
MA_API ma_lpf_node_config ma_lpf_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order)
{
    ma_lpf_node_config config;

    config.nodeConfig = ma_node_config_init();
    config.lpf = ma_lpf_config_init(ma_format_f32, channels, sampleRate, cutoffFrequency, order);

    return config;
}

static void ma_lpf_node_process_pcm_frames(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    ma_lpf_node* pLPFNode = (ma_lpf_node*)pNode;

    MA_ASSERT(pNode != NULL);
    (void)pFrameCountIn;

    ma_lpf_process_pcm_frames(&pLPFNode->lpf, ppFramesOut[0], ppFramesIn[0], *pFrameCountOut);
}

static ma_node_vtable g_ma_lpf_node_vtable =
{
    ma_lpf_node_process_pcm_frames,
    NULL,   /* onGetRequiredInputFrameCount */
    1,      /* One input. */
    1,      /* One output. */
    0       /* Default flags. */
};

MA_API ma_result ma_lpf_node_init(ma_node_graph* pNodeGraph, const ma_lpf_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_lpf_node* pNode)
{
    ma_result result;
    ma_node_config baseNodeConfig;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pNode);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->lpf.format != ma_format_f32) {
        return MA_INVALID_ARGS; /* The format must be f32. */
    }

    result = ma_lpf_init(&pConfig->lpf, pAllocationCallbacks, &pNode->lpf);
    if (result != MA_SUCCESS) {
        return result;
    }

    baseNodeConfig = ma_node_config_init();
    baseNodeConfig.vtable          = &g_ma_lpf_node_vtable;
    baseNodeConfig.pInputChannels  = &pConfig->lpf.channels;
    baseNodeConfig.pOutputChannels = &pConfig->lpf.channels;

    result = ma_node_init(pNodeGraph, &baseNodeConfig, pAllocationCallbacks, pNode);
    if (result != MA_SUCCESS) {
        return result;
    }

    return result;
}

MA_API ma_result ma_lpf_node_reinit(const ma_lpf_config* pConfig, ma_lpf_node* pNode)
{
    ma_lpf_node* pLPFNode = (ma_lpf_node*)pNode;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_lpf_reinit(pConfig, &pLPFNode->lpf);
}

MA_API void ma_lpf_node_uninit(ma_lpf_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_lpf_node* pLPFNode = (ma_lpf_node*)pNode;

    if (pNode == NULL) {
        return;
    }

    ma_node_uninit(pNode, pAllocationCallbacks);
    ma_lpf_uninit(&pLPFNode->lpf, pAllocationCallbacks);
}



/*
High Pass Filter Node
*/
MA_API ma_hpf_node_config ma_hpf_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order)
{
    ma_hpf_node_config config;

    config.nodeConfig = ma_node_config_init();
    config.hpf = ma_hpf_config_init(ma_format_f32, channels, sampleRate, cutoffFrequency, order);

    return config;
}

static void ma_hpf_node_process_pcm_frames(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    ma_hpf_node* pHPFNode = (ma_hpf_node*)pNode;

    MA_ASSERT(pNode != NULL);
    (void)pFrameCountIn;

    ma_hpf_process_pcm_frames(&pHPFNode->hpf, ppFramesOut[0], ppFramesIn[0], *pFrameCountOut);
}

static ma_node_vtable g_ma_hpf_node_vtable =
{
    ma_hpf_node_process_pcm_frames,
    NULL,   /* onGetRequiredInputFrameCount */
    1,      /* One input. */
    1,      /* One output. */
    0       /* Default flags. */
};

MA_API ma_result ma_hpf_node_init(ma_node_graph* pNodeGraph, const ma_hpf_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hpf_node* pNode)
{
    ma_result result;
    ma_node_config baseNodeConfig;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pNode);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->hpf.format != ma_format_f32) {
        return MA_INVALID_ARGS; /* The format must be f32. */
    }

    result = ma_hpf_init(&pConfig->hpf, pAllocationCallbacks, &pNode->hpf);
    if (result != MA_SUCCESS) {
        return result;
    }

    baseNodeConfig = ma_node_config_init();
    baseNodeConfig.vtable          = &g_ma_hpf_node_vtable;
    baseNodeConfig.pInputChannels  = &pConfig->hpf.channels;
    baseNodeConfig.pOutputChannels = &pConfig->hpf.channels;

    result = ma_node_init(pNodeGraph, &baseNodeConfig, pAllocationCallbacks, pNode);
    if (result != MA_SUCCESS) {
        return result;
    }

    return result;
}

MA_API ma_result ma_hpf_node_reinit(const ma_hpf_config* pConfig, ma_hpf_node* pNode)
{
    ma_hpf_node* pHPFNode = (ma_hpf_node*)pNode;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_hpf_reinit(pConfig, &pHPFNode->hpf);
}

MA_API void ma_hpf_node_uninit(ma_hpf_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_hpf_node* pHPFNode = (ma_hpf_node*)pNode;

    if (pNode == NULL) {
        return;
    }

    ma_node_uninit(pNode, pAllocationCallbacks);
    ma_hpf_uninit(&pHPFNode->hpf, pAllocationCallbacks);
}




/*
Band Pass Filter Node
*/
MA_API ma_bpf_node_config ma_bpf_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency, ma_uint32 order)
{
    ma_bpf_node_config config;

    config.nodeConfig = ma_node_config_init();
    config.bpf = ma_bpf_config_init(ma_format_f32, channels, sampleRate, cutoffFrequency, order);

    return config;
}

static void ma_bpf_node_process_pcm_frames(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    ma_bpf_node* pBPFNode = (ma_bpf_node*)pNode;

    MA_ASSERT(pNode != NULL);
    (void)pFrameCountIn;

    ma_bpf_process_pcm_frames(&pBPFNode->bpf, ppFramesOut[0], ppFramesIn[0], *pFrameCountOut);
}

static ma_node_vtable g_ma_bpf_node_vtable =
{
    ma_bpf_node_process_pcm_frames,
    NULL,   /* onGetRequiredInputFrameCount */
    1,      /* One input. */
    1,      /* One output. */
    0       /* Default flags. */
};

MA_API ma_result ma_bpf_node_init(ma_node_graph* pNodeGraph, const ma_bpf_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_bpf_node* pNode)
{
    ma_result result;
    ma_node_config baseNodeConfig;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pNode);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->bpf.format != ma_format_f32) {
        return MA_INVALID_ARGS; /* The format must be f32. */
    }

    result = ma_bpf_init(&pConfig->bpf, pAllocationCallbacks, &pNode->bpf);
    if (result != MA_SUCCESS) {
        return result;
    }

    baseNodeConfig = ma_node_config_init();
    baseNodeConfig.vtable          = &g_ma_bpf_node_vtable;
    baseNodeConfig.pInputChannels  = &pConfig->bpf.channels;
    baseNodeConfig.pOutputChannels = &pConfig->bpf.channels;

    result = ma_node_init(pNodeGraph, &baseNodeConfig, pAllocationCallbacks, pNode);
    if (result != MA_SUCCESS) {
        return result;
    }

    return result;
}

MA_API ma_result ma_bpf_node_reinit(const ma_bpf_config* pConfig, ma_bpf_node* pNode)
{
    ma_bpf_node* pBPFNode = (ma_bpf_node*)pNode;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_bpf_reinit(pConfig, &pBPFNode->bpf);
}

MA_API void ma_bpf_node_uninit(ma_bpf_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_bpf_node* pBPFNode = (ma_bpf_node*)pNode;

    if (pNode == NULL) {
        return;
    }

    ma_node_uninit(pNode, pAllocationCallbacks);
    ma_bpf_uninit(&pBPFNode->bpf, pAllocationCallbacks);
}



/*
Notching Filter Node
*/
MA_API ma_notch_node_config ma_notch_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double q, double frequency)
{
    ma_notch_node_config config;

    config.nodeConfig = ma_node_config_init();
    config.notch = ma_notch2_config_init(ma_format_f32, channels, sampleRate, q, frequency);

    return config;
}

static void ma_notch_node_process_pcm_frames(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    ma_notch_node* pBPFNode = (ma_notch_node*)pNode;

    MA_ASSERT(pNode != NULL);
    (void)pFrameCountIn;

    ma_notch2_process_pcm_frames(&pBPFNode->notch, ppFramesOut[0], ppFramesIn[0], *pFrameCountOut);
}

static ma_node_vtable g_ma_notch_node_vtable =
{
    ma_notch_node_process_pcm_frames,
    NULL,   /* onGetRequiredInputFrameCount */
    1,      /* One input. */
    1,      /* One output. */
    0       /* Default flags. */
};

MA_API ma_result ma_notch_node_init(ma_node_graph* pNodeGraph, const ma_notch_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_notch_node* pNode)
{
    ma_result result;
    ma_node_config baseNodeConfig;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pNode);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->notch.format != ma_format_f32) {
        return MA_INVALID_ARGS; /* The format must be f32. */
    }

    result = ma_notch2_init(&pConfig->notch, pAllocationCallbacks, &pNode->notch);
    if (result != MA_SUCCESS) {
        return result;
    }

    baseNodeConfig = ma_node_config_init();
    baseNodeConfig.vtable          = &g_ma_notch_node_vtable;
    baseNodeConfig.pInputChannels  = &pConfig->notch.channels;
    baseNodeConfig.pOutputChannels = &pConfig->notch.channels;

    result = ma_node_init(pNodeGraph, &baseNodeConfig, pAllocationCallbacks, pNode);
    if (result != MA_SUCCESS) {
        return result;
    }

    return result;
}

MA_API ma_result ma_notch_node_reinit(const ma_notch_config* pConfig, ma_notch_node* pNode)
{
    ma_notch_node* pNotchNode = (ma_notch_node*)pNode;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_notch2_reinit(pConfig, &pNotchNode->notch);
}

MA_API void ma_notch_node_uninit(ma_notch_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_notch_node* pNotchNode = (ma_notch_node*)pNode;

    if (pNode == NULL) {
        return;
    }

    ma_node_uninit(pNode, pAllocationCallbacks);
    ma_notch2_uninit(&pNotchNode->notch, pAllocationCallbacks);
}



/*
Peaking Filter Node
*/
MA_API ma_peak_node_config ma_peak_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double q, double frequency)
{
    ma_peak_node_config config;

    config.nodeConfig = ma_node_config_init();
    config.peak = ma_peak2_config_init(ma_format_f32, channels, sampleRate, gainDB, q, frequency);

    return config;
}

static void ma_peak_node_process_pcm_frames(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    ma_peak_node* pBPFNode = (ma_peak_node*)pNode;

    MA_ASSERT(pNode != NULL);
    (void)pFrameCountIn;

    ma_peak2_process_pcm_frames(&pBPFNode->peak, ppFramesOut[0], ppFramesIn[0], *pFrameCountOut);
}

static ma_node_vtable g_ma_peak_node_vtable =
{
    ma_peak_node_process_pcm_frames,
    NULL,   /* onGetRequiredInputFrameCount */
    1,      /* One input. */
    1,      /* One output. */
    0       /* Default flags. */
};

MA_API ma_result ma_peak_node_init(ma_node_graph* pNodeGraph, const ma_peak_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_peak_node* pNode)
{
    ma_result result;
    ma_node_config baseNodeConfig;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pNode);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->peak.format != ma_format_f32) {
        return MA_INVALID_ARGS; /* The format must be f32. */
    }

    result = ma_peak2_init(&pConfig->peak, pAllocationCallbacks, &pNode->peak);
    if (result != MA_SUCCESS) {
        ma_node_uninit(pNode, pAllocationCallbacks);
        return result;
    }

    baseNodeConfig = ma_node_config_init();
    baseNodeConfig.vtable          = &g_ma_peak_node_vtable;
    baseNodeConfig.pInputChannels  = &pConfig->peak.channels;
    baseNodeConfig.pOutputChannels = &pConfig->peak.channels;

    result = ma_node_init(pNodeGraph, &baseNodeConfig, pAllocationCallbacks, pNode);
    if (result != MA_SUCCESS) {
        return result;
    }

    return result;
}

MA_API ma_result ma_peak_node_reinit(const ma_peak_config* pConfig, ma_peak_node* pNode)
{
    ma_peak_node* pPeakNode = (ma_peak_node*)pNode;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_peak2_reinit(pConfig, &pPeakNode->peak);
}

MA_API void ma_peak_node_uninit(ma_peak_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_peak_node* pPeakNode = (ma_peak_node*)pNode;

    if (pNode == NULL) {
        return;
    }

    ma_node_uninit(pNode, pAllocationCallbacks);
    ma_peak2_uninit(&pPeakNode->peak, pAllocationCallbacks);
}



/*
Low Shelf Filter Node
*/
MA_API ma_loshelf_node_config ma_loshelf_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double q, double frequency)
{
    ma_loshelf_node_config config;

    config.nodeConfig = ma_node_config_init();
    config.loshelf = ma_loshelf2_config_init(ma_format_f32, channels, sampleRate, gainDB, q, frequency);

    return config;
}

static void ma_loshelf_node_process_pcm_frames(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    ma_loshelf_node* pBPFNode = (ma_loshelf_node*)pNode;

    MA_ASSERT(pNode != NULL);
    (void)pFrameCountIn;

    ma_loshelf2_process_pcm_frames(&pBPFNode->loshelf, ppFramesOut[0], ppFramesIn[0], *pFrameCountOut);
}

static ma_node_vtable g_ma_loshelf_node_vtable =
{
    ma_loshelf_node_process_pcm_frames,
    NULL,   /* onGetRequiredInputFrameCount */
    1,      /* One input. */
    1,      /* One output. */
    0       /* Default flags. */
};

MA_API ma_result ma_loshelf_node_init(ma_node_graph* pNodeGraph, const ma_loshelf_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_loshelf_node* pNode)
{
    ma_result result;
    ma_node_config baseNodeConfig;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pNode);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->loshelf.format != ma_format_f32) {
        return MA_INVALID_ARGS; /* The format must be f32. */
    }

    result = ma_loshelf2_init(&pConfig->loshelf, pAllocationCallbacks, &pNode->loshelf);
    if (result != MA_SUCCESS) {
        return result;
    }

    baseNodeConfig = ma_node_config_init();
    baseNodeConfig.vtable          = &g_ma_loshelf_node_vtable;
    baseNodeConfig.pInputChannels  = &pConfig->loshelf.channels;
    baseNodeConfig.pOutputChannels = &pConfig->loshelf.channels;

    result = ma_node_init(pNodeGraph, &baseNodeConfig, pAllocationCallbacks, pNode);
    if (result != MA_SUCCESS) {
        return result;
    }

    return result;
}

MA_API ma_result ma_loshelf_node_reinit(const ma_loshelf_config* pConfig, ma_loshelf_node* pNode)
{
    ma_loshelf_node* pLoshelfNode = (ma_loshelf_node*)pNode;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_loshelf2_reinit(pConfig, &pLoshelfNode->loshelf);
}

MA_API void ma_loshelf_node_uninit(ma_loshelf_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_loshelf_node* pLoshelfNode = (ma_loshelf_node*)pNode;

    if (pNode == NULL) {
        return;
    }

    ma_node_uninit(pNode, pAllocationCallbacks);
    ma_loshelf2_uninit(&pLoshelfNode->loshelf, pAllocationCallbacks);
}



/*
High Shelf Filter Node
*/
MA_API ma_hishelf_node_config ma_hishelf_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, double gainDB, double q, double frequency)
{
    ma_hishelf_node_config config;

    config.nodeConfig = ma_node_config_init();
    config.hishelf = ma_hishelf2_config_init(ma_format_f32, channels, sampleRate, gainDB, q, frequency);

    return config;
}

static void ma_hishelf_node_process_pcm_frames(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    ma_hishelf_node* pBPFNode = (ma_hishelf_node*)pNode;

    MA_ASSERT(pNode != NULL);
    (void)pFrameCountIn;

    ma_hishelf2_process_pcm_frames(&pBPFNode->hishelf, ppFramesOut[0], ppFramesIn[0], *pFrameCountOut);
}

static ma_node_vtable g_ma_hishelf_node_vtable =
{
    ma_hishelf_node_process_pcm_frames,
    NULL,   /* onGetRequiredInputFrameCount */
    1,      /* One input. */
    1,      /* One output. */
    0       /* Default flags. */
};

MA_API ma_result ma_hishelf_node_init(ma_node_graph* pNodeGraph, const ma_hishelf_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_hishelf_node* pNode)
{
    ma_result result;
    ma_node_config baseNodeConfig;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pNode);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->hishelf.format != ma_format_f32) {
        return MA_INVALID_ARGS; /* The format must be f32. */
    }

    result = ma_hishelf2_init(&pConfig->hishelf, pAllocationCallbacks, &pNode->hishelf);
    if (result != MA_SUCCESS) {
        return result;
    }

    baseNodeConfig = ma_node_config_init();
    baseNodeConfig.vtable          = &g_ma_hishelf_node_vtable;
    baseNodeConfig.pInputChannels  = &pConfig->hishelf.channels;
    baseNodeConfig.pOutputChannels = &pConfig->hishelf.channels;

    result = ma_node_init(pNodeGraph, &baseNodeConfig, pAllocationCallbacks, pNode);
    if (result != MA_SUCCESS) {
        return result;
    }

    return result;
}

MA_API ma_result ma_hishelf_node_reinit(const ma_hishelf_config* pConfig, ma_hishelf_node* pNode)
{
    ma_hishelf_node* pHishelfNode = (ma_hishelf_node*)pNode;

    if (pNode == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_hishelf2_reinit(pConfig, &pHishelfNode->hishelf);
}

MA_API void ma_hishelf_node_uninit(ma_hishelf_node* pNode, const ma_allocation_callbacks* pAllocationCallbacks)
{
    ma_hishelf_node* pHishelfNode = (ma_hishelf_node*)pNode;

    if (pNode == NULL) {
        return;
    }

    ma_node_uninit(pNode, pAllocationCallbacks);
    ma_hishelf2_uninit(&pHishelfNode->hishelf, pAllocationCallbacks);
}




MA_API ma_delay_node_config ma_delay_node_config_init(ma_uint32 channels, ma_uint32 sampleRate, ma_uint32 delayInFrames, float decay)
{
    ma_delay_node_config config;

    config.nodeConfig = ma_node_config_init();
    config.delay = ma_delay_config_init(channels, sampleRate, delayInFrames, decay);

    return config;
}


static void ma_delay_node_process_pcm_frames(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    ma_delay_node* pDelayNode = (ma_delay_node*)pNode;

    (void)pFrameCountIn;

    ma_delay_process_pcm_frames(&pDelayNode->delay, ppFramesOut[0], ppFramesIn[0], *pFrameCountOut);
}

static ma_node_vtable g_ma_delay_node_vtable =
{
    ma_delay_node_process_pcm_frames,
    NULL,
    1,  /* 1 input channels. */
    1,  /* 1 output channel. */
    MA_NODE_FLAG_CONTINUOUS_PROCESSING  /* Delay requires continuous processing to ensure the tail get's processed. */
};

MA_API ma_result ma_delay_node_init(ma_node_graph* pNodeGraph, const ma_delay_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_delay_node* pDelayNode)
{
    ma_result result;
    ma_node_config baseConfig;

    if (pDelayNode == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pDelayNode);

    result = ma_delay_init(&pConfig->delay, pAllocationCallbacks, &pDelayNode->delay);
    if (result != MA_SUCCESS) {
        return result;
    }

    baseConfig = pConfig->nodeConfig;
    baseConfig.vtable          = &g_ma_delay_node_vtable;
    baseConfig.pInputChannels  = &pConfig->delay.channels;
    baseConfig.pOutputChannels = &pConfig->delay.channels;

    result = ma_node_init(pNodeGraph, &baseConfig, pAllocationCallbacks, &pDelayNode->baseNode);
    if (result != MA_SUCCESS) {
        ma_delay_uninit(&pDelayNode->delay, pAllocationCallbacks);
        return result;
    }

    return result;
}

MA_API void ma_delay_node_uninit(ma_delay_node* pDelayNode, const ma_allocation_callbacks* pAllocationCallbacks)
{
    if (pDelayNode == NULL) {
        return;
    }

    /* The base node is always uninitialized first. */
    ma_node_uninit(pDelayNode, pAllocationCallbacks);
    ma_delay_uninit(&pDelayNode->delay, pAllocationCallbacks);
}

MA_API void ma_delay_node_set_wet(ma_delay_node* pDelayNode, float value)
{
    if (pDelayNode == NULL) {
        return;
    }

    ma_delay_set_wet(&pDelayNode->delay, value);
}

MA_API float ma_delay_node_get_wet(const ma_delay_node* pDelayNode)
{
    if (pDelayNode == NULL) {
        return 0;
    }

    return ma_delay_get_wet(&pDelayNode->delay);
}

MA_API void ma_delay_node_set_dry(ma_delay_node* pDelayNode, float value)
{
    if (pDelayNode == NULL) {
        return;
    }

    ma_delay_set_dry(&pDelayNode->delay, value);
}

MA_API float ma_delay_node_get_dry(const ma_delay_node* pDelayNode)
{
    if (pDelayNode == NULL) {
        return 0;
    }

    return ma_delay_get_dry(&pDelayNode->delay);
}

MA_API void ma_delay_node_set_decay(ma_delay_node* pDelayNode, float value)
{
    if (pDelayNode == NULL) {
        return;
    }

    ma_delay_set_decay(&pDelayNode->delay, value);
}

MA_API float ma_delay_node_get_decay(const ma_delay_node* pDelayNode)
{
    if (pDelayNode == NULL) {
        return 0;
    }

    return ma_delay_get_decay(&pDelayNode->delay);
}
#endif  /* MA_NO_NODE_GRAPH */


/* SECTION: miniaudio_engine.c */
#if !defined(MA_NO_ENGINE) && !defined(MA_NO_NODE_GRAPH)
/**************************************************************************************************************************************************************

Engine

**************************************************************************************************************************************************************/
#define MA_SEEK_TARGET_NONE         (~(ma_uint64)0)


static void ma_sound_set_at_end(ma_sound* pSound, ma_bool32 atEnd)
{
    MA_ASSERT(pSound != NULL);
    ma_atomic_exchange_32(&pSound->atEnd, atEnd);

    /* Fire any callbacks or events. */
    if (atEnd) {
        if (pSound->endCallback != NULL) {
            pSound->endCallback(pSound->pEndCallbackUserData, pSound);
        }
    }
}

static ma_bool32 ma_sound_get_at_end(const ma_sound* pSound)
{
    MA_ASSERT(pSound != NULL);
    return ma_atomic_load_32(&pSound->atEnd);
}


MA_API ma_engine_node_config ma_engine_node_config_init(ma_engine* pEngine, ma_engine_node_type type, ma_uint32 flags)
{
    ma_engine_node_config config;

    MA_ZERO_OBJECT(&config);
    config.pEngine                  = pEngine;
    config.type                     = type;
    config.isPitchDisabled          = (flags & MA_SOUND_FLAG_NO_PITCH) != 0;
    config.isSpatializationDisabled = (flags & MA_SOUND_FLAG_NO_SPATIALIZATION) != 0;
    config.monoExpansionMode        = pEngine->monoExpansionMode;

    return config;
}


static void ma_engine_node_update_pitch_if_required(ma_engine_node* pEngineNode)
{
    ma_bool32 isUpdateRequired = MA_FALSE;
    float newPitch;

    MA_ASSERT(pEngineNode != NULL);

    newPitch = ma_atomic_load_explicit_f32(&pEngineNode->pitch, ma_atomic_memory_order_acquire);

    if (pEngineNode->oldPitch != newPitch) {
        pEngineNode->oldPitch  = newPitch;
        isUpdateRequired = MA_TRUE;
    }

    if (pEngineNode->oldDopplerPitch != pEngineNode->spatializer.dopplerPitch) {
        pEngineNode->oldDopplerPitch  = pEngineNode->spatializer.dopplerPitch;
        isUpdateRequired = MA_TRUE;
    }

    if (isUpdateRequired) {
        float basePitch = (float)pEngineNode->sampleRate / ma_engine_get_sample_rate(pEngineNode->pEngine);
        ma_linear_resampler_set_rate_ratio(&pEngineNode->resampler, basePitch * pEngineNode->oldPitch * pEngineNode->oldDopplerPitch);
    }
}

static ma_bool32 ma_engine_node_is_pitching_enabled(const ma_engine_node* pEngineNode)
{
    MA_ASSERT(pEngineNode != NULL);

    /* Don't try to be clever by skipping resampling in the pitch=1 case or else you'll glitch when moving away from 1. */
    return !ma_atomic_load_explicit_32(&pEngineNode->isPitchDisabled, ma_atomic_memory_order_acquire);
}

static ma_bool32 ma_engine_node_is_spatialization_enabled(const ma_engine_node* pEngineNode)
{
    MA_ASSERT(pEngineNode != NULL);

    return !ma_atomic_load_explicit_32(&pEngineNode->isSpatializationDisabled, ma_atomic_memory_order_acquire);
}

static ma_uint64 ma_engine_node_get_required_input_frame_count(const ma_engine_node* pEngineNode, ma_uint64 outputFrameCount)
{
    ma_uint64 inputFrameCount = 0;

    if (ma_engine_node_is_pitching_enabled(pEngineNode)) {
        ma_result result = ma_linear_resampler_get_required_input_frame_count(&pEngineNode->resampler, outputFrameCount, &inputFrameCount);
        if (result != MA_SUCCESS) {
            inputFrameCount = 0;
        }
    } else {
        inputFrameCount = outputFrameCount;    /* No resampling, so 1:1. */
    }

    return inputFrameCount;
}

static ma_result ma_engine_node_set_volume(ma_engine_node* pEngineNode, float volume)
{
    if (pEngineNode == NULL) {
        return MA_INVALID_ARGS;
    }

    ma_atomic_float_set(&pEngineNode->volume, volume);

    /* If we're not smoothing we should bypass the volume gainer entirely. */
    if (pEngineNode->volumeSmoothTimeInPCMFrames == 0) {
        /* We should always have an active spatializer because it can be enabled and disabled dynamically. We can just use that for holding our volume. */
        ma_spatializer_set_master_volume(&pEngineNode->spatializer, volume);
    } else {
        /* We're using volume smoothing, so apply the master volume to the gainer. */
        ma_gainer_set_gain(&pEngineNode->volumeGainer, volume);
    }

    return MA_SUCCESS;
}

static ma_result ma_engine_node_get_volume(const ma_engine_node* pEngineNode, float* pVolume)
{
    if (pVolume == NULL) {
        return MA_INVALID_ARGS;
    }

    *pVolume = 0.0f;

    if (pEngineNode == NULL) {
        return MA_INVALID_ARGS;
    }

    *pVolume = ma_atomic_float_get((ma_atomic_float*)&pEngineNode->volume);

    return MA_SUCCESS;
}


static void ma_engine_node_process_pcm_frames__general(ma_engine_node* pEngineNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    ma_uint32 frameCountIn;
    ma_uint32 frameCountOut;
    ma_uint32 totalFramesProcessedIn;
    ma_uint32 totalFramesProcessedOut;
    ma_uint32 channelsIn;
    ma_uint32 channelsOut;
    ma_bool32 isPitchingEnabled;
    ma_bool32 isFadingEnabled;
    ma_bool32 isSpatializationEnabled;
    ma_bool32 isPanningEnabled;
    ma_bool32 isVolumeSmoothingEnabled;

    frameCountIn  = *pFrameCountIn;
    frameCountOut = *pFrameCountOut;

    channelsIn  = ma_spatializer_get_input_channels(&pEngineNode->spatializer);
    channelsOut = ma_spatializer_get_output_channels(&pEngineNode->spatializer);

    totalFramesProcessedIn  = 0;
    totalFramesProcessedOut = 0;

    /* Update the fader if applicable. */
    {
        ma_uint64 fadeLengthInFrames = ma_atomic_uint64_get(&pEngineNode->fadeSettings.fadeLengthInFrames);
        if (fadeLengthInFrames != ~(ma_uint64)0) {
            float fadeVolumeBeg = ma_atomic_float_get(&pEngineNode->fadeSettings.volumeBeg);
            float fadeVolumeEnd = ma_atomic_float_get(&pEngineNode->fadeSettings.volumeEnd);
            ma_int64 fadeStartOffsetInFrames = (ma_int64)ma_atomic_uint64_get(&pEngineNode->fadeSettings.absoluteGlobalTimeInFrames);
            if (fadeStartOffsetInFrames == (ma_int64)(~(ma_uint64)0)) {
                fadeStartOffsetInFrames = 0;
            } else {
                fadeStartOffsetInFrames -= ma_engine_get_time_in_pcm_frames(pEngineNode->pEngine);
            }

            ma_fader_set_fade_ex(&pEngineNode->fader, fadeVolumeBeg, fadeVolumeEnd, fadeLengthInFrames, fadeStartOffsetInFrames);

            /* Reset the fade length so we don't erroneously apply it again. */
            ma_atomic_uint64_set(&pEngineNode->fadeSettings.fadeLengthInFrames, ~(ma_uint64)0);
        }
    }

    isPitchingEnabled        = ma_engine_node_is_pitching_enabled(pEngineNode);
    isFadingEnabled          = pEngineNode->fader.volumeBeg != 1 || pEngineNode->fader.volumeEnd != 1;
    isSpatializationEnabled  = ma_engine_node_is_spatialization_enabled(pEngineNode);
    isPanningEnabled         = pEngineNode->panner.pan != 0 && channelsOut != 1;
    isVolumeSmoothingEnabled = pEngineNode->volumeSmoothTimeInPCMFrames > 0;

    /* Keep going while we've still got data available for processing. */
    while (totalFramesProcessedOut < frameCountOut) {
        /*
        We need to process in a specific order. We always do resampling first because it's likely
        we're going to be increasing the channel count after spatialization. Also, I want to do
        fading based on the output sample rate.

        We'll first read into a buffer from the resampler. Then we'll do all processing that
        operates on the on the input channel count. We'll then get the spatializer to output to
        the output buffer and then do all effects from that point directly in the output buffer
        in-place.

        Note that we're always running the resampler if pitching is enabled, even when the pitch
        is 1. If we try to be clever and skip resampling when the pitch is 1, we'll get a glitch
        when we move away from 1, back to 1, and then away from 1 again. We'll want to implement
        any pitch=1 optimizations in the resampler itself.

        There's a small optimization here that we'll utilize since it might be a fairly common
        case. When the input and output channel counts are the same, we'll read straight into the
        output buffer from the resampler and do everything in-place.
        */
        const float* pRunningFramesIn;
        float* pRunningFramesOut;
        float* pWorkingBuffer;   /* This is the buffer that we'll be processing frames in. This is in input channels. */
        float temp[MA_DATA_CONVERTER_STACK_BUFFER_SIZE / sizeof(float)];
        ma_uint32 tempCapInFrames = ma_countof(temp) / channelsIn;
        ma_uint32 framesAvailableIn;
        ma_uint32 framesAvailableOut;
        ma_uint32 framesJustProcessedIn;
        ma_uint32 framesJustProcessedOut;
        ma_bool32 isWorkingBufferValid = MA_FALSE;

        framesAvailableIn  = frameCountIn  - totalFramesProcessedIn;
        framesAvailableOut = frameCountOut - totalFramesProcessedOut;

        pRunningFramesIn  = ma_offset_pcm_frames_const_ptr_f32(ppFramesIn[0], totalFramesProcessedIn, channelsIn);
        pRunningFramesOut = ma_offset_pcm_frames_ptr_f32(ppFramesOut[0], totalFramesProcessedOut, channelsOut);

        if (channelsIn == channelsOut) {
            /* Fast path. Channel counts are the same. No need for an intermediary input buffer. */
            pWorkingBuffer = pRunningFramesOut;
        } else {
            /* Slow path. Channel counts are different. Need to use an intermediary input buffer. */
            pWorkingBuffer = temp;
            if (framesAvailableOut > tempCapInFrames) {
                framesAvailableOut = tempCapInFrames;
            }
        }

        /* First is resampler. */
        if (isPitchingEnabled) {
            ma_uint64 resampleFrameCountIn  = framesAvailableIn;
            ma_uint64 resampleFrameCountOut = framesAvailableOut;

            ma_linear_resampler_process_pcm_frames(&pEngineNode->resampler, pRunningFramesIn, &resampleFrameCountIn, pWorkingBuffer, &resampleFrameCountOut);
            isWorkingBufferValid = MA_TRUE;

            framesJustProcessedIn  = (ma_uint32)resampleFrameCountIn;
            framesJustProcessedOut = (ma_uint32)resampleFrameCountOut;
        } else {
            framesJustProcessedIn  = ma_min(framesAvailableIn, framesAvailableOut);
            framesJustProcessedOut = framesJustProcessedIn; /* When no resampling is being performed, the number of output frames is the same as input frames. */
        }

        /* Fading. */
        if (isFadingEnabled) {
            if (isWorkingBufferValid) {
                ma_fader_process_pcm_frames(&pEngineNode->fader, pWorkingBuffer, pWorkingBuffer, framesJustProcessedOut);   /* In-place processing. */
            } else {
                ma_fader_process_pcm_frames(&pEngineNode->fader, pWorkingBuffer, pRunningFramesIn, framesJustProcessedOut);
                isWorkingBufferValid = MA_TRUE;
            }
        }

        /*
        If we're using smoothing, we won't be applying volume via the spatializer, but instead from a ma_gainer. In this case
        we'll want to apply our volume now.
        */
        if (isVolumeSmoothingEnabled) {
            if (isWorkingBufferValid) {
                ma_gainer_process_pcm_frames(&pEngineNode->volumeGainer, pWorkingBuffer, pWorkingBuffer, framesJustProcessedOut);
            } else {
                ma_gainer_process_pcm_frames(&pEngineNode->volumeGainer, pWorkingBuffer, pRunningFramesIn, framesJustProcessedOut);
                isWorkingBufferValid = MA_TRUE;
            }
        }

        /*
        If at this point we still haven't actually done anything with the working buffer we need
        to just read straight from the input buffer.
        */
        if (isWorkingBufferValid == MA_FALSE) {
            pWorkingBuffer = (float*)pRunningFramesIn;  /* Naughty const cast, but it's safe at this point because we won't ever be writing to it from this point out. */
        }

        /* Spatialization. */
        if (isSpatializationEnabled) {
            ma_uint32 iListener;

            /*
            When determining the listener to use, we first check to see if the sound is pinned to a
            specific listener. If so, we use that. Otherwise we just use the closest listener.
            */
            if (pEngineNode->pinnedListenerIndex != MA_LISTENER_INDEX_CLOSEST && pEngineNode->pinnedListenerIndex < ma_engine_get_listener_count(pEngineNode->pEngine)) {
                iListener = pEngineNode->pinnedListenerIndex;
            } else {
                ma_vec3f spatializerPosition = ma_spatializer_get_position(&pEngineNode->spatializer);
                iListener = ma_engine_find_closest_listener(pEngineNode->pEngine, spatializerPosition.x, spatializerPosition.y, spatializerPosition.z);
            }

            ma_spatializer_process_pcm_frames(&pEngineNode->spatializer, &pEngineNode->pEngine->listeners[iListener], pRunningFramesOut, pWorkingBuffer, framesJustProcessedOut);
        } else {
            /* No spatialization, but we still need to do channel conversion and master volume. */
            float volume;
            ma_engine_node_get_volume(pEngineNode, &volume);    /* Should never fail. */

            if (channelsIn == channelsOut) {
                /* No channel conversion required. Just copy straight to the output buffer. */
                if (isVolumeSmoothingEnabled) {
                    /* Volume has already been applied. Just copy straight to the output buffer. */
                    ma_copy_pcm_frames(pRunningFramesOut, pWorkingBuffer, framesJustProcessedOut * channelsOut, ma_format_f32, channelsOut);
                } else {
                    /* Volume has not been applied yet. Copy and apply volume in the same pass. */
                    ma_copy_and_apply_volume_factor_f32(pRunningFramesOut, pWorkingBuffer, framesJustProcessedOut * channelsOut, volume);
                }
            } else {
                /* Channel conversion required. TODO: Add support for channel maps here. */
                ma_channel_map_apply_f32(pRunningFramesOut, NULL, channelsOut, pWorkingBuffer, NULL, channelsIn, framesJustProcessedOut, ma_channel_mix_mode_simple, pEngineNode->monoExpansionMode);

                /* If we're using smoothing, the volume will have already been applied. */
                if (!isVolumeSmoothingEnabled) {
                    ma_apply_volume_factor_f32(pRunningFramesOut, framesJustProcessedOut * channelsOut, volume);
                }
            }
        }

        /* At this point we can guarantee that the output buffer contains valid data. We can process everything in place now. */

        /* Panning. */
        if (isPanningEnabled) {
            ma_panner_process_pcm_frames(&pEngineNode->panner, pRunningFramesOut, pRunningFramesOut, framesJustProcessedOut);   /* In-place processing. */
        }

        /* We're done for this chunk. */
        totalFramesProcessedIn  += framesJustProcessedIn;
        totalFramesProcessedOut += framesJustProcessedOut;

        /* If we didn't process any output frames this iteration it means we've either run out of input data, or run out of room in the output buffer. */
        if (framesJustProcessedOut == 0) {
            break;
        }
    }

    /* At this point we're done processing. */
    *pFrameCountIn  = totalFramesProcessedIn;
    *pFrameCountOut = totalFramesProcessedOut;
}

static void ma_engine_node_process_pcm_frames__sound(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    /* For sounds, we need to first read from the data source. Then we need to apply the engine effects (pan, pitch, fades, etc.). */
    ma_result result = MA_SUCCESS;
    ma_sound* pSound = (ma_sound*)pNode;
    ma_uint32 frameCount = *pFrameCountOut;
    ma_uint32 totalFramesRead = 0;
    ma_format dataSourceFormat;
    ma_uint32 dataSourceChannels;
    ma_uint8 temp[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
    ma_uint32 tempCapInFrames;
    ma_uint64 seekTarget;

    /* This is a data source node which means no input buses. */
    (void)ppFramesIn;
    (void)pFrameCountIn;

    /* If we're marked at the end we need to stop the sound and do nothing. */
    if (ma_sound_at_end(pSound)) {
        ma_sound_stop(pSound);
        *pFrameCountOut = 0;
        return;
    }

    /* If we're seeking, do so now before reading. */
    seekTarget = ma_atomic_load_64(&pSound->seekTarget);
    if (seekTarget != MA_SEEK_TARGET_NONE) {
        ma_data_source_seek_to_pcm_frame(pSound->pDataSource, seekTarget);

        /* Any time-dependant effects need to have their times updated. */
        ma_node_set_time(pSound, seekTarget);

        ma_atomic_exchange_64(&pSound->seekTarget, MA_SEEK_TARGET_NONE);
    }

    /*
    We want to update the pitch once. For sounds, this can be either at the start or at the end. If
    we don't force this to only ever be updating once, we could end up in a situation where
    retrieving the required input frame count ends up being different to what we actually retrieve.
    What could happen is that the required input frame count is calculated, the pitch is update,
    and then this processing function is called resulting in a different number of input frames
    being processed. Do not call this in ma_engine_node_process_pcm_frames__general() or else
    you'll hit the aforementioned bug.
    */
    ma_engine_node_update_pitch_if_required(&pSound->engineNode);

    /*
    For the convenience of the caller, we're doing to allow data sources to use non-floating-point formats and channel counts that differ
    from the main engine.
    */
    result = ma_data_source_get_data_format(pSound->pDataSource, &dataSourceFormat, &dataSourceChannels, NULL, NULL, 0);
    if (result == MA_SUCCESS) {
        tempCapInFrames = sizeof(temp) / ma_get_bytes_per_frame(dataSourceFormat, dataSourceChannels);

        /* Keep reading until we've read as much as was requested or we reach the end of the data source. */
        while (totalFramesRead < frameCount) {
            ma_uint32 framesRemaining = frameCount - totalFramesRead;
            ma_uint32 framesToRead;
            ma_uint64 framesJustRead;
            ma_uint32 frameCountIn;
            ma_uint32 frameCountOut;
            const float* pRunningFramesIn;
            float* pRunningFramesOut;

            /*
            The first thing we need to do is read into the temporary buffer. We can calculate exactly
            how many input frames we'll need after resampling.
            */
            framesToRead = (ma_uint32)ma_engine_node_get_required_input_frame_count(&pSound->engineNode, framesRemaining);
            if (framesToRead > tempCapInFrames) {
                framesToRead = tempCapInFrames;
            }

            result = ma_data_source_read_pcm_frames(pSound->pDataSource, temp, framesToRead, &framesJustRead);

            /* If we reached the end of the sound we'll want to mark it as at the end and stop it. This should never be returned for looping sounds. */
            if (result == MA_AT_END) {
                ma_sound_set_at_end(pSound, MA_TRUE);   /* This will be set to false in ma_sound_start(). */
            }

            pRunningFramesOut = ma_offset_pcm_frames_ptr_f32(ppFramesOut[0], totalFramesRead, ma_node_get_output_channels(pNode, 0));

            frameCountIn = (ma_uint32)framesJustRead;
            frameCountOut = framesRemaining;

            /* Convert if necessary. */
            if (dataSourceFormat == ma_format_f32) {
                /* Fast path. No data conversion necessary. */
                pRunningFramesIn = (float*)temp;
                ma_engine_node_process_pcm_frames__general(&pSound->engineNode, &pRunningFramesIn, &frameCountIn, &pRunningFramesOut, &frameCountOut);
            } else {
                /* Slow path. Need to do sample format conversion to f32. If we give the f32 buffer the same count as the first temp buffer, we're guaranteed it'll be large enough. */
                float tempf32[MA_DATA_CONVERTER_STACK_BUFFER_SIZE]; /* Do not do `MA_DATA_CONVERTER_STACK_BUFFER_SIZE/sizeof(float)` here like we've done in other places. */
                ma_convert_pcm_frames_format(tempf32, ma_format_f32, temp, dataSourceFormat, framesJustRead, dataSourceChannels, ma_dither_mode_none);

                /* Now that we have our samples in f32 format we can process like normal. */
                pRunningFramesIn = tempf32;
                ma_engine_node_process_pcm_frames__general(&pSound->engineNode, &pRunningFramesIn, &frameCountIn, &pRunningFramesOut, &frameCountOut);
            }

            /* We should have processed all of our input frames since we calculated the required number of input frames at the top. */
            MA_ASSERT(frameCountIn == framesJustRead);
            totalFramesRead += (ma_uint32)frameCountOut;   /* Safe cast. */

            if (result != MA_SUCCESS || ma_sound_at_end(pSound)) {
                break;  /* Might have reached the end. */
            }
        }
    }

    *pFrameCountOut = totalFramesRead;
}

static void ma_engine_node_process_pcm_frames__group(ma_node* pNode, const float** ppFramesIn, ma_uint32* pFrameCountIn, float** ppFramesOut, ma_uint32* pFrameCountOut)
{
    /*
    Make sure the pitch is updated before trying to read anything. It's important that this is done
    only once and not in ma_engine_node_process_pcm_frames__general(). The reason for this is that
    ma_engine_node_process_pcm_frames__general() will call ma_engine_node_get_required_input_frame_count(),
    and if another thread modifies the pitch just after that call it can result in a glitch due to
    the input rate changing.
    */
    ma_engine_node_update_pitch_if_required((ma_engine_node*)pNode);

    /* For groups, the input data has already been read and we just need to apply the effect. */
    ma_engine_node_process_pcm_frames__general((ma_engine_node*)pNode, ppFramesIn, pFrameCountIn, ppFramesOut, pFrameCountOut);
}

static ma_result ma_engine_node_get_required_input_frame_count__group(ma_node* pNode, ma_uint32 outputFrameCount, ma_uint32* pInputFrameCount)
{
    ma_uint64 inputFrameCount;

    MA_ASSERT(pInputFrameCount != NULL);

    /* Our pitch will affect this calculation. We need to update it. */
    ma_engine_node_update_pitch_if_required((ma_engine_node*)pNode);

    inputFrameCount = ma_engine_node_get_required_input_frame_count((ma_engine_node*)pNode, outputFrameCount);
    if (inputFrameCount > 0xFFFFFFFF) {
        inputFrameCount = 0xFFFFFFFF;    /* Will never happen because miniaudio will only ever process in relatively small chunks. */
    }

    *pInputFrameCount = (ma_uint32)inputFrameCount;

    return MA_SUCCESS;
}


static ma_node_vtable g_ma_engine_node_vtable__sound =
{
    ma_engine_node_process_pcm_frames__sound,
    NULL,   /* onGetRequiredInputFrameCount */
    0,      /* Sounds are data source nodes which means they have zero inputs (their input is drawn from the data source itself). */
    1,      /* Sounds have one output bus. */
    0       /* Default flags. */
};

static ma_node_vtable g_ma_engine_node_vtable__group =
{
    ma_engine_node_process_pcm_frames__group,
    ma_engine_node_get_required_input_frame_count__group,
    1,      /* Groups have one input bus. */
    1,      /* Groups have one output bus. */
    MA_NODE_FLAG_DIFFERENT_PROCESSING_RATES /* The engine node does resampling so should let miniaudio know about it. */
};



static ma_node_config ma_engine_node_base_node_config_init(const ma_engine_node_config* pConfig)
{
    ma_node_config baseNodeConfig;

    if (pConfig->type == ma_engine_node_type_sound) {
        /* Sound. */
        baseNodeConfig = ma_node_config_init();
        baseNodeConfig.vtable       = &g_ma_engine_node_vtable__sound;
        baseNodeConfig.initialState = ma_node_state_stopped;    /* Sounds are stopped by default. */
    } else {
        /* Group. */
        baseNodeConfig = ma_node_config_init();
        baseNodeConfig.vtable       = &g_ma_engine_node_vtable__group;
        baseNodeConfig.initialState = ma_node_state_started;    /* Groups are started by default. */
    }

    return baseNodeConfig;
}

static ma_spatializer_config ma_engine_node_spatializer_config_init(const ma_node_config* pBaseNodeConfig)
{
    return ma_spatializer_config_init(pBaseNodeConfig->pInputChannels[0], pBaseNodeConfig->pOutputChannels[0]);
}

typedef struct
{
    size_t sizeInBytes;
    size_t baseNodeOffset;
    size_t resamplerOffset;
    size_t spatializerOffset;
    size_t gainerOffset;
} ma_engine_node_heap_layout;

static ma_result ma_engine_node_get_heap_layout(const ma_engine_node_config* pConfig, ma_engine_node_heap_layout* pHeapLayout)
{
    ma_result result;
    size_t tempHeapSize;
    ma_node_config baseNodeConfig;
    ma_linear_resampler_config resamplerConfig;
    ma_spatializer_config spatializerConfig;
    ma_gainer_config gainerConfig;
    ma_uint32 channelsIn;
    ma_uint32 channelsOut;
    ma_channel defaultStereoChannelMap[2] = {MA_CHANNEL_SIDE_LEFT, MA_CHANNEL_SIDE_RIGHT};  /* <-- Consistent with the default channel map of a stereo listener. Means channel conversion can run on a fast path. */

    MA_ASSERT(pHeapLayout);

    MA_ZERO_OBJECT(pHeapLayout);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    if (pConfig->pEngine == NULL) {
        return MA_INVALID_ARGS; /* An engine must be specified. */
    }

    pHeapLayout->sizeInBytes = 0;

    channelsIn  = (pConfig->channelsIn  != 0) ? pConfig->channelsIn  : ma_engine_get_channels(pConfig->pEngine);
    channelsOut = (pConfig->channelsOut != 0) ? pConfig->channelsOut : ma_engine_get_channels(pConfig->pEngine);


    /* Base node. */
    baseNodeConfig = ma_engine_node_base_node_config_init(pConfig);
    baseNodeConfig.pInputChannels  = &channelsIn;
    baseNodeConfig.pOutputChannels = &channelsOut;

    result = ma_node_get_heap_size(ma_engine_get_node_graph(pConfig->pEngine), &baseNodeConfig, &tempHeapSize);
    if (result != MA_SUCCESS) {
        return result;  /* Failed to retrieve the size of the heap for the base node. */
    }

    pHeapLayout->baseNodeOffset = pHeapLayout->sizeInBytes;
    pHeapLayout->sizeInBytes += ma_align_64(tempHeapSize);


    /* Resmapler. */
    resamplerConfig = ma_linear_resampler_config_init(ma_format_f32, channelsIn, 1, 1); /* Input and output sample rates don't affect the calculation of the heap size. */
    resamplerConfig.lpfOrder = 0;

    result = ma_linear_resampler_get_heap_size(&resamplerConfig, &tempHeapSize);
    if (result != MA_SUCCESS) {
        return result;  /* Failed to retrieve the size of the heap for the resampler. */
    }

    pHeapLayout->resamplerOffset = pHeapLayout->sizeInBytes;
    pHeapLayout->sizeInBytes += ma_align_64(tempHeapSize);


    /* Spatializer. */
    spatializerConfig = ma_engine_node_spatializer_config_init(&baseNodeConfig);

    if (spatializerConfig.channelsIn == 2) {
        spatializerConfig.pChannelMapIn = defaultStereoChannelMap;
    }

    result = ma_spatializer_get_heap_size(&spatializerConfig, &tempHeapSize);
    if (result != MA_SUCCESS) {
        return result;  /* Failed to retrieve the size of the heap for the spatializer. */
    }

    pHeapLayout->spatializerOffset = pHeapLayout->sizeInBytes;
    pHeapLayout->sizeInBytes += ma_align_64(tempHeapSize);


    /* Gainer. Will not be used if we are not using smoothing. */
    if (pConfig->volumeSmoothTimeInPCMFrames > 0) {
        gainerConfig = ma_gainer_config_init(channelsIn, pConfig->volumeSmoothTimeInPCMFrames);

        result = ma_gainer_get_heap_size(&gainerConfig, &tempHeapSize);
        if (result != MA_SUCCESS) {
            return result;
        }

        pHeapLayout->gainerOffset = pHeapLayout->sizeInBytes;
        pHeapLayout->sizeInBytes += ma_align_64(tempHeapSize);
    }


    return MA_SUCCESS;
}

MA_API ma_result ma_engine_node_get_heap_size(const ma_engine_node_config* pConfig, size_t* pHeapSizeInBytes)
{
    ma_result result;
    ma_engine_node_heap_layout heapLayout;

    if (pHeapSizeInBytes == NULL) {
        return MA_INVALID_ARGS;
    }

    *pHeapSizeInBytes = 0;

    result = ma_engine_node_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    *pHeapSizeInBytes = heapLayout.sizeInBytes;

    return MA_SUCCESS;
}

MA_API ma_result ma_engine_node_init_preallocated(const ma_engine_node_config* pConfig, void* pHeap, ma_engine_node* pEngineNode)
{
    ma_result result;
    ma_engine_node_heap_layout heapLayout;
    ma_node_config baseNodeConfig;
    ma_linear_resampler_config resamplerConfig;
    ma_fader_config faderConfig;
    ma_spatializer_config spatializerConfig;
    ma_panner_config pannerConfig;
    ma_gainer_config gainerConfig;
    ma_uint32 channelsIn;
    ma_uint32 channelsOut;
    ma_channel defaultStereoChannelMap[2] = {MA_CHANNEL_SIDE_LEFT, MA_CHANNEL_SIDE_RIGHT};  /* <-- Consistent with the default channel map of a stereo listener. Means channel conversion can run on a fast path. */

    if (pEngineNode == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pEngineNode);

    result = ma_engine_node_get_heap_layout(pConfig, &heapLayout);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (pConfig->pinnedListenerIndex != MA_LISTENER_INDEX_CLOSEST && pConfig->pinnedListenerIndex >= ma_engine_get_listener_count(pConfig->pEngine)) {
        return MA_INVALID_ARGS; /* Invalid listener. */
    }

    pEngineNode->_pHeap = pHeap;
    MA_ZERO_MEMORY(pHeap, heapLayout.sizeInBytes);

    pEngineNode->pEngine                     = pConfig->pEngine;
    pEngineNode->sampleRate                  = (pConfig->sampleRate > 0) ? pConfig->sampleRate : ma_engine_get_sample_rate(pEngineNode->pEngine);
    pEngineNode->volumeSmoothTimeInPCMFrames = pConfig->volumeSmoothTimeInPCMFrames;
    pEngineNode->monoExpansionMode           = pConfig->monoExpansionMode;
    ma_atomic_float_set(&pEngineNode->volume, 1);
    pEngineNode->pitch                       = 1;
    pEngineNode->oldPitch                    = 1;
    pEngineNode->oldDopplerPitch             = 1;
    pEngineNode->isPitchDisabled             = pConfig->isPitchDisabled;
    pEngineNode->isSpatializationDisabled    = pConfig->isSpatializationDisabled;
    pEngineNode->pinnedListenerIndex         = pConfig->pinnedListenerIndex;
    ma_atomic_float_set(&pEngineNode->fadeSettings.volumeBeg, 1);
    ma_atomic_float_set(&pEngineNode->fadeSettings.volumeEnd, 1);
    ma_atomic_uint64_set(&pEngineNode->fadeSettings.fadeLengthInFrames, (~(ma_uint64)0));
    ma_atomic_uint64_set(&pEngineNode->fadeSettings.absoluteGlobalTimeInFrames, (~(ma_uint64)0));   /* <-- Indicates that the fade should start immediately. */

    channelsIn  = (pConfig->channelsIn  != 0) ? pConfig->channelsIn  : ma_engine_get_channels(pConfig->pEngine);
    channelsOut = (pConfig->channelsOut != 0) ? pConfig->channelsOut : ma_engine_get_channels(pConfig->pEngine);

    /*
    If the sample rate of the sound is different to the engine, make sure pitching is enabled so that the resampler
    is activated. Not doing this will result in the sound not being resampled if MA_SOUND_FLAG_NO_PITCH is used.
    */
    if (pEngineNode->sampleRate != ma_engine_get_sample_rate(pEngineNode->pEngine)) {
        pEngineNode->isPitchDisabled = MA_FALSE;
    }


    /* Base node. */
    baseNodeConfig = ma_engine_node_base_node_config_init(pConfig);
    baseNodeConfig.pInputChannels  = &channelsIn;
    baseNodeConfig.pOutputChannels = &channelsOut;

    result = ma_node_init_preallocated(&pConfig->pEngine->nodeGraph, &baseNodeConfig, ma_offset_ptr(pHeap, heapLayout.baseNodeOffset), &pEngineNode->baseNode);
    if (result != MA_SUCCESS) {
        goto error0;
    }


    /*
    We can now initialize the effects we need in order to implement the engine node. There's a
    defined order of operations here, mainly centered around when we convert our channels from the
    data source's native channel count to the engine's channel count. As a rule, we want to do as
    much computation as possible before spatialization because there's a chance that will increase
    the channel count, thereby increasing the amount of work needing to be done to process.
    */

    /* We'll always do resampling first. */
    resamplerConfig = ma_linear_resampler_config_init(ma_format_f32, baseNodeConfig.pInputChannels[0], pEngineNode->sampleRate, ma_engine_get_sample_rate(pEngineNode->pEngine));
    resamplerConfig.lpfOrder = 0;    /* <-- Need to disable low-pass filtering for pitch shifting for now because there's cases where the biquads are becoming unstable. Need to figure out a better fix for this. */

    result = ma_linear_resampler_init_preallocated(&resamplerConfig, ma_offset_ptr(pHeap, heapLayout.resamplerOffset), &pEngineNode->resampler);
    if (result != MA_SUCCESS) {
        goto error1;
    }


    /* After resampling will come the fader. */
    faderConfig = ma_fader_config_init(ma_format_f32, baseNodeConfig.pInputChannels[0], ma_engine_get_sample_rate(pEngineNode->pEngine));

    result = ma_fader_init(&faderConfig, &pEngineNode->fader);
    if (result != MA_SUCCESS) {
        goto error2;
    }


    /*
    Spatialization comes next. We spatialize based on the node's output channel count. It's up the caller to
    ensure channels counts link up correctly in the node graph.
    */
    spatializerConfig = ma_engine_node_spatializer_config_init(&baseNodeConfig);
    spatializerConfig.gainSmoothTimeInFrames = pEngineNode->pEngine->gainSmoothTimeInFrames;

    if (spatializerConfig.channelsIn == 2) {
        spatializerConfig.pChannelMapIn = defaultStereoChannelMap;
    }

    result = ma_spatializer_init_preallocated(&spatializerConfig, ma_offset_ptr(pHeap, heapLayout.spatializerOffset), &pEngineNode->spatializer);
    if (result != MA_SUCCESS) {
        goto error2;
    }


    /*
    After spatialization comes panning. We need to do this after spatialization because otherwise we wouldn't
    be able to pan mono sounds.
    */
    pannerConfig = ma_panner_config_init(ma_format_f32, baseNodeConfig.pOutputChannels[0]);

    result = ma_panner_init(&pannerConfig, &pEngineNode->panner);
    if (result != MA_SUCCESS) {
        goto error3;
    }


    /* We'll need a gainer for smoothing out volume changes if we have a non-zero smooth time. We apply this before converting to the output channel count. */
    if (pConfig->volumeSmoothTimeInPCMFrames > 0) {
        gainerConfig = ma_gainer_config_init(channelsIn, pConfig->volumeSmoothTimeInPCMFrames);

        result = ma_gainer_init_preallocated(&gainerConfig, ma_offset_ptr(pHeap, heapLayout.gainerOffset), &pEngineNode->volumeGainer);
        if (result != MA_SUCCESS) {
            goto error3;
        }
    }


    return MA_SUCCESS;

    /* No need for allocation callbacks here because we use a preallocated heap. */
error3: ma_spatializer_uninit(&pEngineNode->spatializer, NULL);
error2: ma_linear_resampler_uninit(&pEngineNode->resampler, NULL);
error1: ma_node_uninit(&pEngineNode->baseNode, NULL);
error0: return result;
}

MA_API ma_result ma_engine_node_init(const ma_engine_node_config* pConfig, const ma_allocation_callbacks* pAllocationCallbacks, ma_engine_node* pEngineNode)
{
    ma_result result;
    size_t heapSizeInBytes;
    void* pHeap;

    result = ma_engine_node_get_heap_size(pConfig, &heapSizeInBytes);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (heapSizeInBytes > 0) {
        pHeap = ma_malloc(heapSizeInBytes, pAllocationCallbacks);
        if (pHeap == NULL) {
            return MA_OUT_OF_MEMORY;
        }
    } else {
        pHeap = NULL;
    }

    result = ma_engine_node_init_preallocated(pConfig, pHeap, pEngineNode);
    if (result != MA_SUCCESS) {
        ma_free(pHeap, pAllocationCallbacks);
        return result;
    }

    pEngineNode->_ownsHeap = MA_TRUE;
    return MA_SUCCESS;
}

MA_API void ma_engine_node_uninit(ma_engine_node* pEngineNode, const ma_allocation_callbacks* pAllocationCallbacks)
{
    /*
    The base node always needs to be uninitialized first to ensure it's detached from the graph completely before we
    destroy anything that might be in the middle of being used by the processing function.
    */
    ma_node_uninit(&pEngineNode->baseNode, pAllocationCallbacks);

    /* Now that the node has been uninitialized we can safely uninitialize the rest. */
    if (pEngineNode->volumeSmoothTimeInPCMFrames > 0) {
        ma_gainer_uninit(&pEngineNode->volumeGainer, pAllocationCallbacks);
    }

    ma_spatializer_uninit(&pEngineNode->spatializer, pAllocationCallbacks);
    ma_linear_resampler_uninit(&pEngineNode->resampler, pAllocationCallbacks);

    /* Free the heap last. */
    if (pEngineNode->_ownsHeap) {
        ma_free(pEngineNode->_pHeap, pAllocationCallbacks);
    }
}


MA_API ma_sound_config ma_sound_config_init(void)
{
    return ma_sound_config_init_2(NULL);
}

MA_API ma_sound_config ma_sound_config_init_2(ma_engine* pEngine)
{
    ma_sound_config config;

    MA_ZERO_OBJECT(&config);

    if (pEngine != NULL) {
        config.monoExpansionMode = pEngine->monoExpansionMode;
    } else {
        config.monoExpansionMode = ma_mono_expansion_mode_default;
    }

    config.rangeEndInPCMFrames     = ~((ma_uint64)0);
    config.loopPointEndInPCMFrames = ~((ma_uint64)0);

    return config;
}

MA_API ma_sound_group_config ma_sound_group_config_init(void)
{
    return ma_sound_group_config_init_2(NULL);
}

MA_API ma_sound_group_config ma_sound_group_config_init_2(ma_engine* pEngine)
{
    ma_sound_group_config config;

    MA_ZERO_OBJECT(&config);

    if (pEngine != NULL) {
        config.monoExpansionMode = pEngine->monoExpansionMode;
    } else {
        config.monoExpansionMode = ma_mono_expansion_mode_default;
    }

    return config;
}


MA_API ma_engine_config ma_engine_config_init(void)
{
    ma_engine_config config;

    MA_ZERO_OBJECT(&config);
    config.listenerCount     = 1;   /* Always want at least one listener. */
    config.monoExpansionMode = ma_mono_expansion_mode_default;

    return config;
}



MA_API ma_result ma_engine_init(const ma_engine_config* pConfig, ma_engine* pEngine)
{
    ma_result result;
    ma_node_graph_config nodeGraphConfig;
    ma_engine_config engineConfig;
    ma_spatializer_listener_config listenerConfig;
    ma_uint32 iListener;

    if (pEngine == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pEngine);

    /* The config is allowed to be NULL in which case we use defaults for everything. */
    if (pConfig != NULL) {
        engineConfig = *pConfig;
    } else {
        engineConfig = ma_engine_config_init();
    }

    pEngine->monoExpansionMode = engineConfig.monoExpansionMode;
    pEngine->defaultVolumeSmoothTimeInPCMFrames = engineConfig.defaultVolumeSmoothTimeInPCMFrames;
    pEngine->onProcess = engineConfig.onProcess;
    pEngine->pProcessUserData = engineConfig.pProcessUserData;
    ma_allocation_callbacks_init_copy(&pEngine->allocationCallbacks, &engineConfig.allocationCallbacks);

    #if !defined(MA_NO_RESOURCE_MANAGER)
    {
        pEngine->pResourceManager = engineConfig.pResourceManager;
    }
    #endif


    if (engineConfig.channels == 0 || engineConfig.sampleRate == 0) {
        return MA_INVALID_ARGS;
    }

    pEngine->sampleRate = engineConfig.sampleRate;

    /* The engine always uses either the log that was passed into the config, or the context's log is available. */
    if (engineConfig.pLog != NULL) {
        pEngine->pLog = engineConfig.pLog;
    } else {
        {
            pEngine->pLog = NULL;
        }
    }


    /* The engine is a node graph. This needs to be initialized after we have the device so we can determine the channel count. */
    nodeGraphConfig = ma_node_graph_config_init(engineConfig.channels);
    nodeGraphConfig.processingSizeInFrames = engineConfig.periodSizeInFrames;
    nodeGraphConfig.preMixStackSizeInBytes = engineConfig.preMixStackSizeInBytes;

    result = ma_node_graph_init(&nodeGraphConfig, &pEngine->allocationCallbacks, &pEngine->nodeGraph);
    if (result != MA_SUCCESS) {
        goto on_error_1;
    }


    /* We need at least one listener. */
    if (engineConfig.listenerCount == 0) {
        engineConfig.listenerCount = 1;
    }

    if (engineConfig.listenerCount > MA_ENGINE_MAX_LISTENERS) {
        result = MA_INVALID_ARGS;   /* Too many listeners. */
        goto on_error_1;
    }

    for (iListener = 0; iListener < engineConfig.listenerCount; iListener += 1) {
        listenerConfig = ma_spatializer_listener_config_init(ma_node_graph_get_channels(&pEngine->nodeGraph));

        /*
        If we're using a device, use the device's channel map for the listener. Otherwise just use
        miniaudio's default channel map.
        */

        result = ma_spatializer_listener_init(&listenerConfig, &pEngine->allocationCallbacks, &pEngine->listeners[iListener]);  /* TODO: Change this to a pre-allocated heap. */
        if (result != MA_SUCCESS) {
            goto on_error_2;
        }

        pEngine->listenerCount += 1;
    }


    /* Gain smoothing for spatialized sounds. */
    pEngine->gainSmoothTimeInFrames = engineConfig.gainSmoothTimeInFrames;
    if (pEngine->gainSmoothTimeInFrames == 0) {
        ma_uint32 gainSmoothTimeInMilliseconds = engineConfig.gainSmoothTimeInMilliseconds;
        if (gainSmoothTimeInMilliseconds == 0) {
            gainSmoothTimeInMilliseconds = 8;
        }

        pEngine->gainSmoothTimeInFrames = (gainSmoothTimeInMilliseconds * ma_engine_get_sample_rate(pEngine)) / 1000;  /* 8ms by default. */
    }


    /* We need a resource manager. */
    #ifndef MA_NO_RESOURCE_MANAGER
    {
        if (pEngine->pResourceManager == NULL) {
            ma_resource_manager_config resourceManagerConfig;

            pEngine->pResourceManager = (ma_resource_manager*)ma_malloc(sizeof(*pEngine->pResourceManager), &pEngine->allocationCallbacks);
            if (pEngine->pResourceManager == NULL) {
                result = MA_OUT_OF_MEMORY;
                goto on_error_2;
            }

            resourceManagerConfig = ma_resource_manager_config_init();
            resourceManagerConfig.pLog              = pEngine->pLog;    /* Always use the engine's log for internally-managed resource managers. */
            resourceManagerConfig.decodedFormat     = ma_format_f32;
            resourceManagerConfig.decodedChannels   = 0;  /* Leave the decoded channel count as 0 so we can get good spatialization. */
            resourceManagerConfig.decodedSampleRate = ma_engine_get_sample_rate(pEngine);
            ma_allocation_callbacks_init_copy(&resourceManagerConfig.allocationCallbacks, &pEngine->allocationCallbacks);
            resourceManagerConfig.pVFS              = engineConfig.pResourceManagerVFS;

            /* The Emscripten build cannot use threads unless it's targeting pthreads. */
            #if defined(MA_EMSCRIPTEN) && !defined(__EMSCRIPTEN_PTHREADS__)
            {
                resourceManagerConfig.jobThreadCount = 0;
                resourceManagerConfig.flags |= MA_RESOURCE_MANAGER_FLAG_NO_THREADING;
            }
            #endif

            result = ma_resource_manager_init(&resourceManagerConfig, pEngine->pResourceManager);
            if (result != MA_SUCCESS) {
                goto on_error_3;
            }

            pEngine->ownsResourceManager = MA_TRUE;
        }
    }
    #endif

    /* Setup some stuff for inlined sounds. That is sounds played with ma_engine_play_sound(). */
    pEngine->inlinedSoundLock  = 0;
    pEngine->pInlinedSoundHead = NULL;

    /* Start the engine if required. This should always be the last step. */

    return MA_SUCCESS;

#if !defined(MA_NO_RESOURCE_MANAGER)
on_error_3:
    if (pEngine->ownsResourceManager) {
        ma_free(pEngine->pResourceManager, &pEngine->allocationCallbacks);
    }
#endif  /* MA_NO_RESOURCE_MANAGER */
on_error_2:
    for (iListener = 0; iListener < pEngine->listenerCount; iListener += 1) {
        ma_spatializer_listener_uninit(&pEngine->listeners[iListener], &pEngine->allocationCallbacks);
    }

    ma_node_graph_uninit(&pEngine->nodeGraph, &pEngine->allocationCallbacks);
on_error_1:

    return result;
}

MA_API void ma_engine_uninit(ma_engine* pEngine)
{
    ma_uint32 iListener;

    if (pEngine == NULL) {
        return;
    }

    /* The device must be uninitialized before the node graph to ensure the audio thread doesn't try accessing it. */

    /*
    All inlined sounds need to be deleted. I'm going to use a lock here just to future proof in case
    I want to do some kind of garbage collection later on.
    */
    ma_spinlock_lock(&pEngine->inlinedSoundLock);
    {
        for (;;) {
            ma_sound_inlined* pSoundToDelete = pEngine->pInlinedSoundHead;
            if (pSoundToDelete == NULL) {
                break;  /* Done. */
            }

            pEngine->pInlinedSoundHead = pSoundToDelete->pNext;

            ma_sound_uninit(&pSoundToDelete->sound);
            ma_free(pSoundToDelete, &pEngine->allocationCallbacks);
        }
    }
    ma_spinlock_unlock(&pEngine->inlinedSoundLock);

    for (iListener = 0; iListener < pEngine->listenerCount; iListener += 1) {
        ma_spatializer_listener_uninit(&pEngine->listeners[iListener], &pEngine->allocationCallbacks);
    }

    /* Make sure the node graph is uninitialized after the audio thread has been shutdown to prevent accessing of the node graph after being uninitialized. */
    ma_node_graph_uninit(&pEngine->nodeGraph, &pEngine->allocationCallbacks);

    /* Uninitialize the resource manager last to ensure we don't have a thread still trying to access it. */
#ifndef MA_NO_RESOURCE_MANAGER
    if (pEngine->ownsResourceManager) {
        ma_resource_manager_uninit(pEngine->pResourceManager);
        ma_free(pEngine->pResourceManager, &pEngine->allocationCallbacks);
    }
#endif
}

MA_API ma_result ma_engine_read_pcm_frames(ma_engine* pEngine, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead)
{
    ma_result result;
    ma_uint64 framesRead = 0;

    if (pFramesRead != NULL) {
        *pFramesRead = 0;
    }

    result = ma_node_graph_read_pcm_frames(&pEngine->nodeGraph, pFramesOut, frameCount, &framesRead);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (pFramesRead != NULL) {
        *pFramesRead = framesRead;
    }

    if (pEngine->onProcess) {
        pEngine->onProcess(pEngine->pProcessUserData, (float*)pFramesOut, framesRead);  /* Safe cast to float* because the engine always works on floating point samples. */
    }

    return MA_SUCCESS;
}

MA_API ma_node_graph* ma_engine_get_node_graph(ma_engine* pEngine)
{
    if (pEngine == NULL) {
        return NULL;
    }

    return &pEngine->nodeGraph;
}

#if !defined(MA_NO_RESOURCE_MANAGER)
MA_API ma_resource_manager* ma_engine_get_resource_manager(ma_engine* pEngine)
{
    if (pEngine == NULL) {
        return NULL;
    }

    #if !defined(MA_NO_RESOURCE_MANAGER)
    {
        return pEngine->pResourceManager;
    }
    #else
    {
        return NULL;
    }
    #endif
}
#endif

MA_API ma_device* ma_engine_get_device(ma_engine* pEngine)
{
    if (pEngine == NULL) {
        return NULL;
    }

    {
        return NULL;
    }
}

MA_API ma_log* ma_engine_get_log(ma_engine* pEngine)
{
    if (pEngine == NULL) {
        return NULL;
    }

    if (pEngine->pLog != NULL) {
        return pEngine->pLog;
    } else {
        {
            return NULL;
        }
    }
}

MA_API ma_node* ma_engine_get_endpoint(ma_engine* pEngine)
{
    return ma_node_graph_get_endpoint(&pEngine->nodeGraph);
}

MA_API ma_uint64 ma_engine_get_time_in_pcm_frames(const ma_engine* pEngine)
{
    return ma_node_graph_get_time(&pEngine->nodeGraph);
}

MA_API ma_uint64 ma_engine_get_time_in_milliseconds(const ma_engine* pEngine)
{
    return ma_engine_get_time_in_pcm_frames(pEngine) * 1000 / ma_engine_get_sample_rate(pEngine);
}

MA_API ma_result ma_engine_set_time_in_pcm_frames(ma_engine* pEngine, ma_uint64 globalTime)
{
    return ma_node_graph_set_time(&pEngine->nodeGraph, globalTime);
}

MA_API ma_result ma_engine_set_time_in_milliseconds(ma_engine* pEngine, ma_uint64 globalTime)
{
    return ma_engine_set_time_in_pcm_frames(pEngine, globalTime * ma_engine_get_sample_rate(pEngine) / 1000);
}

MA_API ma_uint64 ma_engine_get_time(const ma_engine* pEngine)
{
    return ma_engine_get_time_in_pcm_frames(pEngine);
}

MA_API ma_result ma_engine_set_time(ma_engine* pEngine, ma_uint64 globalTime)
{
    return ma_engine_set_time_in_pcm_frames(pEngine, globalTime);
}

MA_API ma_uint32 ma_engine_get_channels(const ma_engine* pEngine)
{
    return ma_node_graph_get_channels(&pEngine->nodeGraph);
}

MA_API ma_uint32 ma_engine_get_sample_rate(const ma_engine* pEngine)
{
    if (pEngine == NULL) {
        return 0;
    }

    return pEngine->sampleRate;
}


MA_API ma_result ma_engine_start(ma_engine* pEngine)
{
    ma_result result;

    if (pEngine == NULL) {
        return MA_INVALID_ARGS;
    }

    {
        result = MA_INVALID_OPERATION;  /* Device IO is disabled, so there's no real notion of "starting" the engine. */
    }

    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_engine_stop(ma_engine* pEngine)
{
    ma_result result;

    if (pEngine == NULL) {
        return MA_INVALID_ARGS;
    }

    {
        result = MA_INVALID_OPERATION;  /* Device IO is disabled, so there's no real notion of "stopping" the engine. */
    }

    if (result != MA_SUCCESS) {
        return result;
    }

    return MA_SUCCESS;
}

MA_API ma_result ma_engine_set_volume(ma_engine* pEngine, float volume)
{
    if (pEngine == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_node_set_output_bus_volume(ma_node_graph_get_endpoint(&pEngine->nodeGraph), 0, volume);
}

MA_API float ma_engine_get_volume(ma_engine* pEngine)
{
    if (pEngine == NULL) {
        return 0;
    }

    return ma_node_get_output_bus_volume(ma_node_graph_get_endpoint(&pEngine->nodeGraph), 0);
}

MA_API ma_result ma_engine_set_gain_db(ma_engine* pEngine, float gainDB)
{
    return ma_engine_set_volume(pEngine, ma_volume_db_to_linear(gainDB));
}

MA_API float ma_engine_get_gain_db(ma_engine* pEngine)
{
    return ma_volume_linear_to_db(ma_engine_get_volume(pEngine));
}


MA_API ma_uint32 ma_engine_get_listener_count(const ma_engine* pEngine)
{
    if (pEngine == NULL) {
        return 0;
    }

    return pEngine->listenerCount;
}

MA_API ma_uint32 ma_engine_find_closest_listener(const ma_engine* pEngine, float absolutePosX, float absolutePosY, float absolutePosZ)
{
    ma_uint32 iListener;
    ma_uint32 iListenerClosest;
    float closestLen2 = MA_FLT_MAX;

    if (pEngine == NULL || pEngine->listenerCount == 1) {
        return 0;
    }

    iListenerClosest = 0;
    for (iListener = 0; iListener < pEngine->listenerCount; iListener += 1) {
        if (ma_engine_listener_is_enabled(pEngine, iListener)) {
            float len2 = ma_vec3f_len2(ma_vec3f_sub(ma_spatializer_listener_get_position(&pEngine->listeners[iListener]), ma_vec3f_init_3f(absolutePosX, absolutePosY, absolutePosZ)));
            if (closestLen2 > len2) {
                closestLen2 = len2;
                iListenerClosest = iListener;
            }
        }
    }

    MA_ASSERT(iListenerClosest < 255);
    return iListenerClosest;
}

MA_API void ma_engine_listener_set_position(ma_engine* pEngine, ma_uint32 listenerIndex, float x, float y, float z)
{
    if (pEngine == NULL || listenerIndex >= pEngine->listenerCount) {
        return;
    }

    ma_spatializer_listener_set_position(&pEngine->listeners[listenerIndex], x, y, z);
}

MA_API ma_vec3f ma_engine_listener_get_position(const ma_engine* pEngine, ma_uint32 listenerIndex)
{
    if (pEngine == NULL || listenerIndex >= pEngine->listenerCount) {
        return ma_vec3f_init_3f(0, 0, 0);
    }

    return ma_spatializer_listener_get_position(&pEngine->listeners[listenerIndex]);
}

MA_API void ma_engine_listener_set_direction(ma_engine* pEngine, ma_uint32 listenerIndex, float x, float y, float z)
{
    if (pEngine == NULL || listenerIndex >= pEngine->listenerCount) {
        return;
    }

    ma_spatializer_listener_set_direction(&pEngine->listeners[listenerIndex], x, y, z);
}

MA_API ma_vec3f ma_engine_listener_get_direction(const ma_engine* pEngine, ma_uint32 listenerIndex)
{
    if (pEngine == NULL || listenerIndex >= pEngine->listenerCount) {
        return ma_vec3f_init_3f(0, 0, -1);
    }

    return ma_spatializer_listener_get_direction(&pEngine->listeners[listenerIndex]);
}

MA_API void ma_engine_listener_set_velocity(ma_engine* pEngine, ma_uint32 listenerIndex, float x, float y, float z)
{
    if (pEngine == NULL || listenerIndex >= pEngine->listenerCount) {
        return;
    }

    ma_spatializer_listener_set_velocity(&pEngine->listeners[listenerIndex], x, y, z);
}

MA_API ma_vec3f ma_engine_listener_get_velocity(const ma_engine* pEngine, ma_uint32 listenerIndex)
{
    if (pEngine == NULL || listenerIndex >= pEngine->listenerCount) {
        return ma_vec3f_init_3f(0, 0, 0);
    }

    return ma_spatializer_listener_get_velocity(&pEngine->listeners[listenerIndex]);
}

MA_API void ma_engine_listener_set_cone(ma_engine* pEngine, ma_uint32 listenerIndex, float innerAngleInRadians, float outerAngleInRadians, float outerGain)
{
    if (pEngine == NULL || listenerIndex >= pEngine->listenerCount) {
        return;
    }

    ma_spatializer_listener_set_cone(&pEngine->listeners[listenerIndex], innerAngleInRadians, outerAngleInRadians, outerGain);
}

MA_API void ma_engine_listener_get_cone(const ma_engine* pEngine, ma_uint32 listenerIndex, float* pInnerAngleInRadians, float* pOuterAngleInRadians, float* pOuterGain)
{
    if (pInnerAngleInRadians != NULL) {
        *pInnerAngleInRadians = 0;
    }

    if (pOuterAngleInRadians != NULL) {
        *pOuterAngleInRadians = 0;
    }

    if (pOuterGain != NULL) {
        *pOuterGain = 0;
    }

    if (pEngine == NULL || listenerIndex >= pEngine->listenerCount) {
        return;
    }

    ma_spatializer_listener_get_cone(&pEngine->listeners[listenerIndex], pInnerAngleInRadians, pOuterAngleInRadians, pOuterGain);
}

MA_API void ma_engine_listener_set_world_up(ma_engine* pEngine, ma_uint32 listenerIndex, float x, float y, float z)
{
    if (pEngine == NULL || listenerIndex >= pEngine->listenerCount) {
        return;
    }

    ma_spatializer_listener_set_world_up(&pEngine->listeners[listenerIndex], x, y, z);
}

MA_API ma_vec3f ma_engine_listener_get_world_up(const ma_engine* pEngine, ma_uint32 listenerIndex)
{
    if (pEngine == NULL || listenerIndex >= pEngine->listenerCount) {
        return ma_vec3f_init_3f(0, 1, 0);
    }

    return ma_spatializer_listener_get_world_up(&pEngine->listeners[listenerIndex]);
}

MA_API void ma_engine_listener_set_enabled(ma_engine* pEngine, ma_uint32 listenerIndex, ma_bool32 isEnabled)
{
    if (pEngine == NULL || listenerIndex >= pEngine->listenerCount) {
        return;
    }

    ma_spatializer_listener_set_enabled(&pEngine->listeners[listenerIndex], isEnabled);
}

MA_API ma_bool32 ma_engine_listener_is_enabled(const ma_engine* pEngine, ma_uint32 listenerIndex)
{
    if (pEngine == NULL || listenerIndex >= pEngine->listenerCount) {
        return MA_FALSE;
    }

    return ma_spatializer_listener_is_enabled(&pEngine->listeners[listenerIndex]);
}


#ifndef MA_NO_RESOURCE_MANAGER
MA_API ma_result ma_engine_play_sound_ex(ma_engine* pEngine, const char* pFilePath, ma_node* pNode, ma_uint32 nodeInputBusIndex)
{
    ma_result result = MA_SUCCESS;
    ma_sound_inlined* pSound = NULL;
    ma_sound_inlined* pNextSound = NULL;

    if (pEngine == NULL || pFilePath == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Attach to the endpoint node if nothing is specified. */
    if (pNode == NULL) {
        pNode = ma_node_graph_get_endpoint(&pEngine->nodeGraph);
        nodeInputBusIndex = 0;
    }

    /*
    We want to check if we can recycle an already-allocated inlined sound. Since this is just a
    helper I'm not *too* concerned about performance here and I'm happy to use a lock to keep
    the implementation simple. Maybe this can be optimized later if there's enough demand, but
    if this function is being used it probably means the caller doesn't really care too much.

    What we do is check the atEnd flag. When this is true, we can recycle the sound. Otherwise
    we just keep iterating. If we reach the end without finding a sound to recycle we just
    allocate a new one. This doesn't scale well for a massive number of sounds being played
    simultaneously as we don't ever actually free the sound objects. Some kind of garbage
    collection routine might be valuable for this which I'll think about.
    */
    ma_spinlock_lock(&pEngine->inlinedSoundLock);
    {
        ma_uint32 soundFlags = 0;

        for (pNextSound = pEngine->pInlinedSoundHead; pNextSound != NULL; pNextSound = pNextSound->pNext) {
            if (ma_sound_at_end(&pNextSound->sound)) {
                /*
                The sound is at the end which means it's available for recycling. All we need to do
                is uninitialize it and reinitialize it. All we're doing is recycling memory.
                */
                pSound = pNextSound;
                ma_atomic_fetch_sub_32(&pEngine->inlinedSoundCount, 1);
                break;
            }
        }

        if (pSound != NULL) {
            /*
            We actually want to detach the sound from the list here. The reason is because we want the sound
            to be in a consistent state at the non-recycled case to simplify the logic below.
            */
            if (pEngine->pInlinedSoundHead == pSound) {
                pEngine->pInlinedSoundHead =  pSound->pNext;
            }

            if (pSound->pPrev != NULL) {
                pSound->pPrev->pNext = pSound->pNext;
            }
            if (pSound->pNext != NULL) {
                pSound->pNext->pPrev = pSound->pPrev;
            }

            /* Now the previous sound needs to be uninitialized. */
            ma_sound_uninit(&pNextSound->sound);
        } else {
            /* No sound available for recycling. Allocate one now. */
            pSound = (ma_sound_inlined*)ma_malloc(sizeof(*pSound), &pEngine->allocationCallbacks);
        }

        if (pSound != NULL) {   /* Safety check for the allocation above. */
            /*
            At this point we should have memory allocated for the inlined sound. We just need
            to initialize it like a normal sound now.
            */
            soundFlags |= MA_SOUND_FLAG_ASYNC;                 /* For inlined sounds we don't want to be sitting around waiting for stuff to load so force an async load. */
            soundFlags |= MA_SOUND_FLAG_NO_DEFAULT_ATTACHMENT; /* We want specific control over where the sound is attached in the graph. We'll attach it manually just before playing the sound. */
            soundFlags |= MA_SOUND_FLAG_NO_PITCH;              /* Pitching isn't usable with inlined sounds, so disable it to save on speed. */
            soundFlags |= MA_SOUND_FLAG_NO_SPATIALIZATION;     /* Not currently doing spatialization with inlined sounds, but this might actually change later. For now disable spatialization. Will be removed if we ever add support for spatialization here. */

            result = ma_sound_init_from_file(pEngine, pFilePath, soundFlags, NULL, NULL, &pSound->sound);
            if (result == MA_SUCCESS) {
                /* Now attach the sound to the graph. */
                result = ma_node_attach_output_bus(pSound, 0, pNode, nodeInputBusIndex);
                if (result == MA_SUCCESS) {
                    /* At this point the sound should be loaded and we can go ahead and add it to the list. The new item becomes the new head. */
                    pSound->pNext = pEngine->pInlinedSoundHead;
                    pSound->pPrev = NULL;

                    pEngine->pInlinedSoundHead = pSound;    /* <-- This is what attaches the sound to the list. */
                    if (pSound->pNext != NULL) {
                        pSound->pNext->pPrev = pSound;
                    }
                } else {
                    ma_free(pSound, &pEngine->allocationCallbacks);
                }
            } else {
                ma_free(pSound, &pEngine->allocationCallbacks);
            }
        } else {
            result = MA_OUT_OF_MEMORY;
        }
    }
    ma_spinlock_unlock(&pEngine->inlinedSoundLock);

    if (result != MA_SUCCESS) {
        return result;
    }

    /* Finally we can start playing the sound. */
    result = ma_sound_start(&pSound->sound);
    if (result != MA_SUCCESS) {
        /* Failed to start the sound. We need to mark it for recycling and return an error. */
        ma_atomic_exchange_32(&pSound->sound.atEnd, MA_TRUE);
        return result;
    }

    ma_atomic_fetch_add_32(&pEngine->inlinedSoundCount, 1);
    return result;
}

MA_API ma_result ma_engine_play_sound(ma_engine* pEngine, const char* pFilePath, ma_sound_group* pGroup)
{
    return ma_engine_play_sound_ex(pEngine, pFilePath, pGroup, 0);
}
#endif


static ma_result ma_sound_preinit(ma_engine* pEngine, ma_sound* pSound)
{
    if (pSound == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pSound);
    pSound->seekTarget = MA_SEEK_TARGET_NONE;

    if (pEngine == NULL) {
        return MA_INVALID_ARGS;
    }

    return MA_SUCCESS;
}

static ma_result ma_sound_init_from_data_source_internal(ma_engine* pEngine, const ma_sound_config* pConfig, ma_sound* pSound)
{
    ma_result result;
    ma_engine_node_config engineNodeConfig;
    ma_engine_node_type type;   /* Will be set to ma_engine_node_type_group if no data source is specified. */

    /* Do not clear pSound to zero here - that's done at a higher level with ma_sound_preinit(). */
    MA_ASSERT(pEngine != NULL);
    MA_ASSERT(pSound  != NULL);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    pSound->pDataSource = pConfig->pDataSource;

    if (pConfig->pDataSource != NULL) {
        type = ma_engine_node_type_sound;
    } else {
        type = ma_engine_node_type_group;
    }

    /*
    Sounds are engine nodes. Before we can initialize this we need to determine the channel count.
    If we can't do this we need to abort. It's up to the caller to ensure they're using a data
    source that provides this information upfront.
    */
    engineNodeConfig = ma_engine_node_config_init(pEngine, type, pConfig->flags);
    engineNodeConfig.channelsIn                  = pConfig->channelsIn;
    engineNodeConfig.channelsOut                 = pConfig->channelsOut;
    engineNodeConfig.volumeSmoothTimeInPCMFrames = pConfig->volumeSmoothTimeInPCMFrames;
    engineNodeConfig.monoExpansionMode           = pConfig->monoExpansionMode;

    if (engineNodeConfig.volumeSmoothTimeInPCMFrames == 0) {
        engineNodeConfig.volumeSmoothTimeInPCMFrames = pEngine->defaultVolumeSmoothTimeInPCMFrames;
    }

    /* If we're loading from a data source the input channel count needs to be the data source's native channel count. */
    if (pConfig->pDataSource != NULL) {
        result = ma_data_source_get_data_format(pConfig->pDataSource, NULL, &engineNodeConfig.channelsIn, &engineNodeConfig.sampleRate, NULL, 0);
        if (result != MA_SUCCESS) {
            return result;  /* Failed to retrieve the channel count. */
        }

        if (engineNodeConfig.channelsIn == 0) {
            return MA_INVALID_OPERATION;    /* Invalid channel count. */
        }

        if (engineNodeConfig.channelsOut == MA_SOUND_SOURCE_CHANNEL_COUNT) {
            engineNodeConfig.channelsOut = engineNodeConfig.channelsIn;
        }
    }


    /* Getting here means we should have a valid channel count and we can initialize the engine node. */
    result = ma_engine_node_init(&engineNodeConfig, &pEngine->allocationCallbacks, &pSound->engineNode);
    if (result != MA_SUCCESS) {
        return result;
    }

    /* If no attachment is specified, attach the sound straight to the endpoint. */
    if (pConfig->pInitialAttachment == NULL) {
        /* No group. Attach straight to the endpoint by default, unless the caller has requested that it not. */
        if ((pConfig->flags & MA_SOUND_FLAG_NO_DEFAULT_ATTACHMENT) == 0) {
            result = ma_node_attach_output_bus(pSound, 0, ma_node_graph_get_endpoint(&pEngine->nodeGraph), 0);
        }
    } else {
        /* An attachment is specified. Attach to it by default. The sound has only a single output bus, and the config will specify which input bus to attach to. */
        result = ma_node_attach_output_bus(pSound, 0, pConfig->pInitialAttachment, pConfig->initialAttachmentInputBusIndex);
    }

    if (result != MA_SUCCESS) {
        ma_engine_node_uninit(&pSound->engineNode, &pEngine->allocationCallbacks);
        return result;
    }


    /* Apply initial range and looping state to the data source if applicable. */
    if (pConfig->rangeBegInPCMFrames != 0 || pConfig->rangeEndInPCMFrames != ~((ma_uint64)0)) {
        ma_data_source_set_range_in_pcm_frames(ma_sound_get_data_source(pSound), pConfig->rangeBegInPCMFrames, pConfig->rangeEndInPCMFrames);
    }

    if (pConfig->loopPointBegInPCMFrames != 0 || pConfig->loopPointEndInPCMFrames != ~((ma_uint64)0)) {
        ma_data_source_set_range_in_pcm_frames(ma_sound_get_data_source(pSound), pConfig->loopPointBegInPCMFrames, pConfig->loopPointEndInPCMFrames);
    }

    ma_sound_set_looping(pSound, pConfig->isLooping || ((pConfig->flags & MA_SOUND_FLAG_LOOPING) != 0));

    return MA_SUCCESS;
}

#ifndef MA_NO_RESOURCE_MANAGER
MA_API ma_result ma_sound_init_from_file_internal(ma_engine* pEngine, const ma_sound_config* pConfig, ma_sound* pSound)
{
    ma_result result = MA_SUCCESS;
    ma_uint32 flags;
    ma_sound_config config;
    ma_resource_manager_pipeline_notifications notifications;

    /*
    The engine requires knowledge of the channel count of the underlying data source before it can
    initialize the sound. Therefore, we need to make the resource manager wait until initialization
    of the underlying data source to be initialized so we can get access to the channel count. To
    do this, the MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT is forced.

    Because we're initializing the data source before the sound, there's a chance the notification
    will get triggered before this function returns. This is OK, so long as the caller is aware of
    it and can avoid accessing the sound from within the notification.
    */
    flags = pConfig->flags | MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT;
    if (pConfig->isLooping) {
        flags |= MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_LOOPING;
    }

    pSound->pResourceManagerDataSource = (ma_resource_manager_data_source*)ma_malloc(sizeof(*pSound->pResourceManagerDataSource), &pEngine->allocationCallbacks);
    if (pSound->pResourceManagerDataSource == NULL) {
        return MA_OUT_OF_MEMORY;
    }

    /* Removed in 0.12. Set pDoneFence on the notifications. */
    notifications = pConfig->initNotifications;
    if (pConfig->pDoneFence != NULL && notifications.done.pFence == NULL) {
        notifications.done.pFence = pConfig->pDoneFence;
    }

    /*
    We must wrap everything around the fence if one was specified. This ensures ma_fence_wait() does
    not return prematurely before the sound has finished initializing.
    */
    if (notifications.done.pFence) { ma_fence_acquire(notifications.done.pFence); }
    {
        ma_resource_manager_data_source_config resourceManagerDataSourceConfig = ma_resource_manager_data_source_config_init();
        resourceManagerDataSourceConfig.pFilePath                   = pConfig->pFilePath;
        resourceManagerDataSourceConfig.pFilePathW                  = pConfig->pFilePathW;
        resourceManagerDataSourceConfig.flags                       = flags;
        resourceManagerDataSourceConfig.pNotifications              = &notifications;
        resourceManagerDataSourceConfig.initialSeekPointInPCMFrames = pConfig->initialSeekPointInPCMFrames;
        resourceManagerDataSourceConfig.rangeBegInPCMFrames         = pConfig->rangeBegInPCMFrames;
        resourceManagerDataSourceConfig.rangeEndInPCMFrames         = pConfig->rangeEndInPCMFrames;
        resourceManagerDataSourceConfig.loopPointBegInPCMFrames     = pConfig->loopPointBegInPCMFrames;
        resourceManagerDataSourceConfig.loopPointEndInPCMFrames     = pConfig->loopPointEndInPCMFrames;
        resourceManagerDataSourceConfig.isLooping                   = (flags & MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_LOOPING) != 0;

        result = ma_resource_manager_data_source_init_ex(pEngine->pResourceManager, &resourceManagerDataSourceConfig, pSound->pResourceManagerDataSource);
        if (result != MA_SUCCESS) {
            goto done;
        }

        pSound->ownsDataSource = MA_TRUE;   /* <-- Important. Not setting this will result in the resource manager data source never getting uninitialized. */

        /* We need to use a slightly customized version of the config so we'll need to make a copy. */
        config = *pConfig;
        config.pFilePath   = NULL;
        config.pFilePathW  = NULL;
        config.pDataSource = pSound->pResourceManagerDataSource;

        result = ma_sound_init_from_data_source_internal(pEngine, &config, pSound);
        if (result != MA_SUCCESS) {
            ma_resource_manager_data_source_uninit(pSound->pResourceManagerDataSource);
            ma_free(pSound->pResourceManagerDataSource, &pEngine->allocationCallbacks);
            MA_ZERO_OBJECT(pSound);
            goto done;
        }
    }
done:
    if (notifications.done.pFence) { ma_fence_release(notifications.done.pFence); }
    return result;
}

MA_API ma_result ma_sound_init_from_file(ma_engine* pEngine, const char* pFilePath, ma_uint32 flags, ma_sound_group* pGroup, ma_fence* pDoneFence, ma_sound* pSound)
{
    ma_sound_config config;

    if (pFilePath == NULL) {
        return MA_INVALID_ARGS;
    }

    config = ma_sound_config_init_2(pEngine);
    config.pFilePath          = pFilePath;
    config.flags              = flags;
    config.pInitialAttachment = pGroup;
    config.pDoneFence         = pDoneFence;

    return ma_sound_init_ex(pEngine, &config, pSound);
}

MA_API ma_result ma_sound_init_from_file_w(ma_engine* pEngine, const wchar_t* pFilePath, ma_uint32 flags, ma_sound_group* pGroup, ma_fence* pDoneFence, ma_sound* pSound)
{
    ma_sound_config config;

    if (pFilePath == NULL) {
        return MA_INVALID_ARGS;
    }

    config = ma_sound_config_init_2(pEngine);
    config.pFilePathW         = pFilePath;
    config.flags              = flags;
    config.pInitialAttachment = pGroup;
    config.pDoneFence         = pDoneFence;

    return ma_sound_init_ex(pEngine, &config, pSound);
}

MA_API ma_result ma_sound_init_copy(ma_engine* pEngine, const ma_sound* pExistingSound, ma_uint32 flags, ma_sound_group* pGroup, ma_sound* pSound)
{
    ma_result result;
    ma_sound_config config;

    result = ma_sound_preinit(pEngine, pSound);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (pExistingSound == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Cloning only works for data buffers (not streams) that are loaded from the resource manager. */
    if (pExistingSound->pResourceManagerDataSource == NULL) {
        return MA_INVALID_OPERATION;
    }

    /*
    We need to make a clone of the data source. If the data source is not a data buffer (i.e. a stream)
    this will fail.
    */
    pSound->pResourceManagerDataSource = (ma_resource_manager_data_source*)ma_malloc(sizeof(*pSound->pResourceManagerDataSource), &pEngine->allocationCallbacks);
    if (pSound->pResourceManagerDataSource == NULL) {
        return MA_OUT_OF_MEMORY;
    }

    result = ma_resource_manager_data_source_init_copy(pEngine->pResourceManager, pExistingSound->pResourceManagerDataSource, pSound->pResourceManagerDataSource);
    if (result != MA_SUCCESS) {
        ma_free(pSound->pResourceManagerDataSource, &pEngine->allocationCallbacks);
        return result;
    }

    config = ma_sound_config_init_2(pEngine);
    config.pDataSource                 = pSound->pResourceManagerDataSource;
    config.flags                       = flags;
    config.pInitialAttachment          = pGroup;
    config.monoExpansionMode           = pExistingSound->engineNode.monoExpansionMode;
    config.volumeSmoothTimeInPCMFrames = pExistingSound->engineNode.volumeSmoothTimeInPCMFrames;

    result = ma_sound_init_from_data_source_internal(pEngine, &config, pSound);
    if (result != MA_SUCCESS) {
        ma_resource_manager_data_source_uninit(pSound->pResourceManagerDataSource);
        ma_free(pSound->pResourceManagerDataSource, &pEngine->allocationCallbacks);
        MA_ZERO_OBJECT(pSound);
        return result;
    }

    /* Make sure the sound is marked as the owner of the data source or else it will never get uninitialized. */
    pSound->ownsDataSource = MA_TRUE;

    return MA_SUCCESS;
}
#endif

MA_API ma_result ma_sound_init_from_data_source(ma_engine* pEngine, ma_data_source* pDataSource, ma_uint32 flags, ma_sound_group* pGroup, ma_sound* pSound)
{
    ma_sound_config config = ma_sound_config_init_2(pEngine);
    config.pDataSource        = pDataSource;
    config.flags              = flags;
    config.pInitialAttachment = pGroup;
    return ma_sound_init_ex(pEngine, &config, pSound);
}

MA_API ma_result ma_sound_init_ex(ma_engine* pEngine, const ma_sound_config* pConfig, ma_sound* pSound)
{
    ma_result result;

    result = ma_sound_preinit(pEngine, pSound);
    if (result != MA_SUCCESS) {
        return result;
    }

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    pSound->endCallback          = pConfig->endCallback;
    pSound->pEndCallbackUserData = pConfig->pEndCallbackUserData;

    /* We need to load the sound differently depending on whether or not we're loading from a file. */
#ifndef MA_NO_RESOURCE_MANAGER
    if (pConfig->pFilePath != NULL || pConfig->pFilePathW != NULL) {
        return ma_sound_init_from_file_internal(pEngine, pConfig, pSound);
    } else
#endif
    {
        /*
        Getting here means we're not loading from a file. We may be loading from an already-initialized
        data source, or none at all. If we aren't specifying any data source, we'll be initializing
        the equivalent to a group. ma_data_source_init_from_data_source_internal() will deal with this
        for us, so no special treatment required here.
        */
        return ma_sound_init_from_data_source_internal(pEngine, pConfig, pSound);
    }
}

MA_API void ma_sound_uninit(ma_sound* pSound)
{
    if (pSound == NULL) {
        return;
    }

    /*
    Always uninitialize the node first. This ensures it's detached from the graph and does not return until it has done
    so which makes thread safety beyond this point trivial.
    */
    ma_engine_node_uninit(&pSound->engineNode, &pSound->engineNode.pEngine->allocationCallbacks);

    /* Once the sound is detached from the group we can guarantee that it won't be referenced by the mixer thread which means it's safe for us to destroy the data source. */
#ifndef MA_NO_RESOURCE_MANAGER
    if (pSound->ownsDataSource) {
        ma_resource_manager_data_source_uninit(pSound->pResourceManagerDataSource);
        ma_free(pSound->pResourceManagerDataSource, &pSound->engineNode.pEngine->allocationCallbacks);
        pSound->pDataSource = NULL;
    }
#else
    MA_ASSERT(pSound->ownsDataSource == MA_FALSE);
#endif
}

MA_API ma_engine* ma_sound_get_engine(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return NULL;
    }

    return pSound->engineNode.pEngine;
}

MA_API ma_data_source* ma_sound_get_data_source(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return NULL;
    }

    return pSound->pDataSource;
}

MA_API ma_result ma_sound_start(ma_sound* pSound)
{
    if (pSound == NULL) {
        return MA_INVALID_ARGS;
    }

    /* If the sound is already playing, do nothing. */
    if (ma_sound_is_playing(pSound)) {
        return MA_SUCCESS;
    }

    /* If the sound is at the end it means we want to start from the start again. */
    if (ma_sound_at_end(pSound)) {
        ma_result result = ma_data_source_seek_to_pcm_frame(pSound->pDataSource, 0);
        if (result != MA_SUCCESS && result != MA_NOT_IMPLEMENTED) {
            return result;  /* Failed to seek back to the start. */
        }

        /* Make sure we clear the end indicator. */
        ma_atomic_exchange_32(&pSound->atEnd, MA_FALSE);
    }

    /* Make sure the sound is started. If there's a start delay, the sound won't actually start until the start time is reached. */
    ma_node_set_state(pSound, ma_node_state_started);

    return MA_SUCCESS;
}

MA_API ma_result ma_sound_stop(ma_sound* pSound)
{
    if (pSound == NULL) {
        return MA_INVALID_ARGS;
    }

    /* This will stop the sound immediately. Use ma_sound_set_stop_time() to stop the sound at a specific time. */
    ma_node_set_state(pSound, ma_node_state_stopped);

    return MA_SUCCESS;
}

MA_API ma_result ma_sound_stop_with_fade_in_pcm_frames(ma_sound* pSound, ma_uint64 fadeLengthInFrames)
{
    if (pSound == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Stopping with a fade out requires us to schedule the stop into the future by the fade length. */
    ma_sound_set_stop_time_with_fade_in_pcm_frames(pSound, ma_engine_get_time_in_pcm_frames(ma_sound_get_engine(pSound)) + fadeLengthInFrames, fadeLengthInFrames);

    return MA_SUCCESS;
}

MA_API ma_result ma_sound_stop_with_fade_in_milliseconds(ma_sound* pSound, ma_uint64 fadeLengthInMilliseconds)
{
    ma_uint64 sampleRate;

    if (pSound == NULL) {
        return MA_INVALID_ARGS;
    }

    sampleRate = ma_engine_get_sample_rate(ma_sound_get_engine(pSound));

    return ma_sound_stop_with_fade_in_pcm_frames(pSound, (fadeLengthInMilliseconds * sampleRate) / 1000);
}

MA_API void ma_sound_set_volume(ma_sound* pSound, float volume)
{
    if (pSound == NULL) {
        return;
    }

    ma_engine_node_set_volume(&pSound->engineNode, volume);
}

MA_API float ma_sound_get_volume(const ma_sound* pSound)
{
    float volume = 0;

    if (pSound == NULL) {
        return 0;
    }

    ma_engine_node_get_volume(&pSound->engineNode, &volume);

    return volume;
}

MA_API void ma_sound_set_pan(ma_sound* pSound, float pan)
{
    if (pSound == NULL) {
        return;
    }

    ma_panner_set_pan(&pSound->engineNode.panner, pan);
}

MA_API float ma_sound_get_pan(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return 0;
    }

    return ma_panner_get_pan(&pSound->engineNode.panner);
}

MA_API void ma_sound_set_pan_mode(ma_sound* pSound, ma_pan_mode panMode)
{
    if (pSound == NULL) {
        return;
    }

    ma_panner_set_mode(&pSound->engineNode.panner, panMode);
}

MA_API ma_pan_mode ma_sound_get_pan_mode(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return ma_pan_mode_balance;
    }

    return ma_panner_get_mode(&pSound->engineNode.panner);
}

MA_API void ma_sound_set_pitch(ma_sound* pSound, float pitch)
{
    if (pSound == NULL) {
        return;
    }

    if (pitch <= 0) {
        return;
    }

    ma_atomic_exchange_explicit_f32(&pSound->engineNode.pitch, pitch, ma_atomic_memory_order_release);
}

MA_API float ma_sound_get_pitch(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return 0;
    }

    return ma_atomic_load_f32(&pSound->engineNode.pitch);    /* Naughty const-cast for this. */
}

MA_API void ma_sound_set_spatialization_enabled(ma_sound* pSound, ma_bool32 enabled)
{
    if (pSound == NULL) {
        return;
    }

    ma_atomic_exchange_explicit_32(&pSound->engineNode.isSpatializationDisabled, !enabled, ma_atomic_memory_order_release);
}

MA_API ma_bool32 ma_sound_is_spatialization_enabled(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return MA_FALSE;
    }

    return ma_engine_node_is_spatialization_enabled(&pSound->engineNode);
}

MA_API void ma_sound_set_pinned_listener_index(ma_sound* pSound, ma_uint32 listenerIndex)
{
    if (pSound == NULL || listenerIndex >= ma_engine_get_listener_count(ma_sound_get_engine(pSound))) {
        return;
    }

    ma_atomic_exchange_explicit_32(&pSound->engineNode.pinnedListenerIndex, listenerIndex, ma_atomic_memory_order_release);
}

MA_API ma_uint32 ma_sound_get_pinned_listener_index(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return MA_LISTENER_INDEX_CLOSEST;
    }

    return ma_atomic_load_explicit_32(&pSound->engineNode.pinnedListenerIndex, ma_atomic_memory_order_acquire);
}

MA_API ma_uint32 ma_sound_get_listener_index(const ma_sound* pSound)
{
    ma_uint32 listenerIndex;

    if (pSound == NULL) {
        return 0;
    }

    listenerIndex = ma_sound_get_pinned_listener_index(pSound);
    if (listenerIndex == MA_LISTENER_INDEX_CLOSEST) {
        ma_vec3f position = ma_sound_get_position(pSound);
        return ma_engine_find_closest_listener(ma_sound_get_engine(pSound), position.x, position.y, position.z);
    }

    return listenerIndex;
}

MA_API ma_vec3f ma_sound_get_direction_to_listener(const ma_sound* pSound)
{
    ma_vec3f relativePos;
    ma_engine* pEngine;

    if (pSound == NULL) {
        return ma_vec3f_init_3f(0, 0, -1);
    }

    pEngine = ma_sound_get_engine(pSound);
    if (pEngine == NULL) {
        return ma_vec3f_init_3f(0, 0, -1);
    }

    ma_spatializer_get_relative_position_and_direction(&pSound->engineNode.spatializer, &pEngine->listeners[ma_sound_get_listener_index(pSound)], &relativePos, NULL);

    return ma_vec3f_normalize(ma_vec3f_neg(relativePos));
}

MA_API void ma_sound_set_position(ma_sound* pSound, float x, float y, float z)
{
    if (pSound == NULL) {
        return;
    }

    ma_spatializer_set_position(&pSound->engineNode.spatializer, x, y, z);
}

MA_API ma_vec3f ma_sound_get_position(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return ma_vec3f_init_3f(0, 0, 0);
    }

    return ma_spatializer_get_position(&pSound->engineNode.spatializer);
}

MA_API void ma_sound_set_direction(ma_sound* pSound, float x, float y, float z)
{
    if (pSound == NULL) {
        return;
    }

    ma_spatializer_set_direction(&pSound->engineNode.spatializer, x, y, z);
}

MA_API ma_vec3f ma_sound_get_direction(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return ma_vec3f_init_3f(0, 0, 0);
    }

    return ma_spatializer_get_direction(&pSound->engineNode.spatializer);
}

MA_API void ma_sound_set_velocity(ma_sound* pSound, float x, float y, float z)
{
    if (pSound == NULL) {
        return;
    }

    ma_spatializer_set_velocity(&pSound->engineNode.spatializer, x, y, z);
}

MA_API ma_vec3f ma_sound_get_velocity(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return ma_vec3f_init_3f(0, 0, 0);
    }

    return ma_spatializer_get_velocity(&pSound->engineNode.spatializer);
}

MA_API void ma_sound_set_attenuation_model(ma_sound* pSound, ma_attenuation_model attenuationModel)
{
    if (pSound == NULL) {
        return;
    }

    ma_spatializer_set_attenuation_model(&pSound->engineNode.spatializer, attenuationModel);
}

MA_API ma_attenuation_model ma_sound_get_attenuation_model(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return ma_attenuation_model_none;
    }

    return ma_spatializer_get_attenuation_model(&pSound->engineNode.spatializer);
}

MA_API void ma_sound_set_positioning(ma_sound* pSound, ma_positioning positioning)
{
    if (pSound == NULL) {
        return;
    }

    ma_spatializer_set_positioning(&pSound->engineNode.spatializer, positioning);
}

MA_API ma_positioning ma_sound_get_positioning(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return ma_positioning_absolute;
    }

    return ma_spatializer_get_positioning(&pSound->engineNode.spatializer);
}

MA_API void ma_sound_set_rolloff(ma_sound* pSound, float rolloff)
{
    if (pSound == NULL) {
        return;
    }

    ma_spatializer_set_rolloff(&pSound->engineNode.spatializer, rolloff);
}

MA_API float ma_sound_get_rolloff(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return 0;
    }

    return ma_spatializer_get_rolloff(&pSound->engineNode.spatializer);
}

MA_API void ma_sound_set_min_gain(ma_sound* pSound, float minGain)
{
    if (pSound == NULL) {
        return;
    }

    ma_spatializer_set_min_gain(&pSound->engineNode.spatializer, minGain);
}

MA_API float ma_sound_get_min_gain(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return 0;
    }

    return ma_spatializer_get_min_gain(&pSound->engineNode.spatializer);
}

MA_API void ma_sound_set_max_gain(ma_sound* pSound, float maxGain)
{
    if (pSound == NULL) {
        return;
    }

    ma_spatializer_set_max_gain(&pSound->engineNode.spatializer, maxGain);
}

MA_API float ma_sound_get_max_gain(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return 0;
    }

    return ma_spatializer_get_max_gain(&pSound->engineNode.spatializer);
}

MA_API void ma_sound_set_min_distance(ma_sound* pSound, float minDistance)
{
    if (pSound == NULL) {
        return;
    }

    ma_spatializer_set_min_distance(&pSound->engineNode.spatializer, minDistance);
}

MA_API float ma_sound_get_min_distance(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return 0;
    }

    return ma_spatializer_get_min_distance(&pSound->engineNode.spatializer);
}

MA_API void ma_sound_set_max_distance(ma_sound* pSound, float maxDistance)
{
    if (pSound == NULL) {
        return;
    }

    ma_spatializer_set_max_distance(&pSound->engineNode.spatializer, maxDistance);
}

MA_API float ma_sound_get_max_distance(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return 0;
    }

    return ma_spatializer_get_max_distance(&pSound->engineNode.spatializer);
}

MA_API void ma_sound_set_cone(ma_sound* pSound, float innerAngleInRadians, float outerAngleInRadians, float outerGain)
{
    if (pSound == NULL) {
        return;
    }

    ma_spatializer_set_cone(&pSound->engineNode.spatializer, innerAngleInRadians, outerAngleInRadians, outerGain);
}

MA_API void ma_sound_get_cone(const ma_sound* pSound, float* pInnerAngleInRadians, float* pOuterAngleInRadians, float* pOuterGain)
{
    if (pInnerAngleInRadians != NULL) {
        *pInnerAngleInRadians = 0;
    }

    if (pOuterAngleInRadians != NULL) {
        *pOuterAngleInRadians = 0;
    }

    if (pOuterGain != NULL) {
        *pOuterGain = 0;
    }

    if (pSound == NULL) {
        return;
    }

    ma_spatializer_get_cone(&pSound->engineNode.spatializer, pInnerAngleInRadians, pOuterAngleInRadians, pOuterGain);
}

MA_API void ma_sound_set_doppler_factor(ma_sound* pSound, float dopplerFactor)
{
    if (pSound == NULL) {
        return;
    }

    ma_spatializer_set_doppler_factor(&pSound->engineNode.spatializer, dopplerFactor);
}

MA_API float ma_sound_get_doppler_factor(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return 0;
    }

    return ma_spatializer_get_doppler_factor(&pSound->engineNode.spatializer);
}

MA_API void ma_sound_set_directional_attenuation_factor(ma_sound* pSound, float directionalAttenuationFactor)
{
    if (pSound == NULL) {
        return;
    }

    ma_spatializer_set_directional_attenuation_factor(&pSound->engineNode.spatializer, directionalAttenuationFactor);
}

MA_API float ma_sound_get_directional_attenuation_factor(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return 1;
    }

    return ma_spatializer_get_directional_attenuation_factor(&pSound->engineNode.spatializer);
}


MA_API void ma_sound_set_fade_in_pcm_frames(ma_sound* pSound, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInFrames)
{
    if (pSound == NULL) {
        return;
    }

    ma_sound_set_fade_start_in_pcm_frames(pSound, volumeBeg, volumeEnd, fadeLengthInFrames, (~(ma_uint64)0));
}

MA_API void ma_sound_set_fade_in_milliseconds(ma_sound* pSound, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInMilliseconds)
{
    if (pSound == NULL) {
        return;
    }

    ma_sound_set_fade_in_pcm_frames(pSound, volumeBeg, volumeEnd, (fadeLengthInMilliseconds * pSound->engineNode.fader.config.sampleRate) / 1000);
}

MA_API void ma_sound_set_fade_start_in_pcm_frames(ma_sound* pSound, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInFrames, ma_uint64 absoluteGlobalTimeInFrames)
{
    if (pSound == NULL) {
        return;
    }

    /*
    We don't want to update the fader at this point because we need to use the engine's current time
    to derive the fader's start offset. The timer is being updated on the audio thread so in order to
    do this as accurately as possible we'll need to defer this to the audio thread.
    */
    ma_atomic_float_set(&pSound->engineNode.fadeSettings.volumeBeg, volumeBeg);
    ma_atomic_float_set(&pSound->engineNode.fadeSettings.volumeEnd, volumeEnd);
    ma_atomic_uint64_set(&pSound->engineNode.fadeSettings.fadeLengthInFrames, fadeLengthInFrames);
    ma_atomic_uint64_set(&pSound->engineNode.fadeSettings.absoluteGlobalTimeInFrames, absoluteGlobalTimeInFrames);
}

MA_API void ma_sound_set_fade_start_in_milliseconds(ma_sound* pSound, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInMilliseconds, ma_uint64 absoluteGlobalTimeInMilliseconds)
{
    ma_uint32 sampleRate;

    if (pSound == NULL) {
        return;
    }

    sampleRate = ma_engine_get_sample_rate(ma_sound_get_engine(pSound));

    ma_sound_set_fade_start_in_pcm_frames(pSound, volumeBeg, volumeEnd, (fadeLengthInMilliseconds * sampleRate) / 1000, (absoluteGlobalTimeInMilliseconds * sampleRate) / 1000);
}

MA_API float ma_sound_get_current_fade_volume(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return MA_INVALID_ARGS;
    }

    return ma_fader_get_current_volume(&pSound->engineNode.fader);
}

MA_API void ma_sound_set_start_time_in_pcm_frames(ma_sound* pSound, ma_uint64 absoluteGlobalTimeInFrames)
{
    if (pSound == NULL) {
        return;
    }

    ma_node_set_state_time(pSound, ma_node_state_started, absoluteGlobalTimeInFrames);
}

MA_API void ma_sound_set_start_time_in_milliseconds(ma_sound* pSound, ma_uint64 absoluteGlobalTimeInMilliseconds)
{
    if (pSound == NULL) {
        return;
    }

    ma_sound_set_start_time_in_pcm_frames(pSound, absoluteGlobalTimeInMilliseconds * ma_engine_get_sample_rate(ma_sound_get_engine(pSound)) / 1000);
}

MA_API void ma_sound_set_stop_time_in_pcm_frames(ma_sound* pSound, ma_uint64 absoluteGlobalTimeInFrames)
{
    if (pSound == NULL) {
        return;
    }

    ma_sound_set_stop_time_with_fade_in_pcm_frames(pSound, absoluteGlobalTimeInFrames, 0);
}

MA_API void ma_sound_set_stop_time_in_milliseconds(ma_sound* pSound, ma_uint64 absoluteGlobalTimeInMilliseconds)
{
    if (pSound == NULL) {
        return;
    }

    ma_sound_set_stop_time_in_pcm_frames(pSound, absoluteGlobalTimeInMilliseconds * ma_engine_get_sample_rate(ma_sound_get_engine(pSound)) / 1000);
}

MA_API void ma_sound_set_stop_time_with_fade_in_pcm_frames(ma_sound* pSound, ma_uint64 stopAbsoluteGlobalTimeInFrames, ma_uint64 fadeLengthInFrames)
{
    if (pSound == NULL) {
        return;
    }

    if (fadeLengthInFrames > 0) {
        if (fadeLengthInFrames > stopAbsoluteGlobalTimeInFrames) {
            fadeLengthInFrames = stopAbsoluteGlobalTimeInFrames;
        }

        ma_sound_set_fade_start_in_pcm_frames(pSound, -1, 0, fadeLengthInFrames, stopAbsoluteGlobalTimeInFrames - fadeLengthInFrames);
    }

    ma_node_set_state_time(pSound, ma_node_state_stopped, stopAbsoluteGlobalTimeInFrames);
}

MA_API void ma_sound_set_stop_time_with_fade_in_milliseconds(ma_sound* pSound, ma_uint64 stopAbsoluteGlobalTimeInMilliseconds, ma_uint64 fadeLengthInMilliseconds)
{
    ma_uint32 sampleRate;

    if (pSound == NULL) {
        return;
    }

    sampleRate = ma_engine_get_sample_rate(ma_sound_get_engine(pSound));

    ma_sound_set_stop_time_with_fade_in_pcm_frames(pSound, (stopAbsoluteGlobalTimeInMilliseconds * sampleRate) / 1000, (fadeLengthInMilliseconds * sampleRate) / 1000);
}

MA_API ma_bool32 ma_sound_is_playing(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return MA_FALSE;
    }

    return ma_node_get_state_by_time(pSound, ma_engine_get_time_in_pcm_frames(ma_sound_get_engine(pSound))) == ma_node_state_started;
}

MA_API ma_uint64 ma_sound_get_time_in_pcm_frames(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return 0;
    }

    return ma_node_get_time(pSound);
}

MA_API ma_uint64 ma_sound_get_time_in_milliseconds(const ma_sound* pSound)
{
    return ma_sound_get_time_in_pcm_frames(pSound) * 1000 / ma_engine_get_sample_rate(ma_sound_get_engine(pSound));
}

MA_API void ma_sound_set_looping(ma_sound* pSound, ma_bool32 isLooping)
{
    if (pSound == NULL) {
        return;
    }

    /* Looping is only a valid concept if the sound is backed by a data source. */
    if (pSound->pDataSource == NULL) {
        return;
    }

    /* The looping state needs to be applied to the data source in order for any looping to actually happen. */
    ma_data_source_set_looping(pSound->pDataSource, isLooping);
}

MA_API ma_bool32 ma_sound_is_looping(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return MA_FALSE;
    }

    /* There is no notion of looping for sounds that are not backed by a data source. */
    if (pSound->pDataSource == NULL) {
        return MA_FALSE;
    }

    return ma_data_source_is_looping(pSound->pDataSource);
}

MA_API ma_bool32 ma_sound_at_end(const ma_sound* pSound)
{
    if (pSound == NULL) {
        return MA_FALSE;
    }

    /* There is no notion of an end of a sound if it's not backed by a data source. */
    if (pSound->pDataSource == NULL) {
        return MA_FALSE;
    }

    return ma_sound_get_at_end(pSound);
}

MA_API ma_result ma_sound_seek_to_pcm_frame(ma_sound* pSound, ma_uint64 frameIndex)
{
    if (pSound == NULL) {
        return MA_INVALID_ARGS;
    }

    /* Seeking is only valid for sounds that are backed by a data source. */
    if (pSound->pDataSource == NULL) {
        return MA_INVALID_OPERATION;
    }

    /* We can't be seeking while reading at the same time. We just set the seek target and get the mixing thread to do the actual seek. */
    ma_atomic_exchange_64(&pSound->seekTarget, frameIndex);

    return MA_SUCCESS;
}

MA_API ma_result ma_sound_seek_to_second(ma_sound* pSound, float seekPointInSeconds)
{
    ma_uint64 frameIndex;
    ma_uint32 sampleRate;
    ma_result result;

    if (pSound == NULL) {
        return MA_INVALID_ARGS;
    }

    result = ma_sound_get_data_format(pSound, NULL, NULL, &sampleRate, NULL, 0);
    if (result != MA_SUCCESS) {
        return result;
    }

    /* We need PCM frames. We need to convert first */
    frameIndex = (ma_uint64)(seekPointInSeconds * sampleRate);

    return ma_sound_seek_to_pcm_frame(pSound, frameIndex);
}

MA_API ma_result ma_sound_get_data_format(ma_sound* pSound, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap, size_t channelMapCap)
{
    if (pSound == NULL) {
        return MA_INVALID_ARGS;
    }

    /* The data format is retrieved directly from the data source if the sound is backed by one. Otherwise we pull it from the node. */
    if (pSound->pDataSource == NULL) {
        ma_uint32 channels;

        if (pFormat != NULL) {
            *pFormat = ma_format_f32;
        }

        channels = ma_node_get_input_channels(&pSound->engineNode, 0);
        if (pChannels != NULL) {
            *pChannels = channels;
        }

        if (pSampleRate != NULL) {
            *pSampleRate = pSound->engineNode.resampler.config.sampleRateIn;
        }

        if (pChannelMap != NULL) {
            ma_channel_map_init_standard(ma_standard_channel_map_default, pChannelMap, channelMapCap, channels);
        }

        return MA_SUCCESS;
    } else {
        return ma_data_source_get_data_format(pSound->pDataSource, pFormat, pChannels, pSampleRate, pChannelMap, channelMapCap);
    }
}

MA_API ma_result ma_sound_get_cursor_in_pcm_frames(ma_sound* pSound, ma_uint64* pCursor)
{
    ma_uint64 seekTarget;

    if (pSound == NULL) {
        return MA_INVALID_ARGS;
    }

    /* The notion of a cursor is only valid for sounds that are backed by a data source. */
    if (pSound->pDataSource == NULL) {
        return MA_INVALID_OPERATION;
    }

    seekTarget = ma_atomic_load_64(&pSound->seekTarget);
    if (seekTarget != MA_SEEK_TARGET_NONE) {
        *pCursor = seekTarget;
        return MA_SUCCESS;
    } else {
        return ma_data_source_get_cursor_in_pcm_frames(pSound->pDataSource, pCursor);
    }
}

MA_API ma_result ma_sound_get_length_in_pcm_frames(ma_sound* pSound, ma_uint64* pLength)
{
    if (pSound == NULL) {
        return MA_INVALID_ARGS;
    }

    /* The notion of a sound length is only valid for sounds that are backed by a data source. */
    if (pSound->pDataSource == NULL) {
        return MA_INVALID_OPERATION;
    }

    return ma_data_source_get_length_in_pcm_frames(pSound->pDataSource, pLength);
}

MA_API ma_result ma_sound_get_cursor_in_seconds(ma_sound* pSound, float* pCursor)
{
    ma_result result;
    ma_uint64 cursorInPCMFrames;
    ma_uint32 sampleRate;

    if (pCursor != NULL) {
        *pCursor = 0;
    }

    result = ma_sound_get_cursor_in_pcm_frames(pSound, &cursorInPCMFrames);
    if (result != MA_SUCCESS) {
        return result;
    }

    result = ma_sound_get_data_format(pSound, NULL, NULL, &sampleRate, NULL, 0);
    if (result != MA_SUCCESS) {
        return result;
    }

    /* VC6 does not support division of unsigned 64-bit integers with floating point numbers. Need to use a signed number. This shouldn't effect anything in practice. */
    *pCursor = (ma_int64)cursorInPCMFrames / (float)sampleRate;

    return MA_SUCCESS;
}

MA_API ma_result ma_sound_get_length_in_seconds(ma_sound* pSound, float* pLength)
{
    if (pSound == NULL) {
        return MA_INVALID_ARGS;
    }

    /* The notion of a sound length is only valid for sounds that are backed by a data source. */
    if (pSound->pDataSource == NULL) {
        return MA_INVALID_OPERATION;
    }

    return ma_data_source_get_length_in_seconds(pSound->pDataSource, pLength);
}

MA_API ma_result ma_sound_set_end_callback(ma_sound* pSound, ma_sound_end_proc callback, void* pUserData)
{
    if (pSound == NULL) {
        return MA_INVALID_ARGS;
    }

    /* The notion of an end is only valid for sounds that are backed by a data source. */
    if (pSound->pDataSource == NULL) {
        return MA_INVALID_OPERATION;
    }

    pSound->endCallback          = callback;
    pSound->pEndCallbackUserData = pUserData;

    return MA_SUCCESS;
}


MA_API ma_result ma_sound_group_init(ma_engine* pEngine, ma_uint32 flags, ma_sound_group* pParentGroup, ma_sound_group* pGroup)
{
    ma_sound_group_config config = ma_sound_group_config_init_2(pEngine);
    config.flags              = flags;
    config.pInitialAttachment = pParentGroup;
    return ma_sound_group_init_ex(pEngine, &config, pGroup);
}

MA_API ma_result ma_sound_group_init_ex(ma_engine* pEngine, const ma_sound_group_config* pConfig, ma_sound_group* pGroup)
{
    ma_sound_config soundConfig;

    if (pGroup == NULL) {
        return MA_INVALID_ARGS;
    }

    MA_ZERO_OBJECT(pGroup);

    if (pConfig == NULL) {
        return MA_INVALID_ARGS;
    }

    /* A sound group is just a sound without a data source. */
    soundConfig = *pConfig;
    soundConfig.pFilePath   = NULL;
    soundConfig.pFilePathW  = NULL;
    soundConfig.pDataSource = NULL;

    /*
    Groups need to have spatialization disabled by default because I think it'll be pretty rare
    that programs will want to spatialize groups (but not unheard of). Certainly it feels like
    disabling this by default feels like the right option. Spatialization can be enabled with a
    call to ma_sound_group_set_spatialization_enabled().
    */
    soundConfig.flags |= MA_SOUND_FLAG_NO_SPATIALIZATION;

    return ma_sound_init_ex(pEngine, &soundConfig, pGroup);
}

MA_API void ma_sound_group_uninit(ma_sound_group* pGroup)
{
    ma_sound_uninit(pGroup);
}

MA_API ma_engine* ma_sound_group_get_engine(const ma_sound_group* pGroup)
{
    return ma_sound_get_engine(pGroup);
}

MA_API ma_result ma_sound_group_start(ma_sound_group* pGroup)
{
    return ma_sound_start(pGroup);
}

MA_API ma_result ma_sound_group_stop(ma_sound_group* pGroup)
{
    return ma_sound_stop(pGroup);
}

MA_API void ma_sound_group_set_volume(ma_sound_group* pGroup, float volume)
{
    ma_sound_set_volume(pGroup, volume);
}

MA_API float ma_sound_group_get_volume(const ma_sound_group* pGroup)
{
    return ma_sound_get_volume(pGroup);
}

MA_API void ma_sound_group_set_pan(ma_sound_group* pGroup, float pan)
{
    ma_sound_set_pan(pGroup, pan);
}

MA_API float ma_sound_group_get_pan(const ma_sound_group* pGroup)
{
    return ma_sound_get_pan(pGroup);
}

MA_API void ma_sound_group_set_pan_mode(ma_sound_group* pGroup, ma_pan_mode panMode)
{
    ma_sound_set_pan_mode(pGroup, panMode);
}

MA_API ma_pan_mode ma_sound_group_get_pan_mode(const ma_sound_group* pGroup)
{
    return ma_sound_get_pan_mode(pGroup);
}

MA_API void ma_sound_group_set_pitch(ma_sound_group* pGroup, float pitch)
{
    ma_sound_set_pitch(pGroup, pitch);
}

MA_API float ma_sound_group_get_pitch(const ma_sound_group* pGroup)
{
    return ma_sound_get_pitch(pGroup);
}

MA_API void ma_sound_group_set_spatialization_enabled(ma_sound_group* pGroup, ma_bool32 enabled)
{
    ma_sound_set_spatialization_enabled(pGroup, enabled);
}

MA_API ma_bool32 ma_sound_group_is_spatialization_enabled(const ma_sound_group* pGroup)
{
    return ma_sound_is_spatialization_enabled(pGroup);
}

MA_API void ma_sound_group_set_pinned_listener_index(ma_sound_group* pGroup, ma_uint32 listenerIndex)
{
    ma_sound_set_pinned_listener_index(pGroup, listenerIndex);
}

MA_API ma_uint32 ma_sound_group_get_pinned_listener_index(const ma_sound_group* pGroup)
{
    return ma_sound_get_pinned_listener_index(pGroup);
}

MA_API ma_uint32 ma_sound_group_get_listener_index(const ma_sound_group* pGroup)
{
    return ma_sound_get_listener_index(pGroup);
}

MA_API ma_vec3f ma_sound_group_get_direction_to_listener(const ma_sound_group* pGroup)
{
    return ma_sound_get_direction_to_listener(pGroup);
}

MA_API void ma_sound_group_set_position(ma_sound_group* pGroup, float x, float y, float z)
{
    ma_sound_set_position(pGroup, x, y, z);
}

MA_API ma_vec3f ma_sound_group_get_position(const ma_sound_group* pGroup)
{
    return ma_sound_get_position(pGroup);
}

MA_API void ma_sound_group_set_direction(ma_sound_group* pGroup, float x, float y, float z)
{
    ma_sound_set_direction(pGroup, x, y, z);
}

MA_API ma_vec3f ma_sound_group_get_direction(const ma_sound_group* pGroup)
{
    return ma_sound_get_direction(pGroup);
}

MA_API void ma_sound_group_set_velocity(ma_sound_group* pGroup, float x, float y, float z)
{
    ma_sound_set_velocity(pGroup, x, y, z);
}

MA_API ma_vec3f ma_sound_group_get_velocity(const ma_sound_group* pGroup)
{
    return ma_sound_get_velocity(pGroup);
}

MA_API void ma_sound_group_set_attenuation_model(ma_sound_group* pGroup, ma_attenuation_model attenuationModel)
{
    ma_sound_set_attenuation_model(pGroup, attenuationModel);
}

MA_API ma_attenuation_model ma_sound_group_get_attenuation_model(const ma_sound_group* pGroup)
{
    return ma_sound_get_attenuation_model(pGroup);
}

MA_API void ma_sound_group_set_positioning(ma_sound_group* pGroup, ma_positioning positioning)
{
    ma_sound_set_positioning(pGroup, positioning);
}

MA_API ma_positioning ma_sound_group_get_positioning(const ma_sound_group* pGroup)
{
    return ma_sound_get_positioning(pGroup);
}

MA_API void ma_sound_group_set_rolloff(ma_sound_group* pGroup, float rolloff)
{
    ma_sound_set_rolloff(pGroup, rolloff);
}

MA_API float ma_sound_group_get_rolloff(const ma_sound_group* pGroup)
{
    return ma_sound_get_rolloff(pGroup);
}

MA_API void ma_sound_group_set_min_gain(ma_sound_group* pGroup, float minGain)
{
    ma_sound_set_min_gain(pGroup, minGain);
}

MA_API float ma_sound_group_get_min_gain(const ma_sound_group* pGroup)
{
    return ma_sound_get_min_gain(pGroup);
}

MA_API void ma_sound_group_set_max_gain(ma_sound_group* pGroup, float maxGain)
{
    ma_sound_set_max_gain(pGroup, maxGain);
}

MA_API float ma_sound_group_get_max_gain(const ma_sound_group* pGroup)
{
    return ma_sound_get_max_gain(pGroup);
}

MA_API void ma_sound_group_set_min_distance(ma_sound_group* pGroup, float minDistance)
{
    ma_sound_set_min_distance(pGroup, minDistance);
}

MA_API float ma_sound_group_get_min_distance(const ma_sound_group* pGroup)
{
    return ma_sound_get_min_distance(pGroup);
}

MA_API void ma_sound_group_set_max_distance(ma_sound_group* pGroup, float maxDistance)
{
    ma_sound_set_max_distance(pGroup, maxDistance);
}

MA_API float ma_sound_group_get_max_distance(const ma_sound_group* pGroup)
{
    return ma_sound_get_max_distance(pGroup);
}

MA_API void ma_sound_group_set_cone(ma_sound_group* pGroup, float innerAngleInRadians, float outerAngleInRadians, float outerGain)
{
    ma_sound_set_cone(pGroup, innerAngleInRadians, outerAngleInRadians, outerGain);
}

MA_API void ma_sound_group_get_cone(const ma_sound_group* pGroup, float* pInnerAngleInRadians, float* pOuterAngleInRadians, float* pOuterGain)
{
    ma_sound_get_cone(pGroup, pInnerAngleInRadians, pOuterAngleInRadians, pOuterGain);
}

MA_API void ma_sound_group_set_doppler_factor(ma_sound_group* pGroup, float dopplerFactor)
{
    ma_sound_set_doppler_factor(pGroup, dopplerFactor);
}

MA_API float ma_sound_group_get_doppler_factor(const ma_sound_group* pGroup)
{
    return ma_sound_get_doppler_factor(pGroup);
}

MA_API void ma_sound_group_set_directional_attenuation_factor(ma_sound_group* pGroup, float directionalAttenuationFactor)
{
    ma_sound_set_directional_attenuation_factor(pGroup, directionalAttenuationFactor);
}

MA_API float ma_sound_group_get_directional_attenuation_factor(const ma_sound_group* pGroup)
{
    return ma_sound_get_directional_attenuation_factor(pGroup);
}

MA_API void ma_sound_group_set_fade_in_pcm_frames(ma_sound_group* pGroup, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInFrames)
{
    ma_sound_set_fade_in_pcm_frames(pGroup, volumeBeg, volumeEnd, fadeLengthInFrames);
}

MA_API void ma_sound_group_set_fade_in_milliseconds(ma_sound_group* pGroup, float volumeBeg, float volumeEnd, ma_uint64 fadeLengthInMilliseconds)
{
    ma_sound_set_fade_in_milliseconds(pGroup, volumeBeg, volumeEnd, fadeLengthInMilliseconds);
}

MA_API float ma_sound_group_get_current_fade_volume(ma_sound_group* pGroup)
{
    return ma_sound_get_current_fade_volume(pGroup);
}

MA_API void ma_sound_group_set_start_time_in_pcm_frames(ma_sound_group* pGroup, ma_uint64 absoluteGlobalTimeInFrames)
{
    ma_sound_set_start_time_in_pcm_frames(pGroup, absoluteGlobalTimeInFrames);
}

MA_API void ma_sound_group_set_start_time_in_milliseconds(ma_sound_group* pGroup, ma_uint64 absoluteGlobalTimeInMilliseconds)
{
    ma_sound_set_start_time_in_milliseconds(pGroup, absoluteGlobalTimeInMilliseconds);
}

MA_API void ma_sound_group_set_stop_time_in_pcm_frames(ma_sound_group* pGroup, ma_uint64 absoluteGlobalTimeInFrames)
{
    ma_sound_set_stop_time_in_pcm_frames(pGroup, absoluteGlobalTimeInFrames);
}

MA_API void ma_sound_group_set_stop_time_in_milliseconds(ma_sound_group* pGroup, ma_uint64 absoluteGlobalTimeInMilliseconds)
{
    ma_sound_set_stop_time_in_milliseconds(pGroup, absoluteGlobalTimeInMilliseconds);
}

MA_API ma_bool32 ma_sound_group_is_playing(const ma_sound_group* pGroup)
{
    return ma_sound_is_playing(pGroup);
}

MA_API ma_uint64 ma_sound_group_get_time_in_pcm_frames(const ma_sound_group* pGroup)
{
    return ma_sound_get_time_in_pcm_frames(pGroup);
}
#endif  /* MA_NO_ENGINE */
/* END SECTION: miniaudio_engine.c */



/**************************************************************************************************************************************************************
***************************************************************************************************************************************************************

Auto Generated
==============
All code below is auto-generated from a tool. This mostly consists of decoding backend implementations such as ma_dr_wav, ma_dr_flac, etc. If you find a bug in the
code below please report the bug to the respective repository for the relevant project (probably dr_libs).

***************************************************************************************************************************************************************
**************************************************************************************************************************************************************/




/* End globally disabled warnings. */
#if defined(_MSC_VER)
    #pragma warning(pop)
#endif

#endif  /* miniaudio_c */
#endif  /* MINIAUDIO_IMPLEMENTATION */


/*
This software is available as a choice of the following licenses. Choose
whichever you prefer.

===============================================================================
ALTERNATIVE 1 - Public Domain (www.unlicense.org)
===============================================================================
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.

In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org/>

===============================================================================
ALTERNATIVE 2 - MIT No Attribution
===============================================================================
Copyright 2025 David Reid

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
