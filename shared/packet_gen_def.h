/* SPDX-License-Identifier: MIT
 *
 * SPDX-FileCopyrightText: Copyright (c) 2024 Ian Hangartner <icrashstuff at outlook dot com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/* WARNING: This file is automatically generated by generate_packets_header.py, DO NOT EDIT */

#ifndef MCS_B181_PACKET_H
#error "This header should only be included by packet.h"
#endif

#ifndef MCS_B181_PACKET_GEN_DEFS_H
#define MCS_B181_PACKET_GEN_DEFS_H

struct packet_keep_alive_t : packet_t
{
    packet_keep_alive_t() { id = PACKET_ID_KEEP_ALIVE; }

    jint keep_alive_id = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_KEEP_ALIVE);
        dat.push_back(id);
        assemble_int(dat, keep_alive_id);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_keep_alive_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(keep_alive_id);

        ImGui::EndTable();
    }
};
/**
 * Client -> Server
 */
struct packet_login_request_c2s_t : packet_t
{
    packet_login_request_c2s_t() { id = PACKET_ID_LOGIN_REQUEST; }

    jint protocol_ver = 0;
    std::string username;
    jlong unused0 = 0;
    jint unused1 = 0;
    jbyte unused2 = 0;
    jbyte unused3 = 0;
    jubyte unused4 = 0;
    jubyte unused5 = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_LOGIN_REQUEST);
        dat.push_back(id);
        assemble_int(dat, protocol_ver);
        assemble_string16(dat, username);
        assemble_long(dat, unused0);
        assemble_int(dat, unused1);
        assemble_byte(dat, unused2);
        assemble_byte(dat, unused3);
        assemble_ubyte(dat, unused4);
        assemble_ubyte(dat, unused5);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0 + username.capacity());

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_login_request_c2s_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(protocol_ver);
        PACKET_TABLE_FIELD_JSTRING16(username);
        PACKET_TABLE_FIELD_JLONG(unused0);
        PACKET_TABLE_FIELD_JINT(unused1);
        PACKET_TABLE_FIELD_JBYTE(unused2);
        PACKET_TABLE_FIELD_JBYTE(unused3);
        PACKET_TABLE_FIELD_JUBYTE(unused4);
        PACKET_TABLE_FIELD_JUBYTE(unused5);

        ImGui::EndTable();
    }
};
/**
 * Server -> Client
 */
struct packet_login_request_s2c_t : packet_t
{
    packet_login_request_s2c_t() { id = PACKET_ID_LOGIN_REQUEST; }

    jint player_eid = 0;
    std::string unused;
    jlong seed = 0;
    jint mode = 0;
    jbyte dimension = 0;
    jbyte difficulty = 0;
    jubyte world_height = 0;
    jubyte max_players = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_LOGIN_REQUEST);
        dat.push_back(id);
        assemble_int(dat, player_eid);
        assemble_string16(dat, unused);
        assemble_long(dat, seed);
        assemble_int(dat, mode);
        assemble_byte(dat, dimension);
        assemble_byte(dat, difficulty);
        assemble_ubyte(dat, world_height);
        assemble_ubyte(dat, max_players);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0 + unused.capacity());

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_login_request_s2c_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(player_eid);
        PACKET_TABLE_FIELD_JSTRING16(unused);
        PACKET_TABLE_FIELD_JLONG(seed);
        PACKET_TABLE_FIELD_JINT(mode);
        PACKET_TABLE_FIELD_JBYTE(dimension);
        PACKET_TABLE_FIELD_JBYTE(difficulty);
        PACKET_TABLE_FIELD_JUBYTE(world_height);
        PACKET_TABLE_FIELD_JUBYTE(max_players);

        ImGui::EndTable();
    }
};
/**
 * Client -> Server
 */
struct packet_handshake_c2s_t : packet_t
{
    packet_handshake_c2s_t() { id = PACKET_ID_HANDSHAKE; }

    std::string username;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_HANDSHAKE);
        dat.push_back(id);
        assemble_string16(dat, username);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0 + username.capacity());

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_handshake_c2s_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JSTRING16(username);

        ImGui::EndTable();
    }
};
/**
 * Server -> Client
 */
struct packet_handshake_s2c_t : packet_t
{
    packet_handshake_s2c_t() { id = PACKET_ID_HANDSHAKE; }

    std::string connection_hash;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_HANDSHAKE);
        dat.push_back(id);
        assemble_string16(dat, connection_hash);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0 + connection_hash.capacity());

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_handshake_s2c_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JSTRING16(connection_hash);

        ImGui::EndTable();
    }
};
struct packet_chat_message_t : packet_t
{
    packet_chat_message_t() { id = PACKET_ID_CHAT_MSG; }

    std::string msg;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_CHAT_MSG);
        dat.push_back(id);
        assemble_string16(dat, msg);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0 + msg.capacity());

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_chat_message_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JSTRING16(msg);

        ImGui::EndTable();
    }
};
struct packet_time_update_t : packet_t
{
    packet_time_update_t() { id = PACKET_ID_UPDATE_TIME; }

    jlong time = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_UPDATE_TIME);
        dat.push_back(id);
        assemble_long(dat, time);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_time_update_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JLONG(time);

        ImGui::EndTable();
    }
};
struct packet_ent_equipment_t : packet_t
{
    packet_ent_equipment_t() { id = PACKET_ID_ENT_EQUIPMENT; }

    jint eid = 0;
    jshort slot = 0;
    jshort item_id = 0;
    jshort damage = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_EQUIPMENT);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_short(dat, slot);
        assemble_short(dat, item_id);
        assemble_short(dat, damage);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_equipment_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JSHORT(slot);
        PACKET_TABLE_FIELD_JSHORT(item_id);
        PACKET_TABLE_FIELD_JSHORT(damage);

        ImGui::EndTable();
    }
};
/**
 * Server -> Client
 */
struct packet_spawn_pos_t : packet_t
{
    packet_spawn_pos_t() { id = PACKET_ID_SPAWN_POS; }

    jint x = 0;
    jint y = 0;
    jint z = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_SPAWN_POS);
        dat.push_back(id);
        assemble_int(dat, x);
        assemble_int(dat, y);
        assemble_int(dat, z);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_spawn_pos_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(x);
        PACKET_TABLE_FIELD_JINT(y);
        PACKET_TABLE_FIELD_JINT(z);

        ImGui::EndTable();
    }
};
struct packet_ent_use_t : packet_t
{
    packet_ent_use_t() { id = PACKET_ID_ENT_USE; }

    jint user = 0;
    jint target = 0;
    jbool left_click = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_USE);
        dat.push_back(id);
        assemble_int(dat, user);
        assemble_int(dat, target);
        assemble_bool(dat, left_click);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_use_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(user);
        PACKET_TABLE_FIELD_JINT(target);
        PACKET_TABLE_FIELD_JBOOL(left_click);

        ImGui::EndTable();
    }
};
struct packet_health_t : packet_t
{
    packet_health_t() { id = PACKET_ID_UPDATE_HEALTH; }

    jshort health = 0;
    jshort food = 0;
    jfloat food_saturation = 0.0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_UPDATE_HEALTH);
        dat.push_back(id);
        assemble_short(dat, health);
        assemble_short(dat, food);
        assemble_float(dat, food_saturation);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_health_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JSHORT(health);
        PACKET_TABLE_FIELD_JSHORT(food);
        PACKET_TABLE_FIELD_JFLOAT(food_saturation);

        ImGui::EndTable();
    }
};
/**
 * Sent by client after hitting respawn
 * Sent by server to change dimension or as a response to the client
 */
struct packet_respawn_t : packet_t
{
    packet_respawn_t() { id = PACKET_ID_RESPAWN; }

    jbyte dimension = 0;
    jbyte difficulty = 0;
    jbyte mode = 0;
    jshort world_height = 0;
    jlong seed = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_RESPAWN);
        dat.push_back(id);
        assemble_byte(dat, dimension);
        assemble_byte(dat, difficulty);
        assemble_byte(dat, mode);
        assemble_short(dat, world_height);
        assemble_long(dat, seed);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_respawn_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JBYTE(dimension);
        PACKET_TABLE_FIELD_JBYTE(difficulty);
        PACKET_TABLE_FIELD_JBYTE(mode);
        PACKET_TABLE_FIELD_JSHORT(world_height);
        PACKET_TABLE_FIELD_JLONG(seed);

        ImGui::EndTable();
    }
};
/**
 * Client -> Server
 */
struct packet_on_ground_t : packet_t
{
    packet_on_ground_t() { id = PACKET_ID_PLAYER_ON_GROUND; }

    jbool on_ground = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_PLAYER_ON_GROUND);
        dat.push_back(id);
        assemble_bool(dat, on_ground);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_on_ground_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JBOOL(on_ground);

        ImGui::EndTable();
    }
};
/**
 * Client -> Server
 */
struct packet_player_pos_t : packet_t
{
    packet_player_pos_t() { id = PACKET_ID_PLAYER_POS; }

    jdouble x = 0.0;
    jdouble y = 0.0;
    jdouble stance = 0.0;
    jdouble z = 0.0;
    jbool on_ground = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_PLAYER_POS);
        dat.push_back(id);
        assemble_double(dat, x);
        assemble_double(dat, y);
        assemble_double(dat, stance);
        assemble_double(dat, z);
        assemble_bool(dat, on_ground);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_player_pos_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JDOUBLE(x);
        PACKET_TABLE_FIELD_JDOUBLE(y);
        PACKET_TABLE_FIELD_JDOUBLE(stance);
        PACKET_TABLE_FIELD_JDOUBLE(z);
        PACKET_TABLE_FIELD_JBOOL(on_ground);

        ImGui::EndTable();
    }
};
/**
 * Client -> Server
 */
struct packet_player_look_t : packet_t
{
    packet_player_look_t() { id = PACKET_ID_PLAYER_LOOK; }

    jfloat yaw = 0.0;
    jfloat pitch = 0.0;
    jbool on_ground = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_PLAYER_LOOK);
        dat.push_back(id);
        assemble_float(dat, yaw);
        assemble_float(dat, pitch);
        assemble_bool(dat, on_ground);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_player_look_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JFLOAT(yaw);
        PACKET_TABLE_FIELD_JFLOAT(pitch);
        PACKET_TABLE_FIELD_JBOOL(on_ground);

        ImGui::EndTable();
    }
};
/**
 * Client -> Server
 */
struct packet_player_pos_look_c2s_t : packet_t
{
    packet_player_pos_look_c2s_t() { id = PACKET_ID_PLAYER_POS_LOOK; }

    jdouble x = 0.0;
    jdouble y = 0.0;
    jdouble stance = 0.0;
    jdouble z = 0.0;
    jfloat yaw = 0.0;
    jfloat pitch = 0.0;
    jbool on_ground = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_PLAYER_POS_LOOK);
        dat.push_back(id);
        assemble_double(dat, x);
        assemble_double(dat, y);
        assemble_double(dat, stance);
        assemble_double(dat, z);
        assemble_float(dat, yaw);
        assemble_float(dat, pitch);
        assemble_bool(dat, on_ground);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_player_pos_look_c2s_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JDOUBLE(x);
        PACKET_TABLE_FIELD_JDOUBLE(y);
        PACKET_TABLE_FIELD_JDOUBLE(stance);
        PACKET_TABLE_FIELD_JDOUBLE(z);
        PACKET_TABLE_FIELD_JFLOAT(yaw);
        PACKET_TABLE_FIELD_JFLOAT(pitch);
        PACKET_TABLE_FIELD_JBOOL(on_ground);

        ImGui::EndTable();
    }
};
/**
 * Server -> Client
 */
struct packet_player_pos_look_s2c_t : packet_t
{
    packet_player_pos_look_s2c_t() { id = PACKET_ID_PLAYER_POS_LOOK; }

    jdouble x = 0.0;
    jdouble stance = 0.0;
    jdouble y = 0.0;
    jdouble z = 0.0;
    jfloat yaw = 0.0;
    jfloat pitch = 0.0;
    jbool on_ground = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_PLAYER_POS_LOOK);
        dat.push_back(id);
        assemble_double(dat, x);
        assemble_double(dat, stance);
        assemble_double(dat, y);
        assemble_double(dat, z);
        assemble_float(dat, yaw);
        assemble_float(dat, pitch);
        assemble_bool(dat, on_ground);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_player_pos_look_s2c_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JDOUBLE(x);
        PACKET_TABLE_FIELD_JDOUBLE(stance);
        PACKET_TABLE_FIELD_JDOUBLE(y);
        PACKET_TABLE_FIELD_JDOUBLE(z);
        PACKET_TABLE_FIELD_JFLOAT(yaw);
        PACKET_TABLE_FIELD_JFLOAT(pitch);
        PACKET_TABLE_FIELD_JBOOL(on_ground);

        ImGui::EndTable();
    }
};
struct packet_player_dig_t : packet_t
{
    packet_player_dig_t() { id = PACKET_ID_PLAYER_DIG; }

    jbyte status = 0;
    jint x = 0;
    jbyte y = 0;
    jint z = 0;
    jbyte face = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_PLAYER_DIG);
        dat.push_back(id);
        assemble_byte(dat, status);
        assemble_int(dat, x);
        assemble_byte(dat, y);
        assemble_int(dat, z);
        assemble_byte(dat, face);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_player_dig_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JBYTE(status);
        PACKET_TABLE_FIELD_JINT(x);
        PACKET_TABLE_FIELD_JBYTE(y);
        PACKET_TABLE_FIELD_JINT(z);
        PACKET_TABLE_FIELD_JBYTE(face);

        ImGui::EndTable();
    }
};
struct packet_hold_change_t : packet_t
{
    packet_hold_change_t() { id = PACKET_ID_HOLD_CHANGE; }

    jshort slot_id = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_HOLD_CHANGE);
        dat.push_back(id);
        assemble_short(dat, slot_id);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_hold_change_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JSHORT(slot_id);

        ImGui::EndTable();
    }
};
struct packet_use_bed_t : packet_t
{
    packet_use_bed_t() { id = PACKET_ID_USE_BED; }

    jint eid = 0;
    jbyte unknown_probably_in_bed = 0;
    jint headboard_x = 0;
    jbyte headboard_y = 0;
    jint headboard_z = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_USE_BED);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_byte(dat, unknown_probably_in_bed);
        assemble_int(dat, headboard_x);
        assemble_byte(dat, headboard_y);
        assemble_int(dat, headboard_z);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_use_bed_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JBYTE(unknown_probably_in_bed);
        PACKET_TABLE_FIELD_JINT(headboard_x);
        PACKET_TABLE_FIELD_JBYTE(headboard_y);
        PACKET_TABLE_FIELD_JINT(headboard_z);

        ImGui::EndTable();
    }
};
struct packet_ent_animation_t : packet_t
{
    packet_ent_animation_t() { id = PACKET_ID_ENT_ANIMATION; }

    jint eid = 0;
    jbyte animate = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_ANIMATION);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_byte(dat, animate);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_animation_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JBYTE(animate);

        ImGui::EndTable();
    }
};
struct packet_ent_action_t : packet_t
{
    packet_ent_action_t() { id = PACKET_ID_ENT_ACTION; }

    jint eid = 0;
    jbyte action_id = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_ACTION);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_byte(dat, action_id);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_action_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JBYTE(action_id);

        ImGui::EndTable();
    }
};
struct packet_ent_spawn_named_t : packet_t
{
    packet_ent_spawn_named_t() { id = PACKET_ID_ENT_SPAWN_NAMED; }

    jint eid = 0;
    std::string name;
    jint x = 0;
    jint y = 0;
    jint z = 0;
    jbyte rotation = 0;
    jbyte pitch = 0;
    jshort cur_item = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_SPAWN_NAMED);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_string16(dat, name);
        assemble_int(dat, x);
        assemble_int(dat, y);
        assemble_int(dat, z);
        assemble_byte(dat, rotation);
        assemble_byte(dat, pitch);
        assemble_short(dat, cur_item);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0 + name.capacity());

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_spawn_named_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JSTRING16(name);
        PACKET_TABLE_FIELD_JINT(x);
        PACKET_TABLE_FIELD_JINT(y);
        PACKET_TABLE_FIELD_JINT(z);
        PACKET_TABLE_FIELD_JBYTE(rotation);
        PACKET_TABLE_FIELD_JBYTE(pitch);
        PACKET_TABLE_FIELD_JSHORT(cur_item);

        ImGui::EndTable();
    }
};
struct packet_ent_spawn_pickup_t : packet_t
{
    packet_ent_spawn_pickup_t() { id = PACKET_ID_ENT_SPAWN_PICKUP; }

    jint eid = 0;
    jshort item = 0;
    jbyte count = 0;
    jshort damage = 0;
    jint x = 0;
    jint y = 0;
    jint z = 0;
    jbyte rotation = 0;
    jbyte pitch = 0;
    jbyte roll = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_SPAWN_PICKUP);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_short(dat, item);
        assemble_byte(dat, count);
        assemble_short(dat, damage);
        assemble_int(dat, x);
        assemble_int(dat, y);
        assemble_int(dat, z);
        assemble_byte(dat, rotation);
        assemble_byte(dat, pitch);
        assemble_byte(dat, roll);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_spawn_pickup_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JSHORT(item);
        PACKET_TABLE_FIELD_JBYTE(count);
        PACKET_TABLE_FIELD_JSHORT(damage);
        PACKET_TABLE_FIELD_JINT(x);
        PACKET_TABLE_FIELD_JINT(y);
        PACKET_TABLE_FIELD_JINT(z);
        PACKET_TABLE_FIELD_JBYTE(rotation);
        PACKET_TABLE_FIELD_JBYTE(pitch);
        PACKET_TABLE_FIELD_JBYTE(roll);

        ImGui::EndTable();
    }
};
struct packet_collect_item_t : packet_t
{
    packet_collect_item_t() { id = PACKET_ID_COLLECT_ITEM; }

    jint collected_eid = 0;
    jint collector_eid = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_COLLECT_ITEM);
        dat.push_back(id);
        assemble_int(dat, collected_eid);
        assemble_int(dat, collector_eid);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_collect_item_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(collected_eid);
        PACKET_TABLE_FIELD_JINT(collector_eid);

        ImGui::EndTable();
    }
};
struct packet_ent_spawn_painting_t : packet_t
{
    packet_ent_spawn_painting_t() { id = PACKET_ID_ENT_SPAWN_PAINTING; }

    jint eid = 0;
    std::string title;
    jint center_x = 0;
    jint center_y = 0;
    jint center_z = 0;
    jint direction = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_SPAWN_PAINTING);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_string16(dat, title);
        assemble_int(dat, center_x);
        assemble_int(dat, center_y);
        assemble_int(dat, center_z);
        assemble_int(dat, direction);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0 + title.capacity());

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_spawn_painting_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JSTRING16(title);
        PACKET_TABLE_FIELD_JINT(center_x);
        PACKET_TABLE_FIELD_JINT(center_y);
        PACKET_TABLE_FIELD_JINT(center_z);
        PACKET_TABLE_FIELD_JINT(direction);

        ImGui::EndTable();
    }
};
struct packet_ent_spawn_xp_t : packet_t
{
    packet_ent_spawn_xp_t() { id = PACKET_ID_ENT_SPAWN_XP; }

    jint eid = 0;
    jint x = 0;
    jint y = 0;
    jint z = 0;
    jshort count = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_SPAWN_XP);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_int(dat, x);
        assemble_int(dat, y);
        assemble_int(dat, z);
        assemble_short(dat, count);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_spawn_xp_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JINT(x);
        PACKET_TABLE_FIELD_JINT(y);
        PACKET_TABLE_FIELD_JINT(z);
        PACKET_TABLE_FIELD_JSHORT(count);

        ImGui::EndTable();
    }
};
struct packet_stance_update_t : packet_t
{
    packet_stance_update_t() { id = PACKET_ID_STANCE_UPDATE; }

    jfloat unknown0 = 0.0;
    jfloat unknown1 = 0.0;
    jfloat unknown2 = 0.0;
    jfloat unknown3 = 0.0;
    jbool unknown4 = 0;
    jbool unknown5 = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_STANCE_UPDATE);
        dat.push_back(id);
        assemble_float(dat, unknown0);
        assemble_float(dat, unknown1);
        assemble_float(dat, unknown2);
        assemble_float(dat, unknown3);
        assemble_bool(dat, unknown4);
        assemble_bool(dat, unknown5);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_stance_update_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JFLOAT(unknown0);
        PACKET_TABLE_FIELD_JFLOAT(unknown1);
        PACKET_TABLE_FIELD_JFLOAT(unknown2);
        PACKET_TABLE_FIELD_JFLOAT(unknown3);
        PACKET_TABLE_FIELD_JBOOL(unknown4);
        PACKET_TABLE_FIELD_JBOOL(unknown5);

        ImGui::EndTable();
    }
};
struct packet_ent_velocity_t : packet_t
{
    packet_ent_velocity_t() { id = PACKET_ID_ENT_VELOCITY; }

    jint eid = 0;
    jshort vel_x = 0;
    jshort vel_y = 0;
    jshort vel_z = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_VELOCITY);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_short(dat, vel_x);
        assemble_short(dat, vel_y);
        assemble_short(dat, vel_z);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_velocity_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JSHORT(vel_x);
        PACKET_TABLE_FIELD_JSHORT(vel_y);
        PACKET_TABLE_FIELD_JSHORT(vel_z);

        ImGui::EndTable();
    }
};
struct packet_ent_destroy_t : packet_t
{
    packet_ent_destroy_t() { id = PACKET_ID_ENT_DESTROY; }

    jint eid = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_DESTROY);
        dat.push_back(id);
        assemble_int(dat, eid);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_destroy_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);

        ImGui::EndTable();
    }
};
struct packet_ent_create_t : packet_t
{
    packet_ent_create_t() { id = PACKET_ID_ENT_ENSURE_SPAWN; }

    jint eid = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_ENSURE_SPAWN);
        dat.push_back(id);
        assemble_int(dat, eid);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_create_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);

        ImGui::EndTable();
    }
};
struct packet_ent_move_rel_t : packet_t
{
    packet_ent_move_rel_t() { id = PACKET_ID_ENT_MOVE_REL; }

    jint eid = 0;
    jbyte delta_x = 0;
    jbyte delta_y = 0;
    jbyte delta_z = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_MOVE_REL);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_byte(dat, delta_x);
        assemble_byte(dat, delta_y);
        assemble_byte(dat, delta_z);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_move_rel_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JBYTE(delta_x);
        PACKET_TABLE_FIELD_JBYTE(delta_y);
        PACKET_TABLE_FIELD_JBYTE(delta_z);

        ImGui::EndTable();
    }
};
struct packet_ent_look_t : packet_t
{
    packet_ent_look_t() { id = PACKET_ID_ENT_LOOK; }

    jint eid = 0;
    jbyte yaw = 0;
    jbyte pitch = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_LOOK);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_byte(dat, yaw);
        assemble_byte(dat, pitch);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_look_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JBYTE(yaw);
        PACKET_TABLE_FIELD_JBYTE(pitch);

        ImGui::EndTable();
    }
};
struct packet_ent_look_move_rel_t : packet_t
{
    packet_ent_look_move_rel_t() { id = PACKET_ID_ENT_LOOK_MOVE_REL; }

    jint eid = 0;
    jbyte delta_x = 0;
    jbyte delta_y = 0;
    jbyte delta_z = 0;
    jbyte yaw = 0;
    jbyte pitch = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_LOOK_MOVE_REL);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_byte(dat, delta_x);
        assemble_byte(dat, delta_y);
        assemble_byte(dat, delta_z);
        assemble_byte(dat, yaw);
        assemble_byte(dat, pitch);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_look_move_rel_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JBYTE(delta_x);
        PACKET_TABLE_FIELD_JBYTE(delta_y);
        PACKET_TABLE_FIELD_JBYTE(delta_z);
        PACKET_TABLE_FIELD_JBYTE(yaw);
        PACKET_TABLE_FIELD_JBYTE(pitch);

        ImGui::EndTable();
    }
};
struct packet_ent_teleport_t : packet_t
{
    packet_ent_teleport_t() { id = PACKET_ID_ENT_MOVE_TELEPORT; }

    jint eid = 0;
    jint x = 0;
    jint y = 0;
    jint z = 0;
    jbyte rotation = 0;
    jbyte pitch = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_MOVE_TELEPORT);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_int(dat, x);
        assemble_int(dat, y);
        assemble_int(dat, z);
        assemble_byte(dat, rotation);
        assemble_byte(dat, pitch);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_teleport_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JINT(x);
        PACKET_TABLE_FIELD_JINT(y);
        PACKET_TABLE_FIELD_JINT(z);
        PACKET_TABLE_FIELD_JBYTE(rotation);
        PACKET_TABLE_FIELD_JBYTE(pitch);

        ImGui::EndTable();
    }
};
struct packet_ent_status_t : packet_t
{
    packet_ent_status_t() { id = PACKET_ID_ENT_STATUS; }

    jint eid = 0;
    jbyte status = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_STATUS);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_byte(dat, status);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_status_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JBYTE(status);

        ImGui::EndTable();
    }
};
struct packet_ent_attach_t : packet_t
{
    packet_ent_attach_t() { id = PACKET_ID_ENT_ATTACH; }

    jint eid = 0;
    jint vehicle = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_ATTACH);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_int(dat, vehicle);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_attach_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JINT(vehicle);

        ImGui::EndTable();
    }
};
struct packet_ent_effect_t : packet_t
{
    packet_ent_effect_t() { id = PACKET_ID_ENT_EFFECT; }

    jint eid = 0;
    jbyte effect_id = 0;
    jbyte amplifier = 0;
    jshort duration = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_EFFECT);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_byte(dat, effect_id);
        assemble_byte(dat, amplifier);
        assemble_short(dat, duration);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_effect_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JBYTE(effect_id);
        PACKET_TABLE_FIELD_JBYTE(amplifier);
        PACKET_TABLE_FIELD_JSHORT(duration);

        ImGui::EndTable();
    }
};
struct packet_ent_effect_remove_t : packet_t
{
    packet_ent_effect_remove_t() { id = PACKET_ID_ENT_EFFECT_REMOVE; }

    jint eid = 0;
    jbyte effect_id = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_ENT_EFFECT_REMOVE);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_byte(dat, effect_id);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_ent_effect_remove_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JBYTE(effect_id);

        ImGui::EndTable();
    }
};
struct packet_xp_set_t : packet_t
{
    packet_xp_set_t() { id = PACKET_ID_XP_SET; }

    jbyte current_xp = 0;
    jbyte level = 0;
    jshort total = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_XP_SET);
        dat.push_back(id);
        assemble_byte(dat, current_xp);
        assemble_byte(dat, level);
        assemble_short(dat, total);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_xp_set_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JBYTE(current_xp);
        PACKET_TABLE_FIELD_JBYTE(level);
        PACKET_TABLE_FIELD_JSHORT(total);

        ImGui::EndTable();
    }
};
struct packet_chunk_cache_t : packet_t
{
    packet_chunk_cache_t() { id = PACKET_ID_CHUNK_CACHE; }

    jint chunk_x = 0;
    jint chunk_z = 0;
    jbool mode = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_CHUNK_CACHE);
        dat.push_back(id);
        assemble_int(dat, chunk_x);
        assemble_int(dat, chunk_z);
        assemble_bool(dat, mode);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_chunk_cache_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(chunk_x);
        PACKET_TABLE_FIELD_JINT(chunk_z);
        PACKET_TABLE_FIELD_JBOOL(mode);

        ImGui::EndTable();
    }
};
struct packet_block_change_t : packet_t
{
    packet_block_change_t() { id = PACKET_ID_BLOCK_CHANGE; }

    jint block_x = 0;
    jbyte block_y = 0;
    jint block_z = 0;
    jbyte type = 0;
    jbyte metadata = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_BLOCK_CHANGE);
        dat.push_back(id);
        assemble_int(dat, block_x);
        assemble_byte(dat, block_y);
        assemble_int(dat, block_z);
        assemble_byte(dat, type);
        assemble_byte(dat, metadata);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_block_change_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(block_x);
        PACKET_TABLE_FIELD_JBYTE(block_y);
        PACKET_TABLE_FIELD_JINT(block_z);
        PACKET_TABLE_FIELD_JBYTE(type);
        PACKET_TABLE_FIELD_JBYTE(metadata);

        ImGui::EndTable();
    }
};
struct packet_block_action_t : packet_t
{
    packet_block_action_t() { id = PACKET_ID_BLOCK_ACTION; }

    jint block_x = 0;
    jshort block_y = 0;
    jint block_z = 0;
    jbyte byte0 = 0;
    jbyte byte1 = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_BLOCK_ACTION);
        dat.push_back(id);
        assemble_int(dat, block_x);
        assemble_short(dat, block_y);
        assemble_int(dat, block_z);
        assemble_byte(dat, byte0);
        assemble_byte(dat, byte1);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_block_action_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(block_x);
        PACKET_TABLE_FIELD_JSHORT(block_y);
        PACKET_TABLE_FIELD_JINT(block_z);
        PACKET_TABLE_FIELD_JBYTE(byte0);
        PACKET_TABLE_FIELD_JBYTE(byte1);

        ImGui::EndTable();
    }
};
struct packet_sound_effect_t : packet_t
{
    packet_sound_effect_t() { id = PACKET_ID_SFX; }

    jint effect_id = 0;
    jint x = 0;
    jbyte y = 0;
    jint z = 0;
    jint sound_data = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_SFX);
        dat.push_back(id);
        assemble_int(dat, effect_id);
        assemble_int(dat, x);
        assemble_byte(dat, y);
        assemble_int(dat, z);
        assemble_int(dat, sound_data);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_sound_effect_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(effect_id);
        PACKET_TABLE_FIELD_JINT(x);
        PACKET_TABLE_FIELD_JBYTE(y);
        PACKET_TABLE_FIELD_JINT(z);
        PACKET_TABLE_FIELD_JINT(sound_data);

        ImGui::EndTable();
    }
};
struct packet_new_state_t : packet_t
{
    packet_new_state_t() { id = PACKET_ID_NEW_STATE; }

    jbyte reason = 0;
    jbyte mode = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_NEW_STATE);
        dat.push_back(id);
        assemble_byte(dat, reason);
        assemble_byte(dat, mode);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_new_state_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JBYTE(reason);
        PACKET_TABLE_FIELD_JBYTE(mode);

        ImGui::EndTable();
    }
};
struct packet_thunder_t : packet_t
{
    packet_thunder_t() { id = PACKET_ID_THUNDERBOLT; }

    jint eid = 0;
    jbool unknown = 0;
    jint x = 0;
    jint y = 0;
    jint z = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_THUNDERBOLT);
        dat.push_back(id);
        assemble_int(dat, eid);
        assemble_bool(dat, unknown);
        assemble_int(dat, x);
        assemble_int(dat, y);
        assemble_int(dat, z);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_thunder_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(eid);
        PACKET_TABLE_FIELD_JBOOL(unknown);
        PACKET_TABLE_FIELD_JINT(x);
        PACKET_TABLE_FIELD_JINT(y);
        PACKET_TABLE_FIELD_JINT(z);

        ImGui::EndTable();
    }
};
struct packet_window_open_t : packet_t
{
    packet_window_open_t() { id = PACKET_ID_WINDOW_OPEN; }

    jbyte window_id = 0;
    jbyte type = 0;
    std::string title;
    jbyte num_slots = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_WINDOW_OPEN);
        dat.push_back(id);
        assemble_byte(dat, window_id);
        assemble_byte(dat, type);
        assemble_string16(dat, title);
        assemble_byte(dat, num_slots);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0 + title.capacity());

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_window_open_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JBYTE(window_id);
        PACKET_TABLE_FIELD_JBYTE(type);
        PACKET_TABLE_FIELD_JSTRING16(title);
        PACKET_TABLE_FIELD_JBYTE(num_slots);

        ImGui::EndTable();
    }
};
struct packet_window_close_t : packet_t
{
    packet_window_close_t() { id = PACKET_ID_WINDOW_CLOSE; }

    jbyte window_id = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_WINDOW_CLOSE);
        dat.push_back(id);
        assemble_byte(dat, window_id);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_window_close_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JBYTE(window_id);

        ImGui::EndTable();
    }
};
/**
 * Server -> Client
 */
struct packet_window_update_progress_t : packet_t
{
    packet_window_update_progress_t() { id = PACKET_ID_WINDOW_UPDATE_PROGRESS; }

    jbyte window_id = 0;
    jshort progress = 0;
    jshort value = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_WINDOW_UPDATE_PROGRESS);
        dat.push_back(id);
        assemble_byte(dat, window_id);
        assemble_short(dat, progress);
        assemble_short(dat, value);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_window_update_progress_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JBYTE(window_id);
        PACKET_TABLE_FIELD_JSHORT(progress);
        PACKET_TABLE_FIELD_JSHORT(value);

        ImGui::EndTable();
    }
};
struct packet_window_transaction_t : packet_t
{
    packet_window_transaction_t() { id = PACKET_ID_WINDOW_TRANSACTION; }

    jbyte window_id = 0;
    jshort action_num = 0;
    jbool accepted = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_WINDOW_TRANSACTION);
        dat.push_back(id);
        assemble_byte(dat, window_id);
        assemble_short(dat, action_num);
        assemble_bool(dat, accepted);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_window_transaction_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JBYTE(window_id);
        PACKET_TABLE_FIELD_JSHORT(action_num);
        PACKET_TABLE_FIELD_JBOOL(accepted);

        ImGui::EndTable();
    }
};
struct packet_inventory_action_creative_t : packet_t
{
    packet_inventory_action_creative_t() { id = PACKET_ID_INV_CREATIVE_ACTION; }

    jshort slot = 0;
    jshort item_id = 0;
    jshort quantity = 0;
    jshort damage = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_INV_CREATIVE_ACTION);
        dat.push_back(id);
        assemble_short(dat, slot);
        assemble_short(dat, item_id);
        assemble_short(dat, quantity);
        assemble_short(dat, damage);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_inventory_action_creative_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JSHORT(slot);
        PACKET_TABLE_FIELD_JSHORT(item_id);
        PACKET_TABLE_FIELD_JSHORT(quantity);
        PACKET_TABLE_FIELD_JSHORT(damage);

        ImGui::EndTable();
    }
};
struct packet_update_sign_t : packet_t
{
    packet_update_sign_t() { id = PACKET_ID_UPDATE_SIGN; }

    jint x = 0;
    jshort y = 0;
    jint z = 0;
    std::string text0;
    std::string text1;
    std::string text2;
    std::string text3;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_UPDATE_SIGN);
        dat.push_back(id);
        assemble_int(dat, x);
        assemble_short(dat, y);
        assemble_int(dat, z);
        assemble_string16(dat, text0);
        assemble_string16(dat, text1);
        assemble_string16(dat, text2);
        assemble_string16(dat, text3);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0 + text0.capacity() + text1.capacity() + text2.capacity() + text3.capacity());

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_update_sign_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(x);
        PACKET_TABLE_FIELD_JSHORT(y);
        PACKET_TABLE_FIELD_JINT(z);
        PACKET_TABLE_FIELD_JSTRING16(text0);
        PACKET_TABLE_FIELD_JSTRING16(text1);
        PACKET_TABLE_FIELD_JSTRING16(text2);
        PACKET_TABLE_FIELD_JSTRING16(text3);

        ImGui::EndTable();
    }
};
struct packet_increment_statistic_t : packet_t
{
    packet_increment_statistic_t() { id = PACKET_ID_INCREMENT_STATISTIC; }

    jint stat_id = 0;
    jbyte amount = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_INCREMENT_STATISTIC);
        dat.push_back(id);
        assemble_int(dat, stat_id);
        assemble_byte(dat, amount);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_increment_statistic_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JINT(stat_id);
        PACKET_TABLE_FIELD_JBYTE(amount);

        ImGui::EndTable();
    }
};
struct packet_play_list_item_t : packet_t
{
    packet_play_list_item_t() { id = PACKET_ID_PLAYER_LIST_ITEM; }

    std::string username;
    jbool online = 0;
    jshort ping = 0;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_PLAYER_LIST_ITEM);
        dat.push_back(id);
        assemble_string16(dat, username);
        assemble_bool(dat, online);
        assemble_short(dat, ping);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0 + username.capacity());

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_play_list_item_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JSTRING16(username);
        PACKET_TABLE_FIELD_JBOOL(online);
        PACKET_TABLE_FIELD_JSHORT(ping);

        ImGui::EndTable();
    }
};
struct packet_server_list_ping_t : packet_t
{
    packet_server_list_ping_t() { id = PACKET_ID_SERVER_LIST_PING; }

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_SERVER_LIST_PING);
        dat.push_back(id);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0);

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_server_list_ping_t");

        PACKET_TABLE_FIELD_ID();

        ImGui::EndTable();
    }
};
struct packet_kick_t : packet_t
{
    packet_kick_t() { id = PACKET_ID_KICK; }

    std::string reason;

    std::vector<Uint8> assemble()
    {
        std::vector<Uint8> dat;
        assert(id == PACKET_ID_KICK);
        dat.push_back(id);
        assemble_string16(dat, reason);
        return dat;
    }

    PACKET_DEFINE_MEM_SIZE(0 + reason.capacity());

    void draw_imgui()
    {
        PACKET_NEW_TABLE("packet_kick_t");

        PACKET_TABLE_FIELD_ID();
        PACKET_TABLE_FIELD_JSTRING16(reason);

        ImGui::EndTable();
    }
};

#endif
#ifdef MCS_B181_PACKET_GEN_IMPL

#define P(type)          \
    packet = new type(); \
    type* p = (type*)packet;

#define GET_STR_LEN(var_len_val, off)                                  \
    do                                                                 \
    {                                                                  \
        if (var_len == var_len_val && buf_size >= ((off) + 2))         \
        {                                                              \
            len += (SDL_Swap16BE(*(Uint16*)(buf.data() + (off))) * 2); \
            var_len--;                                                 \
            change_happened++;                                         \
        }                                                              \
    } while (0)

#define PACK_LENV(ID, LEN, VLEN) \
    case ID:                     \
    {                            \
        len = LEN;               \
        var_len = VLEN;          \
        break;                   \
    }

#define PACK_LEN(ID, LEN) PACK_LENV(ID, LEN, 0)

static bool vlen_gen_server(Uint8 packet_type, std::vector<Uint8>& buf, size_t& buf_size, int& change_happened, int& var_len, size_t& len)
{
    switch (packet_type)
    {
    case PACKET_ID_LOGIN_REQUEST:
    {
        GET_STR_LEN(1, 5);
        break;
    }

    case PACKET_ID_HANDSHAKE:
    {
        GET_STR_LEN(1, 1);
        break;
    }

    case PACKET_ID_CHAT_MSG:
    {
        GET_STR_LEN(1, 1);
        break;
    }

    case PACKET_ID_ENT_SPAWN_NAMED:
    {
        GET_STR_LEN(1, 5);
        break;
    }

    case PACKET_ID_ENT_SPAWN_PAINTING:
    {
        GET_STR_LEN(1, 5);
        break;
    }

    case PACKET_ID_WINDOW_OPEN:
    {
        GET_STR_LEN(1, 3);
        break;
    }

        // PACKET_ID_UPDATE_SIGN has a var_len > 1, handle it yourself

    case PACKET_ID_PLAYER_LIST_ITEM:
    {
        GET_STR_LEN(1, 1);
        break;
    }

    case PACKET_ID_KICK:
    {
        GET_STR_LEN(1, 1);
        break;
    }

    default:
        return 0;
    }
    return 1;
}

static bool parse_gen_packets_server(Uint8 packet_type, std::vector<Uint8>& buf, int& err, size_t& pos, packet_t*& packet)
{
    switch (packet_type)
    {
    case PACKET_ID_KEEP_ALIVE:
    {
        P(packet_keep_alive_t)

        err += !read_int(buf, pos, &p->keep_alive_id);

        break;
    }

    case PACKET_ID_LOGIN_REQUEST:
    {
        P(packet_login_request_c2s_t)

        err += !read_int(buf, pos, &p->protocol_ver);
        err += !read_string16(buf, pos, p->username);
        err += !read_long(buf, pos, &p->unused0);
        err += !read_int(buf, pos, &p->unused1);
        err += !read_byte(buf, pos, &p->unused2);
        err += !read_byte(buf, pos, &p->unused3);
        err += !read_ubyte(buf, pos, &p->unused4);
        err += !read_ubyte(buf, pos, &p->unused5);

        break;
    }

    case PACKET_ID_HANDSHAKE:
    {
        P(packet_handshake_c2s_t)

        err += !read_string16(buf, pos, p->username);

        break;
    }

    case PACKET_ID_CHAT_MSG:
    {
        P(packet_chat_message_t)

        err += !read_string16(buf, pos, p->msg);

        break;
    }

    case PACKET_ID_UPDATE_TIME:
    {
        P(packet_time_update_t)

        err += !read_long(buf, pos, &p->time);

        break;
    }

    case PACKET_ID_ENT_EQUIPMENT:
    {
        P(packet_ent_equipment_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_short(buf, pos, &p->slot);
        err += !read_short(buf, pos, &p->item_id);
        err += !read_short(buf, pos, &p->damage);

        break;
    }

    case PACKET_ID_ENT_USE:
    {
        P(packet_ent_use_t)

        err += !read_int(buf, pos, &p->user);
        err += !read_int(buf, pos, &p->target);
        err += !read_ubyte(buf, pos, &p->left_click);

        break;
    }

    case PACKET_ID_UPDATE_HEALTH:
    {
        P(packet_health_t)

        err += !read_short(buf, pos, &p->health);
        err += !read_short(buf, pos, &p->food);
        err += !read_float(buf, pos, &p->food_saturation);

        break;
    }

    case PACKET_ID_RESPAWN:
    {
        P(packet_respawn_t)

        err += !read_byte(buf, pos, &p->dimension);
        err += !read_byte(buf, pos, &p->difficulty);
        err += !read_byte(buf, pos, &p->mode);
        err += !read_short(buf, pos, &p->world_height);
        err += !read_long(buf, pos, &p->seed);

        break;
    }

    case PACKET_ID_PLAYER_ON_GROUND:
    {
        P(packet_on_ground_t)

        err += !read_ubyte(buf, pos, &p->on_ground);

        break;
    }

    case PACKET_ID_PLAYER_POS:
    {
        P(packet_player_pos_t)

        err += !read_double(buf, pos, &p->x);
        err += !read_double(buf, pos, &p->y);
        err += !read_double(buf, pos, &p->stance);
        err += !read_double(buf, pos, &p->z);
        err += !read_ubyte(buf, pos, &p->on_ground);

        break;
    }

    case PACKET_ID_PLAYER_LOOK:
    {
        P(packet_player_look_t)

        err += !read_float(buf, pos, &p->yaw);
        err += !read_float(buf, pos, &p->pitch);
        err += !read_ubyte(buf, pos, &p->on_ground);

        break;
    }

    case PACKET_ID_PLAYER_POS_LOOK:
    {
        P(packet_player_pos_look_c2s_t)

        err += !read_double(buf, pos, &p->x);
        err += !read_double(buf, pos, &p->y);
        err += !read_double(buf, pos, &p->stance);
        err += !read_double(buf, pos, &p->z);
        err += !read_float(buf, pos, &p->yaw);
        err += !read_float(buf, pos, &p->pitch);
        err += !read_ubyte(buf, pos, &p->on_ground);

        break;
    }

    case PACKET_ID_PLAYER_DIG:
    {
        P(packet_player_dig_t)

        err += !read_byte(buf, pos, &p->status);
        err += !read_int(buf, pos, &p->x);
        err += !read_byte(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);
        err += !read_byte(buf, pos, &p->face);

        break;
    }

    case PACKET_ID_HOLD_CHANGE:
    {
        P(packet_hold_change_t)

        err += !read_short(buf, pos, &p->slot_id);

        break;
    }

    case PACKET_ID_USE_BED:
    {
        P(packet_use_bed_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->unknown_probably_in_bed);
        err += !read_int(buf, pos, &p->headboard_x);
        err += !read_byte(buf, pos, &p->headboard_y);
        err += !read_int(buf, pos, &p->headboard_z);

        break;
    }

    case PACKET_ID_ENT_ANIMATION:
    {
        P(packet_ent_animation_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->animate);

        break;
    }

    case PACKET_ID_ENT_ACTION:
    {
        P(packet_ent_action_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->action_id);

        break;
    }

    case PACKET_ID_ENT_SPAWN_NAMED:
    {
        P(packet_ent_spawn_named_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_string16(buf, pos, p->name);
        err += !read_int(buf, pos, &p->x);
        err += !read_int(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);
        err += !read_byte(buf, pos, &p->rotation);
        err += !read_byte(buf, pos, &p->pitch);
        err += !read_short(buf, pos, &p->cur_item);

        break;
    }

    case PACKET_ID_ENT_SPAWN_PICKUP:
    {
        P(packet_ent_spawn_pickup_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_short(buf, pos, &p->item);
        err += !read_byte(buf, pos, &p->count);
        err += !read_short(buf, pos, &p->damage);
        err += !read_int(buf, pos, &p->x);
        err += !read_int(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);
        err += !read_byte(buf, pos, &p->rotation);
        err += !read_byte(buf, pos, &p->pitch);
        err += !read_byte(buf, pos, &p->roll);

        break;
    }

    case PACKET_ID_COLLECT_ITEM:
    {
        P(packet_collect_item_t)

        err += !read_int(buf, pos, &p->collected_eid);
        err += !read_int(buf, pos, &p->collector_eid);

        break;
    }

    case PACKET_ID_ENT_SPAWN_PAINTING:
    {
        P(packet_ent_spawn_painting_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_string16(buf, pos, p->title);
        err += !read_int(buf, pos, &p->center_x);
        err += !read_int(buf, pos, &p->center_y);
        err += !read_int(buf, pos, &p->center_z);
        err += !read_int(buf, pos, &p->direction);

        break;
    }

    case PACKET_ID_ENT_SPAWN_XP:
    {
        P(packet_ent_spawn_xp_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_int(buf, pos, &p->x);
        err += !read_int(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);
        err += !read_short(buf, pos, &p->count);

        break;
    }

    case PACKET_ID_STANCE_UPDATE:
    {
        P(packet_stance_update_t)

        err += !read_float(buf, pos, &p->unknown0);
        err += !read_float(buf, pos, &p->unknown1);
        err += !read_float(buf, pos, &p->unknown2);
        err += !read_float(buf, pos, &p->unknown3);
        err += !read_ubyte(buf, pos, &p->unknown4);
        err += !read_ubyte(buf, pos, &p->unknown5);

        break;
    }

    case PACKET_ID_ENT_VELOCITY:
    {
        P(packet_ent_velocity_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_short(buf, pos, &p->vel_x);
        err += !read_short(buf, pos, &p->vel_y);
        err += !read_short(buf, pos, &p->vel_z);

        break;
    }

    case PACKET_ID_ENT_DESTROY:
    {
        P(packet_ent_destroy_t)

        err += !read_int(buf, pos, &p->eid);

        break;
    }

    case PACKET_ID_ENT_ENSURE_SPAWN:
    {
        P(packet_ent_create_t)

        err += !read_int(buf, pos, &p->eid);

        break;
    }

    case PACKET_ID_ENT_MOVE_REL:
    {
        P(packet_ent_move_rel_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->delta_x);
        err += !read_byte(buf, pos, &p->delta_y);
        err += !read_byte(buf, pos, &p->delta_z);

        break;
    }

    case PACKET_ID_ENT_LOOK:
    {
        P(packet_ent_look_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->yaw);
        err += !read_byte(buf, pos, &p->pitch);

        break;
    }

    case PACKET_ID_ENT_LOOK_MOVE_REL:
    {
        P(packet_ent_look_move_rel_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->delta_x);
        err += !read_byte(buf, pos, &p->delta_y);
        err += !read_byte(buf, pos, &p->delta_z);
        err += !read_byte(buf, pos, &p->yaw);
        err += !read_byte(buf, pos, &p->pitch);

        break;
    }

    case PACKET_ID_ENT_MOVE_TELEPORT:
    {
        P(packet_ent_teleport_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_int(buf, pos, &p->x);
        err += !read_int(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);
        err += !read_byte(buf, pos, &p->rotation);
        err += !read_byte(buf, pos, &p->pitch);

        break;
    }

    case PACKET_ID_ENT_STATUS:
    {
        P(packet_ent_status_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->status);

        break;
    }

    case PACKET_ID_ENT_ATTACH:
    {
        P(packet_ent_attach_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_int(buf, pos, &p->vehicle);

        break;
    }

    case PACKET_ID_ENT_EFFECT:
    {
        P(packet_ent_effect_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->effect_id);
        err += !read_byte(buf, pos, &p->amplifier);
        err += !read_short(buf, pos, &p->duration);

        break;
    }

    case PACKET_ID_ENT_EFFECT_REMOVE:
    {
        P(packet_ent_effect_remove_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->effect_id);

        break;
    }

    case PACKET_ID_XP_SET:
    {
        P(packet_xp_set_t)

        err += !read_byte(buf, pos, &p->current_xp);
        err += !read_byte(buf, pos, &p->level);
        err += !read_short(buf, pos, &p->total);

        break;
    }

    case PACKET_ID_CHUNK_CACHE:
    {
        P(packet_chunk_cache_t)

        err += !read_int(buf, pos, &p->chunk_x);
        err += !read_int(buf, pos, &p->chunk_z);
        err += !read_ubyte(buf, pos, &p->mode);

        break;
    }

    case PACKET_ID_BLOCK_CHANGE:
    {
        P(packet_block_change_t)

        err += !read_int(buf, pos, &p->block_x);
        err += !read_byte(buf, pos, &p->block_y);
        err += !read_int(buf, pos, &p->block_z);
        err += !read_byte(buf, pos, &p->type);
        err += !read_byte(buf, pos, &p->metadata);

        break;
    }

    case PACKET_ID_BLOCK_ACTION:
    {
        P(packet_block_action_t)

        err += !read_int(buf, pos, &p->block_x);
        err += !read_short(buf, pos, &p->block_y);
        err += !read_int(buf, pos, &p->block_z);
        err += !read_byte(buf, pos, &p->byte0);
        err += !read_byte(buf, pos, &p->byte1);

        break;
    }

    case PACKET_ID_SFX:
    {
        P(packet_sound_effect_t)

        err += !read_int(buf, pos, &p->effect_id);
        err += !read_int(buf, pos, &p->x);
        err += !read_byte(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);
        err += !read_int(buf, pos, &p->sound_data);

        break;
    }

    case PACKET_ID_NEW_STATE:
    {
        P(packet_new_state_t)

        err += !read_byte(buf, pos, &p->reason);
        err += !read_byte(buf, pos, &p->mode);

        break;
    }

    case PACKET_ID_THUNDERBOLT:
    {
        P(packet_thunder_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_ubyte(buf, pos, &p->unknown);
        err += !read_int(buf, pos, &p->x);
        err += !read_int(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);

        break;
    }

    case PACKET_ID_WINDOW_OPEN:
    {
        P(packet_window_open_t)

        err += !read_byte(buf, pos, &p->window_id);
        err += !read_byte(buf, pos, &p->type);
        err += !read_string16(buf, pos, p->title);
        err += !read_byte(buf, pos, &p->num_slots);

        break;
    }

    case PACKET_ID_WINDOW_CLOSE:
    {
        P(packet_window_close_t)

        err += !read_byte(buf, pos, &p->window_id);

        break;
    }

    case PACKET_ID_WINDOW_TRANSACTION:
    {
        P(packet_window_transaction_t)

        err += !read_byte(buf, pos, &p->window_id);
        err += !read_short(buf, pos, &p->action_num);
        err += !read_ubyte(buf, pos, &p->accepted);

        break;
    }

    case PACKET_ID_INV_CREATIVE_ACTION:
    {
        P(packet_inventory_action_creative_t)

        err += !read_short(buf, pos, &p->slot);
        err += !read_short(buf, pos, &p->item_id);
        err += !read_short(buf, pos, &p->quantity);
        err += !read_short(buf, pos, &p->damage);

        break;
    }

    case PACKET_ID_UPDATE_SIGN:
    {
        P(packet_update_sign_t)

        err += !read_int(buf, pos, &p->x);
        err += !read_short(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);
        err += !read_string16(buf, pos, p->text0);
        err += !read_string16(buf, pos, p->text1);
        err += !read_string16(buf, pos, p->text2);
        err += !read_string16(buf, pos, p->text3);

        break;
    }

    case PACKET_ID_INCREMENT_STATISTIC:
    {
        P(packet_increment_statistic_t)

        err += !read_int(buf, pos, &p->stat_id);
        err += !read_byte(buf, pos, &p->amount);

        break;
    }

    case PACKET_ID_PLAYER_LIST_ITEM:
    {
        P(packet_play_list_item_t)

        err += !read_string16(buf, pos, p->username);
        err += !read_ubyte(buf, pos, &p->online);
        err += !read_short(buf, pos, &p->ping);

        break;
    }

    case PACKET_ID_SERVER_LIST_PING:
    {
        P(packet_server_list_ping_t)

        break;
    }

    case PACKET_ID_KICK:
    {
        P(packet_kick_t)

        err += !read_string16(buf, pos, p->reason);

        break;
    }

    default:
        return 0;
    }
    return 1;
}

static bool gen_lengths_server(Uint8 packet_type, size_t& len, int& var_len)
{
    switch (packet_type)
    {
        PACK_LEN(PACKET_ID_KEEP_ALIVE, 5)
        PACK_LENV(PACKET_ID_LOGIN_REQUEST, 23, 1)
        PACK_LENV(PACKET_ID_HANDSHAKE, 3, 1)
        PACK_LENV(PACKET_ID_CHAT_MSG, 3, 1)
        PACK_LEN(PACKET_ID_UPDATE_TIME, 9)
        PACK_LEN(PACKET_ID_ENT_EQUIPMENT, 11)
        PACK_LEN(PACKET_ID_ENT_USE, 10)
        PACK_LEN(PACKET_ID_UPDATE_HEALTH, 9)
        PACK_LEN(PACKET_ID_RESPAWN, 14)
        PACK_LEN(PACKET_ID_PLAYER_ON_GROUND, 2)
        PACK_LEN(PACKET_ID_PLAYER_POS, 34)
        PACK_LEN(PACKET_ID_PLAYER_LOOK, 10)
        PACK_LEN(PACKET_ID_PLAYER_POS_LOOK, 42)
        PACK_LEN(PACKET_ID_PLAYER_DIG, 12)
        PACK_LEN(PACKET_ID_HOLD_CHANGE, 3)
        PACK_LEN(PACKET_ID_USE_BED, 15)
        PACK_LEN(PACKET_ID_ENT_ANIMATION, 6)
        PACK_LEN(PACKET_ID_ENT_ACTION, 6)
        PACK_LENV(PACKET_ID_ENT_SPAWN_NAMED, 23, 1)
        PACK_LEN(PACKET_ID_ENT_SPAWN_PICKUP, 25)
        PACK_LEN(PACKET_ID_COLLECT_ITEM, 9)
        PACK_LENV(PACKET_ID_ENT_SPAWN_PAINTING, 23, 1)
        PACK_LEN(PACKET_ID_ENT_SPAWN_XP, 19)
        PACK_LEN(PACKET_ID_STANCE_UPDATE, 19)
        PACK_LEN(PACKET_ID_ENT_VELOCITY, 11)
        PACK_LEN(PACKET_ID_ENT_DESTROY, 5)
        PACK_LEN(PACKET_ID_ENT_ENSURE_SPAWN, 5)
        PACK_LEN(PACKET_ID_ENT_MOVE_REL, 8)
        PACK_LEN(PACKET_ID_ENT_LOOK, 7)
        PACK_LEN(PACKET_ID_ENT_LOOK_MOVE_REL, 10)
        PACK_LEN(PACKET_ID_ENT_MOVE_TELEPORT, 19)
        PACK_LEN(PACKET_ID_ENT_STATUS, 6)
        PACK_LEN(PACKET_ID_ENT_ATTACH, 9)
        PACK_LEN(PACKET_ID_ENT_EFFECT, 9)
        PACK_LEN(PACKET_ID_ENT_EFFECT_REMOVE, 6)
        PACK_LEN(PACKET_ID_XP_SET, 5)
        PACK_LEN(PACKET_ID_CHUNK_CACHE, 10)
        PACK_LEN(PACKET_ID_BLOCK_CHANGE, 12)
        PACK_LEN(PACKET_ID_BLOCK_ACTION, 13)
        PACK_LEN(PACKET_ID_SFX, 18)
        PACK_LEN(PACKET_ID_NEW_STATE, 3)
        PACK_LEN(PACKET_ID_THUNDERBOLT, 18)
        PACK_LENV(PACKET_ID_WINDOW_OPEN, 6, 1)
        PACK_LEN(PACKET_ID_WINDOW_CLOSE, 2)
        PACK_LEN(PACKET_ID_WINDOW_TRANSACTION, 5)
        PACK_LEN(PACKET_ID_INV_CREATIVE_ACTION, 9)
        PACK_LENV(PACKET_ID_UPDATE_SIGN, 19, 4)
        PACK_LEN(PACKET_ID_INCREMENT_STATISTIC, 6)
        PACK_LENV(PACKET_ID_PLAYER_LIST_ITEM, 6, 1)
        PACK_LEN(PACKET_ID_SERVER_LIST_PING, 1)
        PACK_LENV(PACKET_ID_KICK, 3, 1)
    default:
        return 0;
    }
    return 1;
}

static bool vlen_gen_client(Uint8 packet_type, std::vector<Uint8>& buf, size_t& buf_size, int& change_happened, int& var_len, size_t& len)
{
    switch (packet_type)
    {
    case PACKET_ID_LOGIN_REQUEST:
    {
        GET_STR_LEN(1, 5);
        break;
    }

    case PACKET_ID_HANDSHAKE:
    {
        GET_STR_LEN(1, 1);
        break;
    }

    case PACKET_ID_CHAT_MSG:
    {
        GET_STR_LEN(1, 1);
        break;
    }

    case PACKET_ID_ENT_SPAWN_NAMED:
    {
        GET_STR_LEN(1, 5);
        break;
    }

    case PACKET_ID_ENT_SPAWN_PAINTING:
    {
        GET_STR_LEN(1, 5);
        break;
    }

    case PACKET_ID_WINDOW_OPEN:
    {
        GET_STR_LEN(1, 3);
        break;
    }

        // PACKET_ID_UPDATE_SIGN has a var_len > 1, handle it yourself

    case PACKET_ID_PLAYER_LIST_ITEM:
    {
        GET_STR_LEN(1, 1);
        break;
    }

    case PACKET_ID_KICK:
    {
        GET_STR_LEN(1, 1);
        break;
    }

    default:
        return 0;
    }
    return 1;
}

static bool parse_gen_packets_client(Uint8 packet_type, std::vector<Uint8>& buf, int& err, size_t& pos, packet_t*& packet)
{
    switch (packet_type)
    {
    case PACKET_ID_KEEP_ALIVE:
    {
        P(packet_keep_alive_t)

        err += !read_int(buf, pos, &p->keep_alive_id);

        break;
    }

    case PACKET_ID_LOGIN_REQUEST:
    {
        P(packet_login_request_s2c_t)

        err += !read_int(buf, pos, &p->player_eid);
        err += !read_string16(buf, pos, p->unused);
        err += !read_long(buf, pos, &p->seed);
        err += !read_int(buf, pos, &p->mode);
        err += !read_byte(buf, pos, &p->dimension);
        err += !read_byte(buf, pos, &p->difficulty);
        err += !read_ubyte(buf, pos, &p->world_height);
        err += !read_ubyte(buf, pos, &p->max_players);

        break;
    }

    case PACKET_ID_HANDSHAKE:
    {
        P(packet_handshake_s2c_t)

        err += !read_string16(buf, pos, p->connection_hash);

        break;
    }

    case PACKET_ID_CHAT_MSG:
    {
        P(packet_chat_message_t)

        err += !read_string16(buf, pos, p->msg);

        break;
    }

    case PACKET_ID_UPDATE_TIME:
    {
        P(packet_time_update_t)

        err += !read_long(buf, pos, &p->time);

        break;
    }

    case PACKET_ID_ENT_EQUIPMENT:
    {
        P(packet_ent_equipment_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_short(buf, pos, &p->slot);
        err += !read_short(buf, pos, &p->item_id);
        err += !read_short(buf, pos, &p->damage);

        break;
    }

    case PACKET_ID_SPAWN_POS:
    {
        P(packet_spawn_pos_t)

        err += !read_int(buf, pos, &p->x);
        err += !read_int(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);

        break;
    }

    case PACKET_ID_ENT_USE:
    {
        P(packet_ent_use_t)

        err += !read_int(buf, pos, &p->user);
        err += !read_int(buf, pos, &p->target);
        err += !read_ubyte(buf, pos, &p->left_click);

        break;
    }

    case PACKET_ID_UPDATE_HEALTH:
    {
        P(packet_health_t)

        err += !read_short(buf, pos, &p->health);
        err += !read_short(buf, pos, &p->food);
        err += !read_float(buf, pos, &p->food_saturation);

        break;
    }

    case PACKET_ID_RESPAWN:
    {
        P(packet_respawn_t)

        err += !read_byte(buf, pos, &p->dimension);
        err += !read_byte(buf, pos, &p->difficulty);
        err += !read_byte(buf, pos, &p->mode);
        err += !read_short(buf, pos, &p->world_height);
        err += !read_long(buf, pos, &p->seed);

        break;
    }

    case PACKET_ID_PLAYER_POS_LOOK:
    {
        P(packet_player_pos_look_s2c_t)

        err += !read_double(buf, pos, &p->x);
        err += !read_double(buf, pos, &p->stance);
        err += !read_double(buf, pos, &p->y);
        err += !read_double(buf, pos, &p->z);
        err += !read_float(buf, pos, &p->yaw);
        err += !read_float(buf, pos, &p->pitch);
        err += !read_ubyte(buf, pos, &p->on_ground);

        break;
    }

    case PACKET_ID_PLAYER_DIG:
    {
        P(packet_player_dig_t)

        err += !read_byte(buf, pos, &p->status);
        err += !read_int(buf, pos, &p->x);
        err += !read_byte(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);
        err += !read_byte(buf, pos, &p->face);

        break;
    }

    case PACKET_ID_HOLD_CHANGE:
    {
        P(packet_hold_change_t)

        err += !read_short(buf, pos, &p->slot_id);

        break;
    }

    case PACKET_ID_USE_BED:
    {
        P(packet_use_bed_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->unknown_probably_in_bed);
        err += !read_int(buf, pos, &p->headboard_x);
        err += !read_byte(buf, pos, &p->headboard_y);
        err += !read_int(buf, pos, &p->headboard_z);

        break;
    }

    case PACKET_ID_ENT_ANIMATION:
    {
        P(packet_ent_animation_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->animate);

        break;
    }

    case PACKET_ID_ENT_ACTION:
    {
        P(packet_ent_action_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->action_id);

        break;
    }

    case PACKET_ID_ENT_SPAWN_NAMED:
    {
        P(packet_ent_spawn_named_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_string16(buf, pos, p->name);
        err += !read_int(buf, pos, &p->x);
        err += !read_int(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);
        err += !read_byte(buf, pos, &p->rotation);
        err += !read_byte(buf, pos, &p->pitch);
        err += !read_short(buf, pos, &p->cur_item);

        break;
    }

    case PACKET_ID_ENT_SPAWN_PICKUP:
    {
        P(packet_ent_spawn_pickup_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_short(buf, pos, &p->item);
        err += !read_byte(buf, pos, &p->count);
        err += !read_short(buf, pos, &p->damage);
        err += !read_int(buf, pos, &p->x);
        err += !read_int(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);
        err += !read_byte(buf, pos, &p->rotation);
        err += !read_byte(buf, pos, &p->pitch);
        err += !read_byte(buf, pos, &p->roll);

        break;
    }

    case PACKET_ID_COLLECT_ITEM:
    {
        P(packet_collect_item_t)

        err += !read_int(buf, pos, &p->collected_eid);
        err += !read_int(buf, pos, &p->collector_eid);

        break;
    }

    case PACKET_ID_ENT_SPAWN_PAINTING:
    {
        P(packet_ent_spawn_painting_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_string16(buf, pos, p->title);
        err += !read_int(buf, pos, &p->center_x);
        err += !read_int(buf, pos, &p->center_y);
        err += !read_int(buf, pos, &p->center_z);
        err += !read_int(buf, pos, &p->direction);

        break;
    }

    case PACKET_ID_ENT_SPAWN_XP:
    {
        P(packet_ent_spawn_xp_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_int(buf, pos, &p->x);
        err += !read_int(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);
        err += !read_short(buf, pos, &p->count);

        break;
    }

    case PACKET_ID_STANCE_UPDATE:
    {
        P(packet_stance_update_t)

        err += !read_float(buf, pos, &p->unknown0);
        err += !read_float(buf, pos, &p->unknown1);
        err += !read_float(buf, pos, &p->unknown2);
        err += !read_float(buf, pos, &p->unknown3);
        err += !read_ubyte(buf, pos, &p->unknown4);
        err += !read_ubyte(buf, pos, &p->unknown5);

        break;
    }

    case PACKET_ID_ENT_VELOCITY:
    {
        P(packet_ent_velocity_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_short(buf, pos, &p->vel_x);
        err += !read_short(buf, pos, &p->vel_y);
        err += !read_short(buf, pos, &p->vel_z);

        break;
    }

    case PACKET_ID_ENT_DESTROY:
    {
        P(packet_ent_destroy_t)

        err += !read_int(buf, pos, &p->eid);

        break;
    }

    case PACKET_ID_ENT_ENSURE_SPAWN:
    {
        P(packet_ent_create_t)

        err += !read_int(buf, pos, &p->eid);

        break;
    }

    case PACKET_ID_ENT_MOVE_REL:
    {
        P(packet_ent_move_rel_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->delta_x);
        err += !read_byte(buf, pos, &p->delta_y);
        err += !read_byte(buf, pos, &p->delta_z);

        break;
    }

    case PACKET_ID_ENT_LOOK:
    {
        P(packet_ent_look_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->yaw);
        err += !read_byte(buf, pos, &p->pitch);

        break;
    }

    case PACKET_ID_ENT_LOOK_MOVE_REL:
    {
        P(packet_ent_look_move_rel_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->delta_x);
        err += !read_byte(buf, pos, &p->delta_y);
        err += !read_byte(buf, pos, &p->delta_z);
        err += !read_byte(buf, pos, &p->yaw);
        err += !read_byte(buf, pos, &p->pitch);

        break;
    }

    case PACKET_ID_ENT_MOVE_TELEPORT:
    {
        P(packet_ent_teleport_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_int(buf, pos, &p->x);
        err += !read_int(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);
        err += !read_byte(buf, pos, &p->rotation);
        err += !read_byte(buf, pos, &p->pitch);

        break;
    }

    case PACKET_ID_ENT_STATUS:
    {
        P(packet_ent_status_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->status);

        break;
    }

    case PACKET_ID_ENT_ATTACH:
    {
        P(packet_ent_attach_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_int(buf, pos, &p->vehicle);

        break;
    }

    case PACKET_ID_ENT_EFFECT:
    {
        P(packet_ent_effect_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->effect_id);
        err += !read_byte(buf, pos, &p->amplifier);
        err += !read_short(buf, pos, &p->duration);

        break;
    }

    case PACKET_ID_ENT_EFFECT_REMOVE:
    {
        P(packet_ent_effect_remove_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_byte(buf, pos, &p->effect_id);

        break;
    }

    case PACKET_ID_XP_SET:
    {
        P(packet_xp_set_t)

        err += !read_byte(buf, pos, &p->current_xp);
        err += !read_byte(buf, pos, &p->level);
        err += !read_short(buf, pos, &p->total);

        break;
    }

    case PACKET_ID_CHUNK_CACHE:
    {
        P(packet_chunk_cache_t)

        err += !read_int(buf, pos, &p->chunk_x);
        err += !read_int(buf, pos, &p->chunk_z);
        err += !read_ubyte(buf, pos, &p->mode);

        break;
    }

    case PACKET_ID_BLOCK_CHANGE:
    {
        P(packet_block_change_t)

        err += !read_int(buf, pos, &p->block_x);
        err += !read_byte(buf, pos, &p->block_y);
        err += !read_int(buf, pos, &p->block_z);
        err += !read_byte(buf, pos, &p->type);
        err += !read_byte(buf, pos, &p->metadata);

        break;
    }

    case PACKET_ID_BLOCK_ACTION:
    {
        P(packet_block_action_t)

        err += !read_int(buf, pos, &p->block_x);
        err += !read_short(buf, pos, &p->block_y);
        err += !read_int(buf, pos, &p->block_z);
        err += !read_byte(buf, pos, &p->byte0);
        err += !read_byte(buf, pos, &p->byte1);

        break;
    }

    case PACKET_ID_SFX:
    {
        P(packet_sound_effect_t)

        err += !read_int(buf, pos, &p->effect_id);
        err += !read_int(buf, pos, &p->x);
        err += !read_byte(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);
        err += !read_int(buf, pos, &p->sound_data);

        break;
    }

    case PACKET_ID_NEW_STATE:
    {
        P(packet_new_state_t)

        err += !read_byte(buf, pos, &p->reason);
        err += !read_byte(buf, pos, &p->mode);

        break;
    }

    case PACKET_ID_THUNDERBOLT:
    {
        P(packet_thunder_t)

        err += !read_int(buf, pos, &p->eid);
        err += !read_ubyte(buf, pos, &p->unknown);
        err += !read_int(buf, pos, &p->x);
        err += !read_int(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);

        break;
    }

    case PACKET_ID_WINDOW_OPEN:
    {
        P(packet_window_open_t)

        err += !read_byte(buf, pos, &p->window_id);
        err += !read_byte(buf, pos, &p->type);
        err += !read_string16(buf, pos, p->title);
        err += !read_byte(buf, pos, &p->num_slots);

        break;
    }

    case PACKET_ID_WINDOW_CLOSE:
    {
        P(packet_window_close_t)

        err += !read_byte(buf, pos, &p->window_id);

        break;
    }

    case PACKET_ID_WINDOW_UPDATE_PROGRESS:
    {
        P(packet_window_update_progress_t)

        err += !read_byte(buf, pos, &p->window_id);
        err += !read_short(buf, pos, &p->progress);
        err += !read_short(buf, pos, &p->value);

        break;
    }

    case PACKET_ID_WINDOW_TRANSACTION:
    {
        P(packet_window_transaction_t)

        err += !read_byte(buf, pos, &p->window_id);
        err += !read_short(buf, pos, &p->action_num);
        err += !read_ubyte(buf, pos, &p->accepted);

        break;
    }

    case PACKET_ID_INV_CREATIVE_ACTION:
    {
        P(packet_inventory_action_creative_t)

        err += !read_short(buf, pos, &p->slot);
        err += !read_short(buf, pos, &p->item_id);
        err += !read_short(buf, pos, &p->quantity);
        err += !read_short(buf, pos, &p->damage);

        break;
    }

    case PACKET_ID_UPDATE_SIGN:
    {
        P(packet_update_sign_t)

        err += !read_int(buf, pos, &p->x);
        err += !read_short(buf, pos, &p->y);
        err += !read_int(buf, pos, &p->z);
        err += !read_string16(buf, pos, p->text0);
        err += !read_string16(buf, pos, p->text1);
        err += !read_string16(buf, pos, p->text2);
        err += !read_string16(buf, pos, p->text3);

        break;
    }

    case PACKET_ID_INCREMENT_STATISTIC:
    {
        P(packet_increment_statistic_t)

        err += !read_int(buf, pos, &p->stat_id);
        err += !read_byte(buf, pos, &p->amount);

        break;
    }

    case PACKET_ID_PLAYER_LIST_ITEM:
    {
        P(packet_play_list_item_t)

        err += !read_string16(buf, pos, p->username);
        err += !read_ubyte(buf, pos, &p->online);
        err += !read_short(buf, pos, &p->ping);

        break;
    }

    case PACKET_ID_SERVER_LIST_PING:
    {
        P(packet_server_list_ping_t)

        break;
    }

    case PACKET_ID_KICK:
    {
        P(packet_kick_t)

        err += !read_string16(buf, pos, p->reason);

        break;
    }

    default:
        return 0;
    }
    return 1;
}

static bool gen_lengths_client(Uint8 packet_type, size_t& len, int& var_len)
{
    switch (packet_type)
    {
        PACK_LEN(PACKET_ID_KEEP_ALIVE, 5)
        PACK_LENV(PACKET_ID_LOGIN_REQUEST, 23, 1)
        PACK_LENV(PACKET_ID_HANDSHAKE, 3, 1)
        PACK_LENV(PACKET_ID_CHAT_MSG, 3, 1)
        PACK_LEN(PACKET_ID_UPDATE_TIME, 9)
        PACK_LEN(PACKET_ID_ENT_EQUIPMENT, 11)
        PACK_LEN(PACKET_ID_SPAWN_POS, 13)
        PACK_LEN(PACKET_ID_ENT_USE, 10)
        PACK_LEN(PACKET_ID_UPDATE_HEALTH, 9)
        PACK_LEN(PACKET_ID_RESPAWN, 14)
        PACK_LEN(PACKET_ID_PLAYER_POS_LOOK, 42)
        PACK_LEN(PACKET_ID_PLAYER_DIG, 12)
        PACK_LEN(PACKET_ID_HOLD_CHANGE, 3)
        PACK_LEN(PACKET_ID_USE_BED, 15)
        PACK_LEN(PACKET_ID_ENT_ANIMATION, 6)
        PACK_LEN(PACKET_ID_ENT_ACTION, 6)
        PACK_LENV(PACKET_ID_ENT_SPAWN_NAMED, 23, 1)
        PACK_LEN(PACKET_ID_ENT_SPAWN_PICKUP, 25)
        PACK_LEN(PACKET_ID_COLLECT_ITEM, 9)
        PACK_LENV(PACKET_ID_ENT_SPAWN_PAINTING, 23, 1)
        PACK_LEN(PACKET_ID_ENT_SPAWN_XP, 19)
        PACK_LEN(PACKET_ID_STANCE_UPDATE, 19)
        PACK_LEN(PACKET_ID_ENT_VELOCITY, 11)
        PACK_LEN(PACKET_ID_ENT_DESTROY, 5)
        PACK_LEN(PACKET_ID_ENT_ENSURE_SPAWN, 5)
        PACK_LEN(PACKET_ID_ENT_MOVE_REL, 8)
        PACK_LEN(PACKET_ID_ENT_LOOK, 7)
        PACK_LEN(PACKET_ID_ENT_LOOK_MOVE_REL, 10)
        PACK_LEN(PACKET_ID_ENT_MOVE_TELEPORT, 19)
        PACK_LEN(PACKET_ID_ENT_STATUS, 6)
        PACK_LEN(PACKET_ID_ENT_ATTACH, 9)
        PACK_LEN(PACKET_ID_ENT_EFFECT, 9)
        PACK_LEN(PACKET_ID_ENT_EFFECT_REMOVE, 6)
        PACK_LEN(PACKET_ID_XP_SET, 5)
        PACK_LEN(PACKET_ID_CHUNK_CACHE, 10)
        PACK_LEN(PACKET_ID_BLOCK_CHANGE, 12)
        PACK_LEN(PACKET_ID_BLOCK_ACTION, 13)
        PACK_LEN(PACKET_ID_SFX, 18)
        PACK_LEN(PACKET_ID_NEW_STATE, 3)
        PACK_LEN(PACKET_ID_THUNDERBOLT, 18)
        PACK_LENV(PACKET_ID_WINDOW_OPEN, 6, 1)
        PACK_LEN(PACKET_ID_WINDOW_CLOSE, 2)
        PACK_LEN(PACKET_ID_WINDOW_UPDATE_PROGRESS, 6)
        PACK_LEN(PACKET_ID_WINDOW_TRANSACTION, 5)
        PACK_LEN(PACKET_ID_INV_CREATIVE_ACTION, 9)
        PACK_LENV(PACKET_ID_UPDATE_SIGN, 19, 4)
        PACK_LEN(PACKET_ID_INCREMENT_STATISTIC, 6)
        PACK_LENV(PACKET_ID_PLAYER_LIST_ITEM, 6, 1)
        PACK_LEN(PACKET_ID_SERVER_LIST_PING, 1)
        PACK_LENV(PACKET_ID_KICK, 3, 1)
    default:
        return 0;
    }
    return 1;
}

#undef P
#undef GET_STR_LEN
#undef PACK_LEN
#undef PACK_LENV
#endif
